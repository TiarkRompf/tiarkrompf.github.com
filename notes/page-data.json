{"componentChunkName":"component---src-pages-all-public-js","path":"/allPublic/","result":{"data":{"site":{"siteMetadata":{"title":"KB"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"Recent Updates: Smooth DOM Tree Animation 21/02/15 Automatic Live Coding 21/01/31 Graph IRs for Expressive Languages: Taming Higher-Order‚Ä¶","html":"<p>Recent Updates:</p>\n<ul>\n<li><a href=\"/Public/Generic/smooth-tree-animation\">Smooth DOM Tree Animation</a> <div><small>21/02/15</small></div></li>\n<li><a href=\"/Public/Generic/auto-live-coding\">Automatic Live Coding</a> <div><small>21/01/31</small></div></li>\n<li><a href=\"/Public/Generic/graph-ir\">Graph IRs for Expressive Languages: Taming Higher-Order Control and State with Precise Effect Dependencies</a> <div><small>21/01/14</small></div></li>\n<li><a href=\"/Public/Generic/diff-algorithm\">The Histogram Diff Algorithm</a> <div><small>20/12/31</small></div></li>\n<li><a href=\"/Public/Generic/dependent-types\">Implementing Dependent Types</a> <div><small>20/12/28</small></div></li>\n<li><a href=\"/Public/Generic/lets-build-a-microprocessor\">Let‚Äôs Build a Microprocessor</a> <div><small>20/12/23</small></div></li>\n<li><a href=\"/Public/Generic/particles\">Fun With Particle Animation</a> <div><small>20/12/22</small></div></li>\n<li><a href=\"/Public/Generic/just-write-the-parser\">Just Write the #!%/* Parser</a> <div><small>20/10/19</small></div></li>\n<li><a href=\"/Public/Generic/affine-continuations\">Implementing Affine Non-Escaping Delimited Continuations with a Single Auxiliary Stack</a> <div><small>20/07/14</small></div></li>\n<li><a href=\"/Public/Generic/differentiable-graphics\">Differentiable Programming for Interactive Graphics</a> <div><small>20/07/11</small></div></li>\n<li><a href=\"/Public/Generic/deconstructing-react\">Deconstructing React</a> <div><small>20/07/07</small></div></li>\n<li><a href=\"/Public/Generic/touch-camera-device-apis\">Touch, Camera, and Other Device APIs</a> <div><small>20/07/04</small></div></li>\n<li><a href=\"/Public/Generic/drawing-graphs\">Drawing Graphs Like GraphViz</a> <div><small>20/06/28</small></div></li>\n<li><a href=\"/Public/Generic/virtual-piano\">Virtual Piano Practice</a> <div><small>20/06/20</small></div></li>\n<li><a href=\"/Public/Generic/differentiable-programming-in-js\">Differentiable Programming in JS</a> <div><small>20/06/14</small></div></li>\n<li><a href=\"/Public/Generic/interactive-literate-programming\">Interactive Literate Programming</a> <div><small>20/06/12</small></div></li>\n<li><a href=\"/Public/Generic/interactive-coding\">Interacting With Code</a> <div><small>20/06/06</small></div></li>\n<li><a href=\"/Public/Generic/octopus-notes\">Octopus Notes</a> <div><small>20/05/30</small></div></li>\n</ul>\n<!--\nPublications:\n\n- [By year](/Public/Papers/)\n- By topic\n-->\n<div style=\"display:none\">\n<p><a href=\"/Public/Generic/regions-borrowing-coeffects\">/Public/Generic/regions-borrowing-coeffects</a>\n<a href=\"/Public/Generic/graph-ir-dependent\">/Public/Generic/graph-ir-dependent</a>\n<a href=\"/Public/Generic/js-queries\">/Public/Generic/js-queries</a></p>\n</div>\n<p><small>Copyright ¬© 2020-2023 <a href=\"https://tiarkrompf.github.io\">Tiark Rompf</a></small></p>","fields":{"slug":"/Public/Generic/public/"},"frontmatter":{"date":null,"title":"Notes - Start Page","description":null,"keywords":null,"tags":null}}},{"node":{"excerpt":"We want to build an expressive language for high-level data manipulation: Query nested structures (like JSON), produce nested structures as‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>We want to build an expressive language for high-level data manipulation:</p>\n<ul>\n<li>Query nested structures (like JSON), produce nested structures as result</li>\n<li>With a query syntax that resembles existing object notation</li>\n<li>Permit query optimization and code generation</li>\n<li>Compositional and easy to metaprogram</li>\n</ul>\n<p>Ultimately, we want to add incremental and bidirectional computation so that we can build interactive dashboards and CRUD apps directly from a single query (= program).</p>\n<p>We take key inspiration from:</p>\n<ul>\n<li>Existing approaches such as Graph QL, JQ, XQuery, etc.</li>\n<li>Einstein notation (Einsum, Einops) in tensor frameworks</li>\n<li>Logic programming (Datalog), especially nondeterministic choice and unification</li>\n</ul>\n<p>There are several interesting PL aspects and potential new perspectives:</p>\n<ul>\n<li>Loop-free and branch-free code, program structure implicit in dependencies</li>\n<li>Unified representation of functions, records, and tables</li>\n<li>Lambda lifting to decorrelate subqueries</li>\n</ul>\n<aside>\n<h3>Proof-of-Concept Implementation</h3>\n<p>Support code</p>\n<aside>\n<p>Basics</p>\n<p>Test helper:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction expect(a, b) {\n  if (JSON.stringify(a) == JSON.stringify(b))\n    print(\"üü¢ OK\")\n  else\n    print(\"üî¥ ERROR: expected\\n\" + JSON.stringify(b))\n}\n</code>\n<p>Struct helper:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction struct(fields, f) {\n  let res = {}\n  for (let e of fields)\n    res[e] = f(e)\n  return res\n}\n</code>\n<p>DOM Utils:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  const dom = type.startsWith(\"svg:\")\n    ? document.createElementNS(\"http://www.w3.org/2000/svg\", type.slice(4))\n    : document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k)) {\n      dom.addEventListener(eventName(k), props[k])\n    } else if (k == \"style\") { // special case for style ...\n       for (let j in props[k])\n         dom[k][j] = props[k][j]\n    } else {\n      if (dom.setAttribute)\n        dom.setAttribute(k, props[k]) // XXX for SVG!\n      dom[k] = props[k]\n    }\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\nfunction dom(...es) {\n  return e(\"span\",{},...es)\n}\n</code>\n</aside>\n<aside>\n<p>Ambient scope</p>\n<p>Implementation</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction Amb() {\n  this.get = function() {\n    return {...this}\n  }\n  this.set = function(s) {\n    for (let k in this)\n      delete this[k]\n    for (let k in s)\n      this[k] = s[k]\n  }\n  this.begin = function() {\n    this.save = this.get()\n  }\n  this.end = function() {\n    console.assert(this.save, \"too many m.end!\",this)\n    this.set(this.save)\n  }\n  this.enter = function(s) {\n    this.begin()\n    this.set(s)\n  }\n  this.exit = function() {\n    this.end()\n  }\n}\nlet m = new Amb()\n// m.begin = function begin(key) {\n//   let oldDyn = m\n//   m = {...oldDyn}\n//   m.end = () => { m = oldDyn }\n//   return\n// }\n//\n// m.enter = function enter(a) {\n//   let oldDyn = m\n//   s = { parent: s, m: oldDyn }\n//   m = a\n//   return a\n// }\n//\n// m.exit = function exit() {\n//   m = s.m\n//   s = s.parent\n// }\n//\nm.local = function(f) {\n  let cur = this.get()\n  return (...e) => { this.enter(cur); let res = f(...e); this.exit(); return res }\n}\n//\n//\n// dom parent management\n//\nlet beg = m.begin\nm.beg = beg\nm.begin = arg => {\n  m.beg()\n  if (!arg) arg = \"\"\n  if (typeof(arg) == \"string\") arg = m.styled(arg)\n  m.domParent = arg\n}\n//\nm.add = b => {\n  m.domParent.appendChild(b)\n  return b\n}\n//\n// plain dom components\n//\nm.div = function div(...content) {\n  return m.add(e(\"div\",{},...content))\n}\nm.styled = function styled(className,...content) {\n  return m.add(e(\"div\",{className},...content))\n}\nm.li = function li(...content) {\n  return m.add(e(\"li\",{},...content))\n}\nm.pre = function div(className,...content) {\n  return m.add(e(\"pre\",{className},...content))\n}\nm.img = function img(className,src,alt) {\n  return m.add(e(\"img\",{className,src,alt}))\n}\nm.link = function link(className,href,...contents) {\n  return m.add(e(\"a\",{className,href},...contents))\n}\nm.button = function button(className,...contents) {\n  return m.add(e(\"button\",{className},...contents))\n}\nm.input = function input(className,...contents) {\n  return m.add(e(\"input\",{className},...contents))\n}\nm.table = function(...content) {\n  return m.add(e(\"table\",{},...content))\n}\nm.thead = function(...content) {\n  return m.add(e(\"thead\",{},...content))\n}\nm.tbody = function(...content) {\n  return m.add(e(\"tbody\",{},...content))\n}\nm.col = function(...content) {\n  return m.add(e(\"col\",{},...content))\n}\nm.th = function(...content) {\n  return m.add(e(\"th\",{},...content))\n}\nm.td = function(...content) {\n  return m.add(e(\"td\",{},...content))\n}\nm.tr = function(...content) {\n  return m.add(e(\"tr\",{},...content))\n}\n//\n//\nm.domParent = o\n//\n// default display function -- refine this later\n//\nfunction display(o) {\n  return m.add(inspector(o))\n}\n</code>\n</aside>\n<aside>\n<p>Object inspector</p>\n<p>Print and inspect objects, generically</p>\n<p>TODO:</p>\n<ul>\n<li><del>proper nesting, indentation (with key/without)</del></li>\n<li><del>fix glitch with double expand buttons (empty/empty)</del></li>\n<li><del>show constructor name when collapsed</del></li>\n<li><del>don‚Äôt show function source code</del></li>\n<li><del>toDetailString: do not expand function source</del></li>\n<li><del>show constructor name when closed (unless == Object)</del></li>\n<li>allow expansion of functions to reveal source</li>\n<li>expand long field list using ‚Äúmore‚Äù button</li>\n<li>toDetailString: click on ‚Äù‚Ä¶‚Äù to expand</li>\n<li>toDetailString: make sure we always show closing braces</li>\n<li>allow ‚Äúdisplay‚Äù in expansion?</li>\n</ul>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction toDetailString(a, depth) {\n  let maxLen = depth * 20\n  if (depth == 0) return \"...\"\n  if (a instanceof Array) {\n    let acc = [\"[\"]\n    for (let k = 0; k < a.length; k++) {\n      if (acc.length>1) acc.push(\", \")\n      acc.push(toDetailString(a[k], depth-1))\n    }\n    acc.push(\"]\")\n    let str = acc.join(\"\")\n    if (str.length > maxLen)\n      str = str.substring(0,maxLen)+\"...\"\n    return str\n  }\n  let str\n  if (a && typeof(a) == \"object\") {\n    let acc = []\n    if (a.constructor != Object)\n      acc.push(a.constructor.name, \" \")\n    acc.push(\"{\")\n    let j = acc.length\n    for (let k of Object.keys(a)) {\n      if (acc.length > j) acc.push(\", \")\n      acc.push(k,\": \",toDetailString(a[k], depth-1))\n    }\n    acc.push(\"}\")\n    str = acc.join(\"\")\n  } else if (typeof(a) == \"function\") {\n    str = \"function\"\n  } else {\n    str = String(a)\n  }\n  if (str.length > maxLen)\n    str = str.substring(0,maxLen)+\"...\"\n  return str\n}\nfunction toDomLine(a, key) {\n  let d\n  if (a && typeof(a) == \"object\") {\n    d = e(\"div\",{})\n    let open = false\n    function toggle() {\n      open = !open\n      render()\n    }\n    function render() {\n      let btn = e(\"span\",{onClick:toggle},open?\"‚ñΩ \":\"‚ñ∑ \")\n      btn.style.display = \"inline-block\"\n      //btn.style.float = \"left\"\n      btn.style.width = \"2ch\"\n      d.innerText = \"\"\n      d.appendChild(btn)\n      if (key)\n        d.appendChild(dom(key,\": \"))\n      if (!open) {\n        let str = toDetailString(a,3)\n        d.appendChild(dom(str))\n      }\n      if (open) {\n        d.appendChild(dom(a?.constructor.name))\n        let ks = []\n        for (let k of Object.keys(a))\n          ks.push(toDomLine(a[k],k))\n        let inner = e(\"div\",{},...ks)\n        inner.style.marginLeft = \"2ch\" // key ? \"4ch\" : \"2ch\"\n        d.appendChild(inner)\n      }\n    }\n    render()\n  } else if (typeof(a) == \"function\") {\n    // TODO: make expandable\n    if (key) {\n      d = e(\"div\",{},key,\": \",\"function\")\n      d.style.marginLeft = \"2ch\"\n    } else\n      d = e(\"div\",{},\"function\")\n  } else {\n    if (key) {\n      d = e(\"div\",{},key,\": \",String(a))\n      d.style.marginLeft = \"2ch\"\n    } else\n      d = e(\"div\",{},String(a))\n  }\n  return d\n}\nfunction inspector(a) {\n  return toDomLine(a)\n}\nfunction inspect(...args) {\n  if (args.length == 0) return\n  if (args.length == 1) {\n    o.appendChild(toDomLine(args[0]))\n  } else\n    o.appendChild(toDomLine(args))\n}\n</code>\n<p>Test inspector</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ninspect({foo:{baz:1,buh:3},bar:2})\ninspect(\"A\")\ninspect(2)\ninspect(undefined)\ninspect(1,2,3)\ninspect([1,2,3])\ninspect(\"here\",3,\"dx\",{foo:45})\ninspect(document)\n</code>\n</aside>\n<aside>\n<p>Data table</p>\n<p>Implementation</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// table with nested row and col heads, and custom cell rendering\n//\nfunction table3d(rowsArg,colsArg,obj,template,renderCell,renderHead) {\n  //\n  // m.domParent.className += \"relative w-full\"\n  let rows = []\n  let cols = []\n  let numRows = 0\n  let numCols = 0\n  let extraRows = 0 // add extra label if top level is special\n//\n  if (rowsArg) {\n    if (typeof(rowsArg) == \"number\")\n      numRows = rowsArg\n    else {\n      rows = rowsArg\n      numRows = rowsArg.length\n    }\n  }\n  if (colsArg) {\n    if (typeof(colsArg) == \"number\")\n      numCols = colsArg\n    else {\n      cols = colsArg\n      numCols = colsArg.length\n    }\n  }\n  if (!renderHead)\n    renderHead = (x,k) => {\n      if (x != \"\") { // e.g. 0,0 cell is empty\n        m.domParent.style[\"border\"] = \"thin solid black\"\n        m.domParent.style[\"background\"] = \"#EEEEEE\"\n        m.domParent.style[\"padding\"] = \"0px 5px 0px 5px\"\n        m.styled(\"inline\", String(x))\n      }\n    }\n  if (!renderCell)\n    renderCell = (x,k) => {\n      m.domParent.style[\"border\"] = \"thin solid lightgray\"\n      m.domParent.style[\"padding\"] = \"0px 5px 0px 5px\"\n      m.domParent.style[\"vertical-align\"] = \"middle\"\n      display(x)\n    }\n//\n// TODO: add a slow mode for col template: compute all cols\n// for everything!! Right now we rely on the (explicit or\n// implicit) 'template' argument to define the column\n// structure.\n//\n  // column template\n  if (!template) {\n    template = obj\n    for (let i = 0; i < numRows; i++)\n       template = template[\"Total\"] || template[0] || template[Object.keys(template)[0]]\n  }\n//\n  //\n  // Normal objects only have children (indexed by key),\n  // special objects can also have own properties (in\n  // field 'props') in addition to children (in field\n  // 'children')\n  //\n  function isSpecialObject(obj) {\n    return (obj instanceof Object && \"children\" in obj)\n  }\n//\n  // computes spans and indexes of row/col headers\n  function computeMeta(obj,depth) {\n    function rec(obj,key,index,d) {\n      let sub = {}\n      let span = 0\n      let special\n      if (isSpecialObject(obj)) {\n        obj = obj.children\n        special = true\n        span = 1\n      }\n      if (d < depth) {\n        let i = 0\n        for (let k in obj) {\n          sub[k] = rec(obj[k],k,i++,d+1)\n          span += sub[k].span\n        }\n      } else {\n        span = 1\n      }\n      return { span, key, index, sub, special }\n    }\n    return rec(obj,\"root\",0,0)\n  }\n//\n  let colmeta1 = computeMeta(template, numCols)\n  let rowmeta1 = computeMeta(obj, numRows)\n//\n  // console.log(\"meta\", rowmeta1, colmeta1)\n//\n  function iterateMeta(meta,obj,depth,f) {\n    let stack = []\n    function rec(meta,obj,d) {\n      stack[d] = meta\n      if (d < depth) {\n        if (meta.special && obj) {\n          f(meta,obj.props,stack,d)\n          obj = obj.children\n        }\n        for (let k in meta.sub) {\n          rec(meta.sub[k],obj ? obj[k] : null,d+1)\n        }\n      } else {\n        f(meta,obj,stack,d)\n      }\n    }\n    rec(meta,obj,0)\n  }\n//\n  // adjust - show root head only if special\n  if (rowmeta1.special)\n    extraRows += 1\n//\n//\n/*\n  //\n  // Pseudocode for 2D tables:\n  //\n  // compute colmeta\n  for (let c in template) {\n    colmeta[c] = { span: 0, sub: {} }\n    for (let d in template[c]) {\n      colmeta[c].sub[d] = { span: 1, sub: {} }\n      colmeta[c].span++\n    }\n  }\n  // compute rowmeta\n  for (let c in obj) {\n    rowmeta[c] = { span: 0, sub: {} }\n    for (let d in obj[c]) {\n      // compute index in immediate parent (to show/hide)\n      rowmeta[c].sub[d] = { span: 1, index: rowmeta[c].span, sub: {} }\n      rowmeta[c].span++\n    }\n  }\n*/\n//\n  m.begin(\"min-w-full max-w-xl overflow-auto\") // hscroll\n//\n  m.begin(m.table())\n  m.domParent.className = \"table-fixed xxmin-w-full\"\n  m.domParent.style[\"border-collapse\"] = \"collapse\"\n  //m.domParent.style[\"border\"] = \"1px solid black\"\n  //m.domParent.style[\"width\"] = \"100%\"\n  //m.domParent.style[\"text-align\"] = \"left\"\n//\n  // emit col declarations\n  let totalCols = numRows + extraRows + colmeta1.span\n  for (let i = 0; i < totalCols; i++) {\n    m.col().className = \"w-48\"\n  }\n//\n  m.begin(m.thead())\n    m.domParent.className = \"border-b border-gray-200 divide-gray-200\"\n//\n  // thead and tbody\n  for (let i = 0; i < numCols; i++) {\n    // header row\n    m.begin(m.tr())\n      //m.domParent.className = \"text-right w-\"+w+\" max-w-sm truncate\"\n      if (i == 0 && numCols && (numRows + extraRows)) {\n        m.begin(m.th()) // top left empty\n          m.domParent.rowSpan = numCols\n          m.domParent.colSpan = numRows + extraRows // account for root\n          renderHead(\"\")\n        m.end()\n      }\n      // colums\n      iterateMeta(colmeta1,null,i+1, node => {\n        m.begin(m.th())\n          m.domParent.colSpan = node.span\n          m.domParent.className = \"text-right truncate\"\n          renderHead(node.key)\n        m.end()\n      })\n    m.end()\n  }\n//\n/*\n  //\n  // Pseudocode for 2D tables:\n  //\n  // 1st header row\n  m.begin(m.tr())\n    m.begin(m.th()) // top left empty\n      m.domParent.rowSpan = numCols\n      m.domParent.colSpan = numRows\n    m.end()\n  for (let c in colmeta) {\n    let meta1 = colmeta[c]\n    m.begin(m.th())\n      m.domParent.colSpan = meta1.span\n      m.domParent.className = \"text-left max-w-sm truncate\"\n      m.styled(\"inline\", c)\n    m.end()\n  }\n  m.end()\n  // 2nd header row\n  m.begin(m.tr())\n  for (let c in colmeta) {\n  for (let d in colmeta[c].sub) {\n    let meta1 = colmeta[c]\n    let meta2 = meta1.sub[d]\n    m.begin(m.th())\n      m.domParent.colSpan = meta2.span\n      m.domParent.className = \"text-left max-w-sm truncate\"\n      m.styled(\"inline\", d)\n    m.end()\n  }\n  }\n  m.end()\n*/\n//\n  m.end()\n  m.begin(m.tbody())\n  m.domParent.className = \"table-fixed xxmin-w-full divide-y divide-gray-200\"\n//\n//\n//\n  iterateMeta(rowmeta1,obj,numRows, (node,obj,stack,depth) => {\n    // row header\n    m.begin(m.tr())\n      // row header: only at index 0 or if special node\n      let lastNonZero = 0\n      let lastSpecial = 0\n      for (let i = 0; i < depth; i++) {\n        if (stack[i+1].index != 0)\n          lastNonZero = i+1\n        if (stack[i].special && i < depth)\n          lastSpecial = i\n      }\n      // row headers\n      for (let i = Math.max(lastNonZero,lastSpecial); i < depth; i++) {\n          if (i == 0 && !stack[0].special) continue; // don't show root...\n          m.begin(m.th())\n            let {key, span, special} = stack[i]\n            if (special) span -= 1\n            m.domParent.rowSpan = span\n            m.domParent.className = \"text-left max-w-sm truncate\"\n            if (special)\n              renderCell(\"&nbsp;\") // placeholder only\n            else\n              renderHead(key)\n          m.end()\n      }\n      // is this a special object? (interior node with own props)\n      if (depth < numRows) {\n          m.begin(m.th())\n            m.domParent.colSpan = 1 + numRows - depth\n            m.domParent.className = \"text-left max-w-sm truncate\"\n            //m.domParent.style.color = \"navy\"\n            renderHead(stack[depth].key)\n          m.end()\n      } else {\n          m.begin(m.th())\n            //m.domParent.colSpan = 1\n            m.domParent.className = \"text-left max-w-sm truncate\"\n            //m.domParent.style.color = \"pink\"\n            renderHead(stack[depth].key)\n          m.end()\n      }\n      // column data\n      iterateMeta(colmeta1,obj,numCols, (node,obj,stack) => {\n        m.begin(m.td())\n          m.domParent.className = \"text-right max-w-sm truncate\"\n          renderCell(obj,stack[stack.length-1].key)\n        m.end()\n      })\n    m.end()\n  })\n//\n//\n//\n  /*\n  //\n  // Pseudocode for 2D tables:\n  //\n  for (let row1 in obj) {\n  for (let row2 in obj[row1]) {\n    let obj1 = obj[row1]\n    let obj2 = obj1[row2]\n    let meta1 = rowmeta[row1]\n    let meta2 = meta1.sub[row2]\n    m.begin(m.tr())\n      // row headers\n      if (meta2.index == 0) {\n      m.begin(m.th())\n        m.domParent.rowSpan = meta1.span\n        m.domParent.className = \"text-left max-w-sm truncate\"\n        m.styled(\"inline\", row1)\n      m.end()\n      }\n      m.begin(m.th())\n        m.domParent.rowSpan = meta2.span\n        m.domParent.className = \"text-left max-w-sm truncate\"\n        m.styled(\"inline\", row2)\n      m.end()\n      // column data\n      for (let c in template) {\n      for (let d in template[c]) {\n        m.begin(m.td())\n          m.domParent.className = \"max-w-sm truncate\"\n          m.styled(\"inline\", String(obj2[c][d]))\n        m.end()\n      }\n      }\n    m.end()\n  }\n  }\n  */\n  m.end()\n  m.end()\n  m.end()\n}\n</code>\n<p>Test 1: row/col nesting variations</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {region:\"Asia\",city:\"Beijing\",\"population\":20},\n  {region:\"Asia\",city:\"Tokyo\",\"population\":30},\n]\nprint(\"Nest\")\ntable3d([],[],data)\nprint(\"Row,nest\")\ntable3d([\"index\"],[],data)\nprint(\"Col,nest\")\ntable3d([],[\"index\"],data)\nprint(\"Row,col\")\ntable3d([\"index\"],[\"key\"],data)\nprint(\"Row,row\")\ntable3d([\"index\",\"key\"],[],data)\nprint(\"Col,col\")\ntable3d([],[\"index\",\"key\"],data)\n</code>\n</aside>\n<aside>\n<p>Generic display</p>\n<p>Implementation</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n//\nfunction display(o) {\n  switch (o?.[\"$display\"]) {\n    case \"table\":\n      return table3d(o.rows,o.cols,o.data,o.template)\n    case \"select\":\n      return tabGroups(o.data)\n    case \"bar\":\n      let x = o.value\n      let dd = m.add(e(\"span\",{}))\n      //dd.style[\"vertical-align\"] = \"baseline\"\n      dd.style.display = \"inline-block\"\n      dd.style.border = \"1px solid black\"\n      dd.style.backgroundColor = \"#EEEEEE\"\n      dd.style.width = x+\"px\"\n      dd.style.height = \"0.7em\"\n      return dd\n    case \"dom\":\n      let type = o.type ?? \"span\"\n      let props = o.props ?? {}\n      let children = o.children ?? {}\n      let children1 = []\n      for (let i in children) {\n        let child = children[i]\n        if (typeof(child) === \"string\")\n          children1.push(child) // do not recurse on strings\n        else\n          children1.push(display(child))\n      }\n      return m.add(e(type,props,...children1))\n    default:\n      return m.add(inspector(o))\n  }\n}\n//\n// select / tab group panel\n//\nfunction tabGroups(data) {\n  let keys = Object.keys(data)\n  if (!keys.length) return d\n  function styleButton(btn,selected) {\n    btn.style.display = \"inline-block\"\n    btn.style.border = \"1px solid black\"\n    //btn.style.borderRadius = \"6px\"\n    btn.style.padding = \"1px 10px 1px 10px\"\n    //btn.style.marginRight = \"10px\"\n    btn.style.cursor = \"pointer\"\n    if (selected) {\n      btn.style.color = \"white\"\n      btn.style.background = \"black\"\n    } else {\n      btn.style.background = \"white\"\n      btn.style.color = \"black\"\n    }\n  }\n  let selected = keys[0]\n  let buttons = {}\n  let d\n  m.begin()\n    m.begin()\n      m.domParent.style.marginBottom = \"5px\"\n      for (let k of keys) {\n        let btn = buttons[k] = m.add(e(\"span\",{},k))\n        btn.onclick = m.local(ev => render(selected = k))\n      }\n    m.end()\n    d = m.div()\n  m.end()\n  function render() {\n    d.innerText = \"\"\n    m.begin(d)\n      for (let k of keys)\n        styleButton(buttons[k], k == selected)\n      display(data[selected])\n    m.end()\n  }\n  render()\n}\n</code>\n<h3>Table with Custom Cells</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = {\n  \"$display\": \"table\",\n  rows: [0], cols: [1],\n  data: [\n    {region:\"Asia\",city:\"Beijing\",\"population\":{\"$display\":\"bar\",value:40}},\n    {region:\"Asia\",city:\"Tokyo\",\"population\":{\"$display\":\"bar\",value:70}},\n  ]\n}\ndisplay({\n  \"$display\": \"select\",\n  data: {\n    \"Data Table\": data,\n    \"Other Object\": {A:1,b:2}\n  }\n})\n</code>\n<h3>Raw DOM</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$display: dom\nprops: ...\nchildren: ...</code></pre></div>\n<p>Q: inline props?</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ndisplay({\n  \"$display\": \"dom\",\n  type: \"h1\",\n  props: { style: { color: \"lime\" }},\n  children: [\"hello\", \" \", \"jolly\", \" \", \"world\"]\n})\n</code>\n<h3>SVG</h3>\n<p>‚Äúgeoms‚Äù</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ndisplay({\n  \"$display\": \"dom\", type: \"svg:svg\",\n  props: { width: \"300px\", height: \"50px\" },\n  children: [{\n    \"$display\": \"dom\", type: \"svg:rect\",\n    props: { width: \"30px\", height: \"30px\", x: \"10px\", y: \"10px\", fill: \"black\" },\n  },{\n    \"$display\": \"dom\", type: \"svg:ellipse\",\n    props: { rx: \"15px\", ry: \"15px\", cx: \"75px\", cy: \"25px\", fill: \"black\" },\n  },{\n    \"$display\": \"dom\", type: \"svg:rect\",\n    props: { width: \"30px\", height: \"30px\", x: \"110px\", y: \"10px\", fill: \"black\" },\n  }]\n})\n</code>\n</aside>\n<aside>\n<p>CSV loader</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction parseCSV(data) {\n  data = data.split(\"\\n\")\n  let names = data[0].split(\",\")\n  let types = data[1].split(\",\").map(x => isNaN(Number(x)) ? (x => x.trim()) : (x => Number(x)))\n  let data1 = []\n  for (let i = 1; i < data.length; i++) {\n    let line = data[i]\n    let items = line.split(\",\")\n    let row = {}\n    for (let i in names)\n      row[names[i]] = types[i](items[i])\n    data1.push(row)\n  }\n  return data1\n}\nfunction loadCSV(url) {\n  return fetch(url).then(p => p.text()).then(p => parseCSV(p))\n}\n</code>\n<h3>Example 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\ndisplay(parseCSV(\"A,B,C\\n1,2,3\"))\n</code>\n<h3>Example 2: Warehouse</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction loadWarehouseDataset() {\n  let str = `warehouse,product,model,quantity\nSan Jose,iPhone,6s,100\nSan Francisco,iPhone,6s,50\nSan Jose,iPhone,7,50\nSan Francisco,iPhone,7,10\nSan Jose,iPhone,X,150\nSan Francisco,iPhone,X,200\nSan Jose,Samsung,Galaxy S,200\nSan Francisco,Samsung,Galaxy S,200\nSan Francisco,Samsung,Note 8,100\nSan Jose,Samsung,Note 8,150`\n  return new Promise(f => f(parseCSV(str)))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nloadWarehouseDataset().then(show)\nfunction show(data) {\n  table3d(1,1,data)\n}\n</code>\n</aside>\n<p>Query engine</p>\n<aside>\n<p>Implementation</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ---------- API ----------\n//\n//\nlet debug = false\nlet trace = false\nlet api = {}\n{\n//\n// reducer (e.g., sum) expressions\n//\napi[\"sum\"] = (e) => ({\n  xxkey: \"sum\",\n  xxparam: e\n})\napi[\"count\"] = (e) => ({\n  xxkey: \"count\",\n  xxparam: e\n})\napi[\"max\"] = (e) => ({\n  xxkey: \"max\",\n  xxparam: e\n})\napi[\"join\"] = (e) => ({\n  xxkey: \"join\",\n  xxparam: e\n})\napi[\"array\"] = (...es) => ({\n  xxkey: \"array\",\n  xxparam: es\n})\napi[\"last\"] = (e) => ({\n  xxkey: \"last\",\n  xxparam: e\n})\napi[\"first\"] = (e) => ({\n  xxkey: \"first\",\n  xxparam: e\n})\napi[\"keyval\"] = (k,v) => ({\n  xxkey: \"keyval\",\n  xxparam: [k,v]\n})\napi[\"flatten\"] = (k,v) => ({\n  xxkey: \"flatten\",\n  xxparam: [k,v]\n})\napi[\"merge\"] = (k,v) => ({\n  xxkey: \"merge\",\n  xxparam: [k,v]\n})\n//\n// path expressions\n//\napi[\"get\"] = (e1,e2) => ({\n  xxpath: \"get\",\n  xxparam: [e1,e2]\n})\napi[\"apply\"] = (e1,e2) => ({\n  xxpath: \"apply\",\n  xxparam: [e1,e2]\n})\napi[\"pipe\"] = (e1,e2) => ({ // reverse apply\n  xxpath: \"apply\",\n  xxparam: [e2,e1]\n})\napi[\"plus\"] = (e1,e2) => ({\n  xxpath: \"plus\",\n  xxparam: [e1,e2]\n})\napi[\"minus\"] = (e1,e2) => ({\n  xxpath: \"minus\",\n  xxparam: [e1,e2]\n})\napi[\"times\"] = (e1,e2) => ({\n  xxpath: \"times\",\n  xxparam: [e1,e2]\n})\napi[\"fdiv\"] = (e1,e2) => ({\n  xxpath: \"fdiv\",\n  xxparam: [e1,e2]\n})\napi[\"div\"] = (e1,e2) => ({\n  xxpath: \"div\",\n  xxparam: [e1,e2]\n})\napi[\"mod\"] = (e1,e2) => ({\n  xxpath: \"mod\",\n  xxparam: [e1,e2]\n})\n// ---------- Fluent API ----------\nlet Pipe = {\n  sum:   function() { return pipe(api.sum(this)) },\n  count: function() { return pipe(api.count(this)) },\n  max:   function() { return pipe(api.max(this)) },\n  first: function() { return pipe(api.first(this)) },\n  last:  function() { return pipe(api.last(this)) },\n  group: function(k) { let o = {}; o[k] = this; return pipe(o) },\n  map:   function(e) { return pipe(api.apply(e,this)) },\n  get:   function(e) { return pipe(api.get(this,e)) },\n}\nfunction pipe(e) {\n  if (typeof(e) === \"string\")\n    e = api.get(e)\n  let res = Object.create(Pipe)\n  for (let k in e)\n    res[k] = e[k]\n  return res\n}\n//\n// ---------- Internals ----------\n//\n// string literal or iterator variable?\nlet isVar = s => s.startsWith(\"*\") // || s.startsWith(\"$\") || s.startsWith(\"%\")\nlet quoteVar = s => \"KEY\" + s.replaceAll(\"*\",\"_star_\") // dollar, percent, ...\n//\n// create an expression with code 'txt' and dependency on symbols 'args'\nlet expr = (txt,...args) => ({txt,deps:args})\n//\nlet ident = s => isVar(s) ? expr(quoteVar(s),s) : expr(\"'\"+s+\"'\")\n//\n// test if expr is a variable (TODO: optimize. Add a flag?)\nlet exprIsVar = e => e.deps.length == 1 && e.txt == quoteVar(e.deps[0])\n//\n// TODO: support vararg in select/call?\nlet select = (a,b) => expr(a.txt + \"[\"+b.txt+\"]\", ...a.deps,...b.deps)\nlet call = (a,b) => expr(\"\"+a.txt + \"(\" + b.txt+\")\", ...a.deps,...b.deps)\nlet binop = (op,a,b) => expr(\"(\"+a.txt + op + b.txt+\")\", ...a.deps,...b.deps)\nlet unop = (op,a) => expr(op+\"(\"+a.txt+\")\", ...a.deps)\n//\n// path: number, identifier, selection\n//    disambiguate\n//      - total +=\n//      - data.foo +=\n//\n//\n// TODO: reset these in main func\n//\nlet generatorStms = []\nlet assignmentStms = []\nlet allsyms = {}\n//\nlet currentGroupPath = []\nlet tmpVarCount = 0\nlet extraLoopDeps = {} // for each loop sym, a list of extra dependencies\nlet tmpVarWriteRank = {} // for each writable var sym, the number of consecutive write stms\n//\n//\nfunction assign(lhs,op,rhs) {\n  let e = expr(lhs.txt + \" \" + op + \" \" + rhs.txt, ...lhs.deps, ...rhs.deps)\n  e.lhs = lhs\n  e.op = op\n  e.rhs = rhs\n  e.writeSym = lhs.root\n  e.deps = e.deps.filter(e1 => e1 != e.writeSym) // remove cycles\n  // update sym to rank dep map\n  tmpVarWriteRank[e.writeSym] ??= 1\n  e.writeRank = tmpVarWriteRank[e.writeSym]\n  // if (e.op != \"+=\") // do not increment for idempotent ops? (XX todo opt)\n  tmpVarWriteRank[e.writeSym] += 1\n  assignmentStms.push(e)\n}\n//\n//\n//\nfunction selectUser(a,b) {\n  if (exprIsVar(b)) {\n    let b1 = b.deps[0]\n    let e = expr(\"for \"+b1+\" <- \"+a.txt, ...a.deps)\n    e.sym = b1\n    e.rhs = a.txt\n    if (generatorStms.every(e1 => e1.txt != e.txt)) // generator CSE\n      generatorStms.push(e)\n    allsyms[b1] = true\n  }\n  return select(a,b)\n}\n//\n//\n// -- Paths (pure) --\n//\n// base path: number (5), string (foo), selection (foo.bar)\n//\n// TODO: add mode flag -- is string allowed? E.g. not lhs of selection,\n//                           i.e. \"foo\" in api.get(\"foo\",\"bar\")\n//\n// contract: argument p is a Number or String\n//\nfunction path0(p) {\n  if (typeof(p) == \"number\" || !Number.isNaN(Number(p)))  // number?\n    return expr(p)\n  let as = p.split(\".\")\n  if (as.length == 1) return ident(as[0])\n  let ret = expr(\"inp\")\n  for (let i = 0; i < as.length; i++) {\n    if (as[i] == \"\")\n      continue // skip empty\n    ret = selectUser(ret,ident(as[i]))\n  }\n  return ret\n}\n//\n// special path operators: get, apply (TODO!)\n//\n//\nfunction path1(p) {\n  // TODO: assert non null?\n  if (typeof(p) == \"object\" || typeof(p) == \"function\") { // treat fct as obj\n    if (p.xxpath) { // path\n      if (p.xxpath == \"get\") {\n        let [e1,e2] = p.xxparam\n        // TODO: e1 should never be treated as id!\n        // TODO: vararg?\n        return (e2 !== undefined) ? selectUser(path1(e1),path1(e2)) : path1(e1)\n      } else if (p.xxpath == \"apply\") {\n        let [e1,e2] = p.xxparam\n        // TODO: e1 should never be treated as id!\n        return call(path1(e1),path1(e2))\n      } else if (p.xxpath == \"plus\") {\n        let [e1,e2] = p.xxparam\n        return binop(\"+\",path1(e1),path1(e2))\n      } else if (p.xxpath == \"minus\") {\n        let [e1,e2] = p.xxparam\n        return binop(\"-\",path1(e1),path1(e2))\n      } else if (p.xxpath == \"times\") {\n        let [e1,e2] = p.xxparam\n        return binop(\"**\",path1(e1),path1(e2))\n      } else if (p.xxpath == \"fdiv\") {\n        let [e1,e2] = p.xxparam\n        return binop(\"/\",path1(e1),path1(e2))\n      } else if (p.xxpath == \"div\") {\n        let [e1,e2] = p.xxparam\n        return unop(\"Math.trunc\",binop(\"/\",path1(e1),path1(e2)))\n      } else if (p.xxpath == \"mod\") {\n        let [e1,e2] = p.xxparam\n        return unop(\"Math.trunc\",binop(\"%\",path1(e1),path1(e2)))\n      } else {\n        print(\"ERROR - unknown path key '\"+p.xxpath+\"'\")\n        return expr(\"undefined\")\n      }\n    } else if (p.xxkey) { // reducer (stateful)\n      return transStatefulInPath(p)\n    } else { // subquery\n      if (p instanceof Array)\n        print(\"ERROR - Array in path expr not supported yet!\")\n      //print(\"ERROR - we don't support subqueries right now!\")\n      //print(\"TODO: decorrelate and extract\")\n      //inspect(p)\n      //\n      // A stateless object literal: we treat individual\n      // entries as paths, and build a new object for each\n      // series of produced results.\n      //\n      // We take the combined dependencies of the right-hand\n      // side, subtract dependencies of the left-hand side,\n      // and use the remaining deps as a key for the resulting\n      // object.\n      //\n      // This means that we'll iterate over all deps(rhs)\n      // that aren't also in deps(lhs).\n      //\n      // Step 1: traverse RHS and gather dependencies\n      //\n      let entries = {}\n      let keydeps = {}\n      let rhsdeps = {}\n      for (let k of Object.keys(p)) {\n        // flatten, merge, etc.\n        let k1 = path(k)\n        let save = currentGroupPath\n        currentGroupPath = [...currentGroupPath,k1]\n        let rhs1 = path(p[k])\n        currentGroupPath = save\n        entries[k] = { key: k1, rhs: rhs1 }\n        for (d of k1.deps) keydeps[d] = true\n        for (d of rhs1.deps) rhsdeps[d] = true\n      }\n      //\n      // Step 2: build new object, aggregating individual\n      //         paths and indexed by deps(rhs) - deps(lhs)\n      //\n      let save = currentGroupPath\n      let deps = []\n      for (let d in rhsdeps) if (isVar(d) && !(d in keydeps)) deps.push(d)\n      let plus = deps.map(ident)\n      currentGroupPath = [...currentGroupPath,...plus]\n      let lhs1 = createFreshTempVar(deps)\n      assign(lhs1, \"??=\", expr(\"{}\"))\n      for (let k of Object.keys(p)) {\n        let {key,rhs} = entries[k]\n        let ll1 = select(lhs1,key)\n        ll1.root = lhs1.root\n        assign(ll1, \"=\", rhs)\n      }\n      currentGroupPath = save\n      //print(\"XXX fresh temp var \")\n      //inspect({lhs1,entries,deps,plus})\n      return lhs1\n    }\n  } else if (typeof(p) == \"number\") {\n    return path0(p)\n  } else {\n    // TODO: assert it's a string?\n    return path0(String(p))\n  }\n}\nfunction path(p) { return path1(p) }\n//\n//\n// -- Reducers (side effects) --\n//\n//\nfunction transStatefulInPath(p) {\n  return stateful(null,p)\n}\nfunction transStatefulTopLevel(p) {\n  return stateful(null,p)\n}\n//\n//\nfunction relevantGroupPath(deps) {\n  if (!deps)\n    return currentGroupPath // no deps given -> not filtering\n  //\n  let out = []\n  for (let e of currentGroupPath) {\n    // XXX: we explicitly keep entries with no deps\n    // (potential optimization to drop those, but may cause\n    // some trouble in scheduling)\n    // TODO test this again\n    // NOTE tried again, seems to work, except it changes order (e.g. out.total)\n    if (!e.deps.length || e.deps.filter(x => deps.indexOf(x) >= 0).length) {\n      out.push(e)\n    }\n  }\n  return out\n}\nfunction entireGroupPathIsRelevant(deps) {\n  return currentGroupPath.length == relevantGroupPath(deps).length\n}\nfunction canDecorrelateGroupPath(deps) {\n  return !entireGroupPathIsRelevant(deps)\n}\nfunction createFreshTempVar(deps) {\n  // XXX update loop-to-loop effect dep map\n  // when decorrelating, new fresh var should be\n  // computed before current loop. Add an extra\n  // dependency to loop generator.\n  //\n  // Example (as done now):\n  //\n  //  out[data.*A.key] += data.*B.value  (add: *B before *A)\n  //\n  // Alternative:\n  //\n  //  tmp += data.*B.value\n  //  out[data.*A.key] = tmp (add: tmp before *A)\n  //\n  // This appears somewhat more desirable, but had the drawback\n  // that the entire loop over *A was pulled into loop *B.\n  // Hence we currently stick to loop-after-loop dependencies.\n  //\n  // let allDeps = []\n  // for (let e of currentGroupPath) {\n  //   for (let x of e.deps)\n  //     if (allDeps.indexOf(x) < 0)\n  //       allDeps.push(x)\n  // }\n  // for (let x2 of allDeps) {\n  //   for (let x1 of deps) {\n  //     if (x1 == x2) continue\n  //     if (!extraLoopDeps[x2]) extraLoopDeps[x2] = []\n  //     if (extraLoopDeps[x2].indexOf(x1) < 0)\n  //       extraLoopDeps[x2].push(x1)\n  //   }\n  // }\n  // if (trace) print(\"tmp\"+tmpVarCount+\" ... \"+deps+\" before \"+allDeps)\n  // XXX\n  //\n  let lhs1 = select(expr(\"tmp\"),expr(\"\"+(tmpVarCount++)))\n  let root = lhs1.txt\n  lhs1.root = root\n  lhs1.deps = [root]\n  for (let e of relevantGroupPath(deps)) {\n    assign(lhs1, \"??=\", expr(\"{}\"))\n    lhs1 = select(lhs1,e)\n    lhs1.root = root\n  }\n  return lhs1\n}\nfunction openTempVar(lhs, deps) {\n  if (lhs && entireGroupPathIsRelevant(deps))\n    return lhs\n  else\n    return createFreshTempVar(deps)\n}\nfunction closeTempVar(lhs, lhs1) {\n    //\n    //\n//  let allDeps = []\n//  for (let e of currentGroupPath) {\n//    for (let x of e.deps)\n//      if (allDeps.indexOf(x) < 0)\n//        allDeps.push(x)\n//  }\n//print(\"alldeps: \"+lhs1.deps+\" before \"+allDeps)\n    //\n    //\n  if (lhs && lhs != lhs1) {\n    assign(lhs, \"=\", lhs1)\n    return lhs\n  } else {\n    return lhs1\n  }\n}\n//\n//\nfunction stateful(lhs,p) {\n  //\n  // total: api.sum(data.*.value)\n  // k:     api.xxkey(xxparam)\n  //\n  if (p.xxkey == \"sum\") { // sum\n    let rhs = path(p.xxparam)\n    let lhs1 = openTempVar(lhs, rhs.deps)\n    assign(lhs1, \"??=\", expr(\"0\"))\n    assign(lhs1, \"+=\", rhs)\n    return closeTempVar(lhs, lhs1)\n  } else if (p.xxkey == \"count\") { // count\n    let rhs = path(p.xxparam)\n    let lhs1 = openTempVar(lhs, rhs.deps)\n    assign(lhs1, \"??=\", expr(\"0\"))\n    assign(lhs1, \"+=\", expr(\"1\", ...rhs.deps))\n    return closeTempVar(lhs, lhs1)\n  } else if (p.xxkey == \"max\") { // max\n    let rhs = path(p.xxparam)\n    let lhs1 = openTempVar(lhs, rhs.deps)\n    assign(lhs1, \"??=\", expr(\"-Infinity\"))\n    assign(lhs1, \"=\", expr(\"Math.max(\"+lhs1.txt+\",\"+rhs.txt+\")\", ...rhs.deps))\n    return closeTempVar(lhs, lhs1)\n  } else if (p.xxkey == \"join\") { // string join\n    let rhs = path(p.xxparam)\n    let lhs1 = openTempVar(lhs, rhs.deps)\n    assign(lhs1, \"??=\", expr(\"''\"))\n    assign(lhs1, \"+=\", rhs)\n    return closeTempVar(lhs, lhs1)\n  } else if (p.xxkey == \"array\") { // array\n    let rhs = p.xxparam.map(path)\n    let lhs1 = openTempVar(lhs, rhs.flatMap(x=>x.deps))\n    assign(lhs1, \"??=\", expr(\"[]\"))\n    for (let e of rhs)\n      assign(lhs1, \".push\", expr(\"(\"+e.txt+\")\", ...e.deps))\n    return closeTempVar(lhs, lhs1)\n  } else if (p.xxkey) {\n    print(\"ERROR: unknown reducer key '\"+p.xxkey+\"'\")\n    return expr(\"undefined\")\n  } else if (p instanceof Array) {\n    return stateful(lhs, {xxkey: \"array\", xxparam: p})\n  } else if (p instanceof Array) {\n    // XXX not using this anymore\n    if (p.length > 1) {\n      print(\"ERROR: currently not dealing correctly with multi-element arrays\")\n      //return expr(\"undefined\")\n    }\n    let lhs1 = openTempVar(lhs, null)\n    assign(lhs1, \"??=\", expr(\"[]\"))\n    let kCount = 0\n    for (let k in p) {\n      let o = p[k]\n      //kCount = api.plus(kCount,api.count(o))\n    }\n    //\n    // XXX: index for multiple sums isn't the right one yet!!\n    //\n    for (let k in p) {\n      let o = p[k]\n      kCount = api.plus(kCount,api.count(o))\n      //let k0 = path(api.count(o))\n      let k1 = path(api.minus(kCount,1))\n      // TODO: support merge/flatten, too?\n      let save = currentGroupPath\n      currentGroupPath = [...currentGroupPath,k1]\n      let ll1 = select(lhs1,k1)\n      ll1.root = lhs1.root\n      stateful(ll1,o)\n      currentGroupPath = save\n    }\n    return closeTempVar(lhs, lhs1)\n  } else if (typeof(p) == \"object\" && !p.xxpath) {\n    //\n    // TODO: we don't have the entire rhs, so how to get rhs.deps?\n    //\n    //   Right now we have no way to decorrelate ...\n    //\n    let lhs1 = openTempVar(lhs, null)\n    assign(lhs1, \"??=\", expr(\"{}\"))\n    let keys = Object.keys(p)\n    for (let k of keys) {\n      let o = p[k]\n      // NOTE: more expressive merge/flatten could traverse\n      //       child object (to support multiple keys)\n      if (p[k].xxkey == \"keyval\" || p[k].xxkey == \"merge\") { // nesting\n        o = p[k].xxparam[1]\n        k = p[k].xxparam[0]\n      } else if (p[k].xxkey == \"flatten\") { // same, but include parent key\n        o = p[k].xxparam[1]\n        k = api.plus(api.plus(k,\"-\"), p[k].xxparam[0])\n      }\n      let k1 = path(k)\n      let save = currentGroupPath\n      currentGroupPath = [...currentGroupPath,k1]\n      let ll1 = select(lhs1,k1)\n      ll1.root = lhs1.root\n      stateful(ll1,o)\n      currentGroupPath = save\n    }\n    return closeTempVar(lhs, lhs1)\n  } else {\n    // regular path\n    let rhs = path(p)\n    let lhs1 = openTempVar(lhs, rhs.deps)\n    assign(lhs1, \"=\", rhs)\n    return closeTempVar(lhs, lhs1)\n  }\n}\n//\n// main entrypoint\n//\napi[\"show\"] = (query,data,explain) => {\n  let f = api[\"query\"](query)\n  return display(f(data))\n}\napi[\"exec\"] = (query,data) => {\n  let f = api[\"query\"](query)\n  return f(data)\n}\napi[\"query\"] = api[\"compile\"] = (query) => {\n  //\n  // process query root\n  //\n  let res = transStatefulTopLevel(query)\n  //\n  // debug informationn\n  //\n  let explain = {}\n  explain.src = query\n  //\n  // init codegen\n  //\n  let code = []\n  let indent = 0\n  function emit(str) {\n    if (str.indexOf(\"}\") == 0) indent--\n    code.push(\"\".padEnd(indent*4, '¬†') + str)\n    if (str.indexOf(\"{\") >= 0) indent++\n    if (str.indexOf(\"}\") > 0) indent--\n  }\n  emit(\"inp => {\")\n  emit(\"let tmp = {}\")\n  if (debug) {\n    print(\"---- begin code ----\")\n    for (let e of assignmentStms)\n      if (e.txt.indexOf(\"??=\") < 0) // skip init stms\n        print(e.txt + \"  // \" + e.writeSym + \" #\" + e.writeRank + \" <- \" + e.deps)\n    print(\"return \"+res.txt)\n    print(\"---- end code ----\")\n  }\n  explain.ir = {}\n  explain.ir.assignments = [...assignmentStms]\n  explain.ir.generators = [...generatorStms]\n  explain.ir.generators = [...generatorStms]\n  //\n  // Fix explicit loop ordering (added 11/28):\n  //\n  //    tmp0 <- *A\n  //    tmp1 <- *tmp0, *B\n  //\n  // means: *A before *B\n  //\n  // It's not quite sufficient to say \"tmp0 before *B\" because\n  // that might suck the *B loop into the *A loop (right after\n  // the write to tmp0).\n  //\n  // Possible refinement:\n  //\n  // NOTE: we're currently treating tmp's as atomic (all writes)\n  // together. This is probably too coarse when we want to deal\n  // with, say, largely independent queries composed into a\n  // single object.\n  //\n  // IDEA: distinguish tmp0#1, tmp0#2, i.e., take write rank\n  // into account (proper SSA form).\n  //\n  let tmpInsideLoop = {}\n  let tmpAfterLoop = {}\n  let tmpAfterTmp = {}\n  let loopAfterLoop = {}\n  let loopInsideLoop = {} // todo: \"not currently used\"\n  //\n  // compute tmpInsideLoop and tmpAfterTmp\n  //\n  for (let e of assignmentStms) {\n    //if (e.txt.indexOf(\"??=\") < 0) { // skip init stms (??)\n      let isloop = s => s.startsWith(\"*\")\n      let istmp = s => s.startsWith(\"tmp\")\n      tmpInsideLoop[e.writeSym] ??= {}\n      tmpAfterTmp[e.writeSym] ??= {}\n      for (let v of e.deps) {\n        if (isloop(v)) tmpInsideLoop[e.writeSym][v] = true\n        if (istmp(v)) tmpAfterTmp[e.writeSym][v] = true\n      }\n    //}\n  }\n  //\n  // compute tmpAfterLoop\n  //\n  for (let t2 in tmpAfterTmp) {\n    tmpAfterLoop[t2] ??= {}\n    // gather loop prior tmps are in\n    for (let t1 in tmpAfterTmp[t2]) {\n      for (let l in tmpInsideLoop[t1])\n        tmpAfterLoop[t2][l] = true\n    }\n    // remove own loops\n    for (let l in tmpInsideLoop[t2])\n      delete tmpAfterLoop[t2][l]\n  }\n  //\n  // compute loopAfterLoop\n  //\n  for (let t in tmpAfterLoop) {\n    for (let l2 in tmpInsideLoop[t]) {\n      loopAfterLoop[l2] ??= {}\n      for (let l1 in tmpAfterLoop[t]) {\n        // loops may be nested or sequenced\n        loopInsideLoop[l1] ??= {}\n        let nested = false\n        for (let tx in tmpInsideLoop)\n          if (tmpInsideLoop[tx][l1] && tmpInsideLoop[tx][l2])\n            { nested = true; break }\n        if (nested)\n          loopInsideLoop[l1][l2] = true\n        else\n          loopAfterLoop[l2][l1] = true\n      }\n    }\n    // TODO: do we need loopAfterTmp? seed loopAfterTmp/Loop from generator.deps?\n  }\n  explain.dependencies = {tmpInsideLoop,tmpAfterTmp,tmpAfterLoop,loopAfterLoop,loopInsideLoop}\n  let extraLoopDeps = loopAfterLoop\n  if (debug) {\n    inspect({tmpInsideLoop,tmpAfterTmp,tmpAfterLoop,loopAfterLoop,loopInsideLoop})\n    print(\"---- end dependency data ----\")\n  }\n  //\n  //\n  let availableSyms = {} // currently available in scope (for loops)\n  let emittedLoopSyms = {}   // loops that have been fully emitted\n  let emittedSymsRank = {}   // number of writes emitted for each sym\n  function isAvailable(s) {\n    if (s == \"inp\")\n      return true\n    if (s.startsWith(\"*\"))\n      return availableSyms[s]\n    if (s.startsWith(\"tmp\"))\n      return emittedSymsRank[s] == tmpVarWriteRank[s] // all writes emitted\n    return false\n  }\n  function depsAvailable(e) {\n    return e.deps.every(isAvailable)\n  }\n  function extraDepsAvailable(depMap) {\n    return (Object.keys(depMap)).every(s => emittedLoopSyms[s])\n  }\n  function loopsFinished(e) {\n    return extraDepsAvailable(tmpAfterLoop[e.writeSym])\n  }\n  function filterAvailable(stms) {\n    return stms.filter(e => depsAvailable(e) && loopsFinished(e))\n  }\n  function filterNotAvailable(stms) {\n    return stms.filter(e => !depsAvailable(e) || !loopsFinished(e))\n  }\n  function emitAssignments() {\n    // XXX Note: need to call this multiple times,\n    // as emitting stms makes others available\n    // TODO: refactor?\n    let stms = filterAvailable(assignmentStms)\n    assignmentStms = filterNotAvailable(assignmentStms)\n    for (let e of stms) {\n      emit(e.txt)\n      emittedSymsRank[e.writeSym] = e.writeRank+1\n    }\n  }\n  function emitGenerators(gntrStms) {\n    // symbol available <=> all its generators are available\n    // symbol available ? emit loop here : schedule in inner scope\n    //\n    // 1. group generators by symbol\n    // 2. emit loops for available symbols here\n    // 3. recurse to emit nested loops as they become available\n    //\n    // Note: this is like LMS scheduling. Go outside in, pick\n    // what should live at current level. Assume that each loop\n    //\n    //    ** EMITTED EXACTLY ONCE **.\n    //\n    // We have 3 levels of dependencies:\n    //\n    // - assignment or generator to loop var or temporary (true data dep, raw)\n    //    - if dep on temporary, really means the final value (rank), after all writes\n    // - assignment on previous assignment (write after write)\n    //    - synced by rank per temporary\n    // - loop after loop (read after write), e.g. loop *B before loop *A\n    //    - without this, we'd fill loops half and then detect order is wrong\n    //\n    // Note that kind 1 (generator on loop var dep) really only\n    // covers dependency of one generator on another -- not of\n    // one loop body on another generator!\n    //\n    // This means we're missing cases such as\n    //\n    //    data.*A.key -> data.*B.value\n    //\n    // because there is no dependency between *A and *B. Yet,\n    // we have to generate a nested loop to make this work.\n    //\n    // (Of course only if we don't decorrelate!)\n    //\n    // Issues:\n    //\n    //  - We can of course force loops to be nested by\n    //    lifting dependencies from assignments to gens.\n    //  - But we also may have assignments that should\n    //    *not* live in the nested loop!\n    //\n    //    So a generator may occur both in nested and\n    //    top level position.\n    //\n    //\n    // TODO: refinements\n    // + uncorrelated loops\n    //    - data.*A.key -> sum(data.*B.value)\n    //    - XX: done by emitting temp var above\n    // + generate 0 sum if no elements\n    //    - total: sum(empty.*.value)\n    //    - XX: done now, by emitting two assignments above\n    // - loop fusion\n    //    - same level, two generators with identical rhs\n    //        for *A <- in.data ... for *B <- in.data\n    // - direct cycles\n    //    - data.*.foo.*.bar\n    // - indirect cycles\n    //    - data.*A.foo.*B.bar ... other.*B.baz.*A.boo\n    //\n    //\n    let gensBySym = {}\n    // group generators by symbol\n    for (let e of generatorStms) {\n      if (!gensBySym[e.sym]) gensBySym[e.sym] = []\n      gensBySym[e.sym].push(e)\n    }\n    function symGensAvailable(s) {\n      return gensBySym[s].every(depsAvailable) &&\n             extraDepsAvailable(extraLoopDeps[s])\n    }\n    // compute generators left for inner scope\n    generatorStms = []\n    for (let s in gensBySym) {\n      if (!symGensAvailable(s))\n        generatorStms.push(...gensBySym[s])\n    }\n    // emit generators\n    for (let s in gensBySym) {\n      if (!symGensAvailable(s)) continue\n      let [e,...es] = gensBySym[s] // just pick first -- could be more clever!\n      // loop header\n      emit(\"for (let \"+quoteVar(e.sym)+\" in \"+e.rhs+\") {\")\n      // filters\n      for (let e1 of es) {\n        emit(\"if (!\"+e1.rhs+\"[\"+quoteVar(e1.sym)+\"]) continue\")\n      }\n      // recurse!\n      availableSyms[s] = true\n      emitConvergence()\n      // XX here: nested loops\n      // figure out which statements need nested loops\n      // XX done\n      delete availableSyms[s]\n      emit(\"}\")\n      emittedLoopSyms[s] = true\n    }\n  }\n  function emitConvergence() {\n    // emit assignments + generator as long as we're making progress\n    // (assignments may need multiple calls b/c effect deps)\n    let codeLength\n    do {\n      do {\n        codeLength = code.length\n        emitAssignments()\n      } while (codeLength < code.length)\n      emitGenerators()\n    } while (codeLength < code.length)\n  }\n  // XXX\n  emitConvergence()\n  if (assignmentStms.length) {\n    print(\"ERROR - couldn't emit the following assignments (most likely due to circular dependencies:\")\n    for (let e of assignmentStms) {\n      print(e.txt + \" ---- \" +e.deps)\n    }\n  }\n  //\n  // wrap up codegen\n  //\n  emit(\"return \" + res.txt)\n  emit(\"}\")\n  if (trace)\n    code.forEach(s => print(s))\n  let codeString = code.join(\"\\n\")\n  let queryFunc = eval(codeString)\n  queryFunc.explain = explain\n  queryFunc.explain.code = code\n  //queryFunc.explain.codeString = codeString\n  //\n  // execute\n  //\n  return queryFunc\n}}\n</code>\n<p>Status:</p>\n<ul>\n<li>basic temp data and decorrelation works</li>\n<li>compute group average, relative sum</li>\n<li>compute joins via subqueries</li>\n</ul>\n<p>Compilation approach:</p>\n<ul>\n<li>Einstein convention: implicit aggregation over free vars at the top level</li>\n<li>introduce stateful temp vars for things like sum() inside a path expression\n<ul>\n<li>indexed by current grouping path</li>\n</ul>\n</li>\n<li>also introduce stateful temp vars whenever a group key is not an rhs dep\n<ul>\n<li>indexed by ‚Äúrelevant‚Äù part of current grouping path (decorrelate)</li>\n</ul>\n</li>\n<li>assignments to a single temp var are serialized (there may be multiple)</li>\n<li>extract loop-after-loop dependencies from temp-after-temp information</li>\n</ul>\n<p>Caveats and rough edges:</p>\n<ul>\n<li>decorrelate objects (proper subqueries)\n<ul>\n<li>not quite sure how: do not have rhs deps up front?</li>\n<li>tracking writes too coarsely?</li>\n</ul>\n</li>\n<li>loop-in-loop dependencies\n<ul>\n<li>codegen currently doesn‚Äôt support nested loops\nunless one generator depends on another (this covers\nmany cases since we decorrelate aggressively)</li>\n<li>should be easy to infer further loop-in-loop\ndependencies from existing tmp-in-loop and\ngen-in-loop information</li>\n</ul>\n</li>\n</ul>\n<p>Potential extensions:</p>\n<ul>\n<li>sorting</li>\n<li>outer joins</li>\n<li>cycles (datalog)</li>\n<li>incrementality (data changes)</li>\n<li>partial re-evaluation (query changes, e.g. filter, select in UI)</li>\n</ul>\n</aside>\n</aside>\n<h3>Introductory Examples</h3>\n<p>Here is an example data set for illustration:</p>\n<pre>\nlet data = [\n  {key: 'A', val: 20},\n  {key: 'B', val: 30},\n  {key: 'A', val: 10}\n]\n</pre>\n<p>We can use familiar JS-like syntax to extract values\nand to create structured output:</p>\n<pre>\ndata.0.val                        // result: 20\n</pre>\n<pre>\n{ first: data.0.val }             // result: { first: 20 }\n</pre>\n<p>Things get more interesting once we add implicit iteration via ‚Äù<code class=\"language-text\">*</code>‚Äú:</p>\n<pre>\n[data.*.val]                      // result: [20, 30, 10]\n</pre>\n<pre>\nsum(data.*.val)                   // result: 60\n</pre>\n<pre>\n{ total: sum(data.*.val) }        // result: { total: 60 }\n</pre>\n<pre>\n{ data.*.key: [data.*.val] }      // result: { A: [20,10], B: [30] }\n</pre>\n<pre>\n{ data.*.key: sum(data.*.val) }   // result: { A: 30, B: 30 }\n</pre>\n<!--\n<pre>\n{ data.*.key:                     // result: { A: { total: 30},\n  { total: sum(data.*.val) } }                 B: { total: 30} }\n</pre>\n-->\n<p>All of these pieces can be combined flexibly:</p>\n<pre>\n{ data.*.key: {                   // result: {\n    total: sum(data.*.val),       //   A: { total:30, raw:[20,10] },\n    raw:   [data.*.val]           //   B: { total:30, raw:[30] }\n} }                               // }\n</pre>\n<p>Multiple variables such as ‚Äù<code class=\"language-text\">*A</code>‚Äù, ‚Äù<code class=\"language-text\">*B</code>‚Äù, etc. can be used to\nexpress joins, nested loops, etc.</p>\n<p>Finally, a top-level iteration without an explicit aggregation (sum, min, max, list, etc.) is implicitly aggregated to return the last value:</p>\n<pre>\ndata.*.val                        // result: 10\n</pre>\n<p>One could refine this with stricter behavior, e.g., demanding\nall values to be equal.</p>\n<aside>\n<p>Same code in interactive form</p>\n<p>Here is an example data set for illustration:</p>\n<code class=\"runScript\" filter=\"addPreamble\" name=\"data\">\nlet data = [\n  {key: 'A', val: 20},\n  {key: 'B', val: 30},\n  {key: 'A', val: 10}\n]\ntrace = false // <- set to true to print compiled code\nlet run = q => api.show(q, {data})\n</code>\n<p>We can use familiar JS-like syntax to extract values\nand to create structured output:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nrun(\"data.0.val\")\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nrun(\"data.0.val\")\nrun({ first: \"data.0.val\" })\n</code>\n<p>Things get more interesting once we add implicit iteration via <code class=\"language-text\">*</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nrun([\"data.*.val\"])\nrun(api.sum(\"data.*.val\"))\nrun({total:api.sum(\"data.*.val\")})\nrun({\"data.*.key\":[\"data.*.val\"]})\nrun({\"data.*.key\":api.sum(\"data.*.val\")})\n</code>\n<p>All of these pieces can be combined flexibly:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nrun({\n  \"data.*.key\": {\n    total: api.sum(\"data.*.val\"),\n    raw: [\"data.*.val\"]\n  }\n})\n</code>\n<!--\n<code class=\"runScript\" filter=\"coolEditor\">\napi.show(\"data.0.val\",{data})\napi.show({ first: \"data.0.val\" },{data})\napi.show([\"data.*.val\"],{data})\napi.show(api.sum(\"data.*.val\"),{data})\napi.show({total:api.sum(\"data.*.val\")},{data})\napi.show({\"data.*.key\":[\"data.*.val\"]},{data})\napi.show({\"data.*.key\":api.sum(\"data.*.val\")},{data})\napi.show({\n  \"data.*.key\": {\n    total: api.sum(\"data.*.val\"),\n    raw: [\"data.*.val\"]\n  }\n},{data})\n</code>\n-->\n<code class=\"runScript\" filter=\"addPreamble\" name=\"data\">\n</code>\n</aside>\n<h3>More Examples</h3>\n<aside>\n<p>Simple</p>\n<h3>Example 1: Plain sum</h3>\n<p>Exercise top-level stateful operation.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet query = api.sum(\"data.*.value\")\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data})\ndisplay(res)\n// ----------\nexpect(res, 60)\n</code>\n<h3>Example 2: Plain average</h3>\n<p>Exercise stateful operation nested in a stateless op.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet query = api.div(api.sum(\"data.*.value\"),api.count(\"data.*.value\"))\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data})\ndisplay(res)\n// ----------\nexpect(res, 20)\n</code>\n<h3>Example 3: Uncorrelated average</h3>\n<p>Exercise stateful operation nested in a stateless op.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet query = api.div(api.sum(\"data.*A.value\"),api.count(\"data.*B.value\"))\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data})\ndisplay(res)\n// ----------\nexpect(res, 20)\n</code>\n</aside>\n<aside>\n<p>Group-by</p>\n<h3>Example 1: Group by</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet query = {\n  total: api.sum(\"data.*.value\"),\n  \"data.*.key\": api.sum(\"data.*.value\"),\n}\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data})\ndisplay(res)\n// ----------\nexpect(res, {\"total\":60,\"A\":40,\"B\":20})\n</code>\n<h3>Example 2: Group by, Average</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet avg = p => api.div(api.sum(p), api.count(p))\nlet query = {\n  total: api.sum(\"data.*.value\"),\n  \"data.*.key\": avg(\"data.*.value\"),\n}\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data})\ndisplay(res)\n// ----------\nexpect(res, {\"total\":60,\"A\":20,\"B\":20})\n</code>\n<h3>Example 3: Group by, Relative Sum</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet query = {\n  total: api.sum(\"data.*.value\"),\n  \"data.*.key\": api.fdiv(api.sum(\"data.*.value\"),api.sum(\"data.*B.value\"))\n}\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data})\ndisplay(res)\n// ----------\nexpect(res, {\"total\":60,\"A\":0.6666666666666666,\"B\":0.3333333333333333})\n</code>\n<h3>Example 4: Nested Group and Aggregate</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {region: \"Asia\", country: \"Japan\", city: \"Tokyo\", population: 30},\n  {region: \"Asia\", country: \"China\", city: \"Beijing\", population: 20},\n  {region: \"Europe\", country: \"France\", city: \"Paris\", population: 10},\n  {region: \"Europe\", country: \"UK\", city: \"London\", population: 10},\n]\nlet query = {\n  total: api.sum(\"data.*.population\"),\n  \"data.*.region\": {\n    total: api.sum(\"data.*.population\"),\n    \"data.*.city\": api.sum(\"data.*.population\")\n  },\n}\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data})\ndisplay(res)\n// ----------\nexpect(res, {total: 70, Asia: {total: 50, Tokyo: 30, Beijing: 20}, Europe: {total: 20, Paris: 10, London: 10}})\n</code>\n</aside>\n<aside>\n<p>Join</p>\n<h3>Example 1: Join</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet other = [\n  {region: \"Asia\", country: \"Japan\"},\n  {region: \"Asia\", country: \"China\"},\n  {region: \"Europe\", country: \"France\"},\n  {region: \"Europe\", country: \"UK\"},\n]\nlet data = [\n  {country: \"Japan\", city: \"Tokyo\", population: 30},\n  {country: \"China\", city: \"Beijing\", population: 20},\n  {country: \"France\", city: \"Paris\", population: 10},\n  {country: \"UK\", city: \"London\", population: 10},\n]\nlet q1 = {\n  \"other.*O.country\": \"other.*O.region\"\n}\nlet query = {\n  \"-\": api.merge(api.get(q1,\"data.*.country\"), {\n    \"data.*.city\": api.sum(\"data.*.population\")\n  }),\n}\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data, other})\ndisplay(res)\n// ----------\nexpect(res, {\"Asia\":{\"Tokyo\":30,\"Beijing\":20},\"Europe\":{\"Paris\":10,\"London\":10}})\n</code>\n<h3>Example 2: Join With Aggregation</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet other = [\n  {region: \"Asia\", country: \"Japan\"},\n  {region: \"Asia\", country: \"China\"},\n  {region: \"Europe\", country: \"France\"},\n  {region: \"Europe\", country: \"UK\"},\n]\nlet data = [\n  {country: \"Japan\", city: \"Tokyo\", population: 30},\n  {country: \"China\", city: \"Beijing\", population: 20},\n  {country: \"France\", city: \"Paris\", population: 10},\n  {country: \"UK\", city: \"London\", population: 10},\n]\nlet q1 = {\n  \"other.*O.country\": \"other.*O.region\"\n}\nlet query = {\n  total: api.sum(\"data.*.population\"),\n  \"-\": api.merge(api.get(q1,\"data.*.country\"), {\n    total: api.sum(\"data.*.population\"),\n    \"data.*.city\": api.sum(\"data.*.population\")\n  }),\n}\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data, other})\ndisplay(res)\n// ----------\nexpect(res, {\"total\":70,\"Asia\":{\"total\":50,\"Tokyo\":30,\"Beijing\":20},\"Europe\":{\"total\":20,\"Paris\":10,\"London\":10}})\n</code>\n</aside>\n<aside>\n<p>UDFs</p>\n<h3>Example 1: UDFs</h3>\n<p>User-defined functions can be provided along with the input data</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {item: \"iPhone\", price: 1200},\n  {item: \"Galaxy\", price: 800},\n]\nlet udf = {\n  formatDollar: p => \"$\"+p+\".00\"\n}\nlet query = [{\n  item: \"data.*.item\",\n  price: api.apply(\"udf.formatDollar\", \"data.*.price\")\n}]\n// ----------\nlet exec = api.compile(query)\ndisplay(exec.explain)\nlet res = exec({data,udf})\ndisplay(res)\n// ----------\nexpect(res,[{item: \"iPhone\", price: \"$1200.00\"}, {item: \"Galaxy\", price: \"$800.00\"}])\n</code>\n</aside>\n<aside>\n<p>Arrays</p>\n<p>There are some tricky bits in implementing\nan aggregation operator that accumulates values\ninto an array. Test cases for common scenarios\nare below.</p>\n<h3>Test 1</h3>\n<p>A minimal test for nested simple accumulators:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet query4 = api.sum(api.sum(\"data.*.value\"))\nlet exc = api.compile(query4)\ninspect(exc.explain)\nlet res = exc({data})\ndisplay(res)\nexpect(res, 60)\n</code>\n<h3>Test 2</h3>\n<p>Test other variations of nested accumulators:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet queryA = {\"data.*.key\": api.array({foo:\"data.*.value\"})}\nlet queryB = api.array(api.array({foo:\"data.*.value\"}))\nlet query1 = api.array(api.array(\"data.*.value\"))\nlet query2 = api.array(api.sum(\"data.*.value\"))\nlet query2A = api.array({v:api.sum(\"data.*.value\")})\nlet query3 = api.join(api.array(\"data.*.value\"))\nlet query4 = api.sum(api.sum(\"data.*.value\"))\nlet res = api.compile({query1,query2,query2A,query3,query4})\ninspect(res.explain)\nlet vs = res({data})\nlet expected = {\n  query1: [[10,20,30]],\n  query2: [60],\n  query2A: [{v:60}],\n  query3: \"10,20,30\",\n  query4: 60,\n}\nfor (k in vs) {\n  print(\"-- \"+k+\" --\")\n  display(vs[k])\n  expect(vs[k], expected[k])\n}\n</code>\n<h3>Test 3 - FIXME?</h3>\n<p>Test multiple generators</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet query = {\"data.*.key\": [\"Extra1\",{foo:\"data.*.value\"},\"Extra2\"]}\nlet exec = api.compile(query)\ninspect(exec.explain)\nlet res = exec({data})\ndisplay(res)\nexpect(res, {A: [\"Extra1\", \"Extra2\", {foo: 10}, {foo: 30}],\nB: [\"Extra1\", \"Extra2\", {foo: 20}]})\n</code>\n<p>Q: it‚Äôs debatable if is this repetition of Extra1, Extra2\nin A is desirable, but it seems probably not!</p>\n<h3>Test 4</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet queryOK = [\"A\", {foo:\"data.*.value\"}]\nlet query = [{foo:\"data.*.value\"}, \"A\"]\nlet exec = api.compile(query)\ninspect(exec.explain)\nlet res = exec({data})\ndisplay(res)\nexpect(res, [\"A\", {foo: 10}, {foo: 20}, {foo: 30}])\n</code>\n<h3>Test 5</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet queryOK = [{ bar:\"x\", foo:\"data.*.value\"}]\nlet query = [{foo:\"data.*.value\", bar:\"x\"}]\nlet exec = api.compile(query)\ninspect(exec.explain)\nlet res = exec({data})\ndisplay(res)\nexpect(res, [{foo: 10, bar: \"x\"}, {foo: 20, bar: \"x\"}, {foo: 30, bar: \"x\"}])\n</code>\n<p>Previously there was an issue with this pattern that also occured\nfor plain sum or count:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet data = [\n  {key: \"A\", value: 10},\n  {key: \"B\", value: 20},\n  {key: \"A\", value: 30}\n]\nlet queryOK = [{ bar:\"x\", foo:\"data.*.value\"}]\nlet query = api.join({foo:\"data.*.value\", bar:\"x\"})\nlet exec = api.compile(query)\ninspect(exec.explain)\nlet res = exec({data})\ndisplay(res)\nexpect(res, \"[object Object][object Object][object Object]\")\n</code>\n</aside>\n<aside>\n<h3>Fluent API</h3>\n<p>Sometimes the JSON-style API with lots of nested objects\ncan become a bit cumbersome. Fortunately, we can use\nmetaprogramming to provide higher-level APIs that\ncompose queries.</p>\n<p>Below we present a ‚Äúfluent‚Äù API designed in this way\nthat provides a more pipeline-oriented interface.\nWe use an example from <a href=\"https://adventofcode.com/2022\">Advent of Code 2022</a>\nto illustrate.</p>\n<h3>The Challenge</h3>\n<p>Given the following input data, compute the sum for\neach block of lines, then the overall maximum.</p>\n<code class=\"runScript\" filter=\"addPreamble\" name=\"data\">\n// input data\nlet input = `1000\n2000\n3000\n.\n4000\n.\n5000\n6000\n.\n7000\n8000\n9000\n.\n10000`\n// utilities to split input\nlet udf = {\n  splitNN: x => x.split(\"\\n.\\n\"), // adapted input format, octo doesn't like blank lines\n  splitN: x => x.split(\"\\n\"),\n  toNum: x => Number(x),\n}\n</code>\n<h3>Parse Input</h3>\n<p>We can parse the data into structured form as follows.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// potential textual syntax:\n//\n// input | split \"\\n.\\n\" | get *chunk\n//       | split \"\\n\"    | get *line | toNum\n//       | group *line\n//       | group *chunk\nlet query =\n  pipe(\".input\")\n  .map(\"udf.splitNN\").get(\"*chunk\")\n  .map(\"udf.splitN\").get(\"*line\")\n  .map(\"udf.toNum\")\n  .group(\"*line\")\n  .group(\"*chunk\")\nlet res = api.query(query)\ndisplay(res.explain)\ndisplay(res({input, udf}))\n</code>\n<h3>Compute Max Sum</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\n// potential textual syntax:\n//\n// input | split \"\\n.\\n\" | get *chunk\n//       | split \"\\n\"    | get *line  | toNum\n//       | sum | group *chunk | get * | max\nlet query =\n  pipe(\".input\")\n  .map(\"udf.splitNN\").get(\"*chunk\")\n  .map(\"udf.splitN\").get(\"*line\")\n  .map(\"udf.toNum\")\n  .sum()\n  .group(\"*chunk\").get(\"*\")\n  .max()\nlet res = api.query(query)\ndisplay(res.explain)\ndisplay(res({input, udf}))\n</code>\n<h3>Compare to Standard API</h3>\n<p>Parse input</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet query = {\n  \"*chunk\": {\n    \"*line\":\n      api.get(api.apply(\"udf.splitN\",\n        api.get(api.apply(\"udf.splitNN\",\n          \".input\"),\n        \"*chunk\")),\n      \"*line\")\n  }\n}\nlet res = api.query(query)\ndisplay(res.explain)\ndisplay(res({input,udf}))\n</code>\n<p>Compute max sum</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet query = api.max(api.get({\n  \"*chunk\": api.sum(api.apply(\"udf.toNum\",\n      api.get(api.apply(\"udf.splitN\",\n        api.get(api.apply(\"udf.splitNN\",\n          \".input\"),\n        \"*chunk\")),\n      \"*line\")))\n},\"*\"))\nlet res = api.query(query)\ndisplay(res.explain)\ndisplay(res({input,udf}))\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" name=\"data\">\n</code>\n</aside>\n<h3>Pivot Tables</h3>\n<p>We can generate structured tables with partial aggregates\nusing a single query.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nloadWarehouseDataset().then(show)\nlet udf = {\n  formatUSD: p => \"$\"+p+\".00\",\n  formatPercent: p => Math.trunc(p*100) + \" %\",\n  percent: p => Math.trunc(p*100)\n}\nfunction show(data) {\n  let computeEntry = {\n    \"Quantity\":       api.sum(\"data.*.quantity\"),\n    \"Percent Total\":  api.apply(\"udf.formatPercent\",api.fdiv(api.sum(\"data.*.quantity\"),api.sum(\"data.*2.quantity\"))),\n    \"Bar Chart\": {\n      \"$display\": \"bar\",\n      value: api.apply(\"udf.percent\",api.fdiv(api.sum(\"data.*.quantity\"),api.sum(\"data.*2.quantity\")))\n    }\n  }\n  let query = {\n    \"$display\": \"select\",\n    data: {\n      \"Grouped I\": {\n        \"$display\": \"table\",\n        rows: 4, cols: 1,\n        template: {\n          Quantity: {}, \"Bar Chart\":{}, \"Percent Total\": {}\n        },\n        data: { Total: {\n          props: computeEntry,\n          children: { \"data.*.warehouse\": {\n            props: computeEntry,\n            children: { \"data.*.product\": {\n              props: computeEntry,\n              children: {\n                \"data.*.model\": computeEntry\n              }\n            }}\n          }}\n        }}\n      },\n      \"Grouped II\": {\n        \"$display\": \"table\",\n        rows: 3, cols: 1,\n        data: {\n          \"data.*.warehouse\": {\n            \"Total\": {\n              \"-\": computeEntry,\n            },\n            \"data.*.product\": {\n              \"Total\": computeEntry,\n              \"data.*.model\": computeEntry\n            }\n          },\n          \"Total\": {\n            \"-\": {\n              \"-\": computeEntry\n            }\n          }\n        }\n      },\n      \"Raw Data\": {\n        \"$display\": \"table\",\n        rows: 1, cols: 1,\n        data: { \"*\":\"data.*\" }\n      },\n    }\n  }\n  display(api.exec(query, {data,udf}))\n}\n</code>\n<h3>SVG Drawing</h3>\n<p>Likewise, we can render SVG charts or other drawings directly from data.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet data = [{x:20,y:70},{x:40,y:30},{x:60,y:50},{x:80,y:60},{x:100,y:40}]\nlet udf = {sep: \" \"}\nlet line = {\n  \"$display\": \"dom\", type: \"svg:polyline\",\n  props: { points: api.join(api.plus(\"data.*.x\",api.plus(\",\",api.plus(\"data.*.y\",\"udf.sep\")))),\n    stroke: \"black\", fill:\"none\" },\n  // should: api.join(api.string(\"data.*.x\", \",\", \"data.*.y\"))\n}\nlet bars = {\n  \"$display\": \"dom\", type: \"svg:rect\",\n  props: { width: \"16px\", height: api.minus(100,\"data.*.y\"), x: api.minus(\"data.*.x\",8), y: \"data.*.y\",\n    stroke: \"black\", fill: \"none\" },\n}\nlet points = {\n  \"$display\": \"dom\", type: \"svg:ellipse\",\n  props: { rx: \"3px\", ry: \"3px\", cx: \"data.*.x\", cy: \"data.*.y\",\n    stroke: \"black\", fill: \"#EEE\" },\n}\nlet query = {\n  \"$display\": \"select\",\n  data: {\n    \"All in one\": {\n      \"$display\": \"dom\", type: \"svg:svg\",\n      props: { width: \"300px\", height: \"100px\" },\n      children: [bars, line, points]\n    },\n    \"Side by side\": {\n      \"$display\": \"dom\", type: \"div\",\n      children: [{\n        \"$display\": \"dom\", type: \"svg:svg\",\n        props: { width: \"120px\", height: \"100px\" },\n        children: api.array(points)\n      },{\n        \"$display\": \"dom\", type: \"svg:svg\",\n        props: { width: \"120px\", height: \"100px\" },\n        children: api.array(line)\n      },{\n        \"$display\": \"dom\", type: \"svg:svg\",\n        props: { width: \"120px\", height: \"100px\" },\n        children: api.array(bars)\n      }]\n    },\n  }\n}\nlet res = api.query(query)\ndisplay(res({data,udf}))\n</code>\n<aside>\n<p>Variations</p>\n<p>Single chart</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet data = [{x:20,y:70},{x:40,y:30},{x:60,y:50},{x:80,y:60},{x:100,y:40}]\nlet query = {\n  \"$display\": \"dom\", type: \"svg:svg\",\n  props: { width: \"300px\", height: \"100px\" },\n  children: [{\n      \"$display\": \"dom\", type: \"svg:rect\",\n      props: {\n        width: \"16px\", height: api.minus(100,\"data.*.y\"),\n        x: api.minus(\"data.*.x\",8), y: \"data.*.y\",\n        stroke: \"black\", fill: \"white\"\n      }\n  }]\n}\nlet res = api.query(query)\ndisplay(res.explain)\ndisplay(res({data}))\n</code>\n<p>Two charts overlayed</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet data = [{x:20,y:70},{x:40,y:30},{x:60,y:50},{x:80,y:60},{x:100,y:40}]\nlet query = {\n  \"$display\": \"dom\", type: \"svg:svg\",\n  props: { width: \"300px\", height: \"100px\" },\n  children: [{\n    \"$display\": \"dom\", type: \"svg:rect\",\n    props: { width: \"16px\", height: api.minus(100,\"data.*.y\"), x: api.minus(\"data.*.x\",8), y: \"data.*.y\",\n      stroke: \"black\", fill: \"white\" },\n  },{\n    \"$display\": \"dom\", type: \"svg:ellipse\",\n    props: { rx: \"3px\", ry: \"3px\", cx: \"data.*.x\", cy: \"data.*.y\",\n      stroke: \"black\", fill: \"#EEE\" },\n  }]\n}\nlet res = api.query(query)\ndisplay(res.explain)\ndisplay(res({data}))\n</code>\n</aside>","fields":{"slug":"/Public/Generic/js-queries/"},"frontmatter":{"date":"2022-05-02","title":"Let's build a Query Language!","description":null,"keywords":null,"tags":null}}},{"node":{"excerpt":"A version of the Graph IR prototype with dependent types. Types are mapped to first-class graph nodes, like any other terms. What is new‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>A version of the <a href=\"/Public/Generic/graph-ir\">Graph IR prototype</a> with dependent types. Types are mapped to first-class graph nodes, like any other terms.</p>\n<aside>\n<p>What is new / different?</p>\n<ul>\n<li>Terms and types are no longer syntactically distinguished. This conflicts with some prior overloads, in particular wrt. function literals (Œª expressions) and function types (œÄ expressions). To disambiguate, function <em>types</em> are now written as a special arrow:\n<ul>\n<li><code class=\"language-text\">(x:A) =t> B</code> a function type</li>\n<li><code class=\"language-text\">(x:A) => B</code> a function term</li>\n</ul>\n</li>\n<li>Terms are now beta-normalized by default\n<ul>\n<li>Known function calls are inlined</li>\n<li>To generate a function call node, the function can be wrapped using ‚Äúdelay‚Äù</li>\n</ul>\n</li>\n<li>Debugging UX\n<ul>\n<li>Since every type is now composed of graph nodes, the Graph IR view is much more crowded than before and arguably less useful (certainly for having a quick glance at an expression‚Äôs type). There also appears to be some duplication - due to the way scoping works and avoidance of DCE in the Graph IR view (perhaps it should be made lazy and show details only on demand)</li>\n<li>As a partial remedy, debug messages now include clickable symbols. Shift-click prints the definition of a symbol, so one can drill down further.</li>\n</ul>\n</li>\n<li>Parity with previous functionality\n<ul>\n<li>Previous core test cases all work. Output differences are only due to different symbol names (Note: expected outputs haven‚Äôt been updated, so tests are still marked as failing).</li>\n<li>Higher order functions that rely on ‚Äúcall‚Äù effects lead to an additional let binding (see ‚Äúeffect polymorphism‚Äù/‚Äúdelimited continuation‚Äù tests)</li>\n<li>The very latest tests (e.g. pair encoding) have not been ported yet</li>\n</ul>\n</li>\n<li>New functionality\n<ul>\n<li>See new tests: standard dependent types examples, including church numerals, length-indexed lists, etc.</li>\n</ul>\n</li>\n<li>Open questions\n<ul>\n<li>What constraints need to be put on type abstraction? What is the unifying story around parametric polymorphism, ‚Äúcall‚Äù effects, lightweight reachability polymorphism via ‚Äúx @track‚Äù parameters? (Right now there is a flag to turn ‚Äúcall‚Äù effects on or off. Will need more debugging)</li>\n<li>What about effectful operations in types?</li>\n<li>What reductions/optimizations do we want on refs (local CSE/DCE, value propagation, etc)?</li>\n<li>Do we need alpha- or eta-normalization for functions? So far, need hasn‚Äôt come up.</li>\n</ul>\n</li>\n</ul>\n</aside>\n<aside>\n<h2>Implementation and PREVIOUS test cases</h2>\n<h3>Pseudocode</h3>\n<aside>\n<p>Pseudocode</p>\n<p>Node construction</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">local state: for each tracked var\n    - was it created in this block?\n    - symbol of last write, if any\n    - list of reads (after last write, if any)\n\n// create graph node in a stateful way (low-level)\n\nfunction reflect() {\n    result:\n        resolve tracking status and aliases\n    effects:\n        resolve which vars are touched\n        resolve dependencies on prior effects (soft/hard)\n            if no prior local effect, depend on block start\n            record any errors: can't access after kill\n        update local state to record effects of new node // (1)\n    binding structure:\n        resolve dependencies on bound vars (incl. via effects)\n    apply any rewrites:\n        e.g. beta reduction\n        TODO: track provenance\n    apply CSE\n    create node entry:\n        record any aux data\n        // move (1) here?\n}\n\n// Q: what to do if node entry optimized away? do not duplicate effects!\n\n// create a function node\n\nfunction fun() {\n    initialize arg and self ref\n    traverse body using fresh local state\n    compute result type:\n        visible aliases and effects only\n            minEligible\n        XXX: careful about effects applied to return value\n        XXX: (currently prevent returning killed values)\n    compute function type:\n        // Q: use same var names as fun term or fresh ones?\n        resolve aliases and tracking status\n    reflect graph node\n}\n\n// create an application node\n\nfunction app() {\n    check that fun has a function type\n    check that arg has compatible argument type\n    check that fun and arg are sufficiently separate (bounded overlap)\n    compute result type:\n        by substituting actual arg for declared arg in function type\n    effect polymorphism:\n        if fun is a bound sym (arg of an enclosing fun!),\n          refine result type to register a \"call\" effect on the fun instead of any concrete effects on it\n          keep concrete effects on the arg\n    reflect graph node:\n        may trigger beta reduction if fun is a lambda node\n}\n\n// Q: generalize effect polymorphism to always return a kind of \"fun @ arg\" type?</code></pre></div>\n<p>Substitution</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// assumption: we're substituting a bound var (not any sym)\n// recurse in dfs\n\nfunction subst() {\n  if not dependent on subst var: do nothing\n  if seen: return known result\n  if bound sym:\n    // XXX should this really be a case?\n    recurse into type, create new sym if type changes\n  if lambda:\n    recurse, deal with potential new arg symbol, keep function type in sync\n  if fun type:\n    recurse, deal with potential new arg symbol\n  else:\n    recurse over subterms, effect deps, and type\n}\n\n// Q: current impl re-reflects all nodes, so it can only be used in a context that has valid local state\n// NB: DFS does give us topological order</code></pre></div>\n<p>Subtype checking</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function checkSubBase() {\n    if equal return true\n    if both are function types:\n        compare args (contravariant)\n        compare results (assuming smaller arg, fun):\n            subst left arg to right arg\n            subst right fun to left fun\n    else\n      log error\n}\n\nfunction checkSubList() {\n    expand transitively before comparing\n    // XXX: is trans lookup needed?\n    // it seems relevant for user-given types, but could also normalize in track() constructor instead\n}\n\n// Q: precision wrt aliasing, see comments inline\n// XXX only dealing with self types in restricted ways</code></pre></div>\n<p>MinEligible</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Close off a function result:\n// (f(x:T1) -> T2^a)^a  -->  (f(x:T1) -> T2^f)</code></pre></div>\n</aside>\n<h3>Staged graph construction API</h3>\n<aside>\n<p>Implementation code</p>\n<p>Flags and Graph State</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Options\n// ------------------------------------------------------------\nlet flags = {\n  targetSugar: false,\n  softKill: true,\n  callEffect: true,\n  reportMinEligibleWarnings: true\n}\n// ------------------------------------------------------------\n// Internals\n// ------------------------------------------------------------\n// state of ast walker\nlet env = {}        // not really graph state, but important\n// global state: monotonous, add-only\nlet nVars = 0       // number of symbols used\nlet code = []       // list of all definitions (as let stms)\nlet cnstPool = {}   // for cse\n//   the following are all indexed by sym\nlet nameHint = {}\nlet errorLog = {}\nlet infoLog  = {}\nlet symToDef = {}\nlet symToTpe = {}\nlet symToNrm = {}\nlet boundDeps = {}  // the bound syms each node depends on\nlet aliases = {}    // the tracked syms each sym may refer to\nlet trackStatus = {} // the track state of each sym (0,1,2)\n// local state: per-block, add-only\nlet blockStart      // symbol representing current block start\nlet effects = []    // record effects in current block\n// local state: flow-sensitive, change per statement\nlet state = {}      // last read/write for each tracked sym\n                    // (summarizes local effect history)\n//\n// Format of state: for given tracked sym\n//   .init:  set to self if node created in this block\n//   .write: symbol of last write, if any\n//   .reads: list of reads after last write, or block start if no write\n//   .kill:  symbol of kill, if any\n//\nfunction fresh() {\n  return nVars++\n}\nfunction reset() {\n  env = {}\n  nVars = 0\n  code = []\n  cnstPool = {}\n  nameHint = {}\n  errorLog = {}\n  infoLog  = {}\n  symToDef = {}\n  symToTpe = {}\n  symToNrm = {}\n  boundDeps = {}\n  aliases = {}\n  trackStatus = {}\n  blockStart = undefined\n  effects = []\n  state = {}\n  // type checking env\n  // env = {} XXX var not bound here\n}\n</code>\n<p>Default Environment</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction initEnvironment() {\n  fresh() // discard 0!\n  let box = reflect0(fresh(),[\"constBox\"]) // has no type!\n  let boxq = reflect0(fresh(),[\"constBoxQ\"]) // has no type!\n  let star = reflect0(fresh(),[\"constStar\"],{tpe:box})\n  let starq = reflect0(fresh(),[\"constStarQ\"],{tpe:boxq})\n  let IO = constant(star)\n  let Int = constant(star)\n  let Unit = constant(star)\n  nameHint[box] = \"Kind\"\n  nameHint[boxq] = \"QualKind\"\n  nameHint[star] = \"Type\"\n  nameHint[starq] = \"QualType\"\n  nameHint[IO] = \"IO\"\n  nameHint[Int] = \"Int\"\n  nameHint[Unit] = \"Unit\"\n  env[\"Kind\"] = box // shouldn't be user accessible!!\n  env[\"QualKind\"] = starq\n  env[\"Type\"] = star\n  env[\"QualType\"] = starq\n  env[\"IO\"] = IO\n  env[\"Int\"] = Int\n  env[\"Unit\"] = Unit\n}\n</code>\n<p>Errors and Logging</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// note: calls into front-end for rendering & UX\nfunction logInteractive(...es) {\n  let ds = []\n  function rec(e) {\n    if (typeof(e) == \"number\") // treat as sym\n      ds.push(\" \",prettyDomSym(e),\" \")\n    else if (e instanceof Array) {\n      ds.push(\"[\")\n      e.forEach(rec) // should collapse into dom node?\n      ds.push(\"]\")\n    } else\n      ds.push(e)\n  }\n  es.forEach(rec)\n  //oo.appendChild(e(\"div\",{},...ds))\n  print(...ds)\n}\nfunction logError(x,...es) {\n  let el = dom(\"¬†\")\n  registerSymRef(x,el,true)\n  logInteractive(el,\" \",\"Error at node \",x,\": \",...es)\n  let str = es.join(\" \")\n  if (!errorLog[x]) errorLog[x] = []\n  // do not record same error twice\n  for (let es1 of errorLog[x]) {\n    if (es1.join(\" \") == str)\n      return\n  }\n  errorLog[x].push(es)\n  highlightSymError(x)\n}\n</code>\n<p>Stateful Node Construction (reflect)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction reflect(...ss) {\n  // TODO: move CSE logic to reflect0, shouldn't be\n  // restricted to literal constants\n  if (ss.length == 1 && typeof(ss[0]) == \"number\") {\n    if (cnstPool[ss[0]]) return cnstPool[ss[0]]\n    let r = reflect0(fresh(), ss)\n    cnstPool[ss[0]] = r\n    symToTpe[r] = env[\"Int\"]\n    return r\n  } else if (ss.length == 1 && ss[0] == \"()\") {\n    if (cnstPool[ss[0]]) return cnstPool[ss[0]]\n    let r = reflect0(fresh(), ss)\n    cnstPool[ss[0]] = r\n    symToTpe[r] = env[\"Unit\"]\n    return r\n  }\n  return reflect0(fresh(), ss)\n}\nfunction reflect0(x,exp,extra) {\n  // options\n  let bound = []\n  let syms = exp.slice(1).filter(s => typeof(s) === \"number\") // XXX need recursion?\n  let als = [] // untracked by default\n  let alsQ = 0\n  let read = []\n  let write = []\n  let kill = []\n  let self = [] // latent call effects\n  let tpe = undefined\n  let mayCSE = true\n  if (extra) {\n    if (extra.bound) bound = extra.bound\n    if (extra.syms) syms = extra.syms\n    if (extra.aliases) als = extra.aliases\n    if (extra.trackStatus) alsQ = extra.trackStatus\n    if (extra.effect) {\n      if (extra.effect.write) write = extra.effect.write\n      if (extra.effect.read) read = extra.effect.read\n      if (extra.effect.kill) kill = extra.effect.kill\n      if (extra.effect.self) self = extra.effect.self\n    }\n    if (extra.write) write = extra.write\n    if (extra.read) read = extra.read\n    if (extra.kill) kill = extra.kill\n    if (extra.tpe) tpe = extra.tpe\n  }\n  //\n  // record info/error\n  //\n  if (!errorLog[x]) errorLog[x] = []\n  if (!infoLog[x]) infoLog[x] = []\n  //\n  // alias info\n  //\n  if (alsQ) {\n    trackStatus[x] = alsQ\n    aliases[x] = [x,...als.map(x => [...transitiveAliases(x)]).flat()]\n  } else {\n    trackStatus[x] = 0\n    aliases[x] = []\n  }\n  //\n  //\n  // effects: first record effects as declared\n  // (previously: with aliases resolved)\n  //\n  if (!effects.read) effects.read = []\n  if (!effects.write) effects.write = []\n  if (!effects.kill) effects.kill = []\n  if (!effects.self) effects.self = []\n  effects.read.push(...read) // was: allread, etc\n  effects.write.push(...write)\n  effects.kill.push(...kill)\n  effects.self.push(...self)\n  //\n  // effects: resolve latent call effects\n  //\n  // basic logic: for a call\n  // - for dependencies: resolve into actual r/w/k\n  // - for recording what happened: leave as call\n  // - (currently: effects on arg are always resolved)\n  //\n  for (let s of self) {\n    let es = resolveLatentEffect(s)\n    if (es.read) read = [...read,...es.read]\n    if (es.write) write = [...write,...es.write]\n    if (es.kill) kill = [...kill,...es.kill]\n  }\n  //\n  // effects: resolve aliases\n  //\n  let allreads = read.map(x => [...transitiveAliases(x)]).flat()\n  let allwrites = write.map(x => [...transitiveAliases(x)]).flat()\n  let allkills = kill.map(x => [...transitiveAliases(x)]).flat()\n  //\n  // disable CSE if has effect\n  // TODO: could do **local** CSE for reads\n  //\n  if (allreads.length+allwrites.length+allkills.length > 0)\n    mayCSE = false\n  //\n  // now record dependencies\n  //\n  //let deps = {}\n  //for (let e of allwrites)\n  //  deps[e] = state[e] ? state[e] : blockStart\n  let hdeps = {}\n  let sdeps = {}\n  function ensureState(e) {\n    if (!hdeps[e]) hdeps[e] = []\n    if (!sdeps[e]) sdeps[e] = []\n    if (!state[e]) state[e] = { reads: [] }\n  }\n  function checkAccess(e, action) {\n    if (state[e].kill) logError(x, \"can't \"+action+\" dead object: \"+prettySym(e))\n  }\n  function lastWriteOrInit(e) {\n    return state[e].write || state[e].init || blockStart\n  }\n  for (let e of allreads) {\n    ensureState(e)\n    checkAccess(e, \"read\")\n    hdeps[e].push(lastWriteOrInit(e))\n    state[e].reads.push(x)\n  }\n  for (let e of allwrites) {\n    ensureState(e)\n    checkAccess(e, \"write\") // design choice: write could resurrect\n    sdeps[e].push(lastWriteOrInit(e))\n    for (let r of state[e].reads) if (r != x) sdeps[e].push(r)\n    state[e] = { write: x, reads: [] }\n  }\n  for (let e of allkills) {\n    ensureState(e)\n    checkAccess(e, \"kill\") // design choice: kill could be idempotent\n    if (state[e].write != x) sdeps[e].push(lastWriteOrInit(e))\n    for (let r of state[e].reads) if (r != x) sdeps[e].push(r)\n    state[e] = { write: x, reads: [], kill: x }\n  }\n  if (trackStatus[x]) // every tracked value should have an entry\n    state[x] = { init: x, reads: [] }\n  //\n  // XXX DEP register bound syms in type (for subst)\n  //\n  let tdeps = {}\n  if (tpe) tdeps[tpe] = [tpe] // XXX could just add to syms\n  //\n  // bound info (include effect deps)\n  //\n  let allsyms = [...syms]\n  for (let e in hdeps) allsyms.push(...hdeps[e])\n  for (let e in sdeps) allsyms.push(...sdeps[e]) // nothing special about soft deps -- TODO: \"soft bound\"??? not sure how...\n  for (let e in tdeps) allsyms.push(...tdeps[e])\n  let bs = new Set(bound)\n  try {\n  boundDeps[x] = new Set()\n  for (let s of allsyms) {\n    if (!boundDeps[s]) {\n      logInteractive(\"error: \",s,\" has no bound deps array (while reflecting new sym \",x,\"=\"+exp+\" tpe \",tpe,\")\")\n      continue\n    }\n    for (let b of boundDeps[s])\n      if (!bs.has(b)) // lambda should not dep on its own bound var\n        boundDeps[x].add(b)\n  }\n} catch (ex) {\n  print(ex + \"/\"+ allsyms+\"/\"+[...bs]+\"/\"+Object.keys(boundDeps))\n  print(ex.stack)\n}\n  //\n  // check rewrites (beta: apply lambda)!\n  // XXX: perhaps we'd still want to create the def!\n  // (and register that it has been normalized)\n  //\n  if (exp[0] == \"@\") {\n    let [,fun1,arg1] = exp\n    if (symToDef[fun1] && symToDef[fun1][2][0] == \"Œª\") {\n      //print(\"reduce \"+prettySym(fun1)+\"(\"+prettySym(arg1)+\")\")\n      let [,xx,yy,[deps,sdeps],localState] = symToDef[fun1][2]\n      if (xx == arg1) {\n        //print(\"trouble! \"+prettySym(yy)+\"[\"+prettySym(xx)+\"->\"+prettySym(arg1)+\"] ... why??\")\n        //let e = new Error\n        //pp(fun1,4)\n        //pp(yy,4)\n        //print(e.stack)\n      }\n      let res = subst(yy,xx,arg1)\n      //print(\"reduced \"+prettySym(yy)+\" to \"+prettySym(res))\n      //if (boundDeps[res].has(xx)) {\n      //  print(\"bad: \"+prettySym(res)+\"=\"+prettySym(yy)+\"[\"+prettySym(xx)+\"->\"+prettySym(arg1)+\"] still depends on \"+prettySym(xx))\n      //}\n      let tpe1 = symToTpe[res]\n      // can't expect exact match, but could\n      // check for subtype\n      /* if (tpe1 != tpe) {\n        print(\"type mismatch\")\n        print(\"was \"+prettySym(fun1)+\"(\"+prettySym(arg1)+\"):\"+prettySym(tpe))\n        print(\"now \"+prettySym(res)+\":\"+prettySym(tpe1))\n        print(symToDef[tpe])\n        print(symToDef[tpe1])\n      } */\n      return res\n    }\n  }\n  //\n  // check CSE!\n  //\n  if (mayCSE) {\n    if (cnstPool[exp]) return cnstPool[exp]\n    cnstPool[exp] = x\n  }\n  //\n  // create node\n  //\n  let ss = [\"let\", x, exp, [hdeps,sdeps]]\n  code.push(ss)\n  symToDef[x] = ss\n  //\n  // set type\n  //\n  if (tpe) symToTpe[x] = tpe\n  return x\n}\n</code>\n<h3>Core Language</h3>\n<p>Type Expressions</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Type API\n// ------------------------------------------------------------\n/*\nexamples:\n- base types: \"Int\", (previously: \"Ref\")\n- unknown type (to-be-inferred): \"?\"\n- function types: funtype(arg, (f,x) => res)\n- mutable ref cells: reftype(etp)\n- annotated types: track(tpe, \"x\", \"y\"), effect(tpe, \"write\", x\", \"y\")\n*/\nfunction track(tpe, ...xs) {\n  //return [\"track\", tpe, xs]\n  typeCheck(tpe, env[\"Type\"]) // Q: should be QualType? chains...\n  let res = reflect0(fresh(), [\"track\", tpe, ...xs], {\n    tpe: env[\"QualType\"]\n  })\n  return res\n}\nfunction effect(tpe, key, ...xs) {\n  if (!xs.length) return tpe\n  //return [\"effect\", tpe, key, xs]\n  typeCheck(tpe, env[\"Type\"]) // Q: should be QualType? chains...\n  let res = reflect0(fresh(), [\"effect\", tpe, key, ...xs], {\n    tpe: env[\"QualType\"]\n  })\n  return res\n}\nfunction isTypeOrKind(tpk) {\n  // all good, except QualKind\n  // (QualType can't be a parameter!)\n  return (tpk == env[\"Type\"] ||\n          tpk == env[\"QualType\"] ||\n          tpk == env[\"Kind\"])\n}\nfunction funtype(atp,f) {\n  let atpk = symToTpe[atp]\n  if (!isTypeOrKind(atpk))\n    logError(atp, \"illegal arg type/kind: \",atpk)\n  let ff = fresh()\n  let xx = fresh()\n  nameHint[ff] = \"f\"\n  nameHint[xx] = \"a\"\n  symToTpe[xx] = atp // XXX atp or atpk ???\n  boundDeps[ff] = new Set([ff]) // mark fun? XXX\n  boundDeps[xx] = new Set([xx]) // mark arg as bound\n  let yy = f(ff,xx)\n  let ytpk = symToTpe[yy] // XXX check type/kind?\n  if (!isTypeOrKind(ytpk))\n    logError(yy, \"illegal res type/kind: \",ytpk)\n  let res = reflect0(fresh(),[\"=>\", atp, ff, xx, yy],{\n    bound:[xx,ff],\n    syms:[atp,yy],\n    tpe:ytpk\n  })\n  nameHint[res] = \"ftp\"\n  return res\n}\nfunction argtype(atp) {\n  // create a function type with a wildcard result\n  // XXX DEP don't have result type yet, how to deal with wildcards?\n//  return funtype(atp, (f,x) => \"?\")\n  return atp\n}\nfunction reftype(etp) {\n  typeCheck(etp, env[\"Type\"])\n  return reflect0(fresh(),[\"Ref\", etp],{\n    tpe: env[\"Type\"]\n  })\n}\n</code>\n<p>Basic Expressions</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Expression API (without lambda/app)\n// ------------------------------------------------------------\nfunction plus(a,b) {\n  typeCheckUnflat(a, env[\"Int\"]); typeCheckUnflat(b, env[\"Int\"])\n  return reflect0(fresh(),[\"+\", a, b], {tpe:env[\"Int\"]})\n}\nfunction minus(a,b) {\n  typeCheckUnflat(a, env[\"Int\"]); typeCheckUnflat(b, env[\"Int\"])\n  return reflect0(fresh(),[\"-\", a, b], {tpe:env[\"Int\"]})\n}\nfunction times(a,b) {\n  typeCheckUnflat(a, env[\"Int\"]); typeCheckUnflat(b, env[\"Int\"])\n  return reflect0(fresh(),[\"*\", a, b], {tpe:env[\"Int\"]})\n}\n//\n// NOTE: there is a general question on what type checks\n// are needed and possible for effectful primitive operations\n// (e.g. check that refs are writable, tracked, etc).\n//\n// There isn't much use checking that a var is tracked,\n// because untracked vars can always be up-cast to tracked\n// (T <: T @tracked).\n//\n// For Ref types soundness relies on the fact that the sole\n// introduction form, alloc, returns a tracked value.\n// It's entirely possible to declare functions with untracked\n// Ref args, but they can never be called.\n//\n// Alloc and println do check for tracked status -- this is\n// our current crutch to signal an error if main's arg isn't\n// tracked!\n//\n// The bottom line is that ops on references mainly\n// check base types and ignore tracking status.\n//\nfunction println(a,b) {\n  typeCheckBase(a, env[\"IO\"]); typeCheckBase(b, \"?\")\n  // typeCheckBase(a, \"IO\"); typeCheckBase(b, \"?\")\n  // check base type only (see note above)\n  if (!trackStatus[a]) // crutch for top-level\n    logError(a, \"not a tracked value: \"+prettySym(a))\n  let res = reflect0(fresh(), [\"print\", a, b], {\n    read: [a],\n    write: [a],\n    tpe: env[\"Unit\"]\n  })\n  nameHint[res] = \"p\"\n  return res\n}\nfunction alloc(a) {\n  typeCheckBase(a, env[\"IO\"])\n  // check base type only (see note above)\n  // XXX DEP disabled this\n  //if (!trackStatus[a]) // crutch for top-level\n  //  logError(a, \"not a tracked value: \"+prettySym(a))\n  let res = reflect0(fresh(), [\"alloc\", a], {\n    trackStatus: 2, // definitely tracked!\n    aliases: [],\n    read: [a],\n    tpe: reftype(env[\"Int\"])\n  })\n  nameHint[res] = \"c\"\n  return res\n}\nfunction get(a) {\n  typeCheckBase(a, reftype(env[\"Int\"]))\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"get\", a], {\n    read: [a], write: [], tpe: env[\"Int\"]\n  })\n  return res\n}\nfunction set(a,b) {\n  typeCheckBase(a, reftype(env[\"Int\"]))\n  typeCheck(b, env[\"Int\"])\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"set\", a, b], {\n    read: [], write: [a], tpe: env[\"Unit\"]\n  })\n  return res\n}\nfunction inc(a) {\n  typeCheckBase(a, reftype(env[\"Int\"]))\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"inc\", a], {\n    read: [a], write: [a], tpe: env[\"Int\"]\n  })\n  return res\n}\nfunction free(a) {\n  typeCheckBase(a, reftype(env[\"Int\"]))\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"free\", a], {\n    read: [], write: [], kill: [a], tpe: env[\"Unit\"]\n  })\n  return res\n}\nfunction constant(tpe) {\n  // TODO: check tpe is a symbol with type \"Type\" (Star) or \"Kind\" (Box)\n  //let atpk = symToTpe[tpe]\n  //if (!(atpk == env[\"Type\"] || atpk == env[\"Kind\"]))\n  //  logError(atp, \"illegal arg type/kind: \"+prettySym(atpk))\n  let x = fresh()\n  return reflect0(x,[\"const\"+x],{tpe:tpe})\n}\nfunction hole(tpe) {\n  // TODO: check tpe is a symbol with type \"Type\" (Star) or \"Kind\" (Box)\n  //let atpk = symToTpe[tpe]\n  //if (!(atpk == env[\"Type\"] || atpk == env[\"Kind\"]))\n  //  logError(atp, \"illegal arg type/kind: \"+prettySym(atpk))\n  let x = fresh()\n  nameHint[x] = \"hole\"\n  return reflect0(x,[\"hole\"+x],{tpe:tpe})\n}\nfunction delayval(e) { // delay evaluation\n  let tpe = symToTpe[e]\n  let res = reflect0(fresh(), [\"delay\", e], {\n    trackStatus: 1, aliases: [e], tpe: tpe,\n  })\n  nameHint[res] = nameHint[e]\n  return res\n}\nfunction check(a) {\n  print(\"DIAGNOSTICS FOR \",a,\":\",symToTpe[a])\n  print(\"-- aliases^\"+trackStatus[x]+\":\", ...(aliases[a]))\n  return a\n}\n</code>\n<p>Function Expressions (fun &#x26; app)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Public API for app & fun\n// ------------------------------------------------------------\nfunction app(fun, arg) {\n  assert(symToTpe[fun], \"fun doesn't have type\")\n  let [argInfo, frtp] = extractFunTypeFlat(symToTpe[fun])\n  let resInfo = frtp(fun,arg)\n  //let [[argTpe, argAlias], frtp] = extractFunType(symToTpe[fun])\n  //let [resTpe, resAlias, resEffect] = frtp(fun,arg)\n  //\n  // check arg tpe\n  // XXX: may want to add sanity checks for alias/effects\n  //\n  typeCheckBase(arg,argInfo.base)\n  //\n  // check fun and arg are separate\n  // TODO: pull out into a method\n  //\n  let ala = transitiveAliases(fun)\n  let alb = transitiveAliases(arg)\n  for (let aa of ala) {\n    if (alb.has(aa))\n      print(\"ERROR: \"+fun+\" and \"+arg+\" overlap with \"+aa) // XXX\n  }\n  //\n  // Effect polymorphism:\n  // - any calls to a function f passed as arg should\n  //   record effect @self(f) instead of the effects\n  //   from the type. Exception: effects of f on its own\n  //   arg - it may not be visible outside\n  // - if res effect includes @self(f), replace\n  //   with actual latent self effect of f\n  //\n  // Alternative (better?) design:\n  // - result effect is always @call(f,arg)\n  // - resolve it during subtype checking and\n  //   when converting to self type (minEligible)\n  //\n  let resEffect = resInfo.effect\n  // XXX dep\n  if (flags.callEffect && !symToDef[fun]) { // calling a bound sym (an outer fun arg)\n    // only count effects on the argument\n    resEffect = filterEffect(resEffect, y => y == arg)\n    if (!resEffect.self) resEffect.self = []\n    resEffect.self.push(fun)\n  }\n  //\n  // create node and set result type/alias info\n  //\n  let res = reflect0(fresh(), [\"@\", fun, arg], {\n    trackStatus: resInfo.track.status, // XXX soft-track\n    aliases: resInfo.track.alias ? resInfo.track.alias : [],\n    effect: resEffect,\n    tpe: resInfo.base\n  })\n  //symToTpe[res] = resTpe\n  return res\n}\nfunction fun(ftp,f) {\n// XXX DEP: ftp is just the argument type\n//  let [argInfo, frtp] = extractFunTypeFlat(ftp)\n  let argInfo = tpeFlatten(ftp)\n  let argTpe = argInfo.base\n  let argAlias = argInfo.track.alias\n  //\n  // initialize arg and self ref\n  //\n  let ff = fresh()\n  let xx = fresh()\n  // expected type components (may be wildcards \"?\")\n//  let expectedResInfo = frtp(ff,xx)\n//  let [expectedResTpe, expectedResAlias, expectedResEffect] =\n//    [expectedResInfo.base, expectedResInfo.track.alias, //expectedResInfo.effect]\n//  symToTpe[ff] = ftp\n  symToTpe[xx] = argTpe\n  nameHint[ff] = \"fun\"\n  nameHint[xx] = \"arg\"\n  boundDeps[ff] = new Set() // mark fun? XXX\n  boundDeps[xx] = new Set([xx,...boundDeps[argTpe]]) // mark arg as bound\n  trackStatus[xx] = argAlias ? 1 : 0 // XXX ever using 2?\n  aliases[xx] = argAlias ? [... argAlias,xx] : [] // mark arg as tracked\n  //\n  // execute body in fresh state, mapping all entries to arg symbol\n  //\n  let save = {state,effects,blockStart}\n  state = {} // will pick up blockStart as default\n  effects = { }\n  state[xx] = { reads: [] } // must be in as marker that it belongs to this block\n  blockStart = xx\n  let yy = f(ff,xx)\n  let localState = state\n  let localEffects = effects\n  state = save.state\n  effects = save.effects\n  blockStart = save.blockStart\n  //\n  // collect effect dependencies on nodes in block\n  //\n  let esc = transitiveAliases(yy)\n  let deps = {} // \"dependency\" (last write)\n  let sdeps = {} // soft deps\n  for (let e0 in localState) { // e is a string!\n    let e = Number(e0)\n    let nonlocal = (e == ff || e == xx || e in state || esc.has(e))\n    deps[e] = []\n    sdeps[e] = []\n    if (localState[e].write) {\n      // right now we assume write implies read (see above)\n      if (nonlocal) deps[e].push(localState[e].write)\n      else sdeps[e].push(localState[e].write)\n    }\n    if (localState[e].kill) {\n      // XXX cannot return value after killing it\n      if (esc.has(e))\n        logError(yy, \"cannot return dead object: \"+prettySym(e))\n      if (nonlocal || !flags.softKill) deps[e].push(localState[e].kill)\n      else sdeps[e].push(localState[e].kill)\n    }\n    for (let r of localState[e].reads) {\n      sdeps[e].push(r)\n    }\n  }\n  //\n  // compute result type incl. visible effects\n  //\n  let newResTpe = symToTpe[yy]\n  let newResTrackStatus = trackStatus[yy]\n  let newResAlias = aliases[yy]\n  let newResEffect = {}\n  for (let k in localEffects) {\n    newResEffect[k] = [...new Set(localEffects[k])]\n  }\n  // NOTE: we need to remove duplicates here (otherwise reflect0\n  // may blow up, e.g. on double-ref to a write), but minEligible\n  // will do the bulk of the work and eliminate references\n  // to local symbols\n  //\n  // type check block result (if given expected type)\n  // Q: do this before or after minEligible?\n  //\n// XXX not checking against expected result type\n//  checkSubType(newResTpe, expectedResTpe, {sym:yy})\n//  if (expectedResTpe != \"?\") {\n//    checkSubAlias(newResAlias, expectedResAlias, {sym:yy})\n//    checkSubEffect(newResEffect, expectedResEffect, {sym:yy})\n//  }\n  //\n  // compute new type: externally visible, use minEligible to upcast\n  //\n  let newResInfo = { base: newResTpe }\n  newResInfo.track = newResTrackStatus ? { alias: newResAlias } : {}\n  newResInfo.effect = newResEffect\n  let newResInfo1 = minTypeEligibleInParentEnvFlat(newResInfo,[ff,xx])\n  let newArgTpe = tpeUnflatten(argInfo)\n  let newResTpe1 = tpeUnflatten(newResInfo1)\n  // we can use different names in type and expr (but don't have to)\n  //let newFunTpe = funtype(newArgTpe, (f,x) => subst(subst(newResTpe1,xx,x),ff,f) )\n  //let newFunTpe = [\"=>\", newArgTpe, ff, xx, newResTpe1]\n  // XXX check arg and res type/kind\n  let atpk = symToTpe[newArgTpe]\n  if (!isTypeOrKind(atpk)){\n    logError(xx, \"illegal arg type/kind: \",atpk)\n  }\n  let ytpk = symToTpe[newResTpe1]\n  if (!isTypeOrKind(ytpk))\n    logError(yy, \"illegal res type/kind: \",ytpk)\n  // XXX DEP\n  // XXX weirdness of symToTpe[xx] -- should be Type?\n  // XXX Note: using ff here leads to subst cycles ---> should be bound...?\n  boundDeps[ff*10000] = new Set([ff*10000])\n  let newFunTpe = reflect0(fresh(),[\"=>\", newArgTpe, ff*10000, xx, newResTpe1],{\n    bound:[xx,ff*10000],\n    syms:[newArgTpe,newResTpe1],\n    tpe:env[\"Type\"] // could it be a kind?\n  })\n  //\n  //\n  // compute aliases of function: symbols used by func are\n  // aliases and effects of result expression minus function\n  // and argument. no tracked var used means fun is untracked.\n  //\n  let used = new Set()\n  for (let k in newResInfo1.track)\n    newResInfo1.track[k].forEach(x => used.add(x))\n  for (let k in newResInfo1.effect)\n    newResInfo1.effect[k].forEach(x => used.add(x))\n  used.delete(ff); used.delete(xx)\n  used = [...used]\n  let usedTrack = 0\n  for (let x of used)\n    usedTrack = Math.max(trackStatus[x],usedTrack)\n  //\n  // create graph node\n  //\n  let ret = reflect0(ff, [\"Œª\", xx, yy, [deps,sdeps], localState], {\n    bound:[xx],\n    syms:[yy,...Object.values(deps).flat()],\n    aliases:used,\n    trackStatus:usedTrack,\n    tpe:newFunTpe\n  })\n  return ret\n}\n// Head normalization -- make sure it's not an app\nfunction normalize(e) {\n  assert(typeFuel--, \"normalize: out of fuel!\")\n  if (symToNrm[e]) return symToNrm[e]\n  if (symToDef[e]) {\n    let [op, ...args] = symToDef[e][2]\n    if (op == \"@\") {\n      let [fun, arg] = args\n      let fun1 = normalize(fun)\n      if (symToDef[fun1] && symToDef[fun1][2][0] == \"Œª\") { // applying a lambda\n        let [,xx,yy,[deps,sdeps],localState] = symToDef[fun1][2]\n        let res = subst(yy,xx,arg)\n        return symToNrm[e] = res\n      }\n    } else {\n      //print(\"TODO: reflect other op \"+op)\n    }\n    // TODO: eval plus, times, etc\n    // TODO: reflect after norm under lambda/pi? not needed\n    // b/c checkSubBase goes under binders\n  }\n  return e\n}\n</code>\n<h3>Type Internals</h3>\n<p>Transitive Aliases / Latent Effects</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction transitiveAliases(x) {\n  let res = new Set()\n  function rec(x) {\n    if (res.has(x)) return\n    if (!trackStatus[x]) return\n    if (!(aliases[x] instanceof Array)) return\n    res.add(x)\n    aliases[x].forEach(rec)\n  }\n  if (trackStatus[x] && (aliases[x] instanceof Array))\n    rec(x)\n  return res\n}\n// the effect a function has on the\n// environment (not its arg, but may incl self)\n// Q: do we need to resolve aliases?\n//    before and/or after lookup?\nfunction resolveLatentEffect(f) {\n  let [argInfo, frtp] = extractFunTypeFlat(symToTpe[f])\n  let resInfo = frtp(f,nVars) // fresh var without consumption\n  // TODO: need transitive??\n  let es = filterEffect(resInfo.effect, y => y != nVars)\n  if (es.self)\n    print(\"WARNING: transitive 'self' effects currently not handled (at x\"+f+\")\")\n  return es\n}\nfunction filterEffect(es,f) {\n  let res = {}\n  for (let k in es) {\n    let e = es[k].filter(f)\n    if (e.length > 0)\n      res[k] = e\n  }\n  return res\n}\n</code>\n<p>Type Flatten / unflatten</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Type Internals\n// ------------------------------------------------------------\n//\n// We distinguish two forms of type representations:\n//  - flat:   internal, normalized (see tpeFlatten)\n//  - unflat: externally visible (see tpeUnflatten)\n//\nfunction tpeFlatten(tpe) {\n  let res = { track: { status: 0 }, effect: {} }\n  function iter(tpe) {\n    if (symToDef[tpe]) {\n      let [op,...args] = symToDef[tpe][2]\n      if (op == \"track\") {\n        let [base,...xs] = args\n        if (!res.track.alias) res.track.alias = []\n        res.track.alias.push(...xs)\n        res.track.status = 1 // XXX soft-track\n        return iter(base)\n      } else if (op == \"effect\") {\n        let [base,key,...xs] = args\n        if (!res.effect[key]) res.effect[key] = []\n        res.effect[key].push(...xs)\n        return iter(base)\n      }\n    }\n    res.base = tpe\n  }\n  iter(tpe)\n  return res\n}\nfunction tpeUnflatten(tpe) {\n  assert(tpe.base, \"malformed type (base)\")\n  assert(tpe.track, \"malformed type (track)\")\n  assert(tpe.effect, \"malformed type (effect)\")\n  let res = tpe.base\n  // XXX soft-track!\n  if (tpe.track.alias)\n    res = track(res, ...tpe.track.alias)\n  for (let k in tpe.effect)\n    res = effect(res, k, ...tpe.effect[k])\n  return res\n}\nfunction isFunType(_ftp) {\n  let ftp = normalize(_ftp)\n  let [tc_, atp, ff_, xx_, yy_] = symToDef[ftp][2]\n  return (tc_ == \"=>\")\n}\nfunction extractFunTypeFlat(_ftp) {\n  let ftp = normalize(_ftp)\n  let [tc_, atp, ff_, xx_, yy_] = symToDef[ftp][2]\n  assert(tc_ == \"=>\", \"not a function type: \"+ftp)\n  let atpFlat = tpeFlatten(atp)\n  let frtp = (f,b) => {\n    let rtp = subst(subst(yy_,xx_,b),ff_,f) //frtp(f,b)\n    //let rtp = subst(yy_,xx_,b)\n    let rtpFlat = tpeFlatten(rtp)\n    return rtpFlat\n  }\n  return [atpFlat, frtp]\n}\nfunction extractFunTypeUnflat(_ftp,funsym) {\n  let ftp = normalize(_ftp)\n  let [tc_, atp, ff_, xx_, yy_] = symToDef[ftp][2]\n  if (tc_ != \"=>\") {\n    logError(funsym||_ftp, \"not a function type:\",_ftp)\n    throw new Error(\"type\")\n  }\n  //assert(tc_ == \"=>\", \"not a function type (unflat): \"+prettySym(_ftp))\n  let frtp = (f,b) => {\n    let rtp = subst(subst(yy_,xx_,b),ff_,f) //frtp(f,b)\n    //let rtp = subst(yy_,xx_,b)\n    return rtp\n  }\n  return [atp, frtp]\n}\n</code>\n<p>Substitution</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Substitution\n// ------------------------------------------------------------\nfunction substShallow(e,hm) {\n  if (e instanceof Array) return e.map(g => substShallow(g,hm))\n  if (hm[e]) return hm[e]\n  return e\n}\n// XXX refactor! extract node re-construction\nfunction subst(e,a,b) {\n  if (e instanceof Array) return e.map(g => subst(g,a,b))\n  if (e == a) return b\n  if (a == b) return e\n  // Assumption: we're substituting a bound var (not any sym)\n  // TODO: what if b has a dependency on a?\n  let hm = {}\n  hm[a] = b\n  function rec(x) {\n    if (x instanceof Array) return x.map(rec)\n    if (hm[x] == 666) print(\"subst cycle \"+prettySym(x))\n    if (hm[x]) return hm[x]\n    if (!symToDef[x]) {\n      // bound variables: create fresh if type changed!\n      // XXX: doing the right thing with bound & uses?\n      if (symToTpe[x]) {\n        let tpe1 = rec(symToTpe[x])\n        if (tpe1 != symToTpe[x]) {\n          let x1 = fresh()\n          symToTpe[x1] = tpe1\n          nameHint[x1] = nameHint[x]\n          boundDeps[x1] = new Set([x1,...boundDeps[tpe1]])\n          //print(\"replace bound \"+prettySym(x)+\"->\"+prettySym(x1))\n          return hm[x] = x1\n        }\n      }\n      return x\n    }\n    if (!boundDeps[x].has(a)) // should not happen?\n      return x\n    //print(\"subst \"+prettySym(x)+\" \"+prettySym(a)+\" \"+prettySym(b))\n    hm[x] = 666 // mark before we recurse!!!\n    let [_let,_x,exp,[hdeps,sdeps]] = symToDef[x]\n    let op = exp[0]\n    let exp1 = exp//.map(rec)\n    let extra = {} // at least tpe ...\n    //extra.tpe = rec(symToTpe[x])\n    if (op == \"Œª\") {\n      let [,xx,yy,[deps,sdeps]] = exp\n      // XXX Q: can we substitute in tpe or do we need\n      // to recompute it?\n      let ff1 = x // XXX\n      let atp = symToTpe[xx]\n      let newArgTpe = rec(atp)\n      //print(\"bounds of new arg type \"+prettySym(newArgTpe)+\": \"+[...boundDeps[newArgTpe]])\n      let xx1 = xx\n      if (newArgTpe != atp) {\n      // fresh arg sym! (Note: only do this if atp changed, otherwise res won't pick it up)\n          xx1 = fresh()\n          symToTpe[xx1] = newArgTpe\n          nameHint[xx1] = nameHint[xx]\n          boundDeps[xx1] = new Set([xx1,...boundDeps[newArgTpe]])\n          //print(\"replace bound 2 \"+prettySym(xx)+\"->\"+prettySym(xx1))\n          hm[xx] = xx1 // TODO: should this be temporary?\n      }\n      // result\n      let yy1 = rec(yy)\n      let newResTpe = symToTpe[yy1]\n            //print(\"bounds of new res \"+prettySym(yy1)+\": \"+[...boundDeps[yy1]])\n            //print(\"bounds of new res type \"+prettySym(newResTpe)+\": \"+[...boundDeps[newResTpe]])\n      exp1 = [\"Œª\",xx1,yy1,[{},{}]]\n      extra.bound = [xx1]\n      let deps1 = {} // XXX FIXME!\n      extra.syms = [yy1,...Object.values(deps1).flat()]\n        extra.tpe = reflect0(fresh(),[\"=>\", newArgTpe, ff1*10000, xx1, newResTpe],{\n          bound:[xx1],\n          syms:[newArgTpe,newResTpe],\n        tpe:env[\"Type\"]\n      })\n    } else if (op == \"=>\") {\n      // XXX bug: if atp changes, we need to use a different xx!!\n      exp1 = exp.map(rec)\n      extra.tpe = rec(symToTpe[x])\n      let [,atp,ff,xx,yy] = exp1\n      extra.bound = [xx]\n      extra.syms = [atp,yy]\n    } else {\n      exp1 = exp.map(rec)\n      extra.tpe = rec(symToTpe[x])\n    }\n    let res = reflect0(fresh(), exp1, extra)\n// dbg\n    if (boundDeps[res].has(a))\n      print(\"!!! bounds of \"+prettySym(res)+\"=\"+prettySym(x)+\"[\"+prettySym(a)+\"->\"+prettySym(b)+\"] = \"+[...boundDeps[res]]+\" still has \"+prettySym(a))\n    // TODO:\n    // -- ~~special case for lambda & funtype (bound, syms)~~\n    // -- ~~what to do for tpe of sym?~~ subst, too\n    // -- (effects, deps --> \"obvious\" difficulties)\n    // -- (optimizations: reapply rewrites? future ...)\n    return hm[x] = res\n  }\n  // let code1 = [...code] // safety! concurrent mod\n  // for (let [,x,exp,[hdeps,sdeps]] of code1) { // TODO: opt via // reverse index...\n  //   if (boundDeps[x].has(a)) {\n  //     ...\n  //   }\n  // }\n//\n//\n//\n  return rec(e)\n}\n</code>\n<p>Subtype Checking</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Subtype checks (some bits left as TODO)\n// ------------------------------------------------------------\nfunction symToTpeFlat(s) {\n  return {\n    base: symToTpe[s],\n    track: trackStatus[s] ? { alias: aliases[s] } : {},\n    effect: {} // syms represent values -- results do not have effects!\n               // currently we have no need (and no way) to recover the\n               // of individual nodes (fun does this at the block level)\n               // Q: should we keep this info?\n  }\n}\nfunction typeCheckFlat(e,tpe2) {\n  let tpe1 = symToTpeFlat(e)\n  return checkSubTypeFlat(tpe1,tpe2,{sym:e,isValue:true}) // TODO: mayWildcard?\n}\nfunction typeCheckBase(e,tpe2) {\n  let tpe1 = symToTpe[e]\n  return checkSubBase(tpe1,tpe2,{sym:e,isValue:true}) // TODO: mayWildcard?\n}\nfunction checkSubTypeFlat(tpe1, tpe2, extra) {\n  checkSubBase(tpe1.base, tpe2.base, extra)\n  // XXX: alias & effects is pretty generic right now. OK?\n  if (tpe2.base != \"?\") {\n    checkSubAnnotation(tpe1.track, tpe2.track, extra)\n    checkSubAnnotation(tpe1.effect, tpe2.effect, extra)\n  }\n}\nlet typeFuel = 10000\n//let subEnv = {}\nfunction checkSubBase(_tpe1, _tpe2, extra) {\n  assert(typeFuel--, \"checkSubBase: out of fuel!\")\n  if (_tpe2 == \"?\") return // XXX check _tpe1 well formed?\n  if (_tpe1 == _tpe2) return\n//  if (subEnv[_tpe1] && subEnv[_tpe2] && subEnv[_tpe1] == subEnv[_tpe2]) return\n  let tpe1 = normalize(_tpe1)\n  let tpe2 = normalize(_tpe2)\n  if (tpe1 == tpe2) return\n//  if (subEnv[tpe1] && subEnv[tpe2] && subEnv[tpe1] == subEnv[tpe2]) return\n// TODO:\n// - env extension & lookup for bound vars\n// - ~~what about apps in types -- normalize??~~ head normalize\n// - useful to compare before & after normalization?\n//    generative vs applicative?\n  let def1 = symToDef[tpe1]\n  let def2 = symToDef[tpe2]\n//\n  if (def1 && def2 && def1[2][0] == \"=>\" && def2[2][0] == \"=>\") {\n    //print(\"check FN \",def1[2],def2[2])\n    let [,atp1,ff1,xx1,yy1] = def1[2]\n    let [,atp2,ff2,xx2,yy2] = def2[2]\n    checkSubTypeUnflat(atp2,atp1,extra)\n    // XXX TODO: env extension: map xx1 and xx2 to same id\n    //let save = subEnv\n    try {\n      //let n = Object.keys(save).length+1 // shouldn't be 0, note:inefficient\n      //subEnv = {...save,[xx1]:n,[xx2]:n}  // TODO: map to smaller??\n      let yyy1 = yy1\n      let yyy2 = yy2\n      if (xx1 != xx2) yyy1 = subst(yyy1,xx1,xx2) // subst 1 or 2?\n      if (ff1 != ff2) yyy2 = subst(yyy2,ff1,ff2)  // XXXXXX !!!!\n      checkSubTypeUnflat(yyy1,yyy2,extra)\n    } finally {\n      //subEnv = save\n    }\n    // TODO: Ref! (currently rely on cse)\n  } else {\n    logError(extra.sym, \"type check failed: \",tpe1,\" <: \",tpe2)\n  }\n}\nfunction checkSubBase0(tpe1, tpe2, extra) { // XXX old, not used\n  if (tpe1 == tpe2) return\n  if (tpe2 == \"?\") return // type well formed?\n  if (tpe1 instanceof Array && tpe2 instanceof Array) {\n    if (tpe1[0] == \"=>\" && tpe2[0] == \"=>\") {\n      //let [atp1,frtp1] = extractFunTypeUnflat(tpe1)\n      //let [atp2,frtp2] = extractFunTypeUnflat(tpe2)\n      // ???\n      let [, atp1, ff1, xx1, rtp1] = tpe1\n      let [, atp2, ff2, xx2, rtp2] = tpe2\n      // XXX: We're dealing with bound names here.\n      // Right now we're substituting one for the other.\n      // We might need to do something more in line with\n      // DOT (temp environment during type comparison),\n      // especially for dealing with self types.\n      checkSubTypeUnflat(atp2,atp1,extra) // contravariant\n      checkSubTypeUnflat(rtp1,subst(subst(rtp2,xx2,xx1),ff2,ff1),extra) // OK?\n      return\n    } else if (tpe1[0] == \"Ref\" && tpe2[0] == \"Ref\") {\n      let [, atp1] = tpe1\n      let [, atp2] = tpe2\n      checkSubTypeUnflat(atp1,atp2,extra) // invariant\n      checkSubTypeUnflat(atp2,atp1,extra)\n      return\n    }\n  }\n  logError(extra.sym, \"type check failed: \"+tpe1+\" <: \"+tpe2)\n}\nfunction checkSubAnnotation(ls1, ls2, extra) {\n  function sub(k) {\n    return checkSubList(ls1[k],ls2[k],{...extra,key:k})\n  }\n  sub(\"alias\")\n  sub(\"read\")\n  sub(\"write\")\n  sub(\"kill\")\n}\nfunction checkSubList(ls1,ls2, extra) {\n  if (!ls1) return true\n  //if (!ls2) return false\n  if (!ls2) {\n    let s1 = JSON.stringify(ls1)\n    logError(extra.sym, extra.key+\" qualifier check failed: \"+s1+\" <: none\")\n    return\n  }\n  // TODO: good enough? can we use 'transitiveAliases'?\n  // (subtly different until we add extra env...)\n  function trans(xs) {\n    let res = new Set()\n    for (let x of xs) {\n     res.add(x)\n     if (trackStatus[x])\n       for (let a of aliases[x]) res.add(a)\n    }\n    return res\n  }\n  // TODO:\n  // - may need to be more precise w.r.t aliasing on either side\n  // - right now we only check the global alias table: this works\n  //   when a function is passed as argument with an expected function\n  //   self type\n  // - probably need an environment of some sorts to track bindings\n  //   introduced as part of the comparison\n  let ala = trans(ls1)\n  let alb = trans(ls1) // XXXXXX !!!!\n  let ok = true\n  for (let a of ala) {\n    if (!alb.has(a)) {\n      ok = false; break\n    }\n  }\n  //let s1 = JSON.stringify(ls1)\n  //let s2 = JSON.stringify(ls2)\n  //if (s1 == s2) return ls1\n  if (!ok) {\n    let s1 = JSON.stringify(ls1)\n    let s2 = JSON.stringify(ls2)\n    logError(extra.sym, extra.key+\" qualifier check failed: \"+s1+\" <: \"+s2)\n  }\n}\nfunction symToTpeUnflat(s) {\n  return tpeFlatten(symToTpeFlat(s))\n}\nfunction typeCheckUnflat(e,tpe2) {\n  return typeCheckFlat(e,tpeFlatten(tpe2))\n}\nfunction checkSubTypeUnflat(tpe1,tpe2,extra) {\n  return checkSubTypeFlat(tpeFlatten(tpe1),tpeFlatten(tpe2),extra)\n}\n//\n// XXX below are stubs -- only used for expected return types\n// in functions. should replace.\n//\n// XXX stil used by (some) basic exprs\nfunction typeCheck(e,tpe) {\n  if (symToTpe[e] != tpe && tpe != \"?\")\n    print(\"---- CHECK TYPE \"+e+\": \"+symToTpe[e]+\" <: \"+tpe)\n}\nfunction checkSubType(tpe1,tpe2) {\n  if (tpe1 != tpe2 && tpe2 != \"?\")\n    print(\"---- CHECK TYPE \"+tpe1+\" <: \"+tpe2)\n}\nfunction checkSubAlias(al1,al2,extra) {\n  if (al1 != al2 && al2 != \"?\")\n    print(\"---- CHECK ALIAS \"+al1+\" <: \"+al2)\n}\nfunction checkSubEffect(al1,al2,extra) {\n  checkSubAnnotation(al1, al2, extra) // XXX need sym\n  //if (al1 != al2 && al2 != \"?\")\n  //  print(\"---- CHECK EFFECT \"+al1+\" <: \"+al2)\n}\n</code>\n<p>Well-formedness and minEligible</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Close off function result type (by introducing self refs)\n// ------------------------------------------------------------\n//  TODO: How to adapt to dependent types\n//    - can't just enumerate known type constructors:\n//        previously we knew we had just => and Ref,\n//        we need to consider arbitrary terms, incl\n//        application of type functions, etc\n//    - hence, need to recurse into arbitrary terms:\n//        not sure what to do for truly arbitrary terms,\n//        do we default to substitution?\n//    - complication: we want to eliminate vars that\n//        aren't bound in argument position. Hence,\n//        unlike subst, boundDeps isn't of much help\n//    - but: we still know that refs depend on the\n//        enlosing function arg xx!!! so boundDeps\n//        may be useful again -- however it's more\n//        complicated. We *can* depend on xx, just\n//        not on anything else that depends on xx\n//        and needs to remain inside ff.\n//\n// XXX problem: need all parent envs\n//\n//  New design (TODO): make it goal oriented.\n//  Given bound variable x, remove references on\n//  **effectful** dependencies of x\n//\n//\nfunction minTypeEligibleInParentEnvFlat(tpe,extra) {\n  // Close off a function result:\n  // (f(x:T1) -> T2^a)^a  -->  (f(x:T1) -> T2^f)\n  //\n  let env = {}\n  for (let e in state) env[e] = aliases[e]\n  for (let e of extra) env[e] = aliases[e]\n  let topTpe = tpe\n  let topSelf\n  let topSelfAls\n  function drop(als) {\n    let als1 = []\n    for (let e of als)\n      if (!env[e]) {\n         // ignore\n      } else\n        als1.push(e)\n    return als1\n  }\n  function check(als) {\n    let als1 = []\n    for (let e of als)\n      if (!env[e]) {\n        print(\"ERROR: alias not in env: \"+e)\n      } else\n        als1.push(e)\n    return als1\n  }\n  function replace(als) {\n    let als1 = []\n    for (let e of als)\n      if (!env[e]) {\n        if (topSelf && topSelfAls.indexOf(e) >= 0)\n          als1.push(topSelf)\n        else {\n          print(\"ERROR: alias not in env or self type: \"+e)\n          print(\"ENV: \",...Object.keys(env).map(e=>e+\" \"))\n          print(\"SELF: \",topSelf,\" aliases \",topSelfAls)\n        }\n      } else\n        als1.push(e)\n    return als1\n  }\n  function mapTpe(tpe,f) {\n    let res = { base: tpe.base, track:{}, effect:{}}\n    for (let k in tpe.track)\n      if (k != \"status\") // XXX soft-track\n        res.track[k] = f(tpe.track[k])\n    for (let k in tpe.effect)\n      res.effect[k] = f(tpe.effect[k])\n    return res\n  }\n  function maxEligible(tpe) {\n    let tpe1 = {...tpe}\n    let base = symToDef[tpe.base] ? symToDef[tpe.base][2] : null\n    if (base instanceof Array) {\n      if (base[0] == \"=>\") {\n        let [hd, atp, ff, xx, yy] = base\n        let atp1 = tpeUnflatten(minEligible(tpeFlatten(atp)))\n        env[ff] = 1; env[xx] = 1 // could add aliases but don't really need\n        let yy1 = tpeUnflatten(maxEligible(tpeFlatten(yy)))\n        env[ff] = null; env[xx] = null\n        tpe1.base = reflect0(fresh(),[hd, atp, ff, xx, yy1],{\n          bound:[xx,ff],\n          syms:[atp,yy1],\n          tpe:symToTpe[yy1]\n        })\n        if (!nameHint[tpe1.base]) nameHint[tpe1.base] = \"ftp\"\n      } else if (base[0] == \"Ref\") {\n        let [hd, atp] = base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        tpe1.base = reflect0(fresh(),[hd,atp1],{\n          tpe: env[\"Type\"]\n        })\n      } else if (base[0].startsWith(\"const\")) {\n        // const -- do nothing\n      } else {\n        // XXX was assert\n        if (flags.reportMinEligibleWarnings)\n          logInteractive(\"error in maxEligible: unkown type constructor '\"+base[0]+\"' at \",tpe.base,\" inside \",topTpe.base)\n      }\n    } else {\n      // bound type parameter -- do nothing\n      // logInteractive(\"ignore maxEligible (TODO!)\",tpe.base)\n    }\n    return mapTpe(tpe1,check) // drop? contravariant position\n  }\n  function minEligible(tpe,als,efs) {\n    let tpe1 = {...tpe}\n    let base = symToDef[tpe.base] ? symToDef[tpe.base][2] : null\n    if (base instanceof Array) {\n      if (base[0] == \"=>\") {\n        let [hd, atp, ff, xx, yy] = base\n        let atp1 = tpeUnflatten(maxEligible(tpeFlatten(atp)))\n        env[ff] = 1; env[xx] = 1 // could add aliases but don't really need\n        let yy1 = tpeUnflatten(minEligible(tpeFlatten(yy)))\n        env[ff] = null; env[xx] = null\n        tpe1.base = reflect0(fresh(),[hd, atp, ff, xx, yy1],{\n          bound:[xx,ff],\n          syms:[atp,yy1],\n          tpe:symToTpe[yy1]\n        })\n        if (!nameHint[tpe1.base]) nameHint[tpe1.base] = \"ftp\"\n      } else if (base[0] == \"Ref\") {\n        let [hd, atp] = base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        tpe1.base = reflect0(fresh(),[hd,atp1],{\n          tpe: env[\"Type\"]\n        })\n      } else if (base[0].startsWith(\"const\")) {\n        // const -- do nothing\n      } else {\n        // XXX was assert\n        if (flags.reportMinEligibleWarnings)\n          logInteractive(\"error in minEligible: unkown type constructor '\"+base[0]+\"' at \",tpe.base,\" inside \",topTpe.base)\n      }\n    } else {\n      // bound type parameter -- do nothing\n      // logInteractive(\"ignore minEligible (TODO!)\",tpe.base)\n    }\n    return mapTpe(tpe1,replace)\n  }\n  function strictEligible(tpe,als,efs) {\n    let tpe1 = {...tpe}\n    let base = symToDef[tpe.base] ? symToDef[tpe.base][2] : null\n    if (base instanceof Array) {\n      if (base[0] == \"=>\") {\n        let [hd, atp, ff, xx, yy] = base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        env[ff] = 1; env[xx] = 1 // could add aliases but don't really need\n        let yy1 = tpeUnflatten(strictEligible(tpeFlatten(yy)))\n        env[ff] = null; env[xx] = null\n        tpe1.base = reflect0(fresh(),[hd, atp, ff, xx, yy1],{\n          bound:[xx,ff],\n          syms:[atp,yy1],\n          tpe:symToTpe[yy1]\n        })\n        if (!nameHint[tpe1.base]) nameHint[tpe1.base] = \"ftp\"\n      } else if (base[0] == \"Ref\") {\n        let [hd, atp] = base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        tpe1.base = reflect0(fresh(),[hd,atp1],{\n          tpe: env[\"Type\"]\n        })\n      } else if (base[0].startsWith(\"const\")) {\n        // const -- do nothing\n      } else {\n        // XXX was assert\n        if (flags.reportMinEligibleWarnings)\n          logInteractive(\"error in strictEligible: unkown type constructor '\"+base[0]+\"' at \",tpe.base,\" inside \",topTpe.base)\n      }\n    } else {\n      // bound type parameter -- do nothing\n      // logInteractive(\"ignore strictEligible (TODO!)\",tpe.base)\n    }\n    return mapTpe(tpe1,check)\n  }\n  // top level!\n  let tpe1 = tpe // todo: copy?\n  let base = symToDef[tpe.base] ? symToDef[tpe.base][2] : null\n  if (base instanceof Array) {\n    if (base[0] == \"=>\") {\n      let [hd, atp, ff, xx, yy] = base\n      //print(\"enter fun: \",ff,\" \",tpe.track.alias)\n      if (tpe.track.alias)\n        topSelf = ff; topSelfAls = tpe.track.alias\n      let atp1 = tpeUnflatten(maxEligible(tpeFlatten(atp)))\n      env[ff] = 1; env[xx] = 1 // could add aliases but don't really need\n      let yy1 = tpeUnflatten(minEligible(tpeFlatten(yy)))\n      env[ff] = null; env[xx] = null\n      tpe1.base = reflect0(fresh(),[hd, atp, ff, xx, yy1],{\n        bound:[xx,ff],\n        syms:[atp,yy1],\n        tpe:symToTpe[yy1]\n      })\n      if (!nameHint[tpe1.base]) nameHint[tpe1.base] = \"ftp\"\n    } else if (base[0] == \"Ref\") {\n      let [hd, atp] = base\n      let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n      tpe1.base = reflect0(fresh(),[hd,atp1],{\n        tpe: env[\"Type\"]\n      })\n    } else if (base[0].startsWith(\"const\")) {\n      // const -- do nothing\n    } else {\n      // XXX was assert\n      if (flags.reportMinEligibleWarnings)\n        logInteractive(\"error in minEligible (top): unkown type constructor '\"+base[0]+\"' at \",tpe.base,\" inside \",topTpe.base)\n    }\n  } else {\n    // bound type parameter -- do nothing\n    // logInteractive(\"ignore minEligible top (TODO!)\",tpe.base)\n  }\n  return mapTpe(tpe1,drop)\n}\n</code>\n<h3>Traversal &#x26; basic codegen</h3>\n<p>Traversal / Codegen</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Traversal / codegen:\n// ------------------------------------------------------------\nlet path = new Set([])\nlet inner = [] // code\nfunction withScope(p,ns,b) {\n  let [path0, inner0] = [path, inner]\n  path = p; inner = ns\n  try { return b() } finally { path = path0; inner = inner0 }\n}\nfunction traverseBlock(inp, outp) {\n  let path1 = new Set([...inp,...path])\n  withScope(path1, inner, () => {\n    traverseBlock1(outp)})\n}\nfunction traverseBlock1(res) {\n  function available(c) {\n    let [_let, sym, rhs] = c\n    for (let b of boundDeps[sym])\n      if (!path.has(b))\n        return false\n    return true\n  }\n  // this version does not:\n  // - prune by reach(res)\n  // - treat soft deps softly\n  let outer1 = []\n  let inner1 = []\n  for (let c of inner) {\n    if (available(c))\n      outer1.push(c)\n    else\n      inner1.push(c)\n  }\n  withScope(path, inner1, () => {\n    traverseList(outer1, res)})\n}\n</code>\n<p>Core DOM Utils</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// core dom utils\n// ------------------------------------------------------------\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\nfunction dom(...es) {\n  return e(\"span\",{},...es)\n}\n</code>\n<p>Pretty printing / DOM interaction for graph view</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Pretty printing / DOM interaction\n// ------------------------------------------------------------\nfunction prettySym(n) {\n  if (n in nameHint) return nameHint[n]+n\n  return \"x\"+n\n}\nfunction prettyTypeAtom(e) {\n  if (e instanceof Array)\n    return \"(\"+prettyType(e)+\")\"\n  return prettyType(e)\n}\nfunction prettyType(e) {\n  if (e instanceof Array) {\n    if (e[0] == \"track\")\n      return prettyTypeAtom(e[1])+\"^{\"+e[2].map(prettySym)+\"}\"\n    if (e[0] == \"effect\")\n      return prettyTypeAtom(e[1])+\"^^{\"+e[2].map(prettySym)+\"}\"\n    if (e[0] == \"=>\")\n      return prettySym(e[2])+\"(\"+prettySym(e[3])+\":\"+prettyType(e[1]) + \") => \" +\n        prettyType(e[4])\n  }\n  return String(e)\n}\nfunction prettyExpr(e) {\n  let [op, args] = e\n  if (!args.length) return op; else\n  return op+\"(\"+args.map(prettySym)+\")\"\n}\nfunction prettyAliases(es) {\n  if (es instanceof Array) return \"[\"+es.map(prettySym)+\"]\"\n  else return String(es)\n}\nfunction prettyDeps(es) {\n  return JSON.stringify(Object.values(es))\n    .replaceAll(\",\",\"\\n\").replaceAll('\"',\"\")\n    .replaceAll(\"write\",\"w\")\n    .replaceAll(\"read\",\"r\")\n  function prettySummary(e) {\n    if (typeof(e) == \"number\") return prettySym(e)\n    return \"{\"+Object.entries(e).map(([k,v]) =>(k[0]) + \": \" + prettyAliases(v))+\"}\"}  return \"{\"+Object.entries(es).map(([k,v]) => prettySym(k) + \": \" + prettySummary(v)).join(\"\\n\")+\"}\"\n}\nlet seq\nlet nest = 0\nlet symRefs = []\nfunction prettyNode(c) {\n  let [_let, sym, [op,...args], deps] = c\n  if (op == \"Œª\") {\n    let [arg,res,eff] = args\n    let pa = prettySym(arg)+\": \"+prettyType(symToTpe[arg])\n    emit(\"def \"+prettySym(sym)+\"(\"+pa+\") {\",prettyAliases(aliases[arg]))\n    let save = seq\n    seq = []; ++nest\n    try { traverseBlock([arg,sym], [res]) }\n    catch (ex) { emit(ex) }\n    emit(\"return \" + prettySym(res), prettyAliases(aliases[res]), prettyDeps(eff))\n    let r = e(\"div\", {}, ...seq)\n    //r.style[\"margin-left\"] = \"15px\"\n    seq = save; --nest\n    emit(r)\n    emit(\"} // \"+prettyType(symToTpe[sym]), prettyAliases(aliases[sym]), prettyDeps(deps))\n  } else {\n    emit(\"let \"+prettySym(sym)+\" = \"+prettyExpr([op,args]), prettyAliases(aliases[sym]), prettyDeps(deps))\n  }\n}\nlet currentHighlight\nfunction highlightSym(n) {\n  if (currentHighlight) {\n    for (let e of symRefs[currentHighlight]) {\n      if (errorLog[currentHighlight] && errorLog[currentHighlight].length)\n        e.style[\"background\"] = \"lightpink\"\n      else\n        e.style[\"background\"] = \"none\"\n    }\n  }\n  if (n && n != currentHighlight) {\n    for (let e of symRefs[n]||[]) {\n      e.style[\"background\"] = \"lightgreen\"\n    }\n    currentHighlight = n\n  } else\n    currentHighlight = undefined\n}\nfunction highlightSymError(n) {\n  if (n == currentHighlight) return\n  for (let e of symRefs[n]||[]) {\n    e.style[\"background\"] = \"lightpink\"\n  }\n}\nfunction registerSymRef(n,d,clickable) {\n  if (!symRefs[n])\n    symRefs[n] = []\n  symRefs[n].push(d)\n  if (errorLog[n] && errorLog[n].length)\n    d.style[\"background\"] = \"lightpink\"\n  if (clickable) {\n    d.style[\"cursor\"] = \"pointer\"\n  }\n  d.addEventListener(\"click\", catchAll(e => {\n    if (e.shiftKey) {\n      if (symToDef[n])\n        logInteractive(\"Clicked on \",n,\"=\",symToDef[n][2],\": \",symToTpe[n])\n      else\n        logInteractive(\"Clicked on \",n,\": \",symToTpe[n])\n    } else //if (clickable || e.ctrlKey)\n      highlightSym(n, true)\n    console.log(e)\n    e.stopPropagation()\n  }))\n  if (d.src)\n    registerSymRef(n,d.src,clickable)\n}\nfunction catchAll(f) {\n  function g(e) {\n    try { return f(e) } catch(ex) { print(ex); throw ex }\n  }\n  return g\n}\nfunction prettyDomSym(n) {\n  let s = n in nameHint ? nameHint[n]+n : \"x\"+n\n  let d = dom(s)\n  registerSymRef(n,d,true)\n  d.style[\"color\"] = \"navy\"\n  return d\n}\nfunction prettyDomCommaList(es,f) {\n  if (!es.length) return dom()\n  let as = [f(es[0])]\n  for (let a of es.slice(1))\n    as.push(\",\",\" \",f(a))\n  return dom(...as)\n}\nfunction prettyDomExpr(e) {\n  let [op, args] = e\n  if (!args.length) return op\n  let as = [prettyDomSym(args[0])]\n  for (let a of args.slice(1))\n    as.push(\",\",\" \",prettyDomSym(a))\n  return dom(op,\"(\",...as,\")\")\n}\nfunction prettyDomTypeAtom(e) {\n  if (e instanceof Array)\n    return dom(\"(\",prettyDomType(e),\")\")\n  return prettyDomType(e)\n}\nfunction prettyDomType(e) {\n  // XXX DEP\n  return prettyDomSym(e)\n  // TODO: call prettyAlias/Effect methods?\n  if (e instanceof Array) {\n    if (e[0] == \"track\")\n      return dom(prettyDomTypeAtom(e[1]),\"^{\",prettyDomCommaList(e[2],prettyDomSym),\"}\")\n    if (e[0] == \"effect\")\n      return dom(prettyDomTypeAtom(e[1]),\"^^\",e[2],\"{\",prettyDomCommaList(e[3],prettyDomSym),\"}\")\n    if (e[0] == \"=>\")\n      return dom(prettyDomSym(e[2]),\"(\",prettyDomSym(e[3]),\":\",prettyDomType(e[1]),\")\",\" \",\"=>\",\" \", prettyDomType(e[4]))\n  }\n  return String(e)\n}\nfunction prettyDomAliases(es) {\n  if (es instanceof Array) return prettyDomCommaList(es,prettyDomSym)\n  else return String(es)\n}\nfunction prettyDomEffects(es) {\n  function prettySummary(es) {\n    let as = []\n    for (let k in es) {\n      as.push(prettyDomSym(k))\n      as.push(\":{\")\n      if (es[k].kill) {\n        as.push(\" \")\n        as.push(\"k:\")\n        as.push(prettyDomSym(es[k].kill))\n      }\n      if (es[k].init) {\n        as.push(\" \")\n        as.push(\"i:\")\n        as.push(prettyDomSym(es[k].init))\n      }\n      if (es[k].write) {\n        as.push(\" \")\n        as.push(\"w:\")\n        as.push(prettyDomSym(es[k].write))\n      }\n      if (es[k].reads.length) {\n        as.push(\" \")\n        as.push(\"r:\")\n        as.push(prettyDomCommaList(es[k].reads, prettyDomSym))\n      }\n      as.push(\" } \")\n    }\n    return dom(...as)\n  }\n  return dom(prettySummary(es))\n}\nfunction prettyDomDeps(es) {\n  function prettySummary(es) {\n    let as = []\n    for (let k in es) {\n      as.push(prettyDomSym(k))\n      as.push(\":[\")\n      as.push(prettyDomCommaList(es[k], prettyDomSym))\n      as.push(\"] \")\n    }\n    return dom(...as)\n  }\n  let [h,s] = es\n  return dom(\"hard: {\",prettySummary(h),\"} soft: {\",prettySummary(s),\"}\")\n}\nfunction emitLine(d) {\n  d.style[\"display\"] = \"block\"\n  d.style[\"border-radius\"] = \"10px\"\n  d.style[\"padding\"] = \"5px\"\n  d.style[\"padding-left\"] = \"10px\"\n  d.style[\"background-color\"] = \"#F2F2F2\"\n  d.style[\"font-weight\"] = \"bold\"\n  seq.push(d)\n}\nfunction emitIndent(d) {\n  d.style[\"display\"] = \"block\"\n  d.style[\"margin-left\"] = \"10px\"\n  seq.push(d)\n}\nfunction emitBox(box) {\n  box.style[\"display\"] = \"block\"\n  //box.style[\"padding\"] = \"5px\"\n  box.style[\"margin-left\"] = \"20px\"\n  box.style[\"font-size\"] = \"10px\"\n  seq.push(box)\n}\nfunction prettyDomNode(c) {\n  let [_let, sym, [op,...args], deps] = c\n  if (op == \"Œª\") {\n    let [arg,res,d,eff] = args\n    let pa = dom(prettyDomSym(arg),\": \",prettyDomType(symToTpe[arg]))\n    emitLine(dom(\"def \",prettyDomSym(sym),\"(\",pa,\") {\"))\n    let save = seq\n    seq = []; ++nest\n    emitBox(dom(\"arg \",prettyDomSym(arg),\":\"))\n    emitBox(dom(\"  aliases:\",\" \",prettyDomAliases(aliases[arg])))\n    for (let er of errorLog[arg]||[]) {\n      let d = e(\"div\",{},\"ERROR:  \",\" \",...er) // TODO: map prettyDomSym\n      d.style[\"background-color\"] = \"red\"\n      d.style[\"font-weight\"] = \"bold\"\n      emitBox(d)\n    }\n    try { traverseBlock([arg,sym], [res]) }\n    catch (ex) { emit(ex) }\n    emitLine(dom(\"return \",prettyDomSym(res)))\n    emitBox(dom(\"aliases: \",prettyDomAliases(aliases[res])))\n    emitBox(dom(\"effects: \",prettyDomEffects(eff)))\n    emitBox(dom(\"deps:    \",prettyDomDeps(d)))\n    let r = e(\"span\", {}, ...seq)\n    //r.style[\"margin-left\"] = \"15px\"\n    seq = save; --nest\n    emitIndent(r)\n    emitLine(dom(\"} // end \",prettyDomSym(sym)))\n  } else if (op == \"=>\") { // function type\n    let [atp,fun,arg,res] = args\n    let pa = dom(prettyDomSym(arg),\": \",prettyDomType(atp),'/',prettyDomType(symToTpe[arg]))\n    emitLine(dom(\"type \",prettyDomSym(sym),\" = \",prettyDomSym(fun),\"(\",pa,\") =t> {\"))\n    let save = seq\n    seq = []; ++nest\n    //emitBox(dom(\"arg \",prettyDomSym(arg),\":\"))\n    //emitBox(dom(\"  aliases:\",\" \",prettyDomAliases(aliases[arg])))\n    for (let er of errorLog[arg]||[]) {\n      let d = e(\"div\",{},\"ERROR:  \",\" \",...er) // TODO: map prettyDomSym\n      d.style[\"background-color\"] = \"red\"\n      d.style[\"font-weight\"] = \"bold\"\n      emitBox(d)\n    }\n    try { traverseBlock([fun,arg,sym], [res]) } // XXX sym vs fun???\n    catch (ex) { emit(ex) }\n    emitLine(dom(\"return \",prettyDomSym(res)))\n    //emitBox(dom(\"aliases: \",prettyDomAliases(aliases[res])))\n    //emitBox(dom(\"effects: \",prettyDomEffects(eff)))\n    //emitBox(dom(\"deps:    \",prettyDomDeps(d)))\n    let r = e(\"span\", {}, ...seq)\n    //r.style[\"margin-left\"] = \"15px\"\n    seq = save; --nest\n    emitIndent(r)\n    emitLine(dom(\"} // end \",prettyDomSym(sym)))\n  } else {\n    let line = e(\"div\", {}, \"let\",\" \",prettyDomSym(sym), \" \", \"=\", \" \", prettyDomExpr([op,args]))\n    emitLine(line)\n  }\n  let as = []\n  as.push(e(\"div\",{},\"type:   \",\" \",prettyDomType(symToTpe[sym])))\n  as.push(e(\"div\",{},\"aliases:\",\" \",prettyDomAliases(aliases[sym])))\n  as.push(e(\"div\",{},\"deps:   \",\" \",prettyDomDeps(deps)))\n  for (let er of errorLog[sym]||[]) {\n    let d = e(\"div\",{},\"ERROR:  \",\" \",...er) // TODO: map prettyDomSym\n    d.style[\"background-color\"] = \"red\"\n    d.style[\"font-weight\"] = \"bold\"\n    as.push(d)\n  }\n  let box = e(\"div\",{}, ...as)\n  emitBox(box)\n}\nfunction traverseList(nodes, res) {\n  for (let c of nodes) {\n    prettyDomNode(c)\n  }\n}\n</code>\n<p>Main Program (old - not used)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction run(test) {\n  // may want to explicitly reset state\n  print(\"--- Staging:\")\n  // type and kind constants\n  let box = reflect0(fresh(),[\"const1\"]) // has no type!\n  let star = constant(knd)\n  nameHint[box] = \"Kind\"\n  nameHint[star] = \"Type\"\n  env[\"Type\"] = star\n  // main function (and its type)\n  let tpe = funtype(track(\"IO\"),(f,x) => effect(effect(effect(\"Int\",\"read\",x),\"write\",x),\"kill\",x))\n//  let tpe = funtype(track(\"IO\"),(f,x) => effect(\"Int\",\"write\",x))\n  let res = fun(tpe,test) // assume 1 tracked arg\n  print(\"--- Traversal / codegen:\")\n  seq = []\n  path = new Set([])\n  inner = code\n  traverseBlock1(res)\n  //emitLine(prettyDomSym(res))\n  //, prettyAliases(aliases[res]), prettyDeps(state))\n  o.appendChild(e(\"pre\",{},...seq))\n}\n</code>\n</aside>\n<p>Examples / test cases:</p>\n<ul>\n<li><aside>\n<p>X Basic println</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test2(f,stdout) {\n  let _0 = reflect(0)\n  let _1 = reflect(1)\n  let _2 = reflect(2)\n  println(stdout, _1)\n  println(stdout, _2)\n  return _0\n}\nrun(test2)\n</code>\n</aside></li>\n<li><aside>\n<p>X Argument separation failure</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test1(f,store) {\n  let _1 = reflect(1)\n  let c1 = alloc(store)\n  let c2 = alloc(store)\n  inc(c1)\n  inc(c2)\n  let f1 = fun(argtype(track(reftype(\"Int\"))), (f1,c) => {\n    inc(c)\n    inc(c1)\n    return _1\n  })\n  app(f1,c1) // error\n  app(f1,c2) // ok\n  inc(c1) // dep on apps\n  inc(c2) // dep on apps\n  return _1\n}\nrun(test1)\n</code>\n</aside></li>\n<li><aside>\n<p>X Escaping ref</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test3(f,store) {\n  let _0 = reflect(0)\n  let _1 = reflect(1)\n  let _2 = reflect(2)\n  let f1 = fun(argtype(\"Int\"), (f1,a) => {\n    let c1 = alloc(store)\n    return fun(argtype(\"Int\"), (f2,b) => {\n      return c1\n    })\n  })\n  let f2 = app(f1, _0)\n  let f3 = app(f1, _1)\n  let c3 = app(f2, _0)\n  let c4 = app(f2, _1)\n  inc(c3)\n  inc(c4)\n  return _0\n}\nrun(test3)\n</code>\n</aside></li>\n</ul>\n<p>Interaction: click ‚Äúcode>>‚Äù to show source, click on any identifier to highlight references.</p>\n<h3>Complete pipeline (with parser and codegen)</h3>\n<aside>\n<p>Implementation code</p>\n<p>Parser</p>\n<p>Core DOM and text editor</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// text selection utils\n//\nfunction findOffsetInParent(node, pos, top) {\n  if (node == top)\n    return pos;\n  while (node.previousSibling) {\n    node = node.previousSibling;\n    var len = node.nodeType == 3 ? node.length : node.innerText.length;\n    pos = len + pos;\n  }\n  return findOffsetInParent(node.parentNode, pos, top);\n}\nfunction findChildForOffset(node, pos) {\n  var len = node.nodeType == 3 ? node.length : node.innerText.length;\n  if (pos > len)\n    return findChildForOffset(node.nextSibling, pos - len);\n  if (node.firstChild)\n    return findChildForOffset(node.firstChild, pos);\n  return {node: node, pos: pos};\n}\n//\n// text editor\n//\nlet text\nfunction textmodel_get(start, end) {\n  return text.substring(start,end)\n}\nfunction textmodel_edit(start, end, data) {\n  text = text.substring(0, start) + data + text.substring(end, text.length)\n}\n// editor setup\nlet p = document.createElement(\"pre\")\nlet d = document.createElement(\"pre\")\nlet row = document.createElement(\"div\")\nrow.style[\"display\"] = \"flex\"\nrow.appendChild(p)\nrow.appendChild(d)\n//o.appendChild(row)\np.setAttribute(\"contenteditable\", true)\np.setAttribute(\"spellcheck\", false)\np.style[\"border\"] = \"1px solid grey\"\np.style[\"padding\"] = \"3px\"\n//p.style[\"width\"] = \"250px\"\np.style[\"min-height\"] = \"200px\"\np.style[\"outline\"] = \"none\"\np.style[\"overflow\"] = \"scroll\"\nd.style[\"border\"] = \"1px solid grey\"\nd.style[\"padding\"] = \"3px\"\n//d.style[\"width\"] = \"250px\"\n//d.style[\"height\"] = \"200px\"\nd.style[\"overflow\"] = \"scroll\"\np.addEventListener(\"beforeinput\", ev => {\n  ev.preventDefault()\n  let data = ev.data || ev.dataTransfer?.getData(\"text/plain\") || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  historyEditor_edit(start, end, data)\n})\nlet onEdit = () => p.innerText = text\nfunction editor_update() {\n  try {\n    onEdit()\n  } catch(ex) {\n    print(\"[Editor Callback] \"+ex)\n    print(ex.stack)\n  }\n}\nfunction editor_edit(start, end, data) {\n  textmodel_edit(start, end, data)\n  editor_update()\n  select(start + data.length, start + data.length)\n}\nfunction select(start, end) {\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\n// history setup\nlet historymodel = {\n  edits: [],//[{ start: 0, end: 0, old: \"\", data: text }],\n  position: 0,\n}\np.addEventListener(\"keypress\", ev => {\n  //clear()\n  if (ev.key == \"z\" && ev.metaKey) {\n    if (!ev.shiftKey) prevEdit()\n    else nextEdit()\n    ev.preventDefault()\n  }\n  //print(ev)\n})\nfunction historyEditor_edit(start, end, data) {\n  recordEdit(start, end, data)\n  editor_edit(start, end, data)\n}\nfunction recordEdit(start, end, data) {\n  let old = textmodel_get(start, end)\n  //if (old == data) return // could check prefix/suffix ...\n  if (historymodel.position > 0) {\n    let e = historymodel.edits[historymodel.position-1]\n    // we only fuse pure inserts or deletes\n    // this could be extended to delete+insert\n//print(e.start+\" \"+e.data)\n    if (e.start == e.end && start == end && e.start + e.data.length == start) { // insert at enprint(e.start+\" \"+e.data)\n      e.data = e.data + data\n//print(e.start+\" \"+e.data)\n      return updateHistoryUI()\n    } else if (e.data.length == 0 && data.length == 0 && end == e.start) { // delete at beginning\n      e.start = start\n      e.old = old + e.old\n      return updateHistoryUI()\n    }\n  }\n  historymodel.edits = historymodel.edits.slice(0, historymodel.position++)\n  historymodel.edits.push({ start, end, old, data })\n  updateHistoryUI()\n}\nfunction rewindHistory() {\n  historymodel.position = 0\n  p.innerText = \"\"\n  updateHistoryUI()\n}\nfunction nextEdit() {\n  if (historymodel.position < historymodel.edits.length) {\n    let e = historymodel.edits[historymodel.position++]\n    editor_edit(e.start, e.end, e.data)\n    updateHistoryUI()\n  }\n}\nfunction prevEdit() {\n  if (historymodel.position > 0) {\n    let e = historymodel.edits[--historymodel.position]\n    editor_edit(e.start, e.start + e.data.length, e.old)\n    updateHistoryUI()\n  }\n}\nfunction updateHistoryUI() {\n  // not used\n}\n</code>\n<p>Parser</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// parser state & lexer\n//\nlet pos, peek\nlet gap, skippedNL, pastGap\nlet str\n//let seq\nfunction init(s) {\n  seq = []\n  input = s;\n  pos = 0;\n  whitespace()\n  read()\n}\nfunction processGap() {\n  if (!pastGap) {\n    if (gap.trim()) {\n      seq.push(dom1(\"comment\", \"\", gap))\n    } else {\n      seq.push(gap)\n    }\n    pastGap = true\n  }\n}\nfunction next() {\n  processGap()\n  if (peek != str)\n    seq.push(dom1(peek, \"\", str))\n  else\n    seq.push(str)\n  let c = peek;\n  whitespace()\n  read()\n  return c\n}\nfunction read() {\n  let isdigit = () => '0' <= input[pos] && input[pos] <= '9'\n  let isletter = () => 'a' <= input[pos] && input[pos] <= 'z' || 'A' <= input[pos] && input[pos] <= 'Z'\n  let isopr = () => input[pos] in {'+':1,'-':1,'*':1,'/':1,'%':1,'<':1,'>':1,'=':1,'!':1}\n  let start = pos\n  if (isdigit()) {\n    while (isdigit()) pos++\n    peek = \"num\"\n  } else if (isletter()) {\n    while (isletter() || isdigit()) pos++\n    peek = \"ident\"\n  } else if (isopr()) {\n    // special cases for function arrow sugar:\n    // =r>, =w>, =k>, =1> etc\n    // general shape: =...> (could permit -...>, ~...> etc)\n    let maybeArrow = input[pos] == \"=\"\n    while (isopr()) pos++\n    let opPrefixEnd = pos\n    if (maybeArrow) {\n      while (isopr() || isdigit() || isletter()) pos++\n      if (input[pos-1] != '>') // backtrack if no closing\n        pos = opPrefixEnd\n    }\n    peek = input.substring(start,pos)\n  } else if (input[pos] == '\"') {\n    pos += 1\n    while (input[pos] && input[pos] != '\"') pos++\n    if (input[pos]) pos++ // may be unterminated!\n    peek = \"str\"\n  } else {\n    peek = input[pos++]\n  }\n  str = input.substring(start,pos)\n}\nfunction whitespace() {\n  let start = pos\n  for (;;) {\n    if (input[pos] == '/' && input[pos+1] == '/') {\n      pos += 2\n      while (input[pos] && input[pos] != '\\n') ++pos\n    } else if (input[pos] == ' ') {\n      pos++\n    } else if (input[pos] == '\\n') {\n      pos++\n    } else {\n      break\n    }\n  }\n  gap = input.substring(start,pos)\n  pastGap = false\n}\n//\n// parser aux\n//\nfunction dom1(key, info, children) {\n  let d = e(\"span\",{key,info},...children)\n  if (key == \"error\") {\n    d.style[\"padding\"] = \"1px\"\n    d.style[\"background\"] = \"red\"\n  } else if (key == \"expected\") {\n    d.style[\"padding\"] = \"1px\"\n    d.style[\"background\"] = \"red\"\n  } else if (key == \"skip\") {\n    d.style[\"background\"] = \"lightpink\"\n  } else if (key == \"comment\") {\n    d.style[\"font-style\"] = \"italic\"\n    d.style[\"color\"] = \"grey\"\n  } else if (key == \"ident\") {\n    d.style[\"color\"] = \"navy\"\n  } else if (key == \"str\") {\n    d.style[\"color\"] = \"purple\"\n  } else {\n    d.style[\"color\"] = \"sienna\"\n  }\n  return d\n}\nfunction collectPT(k,f) {\n  processGap()\n  let save = seq\n  let res = []\n  seq = res\n  try { f() } finally {\n  seq = save\n  let d = dom1(k,\"\",res)\n  seq.push(d)\n  }\n  return res\n}\nfunction detachPT2(k,f) { // collect detached\n  //processGap() messes up order ...\n  let save = seq\n  let res = []\n  seq = res\n  try { f(); seq = save } catch (ex) {\n  seq = save\n  seq.push(dom1(k,\"\",res)) // can't swallow\n  throw ex\n  }\n  return dom1(k,\"\",res)\n}\nfunction clickSrcRef(src) {\n  if (src instanceof Array) return src.map(clickSrcRef)\n  src.highlight = !src.highlight\n  if (src.highlight)\n    src.style[\"background\"] = \"lightgreen\"\n  else\n    src.style[\"background\"] = \"pink\"\n}\nfunction reportSrcInfo(src,msg) {\n  let el = dom(\"¬†\")\n  el.style[\"background\"] = \"pink\"\n  el.style[\"cursor\"] = \"pointer\"\n  el.addEventListener(\"click\", ev => {\n    clickSrcRef([el,src])\n  })\n  print(el,\" \",msg)\n}\nfunction parseError(msg) {\n  //processGap()\n  let el = dom1(\"error\", msg, [])\n  reportSrcInfo(el, \"Parse error: \"+msg)\n  seq.push(el)\n  // alternative logic:\n  // - call markError on skip node\n}\nfunction expect(d,s) {\n  if (peek == d && (!s || str == s)) {\n    next()\n  } else {\n    //parseError(d+\" expected\")\n    let el = dom1(\"expected\", d, [])\n    reportSrcInfo(el, \"Parse error: expected '\"+d+\"'\")\n    seq.push(el)\n  }\n}\n//\n// main parser logic\n//\nfunction split(d,f) {\n  collectPT(d, () => {\n    if (d == ';')\n      for (;;) {\n        let last = pos\n        f()\n        if (peek == d) next();\n        else if (pos > last && gap.includes('\\n'));\n        else break\n      }\n    else\n      for (;;) {\n        f()\n        if (peek == d && !gap.includes('\\n')) next();\n        else break\n      }\n  })\n}\nlet nparens = 0\nfunction parens(f) {\n  collectPT('()', () => {\n    expect('(')\n    nparens++\n    if (peek != ')')\n      try { f() } catch(ex) {} // could rethrow if no match\n    expect(')')\n    nparens--\n  })\n}\nlet nbraces = 0\nfunction braces(f) { // could unify\n  collectPT('{}', () => {\n    expect('{')\n    nbraces++\n    if (peek != '}')\n      try { f() } catch(ex) {} // could rethrow if no match\n    // TODO: close any stray parens\n    expect('}')\n    nbraces--\n  })\n}\nfunction tight() {\n  if (peek == '{') {\n    braces(block)\n  } else if (peek == '(') {\n    parens(expr)\n  } else if (peek == \"num\" || peek == \"str\" || peek == \"ident\") {\n    let res = detachPT2(\"B\",() => next()) // detach and wait\n    while (peek == '(' && !gap.includes('\\n')) {\n      res = detachPT2(\"@@\",() => {\n        seq.push(res)\n        parens(() => split(',', expr))\n      })\n    }\n    seq.push(res)\n  } else {\n    parseError(\"atom expected\")\n  }\n}\n// precedence: higher binds tighter\nlet prec = {\n  ':': 10,\n  //'=': 20,\n  '=>': 30,\n  '=r>': 30,\n  '=w>': 30,\n  '=k>': 30,\n  '=t>': 30,\n  '@': 40,\n  '+': 50,\n  '-': 50,\n  '*': 60,\n  '/': 60\n}\n// associativity: 1 for left, 0 for right\nlet assoc = {\n  ':': 0,\n  //'=': 0,\n  '=>': 0,\n  '=r>': 0,\n  '=w>': 0,\n  '=k>': 0,\n  '=t>': 0,\n  '@': 1,\n  '+': 1,\n  '-': 1,\n  '*': 1,\n  '/': 1\n}\nfunction binop(min) {\n  let res = detachPT2(\"B\",() => tight()) // detach and wait until op\n  while (peek in prec && prec[peek] >= min) {\n    let nextMin = prec[peek] + assoc[peek] // + 1 for left assoc\n    res = detachPT2(peek,() => {\n      seq.push(res)\n      next()\n      binop(nextMin)\n    })\n  }\n  seq.push(res)\n}\nfunction expr() {\n  binop(0)\n}\nfunction expr0() { // old code, no longer used!\n  split(':', () => {\n  split('=k>', () => {\n  split('=w>', () => {\n  split('=r>', () => {\n  split('=t>', () => {\n  split('=>', () => {\n  split('@', () => {\n  split('+', () => {\n    split('*', () => {\n      if (peek == '{') {\n        braces(block)\n      } else if (peek == '(') {\n        parens(expr)\n      } else if (peek == \"num\" || peek == \"ident\") {\n        collectPT('@@', () => {\n          next()\n          while (peek == '(' && !gap.includes('\\n'))\n            parens(() => split(',', expr))\n        })\n      } else {\n        parseError(\"atom expected\")\n      }\n    })\n  })\n  })\n  })\n  })\n  })\n  })\n  })\n  })\n}\nfunction block() {\n  split(';', () => {\n    if (peek == \"ident\" && str == \"def\") {\n      collectPT(\"D\", () => {\n        expect(\"ident\", \"def\")\n        applyTokenStyle(\"keyword\")\n        expect(\"ident\")\n        applyTokenStyle(\"bound\")\n        parens(() => split(',', () => {\n          expect(\"ident\"); expect(\":\"); expr()\n        }))\n        // do not expect res types atm\n        //expect(\":\")\n        //expr()\n        expect(\"=\")\n        expr()\n      })\n    } else if (peek == \"ident\" && str == \"let\") {\n      collectPT(\"L\", () => {\n        expect(\"ident\", \"let\")\n        applyTokenStyle(\"keyword\")\n        //expect(\"ident\")\n        expr()\n        applyTokenStyle(\"bound\")\n        expect(\"=\")\n        expr()\n      })\n    } else if (peek && peek != '}') {\n      expr()\n    }\n  })\n}\n// more formatting\nfunction applyTokenStyle(key) {\n  let d = seq[seq.length-1]\n  if (key == \"keyword\")\n    d.style[\"color\"] = \"purple\"\n  else if (key == \"bound\")\n    d.style[\"color\"] = \"navy\"\n}\n//\n// string -> cst (concrete syntax tree: structured text as html dom)\n//\nfunction parse(text) {\n  try {\n    init(text)\n    block() // should do this inside block?\n    let max = 20\n    while (peek && max--) {\n      processGap()\n      // TODO: close any stray parens & braces\n      parseError(\"unexpected \"+peek,true)\n      next()\n      block()\n    }\n    if (peek) parseError(\"unexpected \"+peek)\n    // Q: need to emit last gap?\n  } catch (ex) {\n    print(\"Exception during parsing: \",ex)\n  }\n  if (pos-1 < text.length) {\n    seq.push(dom1(\"skipped\",\"\",[text.substring(pos-1,text.length)]))\n  } else if (!pastGap) seq.push(gap)\n  return dom1(\"P\",\"\",seq)\n}\n//\n// cst -> ast (abstract syntax tree: html dom formatted as tree)\n//\n// (trivial version, not used)\n//\nfunction walk(a) {\n  let ch = []\n  for (let c of a.children) ch.push(walk(c))\n  //if (a.key in {'+':0,'*':0,'‚èé':0,'=':0,'T':0} && ch.length == 1) return ch[0]\n  if (ch.length == 1) return ch[0]\n  let l = (a.key + \" \\\"\"+ (a.info||a.textContent) + \"\\\"\").substring(0,30).replaceAll(\"\\n\",\"‚èé\");\n  let d = e(\"div\", {}, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  return d\n}\n</code>\n<p>AST to IR converter</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// convert cst -> ast (throw away some empty grouping)\n//\nfunction convertCstToAst(a) {\n  if (a.key == \"comment\") return\n  let ch = []\n  for (let c of a.children) {\n    let c1 = convertCstToAst(c)\n    if (c1) ch.push(c1)\n  }\n  if (ch.length == 1 && a.key != ';' && a.key != ',') return ch[0]\n  let l = a.key\n  let info = \"\"\n  if (a.key == \"ident\" || a.key == \"num\") {\n    l += \" \\\"\"+ a.textContent + \"\\\"\"\n    info = a.textContent\n  } else if (a.info) { // e.g. errors!\n    l += \" \\\"\"+ a.info + \"\\\"\"\n    info = a.info\n  }\n  let d = e(\"div\", {key: a.key, info: info, src: a }, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  if (a.key == \"error\")\n    d.style[\"background-color\"] = \"red\"\n  else if (a.key == \"expected\")\n    d.style[\"background-color\"] = \"lightpink\"\n  else if (a.key == \"skip\")\n    d.style[\"background-color\"] = \"lightpink\"\n  return d\n}\n//\n// convert ast -> graph IR via staging\n//\nfunction syntaxError(x,...es) {\n  let msg = es.join(\" \")\n  reportSrcInfo(x.src||x,\"Syntax error: \"+msg)\n  x.style[\"background\"] = \"red\"\n  x.setAttribute(\"title\", msg)\n  if (x.src) {\n    x.src.style[\"background\"] = \"lightpink\"\n    x.src.setAttribute(\"title\", msg)\n  }\n}\nfunction assertSyntax(c,x,...es) {\n  if (!c) {\n    syntaxError(x,...es)\n    throw new Error(\"syntax\") // catch and swallow later!\n  }\n}\nfunction isArrow(k) {\n  return k.startsWith(\"=\") && k.endsWith(\">\")\n}\nfunction getArrowQualifier(k) {\n  return k.slice(1,-1)\n}\nfunction walkExpr(expr) { try {\n  if (expr.key == \"num\") {\n    expr.sym = reflect(Number(expr.info))\n  } else if (expr.key == \"ident\") {\n    assertSyntax(expr.info in env, expr, \"ident not found: \"+expr.info)\n    expr.sym = env[expr.info]\n  } else if (expr.key == \"+\") { // TODO: -,*,/,%, ...\n    assertSyntax(expr.children.length == 2, expr, \"only binary + supported (for now)\")\n    for (let e of expr.children) {\n      walkExpr(e)\n    }\n    expr.sym = plus(...[...expr.children].map(e=>e.sym))\n  } else if (expr.key == \";\") {\n    walkBlock(expr)\n  } else if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"application needs exactly one argument\")\n    let [fun,args] = expr.children\n    if (fun.key == \"ident\" && fun.info == \"println\") {\n      // TODO: check n args?\n      expr.sym = println(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"alloc\") {\n      expr.sym = alloc(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"set\") {\n      expr.sym = set(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"get\") {\n      expr.sym = get(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"inc\") {\n      expr.sym = inc(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"free\") {\n      expr.sym = free(...[...args.children].map(walkExpr))\n    // dep type stuff\n    } else if (fun.key == \"ident\" && fun.info == \"const\") {\n      expr.sym = constant(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"delay\") {\n      expr.sym = delayval(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"check\") {\n      expr.sym = check(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"Ref\") {\n      assertSyntax(args.children.length == 1, expr, \"need exactly one argument\")\n      expr.sym = reftype(...[...args.children].map(walkExpr))\n    // generic\n    } else {\n      // TODO: check stuff?\n      assertSyntax(args.children.length <= 1, expr, \"application needs zero or one argument\")\n      walkExpr(fun)\n      //extract expected arg types from fun!! (currently only one!)\n      let ftp = symToTpe[fun.sym]\n      //assertSyntax(isFunType(ftp), fun.sym, \"not a function type: \",ftp)\n      let [argTpe, frtp] = extractFunTypeUnflat(ftp,fun.sym)\n      if (args.children.length > 0) {\n        args.children[0].ept = argTpe\n        expr.sym = app(fun.sym, ...[...args.children].map(walkExpr))\n      } else {\n        expr.sym = app(fun.sym, reflect(\"()\"))\n      }\n    }\n  } else if (expr.key == \"=>\") {\n    // XXX DEP (at least) 4 cases:\n    // -> val to val: (x:Int) => 2*x\n    // -> tpe to val: (t:Type) => new Array(t)(200)\n    // -> val to tpe: (x:Bool) => if (x) String else Unit\n    // -> tpe to tpe: (t:Type) => Array(t)\n    // ----\n    // -> Nat => Nat  (a type!)\n    // -> (x:Nat) => Array(Nat)  (a type!)\n    // see DEF case in walkStm for comparison\n    assertSyntax(expr.children.length == 2, expr, \"function literal needs a body\")\n    let ept = expr.ept || \"?\"\n    let [arg,body] = expr.children\n    let [fn,xn,atp0] = walkArgExpr(arg)\n    // TODO: relate given and expected types\n    if (ept == \"?\" && atp0 == \"?\") {\n      assertSyntax(false, xn, \"function literal needs expected type or provided argument type\")\n    }\n    // ignore expected type if arg type given (for now!)\n    let [atp, frtp] = atp0 != \"?\" ? [atp0, (f,x) => \"?\"] : extractFunTypeUnflat(tpeFlatten(ept).base)\n    expr.sym = fun(argtype(atp), (ff,xx) => {\n      let save = env\n      env = {...save}\n      if (fn != \"?\") {\n        env[fn.info] = ff\n        nameHint[ff] = fn.info\n        registerSymRef(ff,fn)\n      }\n      if (xn != \"?\") {\n        env[xn.info] = xx\n        nameHint[xx] = xn.info\n        registerSymRef(xx,xn)\n      }\n      body.ept = frtp(ff,xx)\n      let res = walkExpr(body)\n      // XXX try catch?\n      env = save\n      return res\n    })\n  } else if (expr.key == \"=t>\") {\n    assertSyntax(expr.children.length == 2, expr, \"function type needs a result type\")\n    //let qual = getArrowQualifier(expr.key)\n    let [arg,body] = expr.children\n    let [fn,xn,atp] = walkArgTypeExpr(arg)\n    let env1 = env\n    expr.sym = funtype(atp, (ff,xx) => {\n      let save = env\n      env = {...env1,[fn]:ff,[xn]:xx} // XXX do not add \"?\"\n      if (fn != \"?\") nameHint[ff] = fn\n      if (xn != \"?\") nameHint[xx] = xn\n      // XXX todo: registerSymRef (need to change walkArgTypeExpr to return DOM)\n      try { return walkExpr(body) } finally {\n        env = save\n      }\n    })\n  } else if (expr.key == \"@\") { // type annotation\n    let [base,...rest] = expr.children\n    let tpe = walkTypeExpr(base)\n    for (let e of rest)\n      tpe = walkTypeAnnot(tpe,e)\n    expr.sym = tpe\n  } else if (expr.key == \":\") {\n    let target = expr.children.length > 1 ? expr.children[0] : expr\n    assertSyntax(false, target, \"unexpected type ascription; argument lists require parentheses\")\n  } else {\n    assertSyntax(false, expr, \"unknown expr: \"+expr.key)\n  }\n  registerSymRef(expr.sym,expr)\n  if (expr.ept)\n    typeCheckUnflat(expr.sym, expr.ept)\n  return expr.sym\n} catch(ex) {\n  if (ex.message != \"syntax\" && ex.message != \"type\") {\n    // error originated somewhere else, need to report it\n    print(\"Exception: \",ex)\n    print(ex.stack)\n  }\n  // create a hole!\n  if (expr.ept && expr.ept != \"?\")\n    expr.sym = hole(expr.ept)\n  else\n    expr.sym = hole(hole(env[\"Type\"])) // we do not know if type or kind\n  registerSymRef(expr.sym,expr)\n  return expr.sym\n}\n}\n// e.g. f(x:Int)\n// return [f,[x,\"Int\"]]\nfunction walkArgExpr(expr) {\n  function walkArg(expr) {\n    if (expr.key == \"()\") {\n      // Future: support multiple args\n      assertSyntax(expr.children.length == 0, expr, \"need zero or one argument\")\n      return [\"?\",env[\"Unit\"]]\n    } else if (expr.key == \":\") {\n      assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n      let [name,tpe] = expr.children\n      walkIdent(name)\n      return [name, walkTypeExpr(tpe)]\n    } else {\n      walkIdent(expr)\n      return [expr,\"?\"]\n    }\n  }\n  if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [fun,arg] = expr.children\n    walkIdent(fun)\n    assertSyntax(arg.key == \",\", arg, \"malformed argument list\")\n    assertSyntax(arg.children.length == 1, arg, \"expected exactly one function parameter\")\n    return [fun, ...walkArg(arg.children[0])]\n  } else {\n    return [\"?\", ...walkArg(expr)]\n  }\n}\nfunction walkArgTypeExpr(expr) {\n  // cases:\n  // - named fun & arg: f(x:Int)\n  // - named fun:       f(Int)\n  // - named arg:       x:Int\n  // - type only:       Int\n  // TODO: multiple args, without or without arg/fun name(s)\n  function walkArg(expr) {\n    if (expr.key == \":\") {\n      assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n      let [name,tpe] = expr.children\n      walkIdent(name)\n      return [name.info, walkTypeExpr(tpe)]\n    } else {\n      return [\"?\",walkTypeExpr(expr)]\n    }\n  }\n  if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [fun,arg] = expr.children\n    // TODO: support multiple parameters (via arg.key == \",\" ?)\n    walkIdent(fun)\n    assertSyntax(arg.key == \",\", arg, \"malformed argument list\")\n    assertSyntax(arg.children.length == 1, arg, \"expected exactly one function parameter\")\n    return [fun.info, ...walkArg(arg.children[0])]\n  } else\n    return [\"?\",...walkArg(expr)]\n}\nfunction walkTypeExpr(expr) {\n  return walkExpr(expr)\n  if (expr.key == \"ident\") {\n    //return expr.info XXX DEP\n    walkExpr(expr)\n    return expr.sym\n  } else if (expr.key == \"@\") {\n    let [base,...rest] = expr.children\n    let tpe = walkTypeExpr(base)\n    for (let e of rest)\n      tpe = walkTypeAnnot(tpe,e)\n    return tpe\n  } else if (expr.key == \"@@\") { // only Ref for now\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [fun,arg] = expr.children\n    walkIdent(fun)\n    assertSyntax(fun.info == \"Ref\", expr, \"unknown type constructor: \"+fun.info)\n    assertSyntax(arg.key == \",\", arg, \"malformed argument list\")\n    assertSyntax(arg.children.length == 1, arg, \"expected exactly one function parameter\")\n    return reftype(walkTypeExpr(arg.children[0]))\n  } else if (isArrow(expr.key)) { // expr.key == \"=>\"\n    assertSyntax(expr.children.length == 2, expr, \"function type needs a result type\")\n    let qual = getArrowQualifier(expr.key)\n    let [arg,body] = expr.children\n    let [fn,xn,atp] = walkArgTypeExpr(arg)\n    let env1 = env\n    // sugar: Int =r> Int  =  (f(Int) => Int @read(f)) @track\n    function sugarRes(e,f) { // sugar: Int =r> Int  =  f(Int) => Int @read(f)\n      if (qual == \"r\") return effect(e, \"read\", f)\n      if (qual == \"w\") return effect(effect(e, \"read\", f), \"write\", f)\n      if (qual == \"k\") return effect(effect(effect(e, \"read\", f), \"write\", f), \"kill\", f)\n      assert(qual == \"\", expr, \"unknown arrow qualifier: \"+qual)\n      return e\n    }\n    function sugarFun(f) {\n      if (qual == \"\") return f\n      else return track(f)\n    }\n    return sugarFun(funtype(atp, (f,x) => {\n      let save = env\n      env = {...env1,[fn]:f,[xn]:x} // XXX do not add \"?\"\n      try { return sugarRes(walkTypeExpr(body),f) } finally {\n        env = save\n      }\n    }))\n  } else {\n    assertSyntax(false, expr, \"unknown type expr: \"+expr.key)\n  }\n}\nfunction walkTypeAnnot(base,expr) {\n  if (expr.key == \"ident\" && expr.info == \"track\") {\n    return track(base)\n  } else if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let fun = expr.children[0]\n    let args = expr.children[1]\n    walkIdent(fun)\n    let args1 = walkIdentList(args)\n    if (fun.info == \"track\") {\n      return track(base, ...args1)\n    } else if (fun.info == \"read\") {\n      return effect(base, \"read\", ...args1)\n    } else if (fun.info == \"write\") {\n      return effect(base, \"write\", ...args1)\n    } else if (fun.info == \"kill\") {\n      return effect(base, \"kill\", ...args1)\n    // shorthands...\n    } else if (fun.info == \"r\") {\n      return effect(base, \"read\", ...args1)\n    } else if (fun.info == \"w\") {\n      return effect(base, \"write\", ...args1)\n    } else if (fun.info == \"k\") {\n      return effect(base, \"kill\", ...args1)\n    } else if (fun.info == \"rw\") {\n      return effect(effect(base, \"read\", ...args1), \"write\", ...args1)\n    } else if (fun.info == \"wk\") {\n      return effect(effect(base, \"write\", ...args1), \"kill\", ...args1)\n    } else if (fun.info == \"rwk\") {\n      return effect(effect(effect(base, \"read\", ...args1), \"write\", ...args1), \"kill\", ...args1)\n    }\n  }\n  assertSyntax(false, expr, \"unknown type annotation\")\n  return base\n}\nfunction walkIdentList(es) {\n  assertSyntax(es.key == \",\", es, \"malformed argument list\")\n  let as = []\n  for (let a of es.children) {\n    walkIdent(a)\n    assertSyntax(a.info in env, a, \"ident not found: \"+a.info)\n    as.push(env[a.info])\n  }\n  return as\n}\nfunction walkParamList(params) {\n  if (params.key == \"()\") return [\"?\",env[\"Unit\"]]\n  assertSyntax(params.key == \",\", params, \"malformed argument list\")\n  assertSyntax(params.children.length == 2, params, \"expected exactly one declared function parameter\")\n  //assertSyntax(params.children.length == 2, params, \"need exactly one argument\")\n  let [p,ptp] = params.children\n  walkIdent(p)\n  let ptp1 = walkTypeExpr(ptp)\n  return [p.info,ptp1]\n}\nfunction walkKeyword(k,s) {\n  assertSyntax(k.key == \"ident\" && k.info == s, k, \"expected '\"+s+\"'\")\n}\nfunction walkIdent(k) {\n  assertSyntax(k.key == \"ident\", k, \"expected identifier\")\n}\nfunction walkLhs(expr) {\n  if (expr.key == \"ident\") {\n    walkIdent(expr)\n    return [expr, \"?\"]\n  } else if (expr.key == \":\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [name,tpe] = expr.children\n    walkIdent(name)\n    return [name, walkTypeExpr(tpe)]\n  } else {\n    assertSyntax(false, expr, \"malformed lhs\")\n  }\n}\nfunction walkStm(stm) {\n  if (stm.key == \"D\") {\n    //print(\"DEF\");\n    assertSyntax(stm.children.length == 4, stm, \"malformed def statement\")\n    let [kw, name, params, /*rtp, */body] = stm.children\n    walkKeyword(kw, \"def\")\n    let save = env\n    env = {...save}\n    walkIdent(name)\n    let [x,ptp1] = walkParamList(params)\n    //let rtp1 = walkTypeExpr(rtp) // TODO: used?\n    let ftp = argtype(ptp1)\n    stm.sym = fun(ftp, (ff,xx) => {\n      env[name.info] = ff\n      env[x] = xx\n      nameHint[ff] = name.info\n      nameHint[xx] = x\n      walkExpr(body)\n      env = save\n      return body.sym\n    })\n    env[name.info] = stm.sym\n    nameHint[stm.sym] = name.info\n    registerSymRef(stm.sym,name)\n } else if (stm.key == \"L\") {\n    //print(\"LET\")\n    assertSyntax(stm.children.length == 3, stm, \"malformed let statement\")\n    let [kw, lhs, rhs] = stm.children\n    walkKeyword(kw, \"let\")\n    let [name,tpe] = walkLhs(lhs)\n    rhs.ept = tpe // expected type!!\n    walkExpr(rhs)\n    stm.sym = rhs.sym // needed?\n    env[name.info] = rhs.sym\n    nameHint[rhs.sym] = name.info\n    registerSymRef(rhs.sym,name)\n  } else {\n    walkExpr(stm)\n  }\n}\nfunction walkBlock(block) {\n  // if there were errors, we have have multiple\n  // top level blocks. treat them as one, skipping\n  // parse errors\n  if (block.key == \"P\" && block.children[0]) {\n    for (let s of block.children) {\n      if (s.key == \";\") walkBlock(s)\n    }\n    return\n  }\n  assertSyntax(block.key == \";\", block, \"malformed block statement \"+block.key)\n  for (let s of block.children) {\n    try { walkStm(s) } catch (ex) {\n      if (ex.message != \"syntax\") {\n        print(\"AST to IR \"+ex)\n        print(ex.stack)\n      }\n      // mark s as having been skipped\n      s.style[\"background\"] = \"lightpink\"\n      //if (s.src) s.src.style[\"background\"] = \"lightpink\"\n    }\n  }\n  let len = block.children.length\n  if (len)\n    block.sym = block.children[len-1].sym\n  if (!block.sym)\n    block.sym = reflect(\"()\")\n}\nfunction walk(a) {\n  let stms = convertCstToAst(a)\n  try { walkBlock(stms) } catch (ex) { print(\"AST to IR \"+ex) }\n  return stms\n}\n</code>\n<p>Compact codegen</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// NOTE: shouldInline itself isn't tight enough\n// to prevent reordering of effectful exprs that also\n// return a value (e.g. var reads).\n//   let c = alloc(1)\n//   let r = get(c)\n//   set(c,2)\n//   println(r) // can't inline r here!\n//              // but could if set/println reordered\n// That's why there's an additional pass to fix it up.\n//\n//let path = new Set([])\n//let inner = code // []\nlet shouldInline\nlet needSymbol\n//function withScope(p,ns,b) {\n//  let [path0, inner0] = [path, inner]\n//  path = p; inner = ns\n//  try { return b() } finally { path = path0; inner = inner0 }\n//}\nfunction symsRec(c) {\n  if (typeof(c) === \"string\") return [] // XXX EFF\n  if (typeof(c) === \"number\") return [c]//,symToTpe[c]] // XXX DEP\n  if (!c) { print(\"error: symsRec(null)\"); return [] }\n  return Object.values(c).map(symsRec).flat()\n}\nfunction syms(c) {\n  let [_, sym, [op,...args], [hdeps,sdeps]] = c\n  return {v: symsRec(args), h: symsRec(hdeps), s: symsRec(sdeps)}\n}\nfunction symsFreq(c) {\n  let [_, sym, [op,...args], deps] = c\n  if (op == \"Œª\") {\n    let [xx, yy, [hdeps,sdeps], eff] = args\n    return {v: [[yy,100.0]],\n            h: symsRec(hdeps).map(x => [x,100.00]),\n            s: symsRec(sdeps).map(x => [x,100.00])}\n    // XXX ignoring stm deps -- ok???\n  } else if (op == \"=>\") {\n    let [atp,ff,xx,yy] = args\n    return {v: [[atp,1.0],[yy,100.0]],\n            h: [],\n            s: []}\n  } else if (op == \"?\") {\n    // TODO/FIXME!\n    let [c,xa,[a,yan],xb,[b,ybn]] = args\n    return [[yan,0.5], [ybn,0.5]]\n  } else {\n    let {v,h,s} = syms(c)\n    return {v: v.map(x => [x,1.0]),\n            h: h.map(x => [x,1.0]),\n            s: s.map(x => [x,1.0])}\n  }\n}\nfunction traverseBlockCompact(inp, outp) {\n  let path1 = new Set([...inp,...path])\n  withScope(path1, inner, () => {\n    traverseBlockCompact1(outp)})\n}\nfunction traverseBlockCompact1(res) {\n  function available(c) {\n    let [_let, sym, rhs] = c\n    for (let b of boundDeps[sym])\n      if (!path.has(b)) {\n        //print(prettySym(sym)+\" unavailable bc \"+prettySym(b)+\":\"+prettySym(symToTpe[b])+\" not in path\")\n        //if (symToTpe[b] != env[\"Type\"] &&\n          //symToTpe[b] != env[\"Kind\"])\n        return false\n      }\n    return true\n  }\n  // todo: prune harder by reach(res)\n  // todo: soft/hard\n  let reach = new Set()\n  let df = [] // local definitions\n  let hmo = [] // how many times used outer (as proper val)\n  let hmi = [] // how many times used inner (as proper val)\n  for (let s of res)\n    reach.add(s)\n  hmo[res[0]] = 1 // only first is used as proper val\n  let outer1 = []\n  let inner1 = []\n  inner.reverse()\n  for (let c of inner) {\n    if (reach.has(c[1])) {\n      let sfs = symsFreq(c)\n      if (available(c)) {\n      // XXX careful with successor computation:\n      // XXX we're going bottom up!\n        outer1.push(c)\n        df[c[1]] = c\n        for (let [s,f] of sfs.v) { // value deps\n          if (f > 0.5) reach.add(s)\n          if (f == 1.0) hmo[s] = (hmo[s]||0)+1 // direct syms, no blocks!\n          else hmi[s] = (hmi[s]||0)+1\n        }\n        for (let [s,f] of sfs.h) { // hard effect deps\n          if (f > 0.5) reach.add(s)\n        }\n        // soft effect deps: do nothing\n      } else {\n        inner1.push(c)\n        for (let [s,f] of sfs.v) { // value deps\n          reach.add(s)\n          hmi[s] = (hmi[s]||0)+1\n        }\n        for (let [s,f] of sfs.h) { // hard effect deps\n          reach.add(s)\n        }\n      }\n    } else {\n      // XXX it may be cold-only reachable, but\n      // XXX what if not reachable at all?\n      // XXX can we prune more, based on 'reach'??\n      inner1.push(c)\n      for (let [s,f] of symsFreq(c).v) {\n        hmi[s] = (hmi[s]||0)+1\n      }\n    }\n  }\n  inner.reverse()\n  outer1.reverse()\n  inner1.reverse()\n  let save = {shouldInline,needSymbol}\n  shouldInline = (s) => {\n    // must not have errors (want to print them)\n    if (errorLog[s] && errorLog[s].length > 0)\n      return null\n    // defined as an atom\n    if (symToDef[s] && (typeof(symToDef[s][2][0]) === \"number\" || symToDef[s][2][0]==\"()\"))\n      return symToDef[s]\n    // locally defined, locally used (as value) exactly once,\n    // not used in nested scopes\n    if (df[s] && hmo[s] == 1 && !hmi[s])\n      return df[s]\n  }\n  needSymbol = (s) => {\n    return hmi[s] || hmo[s] // used as value\n  }\n  // --- Check dependencies for inlined expressions ---\n  // Additional traversals to figure out which exprs\n  // can be safely inlined wrt successor dependencies.\n  //\n  // TODO: can this be optimized? (fewer traversals)\n  // TODO: some tweaks/checks will likely be necessary:\n  //       - do we deal with effect deps correctly?\n  //       - especially, what about soft deps?\n  //\n  // 1. compute local successors (fwd)\n  succ = {}\n  for (let c of outer1) {\n      let sfs = symsFreq(c)\n      let ss = [...sfs.v,...sfs.h,...sfs.s]\n      succ[c[1]] = []\n      for (let [s,f] of ss) {\n        if (df[s]) succ[s].push(c[1])\n      }\n  }\n  // 2. check if all successors are emitted after the point\n  //    considered for inlining, if not disable inlining\n  //    for this node (bwd)\n  outer1.reverse()\n  let seen = {}\n  function processNodeHere(c) {\n    seen[c[1]] = true\n    let sfs = symsFreq(c)\n    let ss = [...sfs.v].reverse() // bwd\n    for (let [s,f] of ss) {\n      if (f == 1.0) // direct\n        checkInline(s)\n    }\n  }\n  function checkInline(s) {\n    let c = shouldInline(s)\n    if (c) {\n      // Note: all local defs have succ[s] defined,\n      // but we also inline global constants. These\n      // don't have effects, so we don't need succs.\n      for (let s1 of succ[s]||[]) {\n        if (!seen[s1]) {// a successor hasn't been seen:\n          delete df[s] // disable inlining (somewhat crude)\n          return\n        }\n      }\n      processNodeHere(c)\n    }\n  }\n  //res.forEach(checkInline)\n  checkInline(res[0]) // only value result, not effects!\n  for (let c of outer1) {\n    if (!shouldInline(c[1]))\n      processNodeHere(c)\n  }\n  outer1.reverse()\n  // 3. actual codegen (fwd)\n  withScope(path, inner1, () => {\n    traverseListCompact(outer1, res)})\n  shouldInline = save.shouldInline\n  needSymbol = save.needSymbol\n}\nlet buf = []\nfunction collectOT(f) {\n  let save = buf\n  buf = []\n  nest++\n  f()\n  nest--\n  let res = buf\n  buf = save\n  return res\n}\nfunction dom2(tag, ...children) {\n  let toDom = x => x instanceof Node ? x : document.createTextNode(String(x))\n  let d = document.createElement(tag)\n  for (let e of children)\n    d.appendChild(toDom(e))\n  return d\n}\nfunction emit(s) {\n  let toDom = x => x instanceof Node ? x : document.createTextNode(String(x))\n  buf.push(toDom(s))\n}\nfunction formatNode(...e) {\n  let d = dom2(\"div\", ...e)\n  return d\n}\nfunction newline(indent) {\n  return \"\\n\"+\"\".padStart(2*(indent-1), \" \")\n}\nfunction emitLine1(...e) {\n   if (buf.length > 0) emit(newline(nest))\n   emit(dom2(\"span\",...e))\n}\nfunction formatBlockCompact(f,topLevel) {\n  let d = collectOT(f)\n  if (d.length > 1) {\n    d = topLevel ? dom2(\"span\", ...d) : dom2(\"span\", newline(nest+1), ...d, newline(nest)) // no indent on top level\n    // d.style[\"border\"] = \"1px solid lightgrey\"\n    // d.style[\"padding-left\"] = \"10px\"\n    // d.style[\"padding-right\"] = \"10px\"\n    return d\n  } else return d[0]\n}\nfunction formatSym(n) {\n  let s = n in nameHint ? nameHint[n] : \"x\"\n  let superscript = dom(n)\n  // superscript.style[\"color\"] = \"grey\"\n  superscript.style[\"vertical-align\"] = \"super\"\n  superscript.style[\"font-size\"] = \"50%\"\n  let d = dom(s,superscript)\n  d.style[\"color\"] = \"navy\"\n  registerSymRef(n,d,true)\n  return d\n}\nfunction walkSym(e) {\n  let de = shouldInline(e)\n  if (de)\n    return walkExpr2(de)\n  else\n    return formatSym(e)\n}\nfunction formatCommaList(es,f) {\n  return prettyDomCommaList(es, f)\n}\nfunction walkExpr2(c) {\n    let [_let, sym, rhs] = c\n    let [op,...args] = rhs\n    let d = []\n    if (op == \"Œª\") {\n      let [arg,res,[hdeps,sdeps],eff] = args\n      let body = formatBlockCompact(() => {\n        // emit any errors attached to argument\n        if (errorLog[arg] && errorLog[arg].length > 0) {\n          let aux = []\n          aux.push(\"// error: \")\n          for (let er of errorLog[arg]) {\n            if (aux.length > 1) aux.push(\"; \")\n            let er1 = er.map(e => typeof(e) == \"number\" ? prettyDomSym(e) : e)\n            aux.push(dom(...er1))\n          }\n          emitLine1(...aux)\n        }\n        return traverseBlockCompact([arg,sym], symsRec([res,hdeps]))\n      })\n      let fn = flags.targetSugar ? dom2(\"span\") : formatSym(sym) // do not show fun name when requesting sugared output...\n      let xn = formatSym(arg)\n      d = dom2(\"span\", fn, \"(\", xn,\")\",\" \", \"=> {\",\n      body, \"}\")\n    } else if (op == \"@\") {\n      d = dom2(\"span\", walkSym(args[0]), \"(\", formatCommaList(args.slice(1),walkSym), \")\")\n    } else if (op == \"?\") {// TODO\n      let [c,xa,ya,xb,yb] = args\n      let thenp = formatBlockCompact(() => { traverseBlockCompact([xa], [ya]) })\n      let elsep = formatBlockCompact(() => { traverseBlockCompact([xb], [yb]) })\n      d = dom2(\"span\", \"if\", \" (\", walkSym(c), \") {\", thenp, \"} else {\", elsep, \"}\")\n    } else if (args.length) {\n      d = dom2(\"span\", op, \"(\", formatCommaList(args,walkSym), \")\")\n    } else\n      d = dom2(\"span\", op)\n    //d.style[\"display\"] = \"inline-block\"\n    //d.style[\"border\"] = \"1px solid lightgrey\"\n    //d.style[\"padding\"] = \"1px\"\n    registerSymRef(sym,d,true)\n    return d\n}\nfunction prettyNodeCompact(c) {\n  let [_let, x, rhs] = c\n  // TODO: special case for functions?\n  let aux = []\n  if (errorLog[x] && errorLog[x].length > 0) {\n    aux.push(\" // error: \")\n    for (let er of errorLog[x]) {\n      if (aux.length > 1) aux.push(\"; \")\n      let er1 = er.map(e => typeof(e) == \"number\" ? prettyDomSym(e) : e)\n      aux.push(dom(...er1))\n    }\n  }\n  if (needSymbol(x)) {\n    let kw = dom(\"let\")\n    kw.style[\"color\"] = \"purple\"\n    emitLine1(kw,\" \",formatSym(x),\" \",\"=\",\" \",walkExpr2(c),...aux)\n  }\n  else\n    emitLine1(walkExpr2(c),...aux)\n}\nfunction traverseListCompact(nodes, res) {\n  for (let c of nodes) {\n    let [_let, sym, [op,...args]] = c\n    if (shouldInline(sym)) continue\n    prettyNodeCompact(c)\n  }\n  emitLine1(walkSym(res[0])) // 0 is value, rest is eff\n}\n//o.appendChild(formatBlock(() => {\n//traverseBlock1([res[1]])\n//}))\n;\n</code>\n<p>Main function and augmented editor config</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\no.appendChild(row) // basic editor (p)\nlet oo = e(\"div\",{})\no.appendChild(oo)\nfunction panel(str,d,open) {\n  let sum = e(\"summary\",{},str)\n  sum.style[\"outline\"] = \"none\"\n  let det = e(\"details\",{},sum,d)\n  det.open = open\n  oo.appendChild(det)\n}\nfunction print(...es) {\n  oo.appendChild(e(\"div\",{},...es))\n}\nfunction run(src,dst) {\n  p.style.width = \"100%\"\n  d.style.width = \"100%\"\n  onEdit = () => {\n    // reset state\n    reset()\n    // reset output\n    p.innerText = \"\"\n    d.innerText = \"\"\n    oo.innerText = \"\"\n    // prep environment\n    initEnvironment()\n    // parse & walk (=stage)\n    let cst = parse(text)\n    let ast = walk(cst)\n    p.appendChild(cst)\n    d.appendChild(ast)\n    panel(\"AST\", d)\n    res = env[\"main\"]\n    if (!res) {\n      print(\"Error: no main function found\")\n      return\n    }\n    //print(\"--- Traversal / codegen:\")\n    seq = []\n    path = new Set([])\n    inner = code\n    //XXX dep\n    if (inner.length < 100) // XXX\n      traverseBlock1(res)\n    //emitLine(prettyDomSym(res))\n    //, prettyAliases(aliases[res]), prettyDeps(state))\n    if (asides[\"Graph IR\"]) {\n      let as = asides[\"Graph IR\"]\n      as.innerText = \"\"\n      as.appendChild(e(\"pre\",{},...seq))\n    } else {\n      panel(\"Graph IR\", e(\"pre\",{},...seq))\n    }\n    //print(\"--- Compact Traversal / codegen:\")\n    seq = []\n    path = new Set([])\n    inner = code\n    let out = formatBlockCompact(() => {\n      traverseBlockCompact1([res])\n    }, true)\n    let q = e(\"pre\",{},out)\n    q.style[\"border\"] = \"1px solid grey\"\n    q.style[\"padding\"] = \"3px\"\n    panel(\"Target Code\", q, true)\n    if (dst) {\n      // some visual feedback options: ‚úÖüö´‚ùåüü¢üî¥üü©üü•\n      if (out.textContent.trim() != dst.trim()) {\n        panel(\"üî¥ Test FAILED\",e(\"pre\", {},\n          \"// ACTUAL:\\n\", out.textContent.trim(), \"\\n\",\n          \"// EXPECTED:\\n\", dst.trim()), true)\n      } else {\n        print(\"üü¢ Test passed\")\n      }\n    }\n  }\n  text = src\n  onEdit()\n}\n</code>\n</aside>\n<p>Examples / test cases:</p>\n<ul>\n<li><aside>\n<p>Basic println</p>\n<p>Effect dependencies ensure that side-effecting statements\nare not accidentally removed from the graph or reordered, even though\ntheir result values may never be used (and hence, there is no\ndependency on their result).</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(stdout: IO @track) = {\n  println(stdout,1)\n  println(stdout,2)\n  0\n}\n`,`main2(stdout3) => {\n  print(stdout3, 1)\n  print(stdout3, 2)\n  0\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Basic dce 1</p>\n<p>Pieces of mutable state that are never <em>actually</em> used, i.e.,\nthat do not contribute to any actual value computation are\nremoved.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  let d = alloc(store) // dce\n  get(d) // dce\n  get(c)\n}\n`,`main2(store3) => {get(alloc(store3))}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Basic dce 2</p>\n<p>Pieces of mutable state that are never <em>actually</em> used, i.e.,\nthat do not contribute to any actual value computation are\nremoved.</p>\n<p>This holds even for stateful variables that are modified.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  set(c, 0) // dce\n  get(c)    // dce\n  set(c, 1)\n  get(c)    // dce\n  get(c)\n}\n`,`main2(store3) => {\n  let c4 = alloc(store3)\n  set(c4, 1)\n  get(c4)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Escaping ref</p>\n<p>When a function creates a mutable variable that escapes\n(directly or indirectly via another function), the identity\nof that variable is tracked, even though it does not have\nany externally visible identifier.</p>\n<p>The mechanism to achieve this is by logically subsuming\nthe escaping variable into the function via which it\nescapes, and tracking the identity of that function\nwith a self-type (just like in DOT).</p>\n<p>(See the Graph IR pane below for detailed type assignments)</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def f0(a: Int) = {\n    let c = alloc(store)\n    def g(b: Int) = c\n    g\n  }\n  let f = delay(f0)\n  let h0 = f(0)\n  let h1 = f(1)\n  let c0 = h0(0)\n  let c1 = h0(1) // same as c0\n  let c3 = h1(0)\n  let c4 = h1(1) // same as c3\n  inc(c0)\n  inc(c1)\n  inc(c3)\n  inc(c4)\n  get(c0)\n  // expected result:\n  // - ops on c0 and c1 are serialized\n  // - c3 and c4 are never read and hence\n  //   dce'd along with all their ops\n}\n`,`main2(store3) => {\n  let f6 = f6(a7) => {\n    let c8 = alloc(store3)\n    g11(b12) => {c8}\n  }\n  let h014 = f6(0)\n  let c017 = h014(0)\n  inc(c017)\n  inc(h014(1))\n  get(c017)\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Compact codegen soft deps</p>\n<p>Soft dependencies are honored when inlining an expression.\nWithout further checks, the first read <code class=\"language-text\">r</code> would be inlined as the\nblock result, incorrectly moving it after the <code class=\"language-text\">inc(c)</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  let r = get(c) // may not move after inc\n  inc(c)\n  println(store, get(c))\n  r // tempting to inline r here\n}\n`,`main2(store3) => {\n  let c4 = alloc(store3)\n  let r5 = get(c4)\n  inc(c4)\n  print(store3, get(c4))\n  r5\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Consume effects 1</p>\n<p>Effects can be flow-sensitive, implementing a form of typestate tracking.\nA simple but important use case are ‚Äúcomsume‚Äù or ‚Äúkill‚Äù effects that\nmake a value unusable.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  inc(c)\n  println(store, get(c))\n  free(c)\n  get(c) // error\n}\n`,`main2(store3) => {\n  let c4 = alloc(store3)\n  inc(c4)\n  print(store3, get(c4))\n  free(c4)\n  let x9 = get(c4) // error: can't read dead object: c4\n  x9\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Consume effects 2</p>\n<p>Effects can be flow-sensitive, implementing a form of typestate tracking.\nA simple but important use case are ‚Äúconsume‚Äù or ‚Äúkill‚Äù effects that\nmake a value unusable.</p>\n<p>Of course this also works for user-defined functions, not just primitives.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def myfree(c: Ref(Int) @track) = {\n    free(c)\n  }\n  let c = alloc(store)\n  inc(c)\n  println(store, get(c))\n  delay(myfree)(c)\n  get(c) // error\n}\n`,`let myfree6 = myfree6(c7) => {free(c7)}\nmain2(store3) => {\n  let c9 = alloc(store3)\n  inc(c9)\n  print(store3, get(c9))\n  myfree6(c9)\n  let x14 = get(c9) // error: can't read dead object: c9\n  x14\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Extended parser / type checker</p>\n<p>Note how clicking symbols in the IR highlights program fragments in both the source and target code.</p>\n<p><del>We may want to resolve associativity earlier in the parser and re-nest the concrete syntax tree for better syntax highlighting (TODO?)</del> done</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) =t> Int =t> Int = g(x) => h(y) => x+y\n`,`main6(x7) => {h10(y11) => {+(x7, y11)}}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Expected type failure</p>\n<p>TODO:</p>\n<ul>\n<li><del>invisible output in test 2</del></li>\n<li>double error in test 1\n<ul>\n<li>checkSub: currently reporting innermost comparison on error - show outermost instead?</li>\n</ul>\n</li>\n<li>fix internal checks (base,alias,effect) (12/10 done?)</li>\n<li>fix substitution for function type  (12/10 done?)</li>\n</ul>\n<h3>Test 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) =t> Int =t> Unit = g(x) => h(y) => x+y\n`,`let main6 = main6(x7) => {\n  let h10 = h10(y11) => {\n    let x12 = +(x7, y11) // error: type check failed: Int <: Unit\n    x12\n  } // error: type check failed: Int <: Unit\n  h10\n} // error: type check failed: Int <: Unit\nmain6\n`)\n</code>\n<h3>Test 2</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) =t> Unit =t> Int = g(x) => h(y) => x+y\n`,`main6(x7) => {h10(y11) => {\n    // error: type check failed: Unit <: Int\n    +(x7, y11)\n  }}\n`)\n</code>\n<h3>Test 3</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) =t> Unit =t> Int = g(x) => h(y:Int) => x+y\n`,`let main6 = main6(x7) => {\n  let h10 = h10(y11) => {+(x7, y11)} // error: type check failed: Unit <: Int\n  h10\n} // error: type check failed: Unit <: Int\nmain6\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Effect polymorphism 1</p>\n<p>We support lightweight bounded effect polymorphism\nfor higher order functions using a special <code class=\"language-text\">@call</code>\neffect that is resolved at the call site of the\nhigher order function to the latent effect of\nits argument.</p>\n<p>TODO:</p>\n<ul>\n<li><del>use latent function effect in app</del></li>\n<li><del>subtype checking for self types (via aliasing)</del></li>\n<li><del>record effects explicitly in reflect0</del></li>\n<li><del>track and resolve latent self effect</del></li>\n<li>parse <code class=\"language-text\">@call</code> qualifier</li>\n</ul>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  // rwk is an abbreviation for read, write, kill\n  // result type: Int @call(f)\n  def gen(f: (f(x:Int) =t> Int @rwk(f)) @track) = {\n    f(1)\n  }\n  def g(x: Int) = {\n    println(store, x)\n    x\n  }\n  let res = delay(gen)(g) // effect: @call(g), doesn't really kill g or store!\n  println(store,1)\n}\n`,`let gen8 = gen8(f9) => {f9(1)}\nmain2(store3) => {\n  gen8(g14(x15) => {\n    print(store3, x15)\n    x15\n  })\n  print(store3, 1)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited continuation</p>\n<p>TODO/FIXME:</p>\n<ul>\n<li><del>parse function type and type check</del></li>\n<li><del>parse lambda expr and type check bidirectionally with expected type</del></li>\n<li><del>parse and check effect annotations</del></li>\n<li><del>close type and do self type comparison</del></li>\n</ul>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def gen(f: (f(Int) =t> Int @rw(f)) @track) = {\n    f(1) + f(2)\n  }\n  def g(x: Int) = {\n     println(store, x)\n     x // could do 2*x\n  }\n  let res = delay(gen)(g)\n  println(store,res)\n}\n`,`let gen8 = gen8(f9) => {+(f9(1), f9(2))}\nmain2(store3) => {print(store3, gen8(g17(x18) => {\n    print(store3, x18)\n    x18\n  }))}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited one-shot continuation 1</p>\n<p>Negative case 1</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(Int) =t> Int @rw(f)) @track) = {\n    f(1) + f(2)\n  }\n  def g(x: Int) = {\n     println(store, x)\n     free(c)\n     x\n  }\n  println(store,delay(gen)(g)) // error: type mismatch of g\n}\n`,`let gen9 = gen9(f10) => {+(f10(1), f10(2))}\nmain2(store3) => {\n  let c4 = alloc(store3)\n  let g18 = g18(x19) => {\n    print(store3, x19)\n    free(c4)\n    x19\n  } // error: kill qualifier check failed: [4] <: none\n  print(store3, gen9(g18))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited one-shot continuation 2</p>\n<p>Negative case 2</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(x:Int) =t> Int @rwk(f)) @track) = {\n    f(1) + f(2)  // error: f already killed\n  }\n  def g(x: Int) = {\n     println(store, x)\n     free(c)\n     x\n  }\n  println(store,delay(gen)(g))\n}\n`,`let gen9 = gen9(f10) => {\n  let x12 = f10(1)\n  let x14 = f10(2) // error: can't read dead object: f10; can't write dead object: f10\n  +(x12, x14)\n}\nmain2(store3) => {\n  let c4 = alloc(store3)\n  print(store3, gen9(g18(x19) => {\n    print(store3, x19)\n    free(c4)\n    x19\n  }))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited one-shot continuation 3</p>\n<p>Positive case. Relies on effect polymorphism.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(x:Int) =t> Int @rwk(f)) @track) = {\n    f(1)\n  }\n  def g(x: Int) = {\n    println(store, x)\n    free(c)\n    x\n  }\n  println(store,delay(gen)(g))\n}\n`,`let gen9 = gen9(f10) => {f10(1)}\nmain2(store3) => {\n  let c4 = alloc(store3)\n  print(store3, gen9(g15(x16) => {\n    print(store3, x16)\n    free(c4)\n    x16\n  }))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Parser/typer errors</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\n(d: Int) => 2\ndef main(world: IO @track) = { ((d: Int) => d) }\ndef main(world: IO @track) = { (d: Int) => d }\ndef main(world: IO @track) = { (x:Int => 9) }\ndef main(world: IO @track) = { x:Int => 9 }\ndef main(world: IO @track) = (x:Int => 9)\ndef main(world: IO @track) = x:Int => 9\ndef main(world: IO @track) = x => 9\ndef main(world: IO @track) = x:Int => x\ndef main(world: IO @track) = x => x\ndef main(world: IO @track) = ((d: Int) => d)\ndef main(world: IO @track) = ((d: Int) => 9)\ndef main(world: IO @track) = (d) => d\ndef main(world: IO @track) = (d) => 9\ndef main(world: IO @track) = () => 9\ndef main(world: IO @track) = (d: Int) => 2\n`,`let fun89 = fun89(d90) => {2}\nmain85(world86) => {fun89}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Parse error</p>\n<p><del>Deleting the closing brace below will cause the two comments to be duplicated at the bottom:</del> fixed</p>\n<p>Do note that the syntax highlighting of the trailing comment is off!</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  0\n  // long and tedious comment 1\n  // long and tedious comment 2\n}\n// try deleting the closing brace above\n`,`main2(world3) => {0}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Effect deps of escaping lambda</p>\n<p>This is a variant of the counter example that initializes\ncounters to a given value.</p>\n<p><del>There is a bug right now that drops the initial write\nwhen returning a lambda.</del></p>\n<p>Fixed now. The root cause was that effect deps weren‚Äôt\ncounted for escaping values ‚Äî only for outer values\n(function itself, argument, anything from enclosing scope).\nSee second test case.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def counter0(i: Int) = {\n    let c = alloc(world)\n    set(c,i) // <--- error: shouldn't remove this\n    () => inc(c)\n  }\n  let counter = delay(counter0)\n  let inc1 = counter(0)\n  let inc2 = counter(10)\n  inc1()\n  inc1()\n  inc2()\n  inc2()\n  // uncomment the following lines one by one\n  // and watch the target code change:\n  inc2()\n  // inc1()\n  // inc1() + inc2()\n  // 0\n}\n`,`main2(world3) => {\n  let counter6 = counter6(i7) => {\n    let c8 = alloc(world3)\n    set(c8, i7)\n    fun12(arg13) => {inc(c8)}\n  }\n  let inc218 = counter6(10)\n  inc218(())\n  inc218(())\n  inc218(())\n}\n`)\n</code>\n<p>Second, minimized, test case:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  set(c,2) // <--- error: shouldn't remove this\n  c\n}\n`,`\nmain2(world3) => {\n  let c4 = alloc(world3)\n  set(c4, 2)\n  c4\n}\n`)\n</code>\n</aside></li>\n</ul>\n<p>Limitations / noteworthy behavior:</p>\n<ul>\n<li><aside>\n<p>DCE of Free (the case for soft effects)?</p>\n<p><strong>Case 1:</strong> free is subject to DCE like other nodes, based on\nsoft dependencies, and since there‚Äôs no good reason to\ndepend on the <em>result</em> of a free it can be expected that\n<em>most</em> frees will be DCE‚Äôd in practice.</p>\n<p>This is consistent, but may look undesirable! Is there a\nway to keep the free (or any kill op) if it‚Äôs determined\nthat the alloc needs to stay?</p>\n<p>In general this seems tough, unless we start thinking about\nmust-kill effects (we had those in early LMS versions) and demand\nthat everything that‚Äôs allocated\nis also deallocated.</p>\n<p>But more generally it seems we may want think about deallocation\ndifferently. We know when a tracked symbol goes out of scope:\nwhen it‚Äôs not aliased by the enclosing block‚Äôs return type. So\nat this point we could deallocate it automatically.</p>\n<p>Of course we might still want to deallocate it earlier using\nan explicit free. In that case we‚Äôre still out of luck without\nfurther refinements.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  let res = get(c)\n  free(c)\n  res\n}\n`,`main2(world3) => {\n  let c4 = alloc(world3)\n  get(c4)\n}\n`)\n</code>\n<p><strong>Case 2:</strong> however, the free (or any other effect, really)\nisn‚Äôt removed when it‚Äôs inside another function.</p>\n<p>This definitely looks like a missed optimization opportunity!</p>\n<p>We should investigate a notion of soft effects. Similar to\nsoft dependencies, these would be dropped if the affected\nobject is not required elsewhere.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  let myfree = () => { free(c); 7 }\n  delay(myfree)()\n}\n`,`main2(world3) => {\n  let c4 = alloc(world3)\n  myfree7(arg8) => {\n    free(c4)\n    7\n  }(())\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Capturing/returning dead variables</p>\n<p>Let‚Äôs reflect on how we track liveness - which things have\nbeen killed and which have not.</p>\n<p>Right now, we identify a dead variable by looking at prior effectful\nstatements in the current scope and checking if any of them had a kill\neffect that touched the variable in question.</p>\n<p>In other words, we do not track the liveness state of variables in\ntheir types. We only track kill effects in the types of computations.</p>\n<p>This raises a couple of questions. Importantly, what happens with\nindirect references to killed variables when:</p>\n<ul>\n<li>returning a killed variable</li>\n<li>closing over a killed variable</li>\n<li>(passing a killed variable as argument)</li>\n</ul>\n<p>We consider a number of cases below that all work out in the right\nway (in the return case, after tightening the rules).</p>\n<p>Questions:</p>\n<ul>\n<li>Are there other situations that may cause problems?\n<ul>\n<li>Specifically, related to closing over a dead var?</li>\n</ul>\n</li>\n<li>Potential alternative: track ‚Äúis dead‚Äù (and potentially ‚Äúis killable‚Äù) as part of the type. This would track status of return values and closures explicitly.\n<ul>\n<li>What are the tradeoffs?</li>\n</ul>\n</li>\n</ul>\n<p><strong>Case 1: returning dead variable (checked now)</strong></p>\n<p>This actually lead to escaping dead values, but was easy to fix.</p>\n<p>We now prevent returning anything that aliases a dead value from functions.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def f() = {\n    let c = alloc(world)\n    free(c)\n    c\n  }\n  let dead = delay(f)()\n  get(dead) // should be an error!\n}\n`,`main2(world3) => {get(f6(?7) => {\n    let c8 = alloc(world3) // error: cannot return dead object: c8\n    free(c8)\n    c8\n  }(()))}\n`)\n</code>\n<p><strong>Case 2: passing dead variable as argument (checked)</strong></p>\n<p>Effect on arg becomes part of the function type => error when calling it.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  free(c)\n  def f(c: Ref(Int) @track) = {\n    get(c)\n  }\n  delay(f)(c)\n}\n`,`let f8 = f8(c9) => {get(c9)}\nmain2(world3) => {\n  let c4 = alloc(world3)\n  free(c4)\n  let x11 = f8(c4) // error: can't read dead object: c4\n  x11\n}\n`)\n</code>\n<p><strong>Case 3: closing over dead variable (checked)</strong></p>\n<p>Effect on free var becomes part of the function type => error when calling it.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  free(c)\n  def f() = {\n    get(c)\n  }\n  delay(f)()\n}\n`,`main2(world3) => {\n  let c4 = alloc(world3)\n  free(c4)\n  let x12 = f8(?9) => {get(c4)}(()) // error: can't read dead object: c4\n  x12\n}\n`)\n</code>\n<p><strong>Case 4: return fun that closes over dead var (checked now)</strong></p>\n<p>This is similar to case 1, but with an added level of indirection\nthrough a closure.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def g() = {\n    let c = alloc(world)\n    free(c)\n    def f() = {\n      get(c)\n    }\n  }\n  let f = delay(g)()\n  f()\n}\n`,`main2(world3) => {g6(?7) => {\n    let c8 = alloc(world3)\n    free(c8)\n    let f12 = f12(?13) => {get(c8)} // error: cannot return dead object: c8\n    f12\n  }(())(())}\n`)\n</code>\n</aside></li>\n</ul>\n<p>Currently failing / to be done:</p>\n<ul>\n<li> none right now...\n</li>\n</ul>\n</aside>\n<aside>\n<p>NEW Test cases</p>\n<h3>Polymorphic identity (type -> val function)</h3>\n<p>Standard System F generic type. Test substitution in result of function application.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet pid = (T:Type) => (x:T) => x\nlet main = (world: IO) => pid(Int)(0)\n`)\n</code>\n<h3>Type identity (type -> type function)</h3>\n<p>Higher-kinded type, System Fœâ. Test reduction of application in type comparison.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet id = (T:Type) => T\nlet foo = (n:id(Int)) => n\nlet main = (world: IO) => {\n  foo(7)\n}`)\n</code>\n<h3>Basic Church numerals</h3>\n<p>Test comparison of types modulo alpha equivalence: N1 =t> N1 with N2 =t> N2.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet N = const(Type)\nlet z = const(N)\nlet s = const(N =t> N)\nlet three = (N:Type) => (z:N) => (s:N =t> N) => s(s(s(z)))\nlet th = three(N)(z)(s)\nlet main = (world: IO) => th\n`)\n</code>\n<h3>Church numerals with addition and type abstraction</h3>\n<p><del>Note that the term result is not automatically normalized.</del> now it is</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\n//\nlet ChurchT = (N:Type) =t> (z:N) =t> (s:N =t> N) =t> N\nlet three = (N:Type) => (z:N) => (s:N =t> N) => s(s(s(z)))\n//\nlet id = (a: ChurchT) => (N:Type) => (z:N) => (s:N =t> N) => {\n  a(N)(z)(s)\n}\n//\nlet plus = (a: ChurchT) => (b: ChurchT) =>\n  (N:Type) => (z:N) => (s:N =t> N) => a(N)(b(N)(z)(s))(s)\nlet main = (world: IO) => plus(three)(three)\n`)\n</code>\n<p>Alternative</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet CNat = (N:Type) =t> (z:N) =t> (s:N =t> N) =t> N\nlet CZero = (N:Type) => (z:N) => (s:N =t> N) => z\nlet CSucc = (a: CNat) => (N:Type) => (z:N) => (s:N =t> N) => s(a(N)(z)(s))\nlet three = CSucc(CSucc(CSucc(CZero)))\nlet plus = (a: CNat) => (b: CNat) => a(CNat)(b)(CSucc)\nlet main = (world: IO) => plus(three)(three)\n`)\n</code>\n<h3>Basic Pair encoding</h3>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet pair = (A:Type) => (B:Type) => (a:A) => (b:B) =>\n    (R:Type) => (f: (A =t> B =t> R)) => f(a)(b)\nlet main = (world: IO) => {\nlet p = pair(Int)(Int)(2)(3)\nlet a = p(Int)(a => b => a)\nlet b = p(Int)(a => b => b)\na+b\n}\n`)\n</code>\n<h3>Pair encoding with type abstraction</h3>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet Pair = (A:Type) => (B:Type) => (R:Type) =t> ((A =t> B =t> R)) =t> R\nlet pair = (A:Type) => (B:Type) => (a:A) => (b:B) =>\n    (R:Type) => (f: (A =t> B =t> R)) => f(a)(b)\nlet fst = (A:Type) => (B:Type) => (p:Pair(A)(B)) => p(A)(a => b => a)\nlet snd = (A:Type) => (B:Type) => (p:Pair(A)(B)) => p(B)(a => b => b)\nlet main = (world: IO) => {\nlet p = pair(Int)(Int)(2)(3)\nlet a = fst(Int)(Int)(p)\nlet b = snd(Int)(Int)(p)\na+b\n}\n`)\n</code>\n<h3>Impredicativity for higher-kinded types</h3>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet id = (T:Type) => T\nlet Vec = (TC:Type =t> Type) =t> TC(Int)\n// things that aren't well typed (consistent with Coq):\n// - Vec(Int)\n// - (TC:Type =t> Type) =t> TC(Int)\nlet main = (world: IO) => 8\n`)\n</code>\n<h3>List Encoding</h3>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet List = (B:Type) =>\n    (TW:Type) =t>\n    (nil: TW) =t>\n    (const: B =t> TW =t> TW) =t>\n    TW\nlet nil = (B:Type) =>\n    (TC:Type) =>\n    (nil: TC) =>\n    (cons: B =t> TC =t> TC) =>\n    nil\nlet cons = (B:Type) => (x:B) => (xs:List(B)) =>\n    (TC:Type) =>\n    (nil: TC) =>\n    (cons: B =t> TC =t> TC) =>\n    cons(x)(xs(TC)(nil)(cons))\nlet append = (T:Type) => (a: List(T)) => (b: List(T)) =>\n    a(List(T))(b)(cons(T))\nlet main = (world: IO) => {\n  let n = nil(Int)\n  let a = cons(Int)(10)(n)\n  let b = cons(Int)(20)(a)\n  append(Int)(b)(b)\n}`)\nfunction rec(e,n) {\n  if (n) {\n  if (e instanceof Array) return e.map(x => rec(x,n))\n  if (symToDef[e]) return rec(symToDef[e][2],n-1)\n  }\n  if (nameHint[e])\n    return prettySym(e)\n  else\n    return e\n}\nfunction pp(e,n) {\nprint(prettySym(e),\":\",prettySym(symToTpe[e]),\"=\",JSON.stringify(rec(e,n)))\n}\n</code>\n<h3>Encoding length-indexed lists</h3>\n<p>Test hash consing for CSE (equivalence of x133=TC(z) and 158=TC(z)) as well as unifying argument symbols when subtyping functions (TC(k1a) == TC(k1b))</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nflags.reportMinEligibleWarnings = false // some unrelated logic not implemented\nrun(`// source program\n// source program\nlet Nat = (T:Type) =t> (z:T) =t> (s:T =t> T) =t> T\nlet z = (T:Type) => (z:T) => (s:T =t> T) => z\nlet s = (x:Nat) =>\n  (T:Type) => (z:T) => (s:T =t> T) =>\n  s(x(T)(z)(s))\nlet plus = (a:Nat) => (b:Nat) =>\n  a(Nat)(b)(s)\nlet Vec = (T:Type) => (k:Nat) =>\n  (TC:Nat =t> Type) =t>\n  (nil: TC(z)) =t>\n  (cons: (k1: Nat) =t> (hd: T) =t> (tl: TC(k1)) =t> TC(s(k1))) =t>\n  TC(k)\nlet nil = (T:Type) =>\n  (TC:Nat =t> Type) =>\n  (nil: TC(z)) =>\n  (cons: (k1: Nat) =t> (hd: T) =t> (tl: TC(k1)) =t> TC(s(k1))) =>\n  nil\nlet cons = (T:Type) => (k:Nat) => (hd: T) => (tl: Vec(T)(k)) =>\n  (TC:Nat =t> Type) =>\n  (nil: TC(z)) =>\n  (cons: (k1: Nat) =t> (hd: T) =t> (tl: TC(k1)) =t> TC(s(k1))) =>\n  cons(k)(hd)(tl(TC)(nil)(cons))\nlet append = (T:Type) => (k:Nat) => (l:Nat) => (a: Vec(T)(k)) => (b: Vec(T)(l)) =>\n  a(j=>Vec(T)(plus(j)(l)))(b)(m=>cons(T)(plus(m)(l)))\nlet main = (world: IO) => {\n  let three = s(s(s(z)))\n  let six = plus(three)(three)\n  let a = nil(Int)\n  // let a2 = id(Int)(s(z))(a) // error! (expected: wrong size)\n  //let a2 = id(Int)(z)(a)\n  let b = cons(Int)(z)(10)(a)\n  let c = cons(Int)(s(z))(20)(b)\n  let d = cons(Int)(s(s(z)))(30)(c)\n  append(Int)(three)(three)(d)(d)\n}\n`)\n</code>\n</aside>\n<aside>\n<p>Technical TODOs</p>\n<ul>\n<li>examples\n<ul>\n<li><del>length-indexed lists</del></li>\n<li><del>staging, i.e., selectively delay normalization</del></li>\n</ul>\n</li>\n<li>interactivity\n<ul>\n<li><del>basic interactive error messages</del></li>\n<li>graph view: fix nesting and/or expand on demand\n<ul>\n<li>need to interrupt &#x26; resume traversal</li>\n<li>using same var in type/term means subterms are pushed into type scope (arg is bound there)</li>\n</ul>\n</li>\n<li>browse type comparisons\n<ul>\n<li>need to interrupt &#x26; resume</li>\n</ul>\n</li>\n<li>browse normalization (back &#x26; forth, inline &#x26; expand)</li>\n</ul>\n</li>\n<li>normalization, type comparison\n<ul>\n<li><del>deep subtype comparison</del></li>\n<li><del>explicit normalization in checkSub</del></li>\n<li><del>eager normalization as rewrite in reflect</del></li>\n<li>alpha normalization for functions and fun types\n<ul>\n<li>want to see need first, or just aim to reduce graph size?</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>provenance\n<ul>\n<li>link nodes across (beta) normalization</li>\n<li>link nodes across substitution</li>\n</ul>\n</li>\n<li>features\n<ul>\n<li>recursion</li>\n<li>implicits, inference, holes</li>\n<li><del>bring back aliasing &#x26; effects</del>\n<ul>\n<li>Q: type abstraction is too generic! need type bounds?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Misc</p>\n<p>Front-end</p>\n<ul>\n<li>update expected code for old test cases</li>\n<li>actually check results in new test cases (note: generated code is more meaningful now with normalization)</li>\n</ul>\n<p>Internals</p>\n<ul>\n<li>type/kind check in ‚Äúconstant‚Äù, ‚Äúhole‚Äù (notion of AnyKind?)</li>\n<li>some issues with literal strings (instead of syms) in def (e.g. effect ‚Äúread‚Äù, ‚Äúwrite‚Äù, etc., fix: structured operator or auxiliary static info)</li>\n<li>need to extend minEligible: multiple levels, other type constrs (variance?)</li>\n</ul>\n<p>UX</p>\n<ul>\n<li>codegen: compact codegen not compact enough (?) some tests have an extra let</li>\n<li>graph view: expand on demand?</li>\n<li>browse type comparisons?</li>\n</ul>\n<p>Fixed</p>\n<ul>\n<li><del>nameHints for funtype</del></li>\n<li><del>correct arg type in funtype? Weirdness!</del></li>\n<li><del>Basic DCE 2: CSE hash cons for get(x) is too aggressive</del></li>\n<li><del>Ref type unknown</del></li>\n<li><del>add lift construct</del></li>\n<li><del>basic effect types</del></li>\n<li><del>minEligible (basics done, had to add ff as bound sym in =t>)</del></li>\n<li><del>subtyping for track/effect (see ‚Äúdelimited continuation‚Äù test)</del></li>\n<li><del>lightweight effect polymorphism, <code class=\"language-text\">call</code> effects (see ‚Äúeffect polymorphism‚Äù test)</del></li>\n</ul>\n</aside>\n<p>Polymorphism test cases</p>\n<aside>\n<p>Parametric polymorphism</p>\n<p>Dependent types subsume regular ‚Äúgenerics‚Äù, i.e., parametric types. Not surprisingly, there are a couple of problems when combining generics with reachability types and effects.</p>\n<p><strong>Update:</strong> these problems have been fixed by changing ‚ÄúT @track : Type : Kind‚Äù to ‚ÄúT @track : QualType : QualKind‚Äù. Abstracting over types of ‚ÄúQualKind‚Äù (including ‚ÄúQualType‚Äù) is disallowed, and a parameter of type ‚ÄúType‚Äù cannot be instantiated with a ‚ÄúQualType‚Äù term such as ‚ÄúT @track‚Äù. (To observe the errors below again add ‚Äúlet QualType = Type‚Äù at the beginning of the snippet)</p>\n<p><strong>Update:</strong> it may still be useful to allow parametric effect/reachabibility abstraction (in addition to lightweight techniques). We should investigate a bounded abstraction facility for that. Upper bounds should be required because we do not want to have the equivalent of a ‚Äútop‚Äù effect or alias (which would mean ‚Äúany possible effect‚Äù or ‚Äúaliases with anything‚Äù, rendering any optimization impossible).</p>\n<h3>Problem 1: instantiating pure with effectful</h3>\n<p>Instantiating a type parameter with an effectful type causes trouble:</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet unsafe = (A:Type) => (f:(Int =t> A)@track) => {\n  f(1); f(2); f(3) // error: f is not known to have effects,\n                   // hence, no dependencies are tracked\n                   // (result here: first two calls are DCEd)\n}\nlet main = (world: IO @track) => {\n  let x = alloc(world,1)\n  let t = Int @rw(x)\n  let f = (n:Int) => inc(x)\n  delay(unsafe)(t)(f)\n  get(x)\n}\n`)\n</code>\n<p>Here, we cause incorrect dependencies (and in turn, optimizations) due to the absence of effect information in the generic code path.</p>\n<p>Note that the instantiation looks safe at the call site in main; the problem is that ‚Äúunsafe‚Äù assumes purity for optimization.</p>\n<p>Potential fix: allow instantiation of type parameters only with pure types. Require bounded abstraction for effects and other qualifiers.</p>\n<p>Another potential fix: decouple latent effect from function result type.</p>\n<p>(Glitch: wrong type when inlining f in argument position.)</p>\n<h3>Problem 2: instantiating untracked with tracked</h3>\n<p>Likewise, instantiating a type parameter with a tracked type also causes trouble:</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet unsafe = (A:Type) => (x:A) => () => x\nlet main = (world: IO @track) => {\n  let x = alloc(world,1)\n  let f = delay(unsafe)(Ref(Int)@track)(x)\n  // error: type of f is untracked, even though\n  // it captures x!\n  let y = f() // error: not aliased with x!\n  inc(x)      // DCEd...\n  inc(x)      // DCEd...\n  inc(x)      // DCEd...\n  get(y)\n}\n`)\n</code>\n<p>Here, we create a function that captures a mutable ref but remains untracked. Furthermore, the function returns the captured ref while making it look like a freshly allocated one!</p>\n<h3>Research merit</h3>\n<p>Integrate reachability types with type systems that support generics (go beyond STLC).</p>\n</aside>\n<aside>\n<p>Lightweight reachability polymorphism</p>\n<p>It is desirable to support implicit forms of polymorphism (beyond simple subtyping) without explicit type abstraction.</p>\n<h3>Abstracting over argument aliases</h3>\n<p>The handling of reachability types in function application already provides a flavor of that:</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet f: (x: Ref(Int) @track) =t> Ref(Int) @track(x) = x => x\nlet main = (world: IO @track) => {\n  let c = alloc(world,1)\n  let c1 = delay(f)(c) // result type: Ref(Int) @track(c1,c)\n                       // thanks to dependent application\n  get(c1)\n}\n`)\n</code>\n<p>Function application performs substitution of actual reachability for declared reachability. Hence, we get polymorphism wrt. reachability of the argument.</p>\n<h3>Abstract over untracked vs tracked?</h3>\n<p>It would be highly desirable to use the same mechanism to abstract over tracked vs untracked arguments, too. Let‚Äôs use the identity function to illustrate:</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet f: (x: Int @track) =t> Int @track(x) = x => x\nlet main = (world: IO @track) => {\n  let x = 7\n  let y = delay(f)(x) // result type: Int @track(y,x)\n                      // would prefer Int!\n  y\n}\n`)\n</code>\n<p>It‚Äôs of course a bit silly to use Ints here, but we can easily imagine using functions or other compound types instead. In any case, we want one function that seemlessly supports both tracked and untracked values of the same type as argument, without turning one into the other.</p>\n<p>A key practical example is dealing with data structures, i.e., mapping over a list that could contain tracked or untracked elements.</p>\n<p>Problem: unfortunately this isn‚Äôt safe in the current model (see below), and hence the prototyp prohobits it.</p>\n<h3>Problem 3: instantiating tracked with untracked</h3>\n<p>There is a potential problem with this pattern that could allow creating an untracked Ref.</p>\n<p>Right now the implementation prevents this pattern, so the following (faulty) snippet doesn‚Äôt compile.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\n// gist:\n//   def unsafe(x: Int @track): Ref(Int) @track(x) = alloc(world,1)\n//   let y = unsafe(7) // untracked Ref?\nlet unsafe2 = (x: Ref(Int)) => { 7 }\nlet main = (world: IO @track) => {\n  let t = f(x:Int @track) =t> Ref(Int) @track(x) @rw(f)\n  let unsafe = (f:t @track) => f(7)\n  let f = (n:Int @track) => alloc(world,n)\n  let y = delay(unsafe)(f)\n  delay(unsafe2)(y)\n}\n`)\n</code>\n<p>Can we prevent the problem cases while enabling the safe ones?</p>\n<p>Solution idea: decouple privilege levels (tracked = 2nd class vs untracked = 1st class) from reachability. Type qualifiers would specify both a minimum privilege and a reachable set. This should enable a distinction akin to ‚Äúmay-tracked‚Äù (i.e., tracked-if-any-reachable-var-is-tracked) vs ‚Äúmust-tracked‚Äù.</p>\n<p>Vey close, in fact, to combining the OOPSLA‚Äô16 model with reachability types.</p>\n<h3>Research merit</h3>\n<p>Avoid duplication of code paths for tracked and untracked values, especially data structures.</p>\n</aside>\n<aside>\n<p>Lightweight effect polymorphism</p>\n<h3>Call effects</h3>\n<p>We support lightweight bounded effect polymorphism\nfor higher order functions using a special <code class=\"language-text\">@call</code>\neffect that is resolved at the call site of the\nhigher order function to the latent effect of\nits argument.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = true // <-- flag!\nrun(`// source program\ndef main(store: IO @track) = {\n  // rwk is an abbreviation for read, write, kill\n  // result type: Int @call(f)\n  def gen(f: (f(x:Int) =t> Int @rwk(f)) @track) = {\n    f(1)\n  }\n  def g(x: Int) = {\n    println(store, x)\n    x\n  }\n  let res = delay(gen)(g) // effect: @call(g), doesn't really kill g or store!\n  println(store,1)\n}\n`)\n</code>\n<h3>Problems?</h3>\n<p>None currently known, but need to investigate relation to issues identified with lightweight reachability polymorphism.</p>\n<h3>Research merit</h3>\n<p>This seems like a very useful general pattern for quantale-based effect systems (has it been studied? to a degree: see Lukas Rytz‚Äô PhD thesis, chapter on relative effects)</p>\n</aside></li>\n<h3>Example</h3>\n<p>Challenge: find some problems related to  reachability/effects and type abstraction. Can you make a tracked value escape?</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nflags.callEffect = false\nrun(`// source program\nlet id1 = (A:Type)=>(x:A) => x\nlet id2 = (y:Ref(Int)) => y\nlet id3 = (y:Ref(Int)@track) => y\nlet main = (world: IO @track) => {\n  let a = id1(Ref(Int))(alloc(world,1)) // error (expected)\n  let b = id1(Ref(Int)@track)(alloc(world,1))\n  let c = id2(alloc(world,1)) // error (expected)\n  let d = id3(alloc(world,1))\n  0\n}\n`)\n</code>","fields":{"slug":"/Public/Generic/graph-ir-dependent/"},"frontmatter":{"date":"2021-03-06","title":"Graph IR + Dependent Types","description":null,"keywords":null,"tags":null}}},{"node":{"excerpt":"It‚Äôs easy to animate properties of individual DOM nodes\nusing CSS transitions (fade, change color, size, etc). But\nwhat if we want to‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>It‚Äôs easy to animate properties of individual DOM nodes\nusing CSS transitions (fade, change color, size, etc). But\nwhat if we want to animate changes to the <em>structure</em> of\na DOM tree, like inserting, deleting, or reordering nodes?\nUnfortunately, that‚Äôs not supported by standard CSS transitions.</p>\n<p>More work is necessary if our goal is to visually morph one\nDOM tree into another, with smooth interpolation.\nLet‚Äôs see where this idea takes us!</p>\n<aside>\n<p>Basic DOM Animation</p>\n<p>Core DOM utils</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k)) {\n      dom.addEventListener(eventName(k), props[k])\n    } else if (k == \"style\") { // special case for style ...\n       for (let j in props[k])\n         dom[k][j] = props[k][j]\n    } else\n      dom[k] = props[k]\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nlet e = createElement\nfunction dom(...es) {\n  return e(\"span\",{},...es)\n}\n</code>\n<h3>Basic DOM Manipulation</h3>\n<p>Here‚Äôs a basic DOM interaction experiment. Click a box to create\na new one left to it. Shift-click to delete a box.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet count = 0\nfunction Box() {\n  let s = \"Box \"+count++\n  function onClick(ev) {\n    let e = ev.target\n    if (ev.shiftKey) {\n      e.parentElement.removeChild(e)\n    } else {\n      e.parentElement.insertBefore(Box(),e)\n    }\n  }\n  let p = e(\"span\",{onMouseDown:onClick},s)\n  p.style[\"padding\"] = \"10px\"\n  p.style[\"margin\"] = \"5px\"\n  p.style[\"display\"] = \"inline-block\"\n  p.style[\"border\"] = \"3px solid black\"\n  p.style[\"border-radius\"] = \"15px\"\n  p.style[\"cursor\"] = \"pointer\"\n  return p\n}\nlet p = e(\"div\",{})\np.style[\"-webkit-user-select\"] = \"none\"\nfor (let i = 0; i < 10; i++)\n  p.appendChild(Box())\no.appendChild(p)\n</code>\n<p>It‚Äôs pretty confusing to follow what‚Äôs going on as there aren‚Äôt any visual clues besides the numbers changing. Wouldn‚Äôt it be great if we could add some visual feedback?</p>\n<h3>Animate Movement</h3>\n<p>Let‚Äôs animate it! First the individual movements.</p>\n<p>The technique we use is sometimes called FLIP:\nfirst, last, invert, play.\nThe basic idea is to record the absolute positions of\nall elements, then apply the desired DOM changes,\nget the new positions, and animate a transition from\nold to new using the <code class=\"language-text\">transform: translate(x,y)</code> CSS\nproperty.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction savePos(e) {\n  e.savedRect = e.getBoundingClientRect()\n}\nfunction animateMove(e) {\n  if (!e.savedRect) return // fresh element\n  let b0 = e.savedRect\n  let b1 = e.getBoundingClientRect()\n  // animate from old pos to new one\n  // (could also do this for size, etc)\n  let dx = b0.x - b1.x\n  let dy = b0.y - b1.y\n  e.animate({\n    transform: ['translate('+dx+'px,'+dy+'px)', 'none'],\n  }, {\n    easing: 'ease',\n    duration: 500,\n  })\n}\nfunction onClick(ev) {\n  let e = ev.target\n  let p = e.parentElement\n  for (let c of p.children) savePos(c)\n  if (ev.shiftKey) {\n    p.removeChild(e)\n  } else {\n    p.insertBefore(Box(),e)\n  }\n  for (let c of p.children) animateMove(c)\n}\nlet count = 0\nfunction Box() {\n  let s = \"Box \"+count++\n  let p = e(\"span\",{onMouseDown:onClick},s)\n  p.style[\"padding\"] = \"10px\"\n  p.style[\"margin\"] = \"5px\"\n  p.style[\"display\"] = \"inline-block\"\n  p.style[\"border\"] = \"3px solid black\"\n  p.style[\"border-radius\"] = \"15px\"\n  p.style[\"cursor\"] = \"pointer\"\n  return p\n}\nlet p = e(\"div\",{})\np.style[\"-webkit-user-select\"] = \"none\"\nfor (let i = 0; i < 10; i++)\n  p.appendChild(Box())\no.appendChild(p)\n</code>\n<p>That‚Äôs better! now we see how and where elements move.\nHowever, we still don‚Äôt have a lot of visual clues about\nhow elements are added and removed.</p>\n<h3>Animate Enter and Exit</h3>\n<p>Now let‚Äôs animate enter and exit, i.e., insertion and\ndeletion of elements. Enter is easy: we add the\nelement and then fade &#x26; scale it in.</p>\n<p>Exit is more complicated: we can‚Äôt remove the element right\naway since we want to fade it out, but we need it gone from\nthe layout so that the <em>other</em> elements move!</p>\n<p>We solve this as follows: set the element style to\n<code class=\"language-text\">position: absolute</code> which will remove it from the layout\nflow, and at the same time visually move it back to its\nold position using <code class=\"language-text\">transform: translate(x,y)</code>. Then\nwe animate it and schedule removal from the DOM tree\nonce the animation finishes.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction savePos(e) {\n  e.savedRect = e.getBoundingClientRect()\n}\nfunction animateMove(e) {\n  let b0 = e.savedRect\n  let b1 = e.getBoundingClientRect()\n  // animate from old pos to new one\n  // (could also do this for size, etc)\n  let dx = b0.x - b1.x\n  let dy = b0.y - b1.y\n  e.animate({\n    transform: ['translate('+dx+'px,'+dy+'px)', 'none'],\n  }, {\n    easing: 'ease',\n    duration: 500,\n  })\n}\nfunction animateEnter(e) {\n  e.animate({\n    transform: ['scale(0)', 'none'],\n    opacity: ['0%', '100%'],\n  }, {\n    easing: 'ease',\n    duration: 500,\n  })\n}\nfunction animateExit(e) {\n  let b0 = e.savedRect\n  // switch to absolute position\n  e.style.position = \"absolute\"\n  e.style.left = \"0px\"\n  e.style.top = \"0px\"\n  e.style.width = b0.width + \"px\"\n  e.style.height = b0.height + \"px\"\n  // visually move to old pos & animate there\n  let b1 = e.getBoundingClientRect()\n  let dx = b0.x - b1.x\n  let dy = b0.y - b1.y\n  return e.animate({\n    transform: ['translate('+dx+'px,'+dy+'px) scale(1.0)',\n                'translate('+dx+'px,'+dy+'px) scale(0)'],\n    opacity: ['100%', '0%'],\n  }, {\n    easing: 'ease',\n    duration: 500,\n  })\n}\nfunction onClick(ev) {\n  let e = ev.target\n  let p = e.parentElement\n  for (let c of p.children) savePos(c)\n  if (ev.shiftKey) {\n    let a = animateExit(e)\n    a.addEventListener(\"finish\", ev => p.removeChild(e))\n    // alternative:\n    // setTimeout(() => p.removeChild(e), 500)\n  } else {\n    let e1 = Box()\n    p.insertBefore(e1,e)\n    animateEnter(e1)\n  }\n  for (let c of p.children) {\n    if (c.savedRect && c.style.position != \"absolute\")\n      animateMove(c) // skip fresh/stale element\n  }\n}\nlet count = 0\nfunction Box() {\n  let s = \"Box \"+count++\n  let p = e(\"span\",{onMouseDown:onClick},s)\n  p.style[\"padding\"] = \"10px\"\n  p.style[\"margin\"] = \"5px\"\n  p.style[\"display\"] = \"inline-block\"\n  p.style[\"border\"] = \"3px solid black\"\n  p.style[\"border-radius\"] = \"15px\"\n  p.style[\"cursor\"] = \"pointer\"\n  return p\n}\nlet p = e(\"div\",{})\n//p.style[\"text-align\"] = \"center\"\np.style[\"-webkit-user-select\"] = \"none\"\nfor (let i = 0; i < 10; i++)\n  p.appendChild(Box())\no.appendChild(p)\n</code>\n<p>We have to be a little careful with parts of the other\nlogic since we keep logically deleted elements around.\nFor example <code class=\"language-text\">animateMove</code> should not add any new animations\nto elements that are currently fading out. We check for\n<code class=\"language-text\">position: absolute</code> to prevent this but more explicit\nflags would also be possible.</p>\n<p>It is also a good idea to set the <code class=\"language-text\">height</code> and <code class=\"language-text\">width</code>\nattributes of the element to explicit pixel values\nafter moving it to an absolute position. In this example\nit doesn‚Äôt matter, but whenever the size is computed\nas percentage of a container, switching to absolute\npositioning will change that calculation.</p>\n<h3>Eliminate Jumpiness</h3>\n<p>If you click to add or remove boxes very fast, you will observe a fair\nbit of ‚Äújumpiness‚Äù. This is because new animations are started before\nthe current ones have finished.</p>\n<p>What we‚Äôd like to do is to overlay animations, so that a new animation\nmodifies the old one to gradually move to the new position. More\ndetails are below. The TL;DR is that we need to cancel the running\nanimation explicitly, after computing the old position but before\ncomputing the new one. This will take the current mid-animation\nposition as starting point without applying any computed animation\ntransform to the destination rect.</p>\n<aside>\n<p>More details about eliminating jumpiness</p>\n<p>What we‚Äôd like to do is to overlay animations, so that a new animation\nmodifies the old one gradually to move to the new position. The good news\nis that there‚Äôs an emerging solution for this: setting <code class=\"language-text\">composite: \"accumulate\"</code>\nshould achieve what we want. The bad news is that this feature is still\nexperimental and not supported by all browsers, including Safari.</p>\n<p>Here is a series of small test cases. First we highlight the jumpiness\nthat occurs without any special measures:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet sq = e(\"div\")\nsq.style[\"border\"] = \"3px solid black\"\nsq.style[\"position\"] = \"relative\"\nsq.style[\"left\"] = \"0px\"\nsq.style[\"width\"] = \"50px\"\nsq.style[\"height\"] = \"50px\"\no.appendChild(sq)\nlet maxX = o.getBoundingClientRect().width - 50\nlet dur = 1000\nfunction moveButton(factor, label) {\n  o.appendChild(e(\"button\",{onClick: e => {\n    let b = sq.getBoundingClientRect() // before update\n    let x2 = factor * maxX\n    sq.style.left = x2+\"px\"\n    let b2 = sq.getBoundingClientRect() // after update\n    let dx = b.x - b2.x\n    sq.animate({\n      transform: [\"translateX(\"+dx+\"px)\",\"translateX(0px)\"]\n    }, {\n      duration: dur,\n    })\n  }},label))\n}\nmoveButton(0.0, \"Left\")\nmoveButton(0.5, \"Center\")\nmoveButton(1.0, \"Right\")\n</code>\n<p>Now we do the same with <code class=\"language-text\">composite: accumulate</code>, which should yield\nsmooth behavior in Firefox and Chrome, but not in Safari (at the\ntime of writing):</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet sq = e(\"div\")\nsq.style[\"border\"] = \"3px solid black\"\nsq.style[\"position\"] = \"relative\"\nsq.style[\"left\"] = \"0px\"\nsq.style[\"width\"] = \"50px\"\nsq.style[\"height\"] = \"50px\"\no.appendChild(sq)\nlet maxX = o.getBoundingClientRect().width - 50\nlet dur = 1000\nfunction moveButton(factor, label) {\n  o.appendChild(e(\"button\",{onClick: e => {\n    let b = sq.getBoundingClientRect() // before update\n    let x2 = factor * maxX\n    sq.style.left = x2+\"px\"\n    let b2 = sq.getBoundingClientRect() // after update\n    let dx = b.x - b2.x\n    sq.animate({\n      transform: [\"translateX(\"+dx+\"px)\",\"translateX(0px)\"]\n    }, {\n      duration: dur,\n      composite: \"accumulate\",\n    })\n  }},label))\n}\nmoveButton(0.0, \"Left\")\nmoveButton(0.5, \"Center\")\nmoveButton(1.0, \"Right\")\n</code>\n<p>Of course, none of this is needed if we can calculate the\ntarget position exactly.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet sq = e(\"div\")\nsq.style[\"border\"] = \"3px solid black\"\nsq.style[\"position\"] = \"relative\"\nsq.style[\"left\"] = \"0px\"\nsq.style[\"width\"] = \"50px\"\nsq.style[\"height\"] = \"50px\"\no.appendChild(sq)\nlet originX = o.getBoundingClientRect().x\nlet maxX = o.getBoundingClientRect().width - 50\nlet dur = 1000\nfunction moveButton(factor, label) {\n  o.appendChild(e(\"button\",{onClick: e => {\n    let b = sq.getBoundingClientRect()\n    let x1 = b.x - originX\n    let x2 = factor * maxX\n    sq.style.left = x2+\"px\"\n    let dx = x1 - x2 // calculate target pos exactly\n    sq.animate({\n      transform: [\"translateX(\"+dx+\"px)\",\"translateX(0px)\"]\n    }, {\n      duration: dur,\n    })\n  }},label))\n}\nmoveButton(0.0, \"Left\")\nmoveButton(0.5, \"Center\")\nmoveButton(1.0, \"Right\")\n</code>\n<p>Unfortunately, this isn‚Äôt the case for most\nDOM animations where we <em>want</em> to be able to rely on the browser‚Äôs\nlayout engine entirely.</p>\n<p>Even in the presence of <code class=\"language-text\">composite: accumulate</code>, there are reasons\nwhy we may want to do something more pedestrian to orchestrate\nconcurrent or overlapping animation. One reason is that we may\nneed to compute an accurate target rect.</p>\n<p>It is important to realize that <code class=\"language-text\">getBoundingClientRect</code> returns the\nbounding box <em>including</em> transforms applied by a currently running\nanimation.</p>\n<p>So if we‚Äôre in the middle of an animation, what we think is the\ntarget rect after applying our DOM changes is actually that\ntarget rect <em>plus</em> the current mid-animation transform.</p>\n<p>To compute the precise destination rect we need to stop the\ncurrent animation explicitly.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet sq = e(\"div\")\nsq.style[\"border\"] = \"3px solid black\"\nsq.style[\"position\"] = \"relative\"\nsq.style[\"left\"] = \"0px\"\nsq.style[\"width\"] = \"50px\"\nsq.style[\"height\"] = \"50px\"\no.appendChild(sq)\nlet originX = o.getBoundingClientRect().x\nlet maxX = o.getBoundingClientRect().width - 50\nlet dur = 1000\nfunction moveButton(factor, label) {\n  o.appendChild(e(\"button\",{onClick: e => {\n    let b = sq.getBoundingClientRect()\n    let x1 = b.x - originX\n    let x2 = factor * maxX\n    sq.style.left = x2+\"px\"\n    sq.getAnimations().forEach(a => a.cancel()) // stop\n    let b2 = sq.getBoundingClientRect() // after update\n    let dx = b.x - b2.x\n    sq.animate({\n      transform: [\"translateX(\"+dx+\"px)\",\"translateX(0px)\"]\n    }, {\n      duration: dur,\n    })\n  }},label))\n}\nmoveButton(0.0, \"Left\")\nmoveButton(0.5, \"Center\")\nmoveButton(1.0, \"Right\")\n</code>\n<p>Another idea would be to retrieve the currently active\ntransformation matrix using <code class=\"language-text\">window.getComputedStyle(sq).transform</code>\nand do some inverse calculations ourselves.</p>\n<p>Note how the animation appears to slow down if we click multiple\ntimes on the same target while running. This is because we animate\nthe shorter remaining distance afresh with the orignal duration.</p>\n<p>If that bothers us we could try to compensate by looking at the\ntranslation distance and adjusting the duration accordingly,\neffectively controlling animation <em>speed</em> rather than duration.</p>\n<p>Note also that we‚Äôre only looking at translation here. Things get a\nlittle more complicated when dealing with scaling or rotations.</p>\n<p>We‚Äôll get to that in a minute.</p>\n</aside>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction savePos(e) {\n  e.savedRect = e.getBoundingClientRect()\n}\nfunction animateMove(e) {\n  let b0 = e.savedRect\n  // stop ongoing animations\n  for (let a of e.getAnimations()) a.cancel()\n  // animate from old pos to new one\n  // (could also do this for size, etc)\n  let b1 = e.getBoundingClientRect()\n  let dx = b0.x - b1.x\n  let dy = b0.y - b1.y\n  e.animate({\n    transform: ['translate('+dx+'px,'+dy+'px)', 'none'],\n  }, {\n    easing: 'ease',\n    duration: 500,\n  })\n}\nfunction animateEnter(e) {\n  e.animate({\n    transform: ['scale(0)', 'none'],\n    opacity: ['0%', '100%'],\n  }, {\n    easing: 'ease',\n    duration: 500,\n  })\n}\nfunction animateExit(e) {\n  let b0 = e.savedRect\n  // stop ongoing animations\n  for (let a of e.getAnimations()) a.cancel()\n  // switch to absolute position\n  e.style.position = \"absolute\"\n  e.style.left = \"0px\"\n  e.style.top = \"0px\"\n  // we're not animating scale here, so setting\n  // width/height could lead to sizing artifacts\n  //e.style.width = b0.width + \"px\"\n  //e.style.height = b0.height + \"px\"\n  // visually move to old pos & animate there\n  let b1 = e.getBoundingClientRect()\n  let dx = b0.x - b1.x\n  let dy = b0.y - b1.y\n  return e.animate({\n    transform: ['translate('+dx+'px,'+dy+'px) scale(1.0)',\n                'translate('+dx+'px,'+dy+'px) scale(0)'],\n    opacity: ['100%', '0%'],\n  }, {\n    easing: 'ease',\n    duration: 500,\n  })\n}\nfunction onClick(ev) {\n  let e = ev.target\n  let p = e.parentElement\n  for (let c of p.children) savePos(c)\n  if (ev.shiftKey) {\n    let a = animateExit(e)\n    a.addEventListener(\"finish\", ev => p.removeChild(e))\n    // alternative:\n    // setTimeout(() => p.removeChild(e), 500)\n  } else {\n    let e1 = Box()\n    p.insertBefore(e1,e)\n    animateEnter(e1)\n  }\n  for (let c of p.children) {\n    if (c.savedRect && c.style.position != \"absolute\")\n      animateMove(c) // skip fresh/stale element\n  }\n}\nlet count = 0\nfunction Box() {\n  let s = \"Box \"+count++\n  let p = e(\"span\",{onMouseDown:onClick},s)\n  p.style[\"padding\"] = \"10px\"\n  p.style[\"margin\"] = \"5px\"\n  p.style[\"display\"] = \"inline-block\"\n  p.style[\"border\"] = \"3px solid black\"\n  p.style[\"border-radius\"] = \"15px\"\n  p.style[\"cursor\"] = \"pointer\"\n  return p\n}\nlet p = e(\"div\",{})\n//p.style[\"text-align\"] = \"center\"\np.style[\"-webkit-user-select\"] = \"none\"\nfor (let i = 0; i < 10; i++)\n  p.appendChild(Box())\no.appendChild(p)\n</code>\n<h3>Nested Animation and Size Changes</h3>\n<p>So far, we‚Äôve only animated changes in positions of elements.\nWhat happens when an element changes it size due to some\nlayout change? We‚Äôd like to animate such cases smoothly as\nwell.</p>\n<p>In principle, we can do the same thing as before, just\nfor the <code class=\"language-text\">transform: scale(s)</code> property.</p>\n<p>However, there are a couple of things to watch out for when\nthe resized element contains other elements, including text.\nScaling the computed pixel representation (which is what\nthe transform property does) would lead to a pretty\ndistorted image on screen. This is especially annoying\nwith text. To prevent this, we need to scale the inner\nelements inversely to their parents, which will make up\nfor this distortion.</p>\n<p>Hence, it make sense to consider nested animation right\naway when looking at scaling.</p>\n<p>In the example below, we have multiple nested containers\nthat can be moved or resized concurrently. The inner\ncontainers are scaled inversely when their parents\nresize to preserve their visual proportions and relative\npositions.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction box(w,h) {\n  let sq = e(\"div\")\n  sq.style[\"border\"] = \"3px solid black\"\n  sq.style[\"display\"] = \"flex\"\n  sq.style[\"padding\"] = \"3px\"\n  sq.style[\"width\"] = w+\"px\"\n  sq.style[\"height\"] = h+\"px\"\n  return sq\n}\nlet A = box(400,200)\nlet B = box(150,150)\nlet C = box(50,50)\nlet D = e(\"div\", {}, \"ABC\")\nC.appendChild(D)\nB.appendChild(C)\nA.appendChild(B)\no.appendChild(A)\nlet dur = 2000\nfunction pre() {\n  for (let sq of [A,B,C,D])\n    sq.box = sq.getBoundingClientRect()\n}\nfunction anim(sq,p) {\n  sq.getAnimations().forEach(a => a.cancel())\n  let b = sq.box\n  let b2 = sq.getBoundingClientRect()\n  let dx = b.x - b2.x\n  let dy = b.y - b2.y\n  let rw = b.width / b2.width\n  let rh = b.height / b2.height\n  // scale delta by parent scaling factor\n  dx /= p.rw\n  dy /= p.rh\n  let str =\n    \"translate(\"+dx+\"px,\"+dy+\"px) \" +\n    \"scale(\"+rw+\",\"+rh+\") \"\n  sq.animate({\n    transform: [str,\"none\"],\n    transformOrigin: [\"top left\",\"top left\"]\n  }, {\n    duration: dur,\n    easing: \"ease\",\n  })\n  // transform children after parent:\n  // take parent transform already into account\n  for (let c of sq.children)\n    anim(c,{dx:p.dx+dx,dy:p.dy+dy,rw:rw*p.rw,rh:rh*p.rh})\n}\nfunction moveButton(sq,dir,off, label) {\n  o.appendChild(e(\"button\",{onClick: e => {\n    pre()\n    sq.style[dir] = off\n    anim(A,{dx:0,dy:0,rw:1,rh:1}) // top\n  }},label))\n}\n// initial config\nC.style.justifyContent = \"center\"\nC.style.alignItems = \"center\"\nC.style.width = \"100px\"\nB.style.justifyContent = \"flex-end\"\n// UI\nprint(\"A:\")\nmoveButton(A, \"width\", \"200px\", \"Small\")\nmoveButton(A, \"width\", \"600px\", \"Large\")\nprint(\"B:\")\nmoveButton(A, \"justify-content\", \"flex-start\", \"Left\")\nmoveButton(A, \"justify-content\", \"center\", \"Center\")\nmoveButton(A, \"justify-content\", \"flex-end\", \"Right\")\n//print(\"B v:\")\nmoveButton(A, \"align-items\", \"flex-start\", \"Top\")\nmoveButton(A, \"align-items\", \"center\", \"Center\")\nmoveButton(A, \"align-items\", \"flex-end\", \"Bottom\")\nmoveButton(B, \"width\", \"100px\", \"Small\")\nmoveButton(B, \"width\", \"200px\", \"Large\")\nprint(\"C:\")\nmoveButton(B, \"justify-content\", \"flex-start\", \"Left\")\nmoveButton(B, \"justify-content\", \"center\", \"Center\")\nmoveButton(B, \"justify-content\", \"flex-end\", \"Right\")\n//print(\"C v:\")\nmoveButton(B, \"align-items\", \"flex-start\", \"Top\")\nmoveButton(B, \"align-items\", \"center\", \"Center\")\nmoveButton(B, \"align-items\", \"flex-end\", \"Bottom\")\nmoveButton(C, \"width\", \"50px\", \"Small\")\nmoveButton(C, \"width\", \"100px\", \"Large\")\n</code>\n<p>In the code, we need to propagate scaling factors from parents to children\nso that children can express their desired translation relative to the parent. We transform parents before children so that children can obtain an\naccurate relative position from the browser.</p>\n<p>Note that the size of the text remains mostly stable, however there is still some ‚Äúsoft‚Äù stretching in the middle of animations, for example, when changing the size of A.</p>\n<p>This happens because scaling is expressed as a factor, and we only control the endpoints of the animation. Interpolating this factor linearly or according to some other easing curve does not change the <em>size</em> according to the same formula. In addition, size is relative to the parent. So even if we use an inverse scale for the child element that leads to the correct size at the beginning and end of the animation this doesn‚Äôt mean that the parent transformation is fully compensated at each point during the animation.</p>\n<p>It should be possible to mitigate these effects further using programmatic keyframes and/or specialized easing curves. However, if the animations are reasonaly quick (quicker than in this example), the effect often isn‚Äôt very distracting.</p>\n<p>Note also that other aspects of the element such as borders or rounded\ncorners may appear distorted during the animation. There are several possible countermeasures, including animating the <code class=\"language-text\">clip</code> property or <code class=\"language-text\">width</code>/<code class=\"language-text\">height</code> instead of <code class=\"language-text\">scale</code>. The latter may yield poor performance if it leads to reflowing the layout, but it may still be a viable option for some cases.\nAnother option is to surround a variable-size plain-color element with fixed-size border areas.</p>\n<h3>Notes &#x26; References</h3>\n<p>Notes</p>\n<ul>\n<li>This approach doesn‚Äôt work for <code class=\"language-text\">display: inline</code> elements, only for <code class=\"language-text\">block</code> or <code class=\"language-text\">inline-block</code></li>\n<li>It‚Äôs possible to stagger animations, e.g., move elements one after the other or children before their parents. An easy way is to use <code class=\"language-text\">delay: i*50ms</code></li>\n<li>It‚Äôs also possible to animate elements so that they appear to move in from any other position, such as from the apparent position of a <em>different</em> element. This can be useful, e.g., to zoom in into a thumbnail</li>\n</ul>\n<p>References</p>\n<ul>\n<li><a href=\"https://css-tricks.com/animating-layouts-with-the-flip-technique/\">https://css-tricks.com/animating-layouts-with-the-flip-technique/</a></li>\n<li><a href=\"https://www.joshwcomeau.com/react/animating-the-unanimatable/\">https://www.joshwcomeau.com/react/animating-the-unanimatable/</a></li>\n</ul>\n<p>Advanced</p>\n<ul>\n<li><a href=\"https://pqina.nl/blog/animating-width-and-height-without-the-squish-effect/\">https://pqina.nl/blog/animating-width-and-height-without-the-squish-effect/</a></li>\n</ul>\n</aside>\n<aside>\n<p>Virtual DOM Animation</p>\n<p>Animating changes is ideally suited to a React-style virtual\nDOM setting, where changes are diffed and patched with\nrespect to physical DOM components.</p>\n<h3>Basic VDOM Reconciliation</h3>\n<p>We start by recalling key bits of our DOM diffing\nimplementation from the post on\n<a href=\"/Public/Generic/deconstructing-react\">Deconstructing React</a>.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createVirtualElement(type, props, ...children) {\n  return {\n    type,\n    props: props,\n    children: children.map(child =>\n      typeof child === \"object\"\n        ? child\n        : createTextElement(child)\n      )\n  }\n}\n// Special case for plain strings: distinction\n// is not really necessary here, but it allows\n// updating \"nodeValue\" as property without\n// dispatch later\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: String(text),\n    },\n    children: []\n  }\n}\n// Create an actual DOM node\nfunction createDom(type) {\n  const dom = type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(type)\n  return dom\n}\n</code>\n<p>Virtual DOM diff (so far)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction updateProperties(dom, prevProps, nextProps) {\n  const isNew  = key => prevProps[key] !== nextProps[key]\n  const isGone = key => !(key in nextProps)\n  // Remove old properties and event listeners\n  for (let k in prevProps) {\n    if (isEvent(k)) {\n      if (isGone(k) || isNew(k))\n        dom.removeEventListener(eventName(k), prevProps[k])\n    } else {\n      if (isGone(k))\n        delete dom[k]\n    }\n  }\n  // Remove new/updated properties and event listeners\n  for (let k in nextProps) {\n    if (isEvent(k)) {\n      if (isNew(k))\n        dom.addEventListener(eventName(k), nextProps[k])\n    } else if (k == \"style\") { // special case for style ...\n       let pp = prevProps[k]\n       let np = nextProps[k]\n       for (let j in np) {\n         dom[k][j] = np[j]\n       }\n    } else {\n      if (isNew(k) && dom[k] != nextProps[k]) {\n        dom[k] = nextProps[k]\n      }\n    }\n  }\n}\nfunction updateChildrenByIndex(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      newChild.dom = oldChild.dom\n      updateProperties(newChild.dom, oldChild.props, newChild.props)\n      updateChildren(newChild.dom, oldChild.children, newChild.children)\n    } else {\n      if (oldChild) {\n        domParent.removeChild(oldChild.dom)\n      }\n      if (newChild) {\n        newChild.dom = createDom(newChild.type)\n        updateProperties(newChild.dom, {}, newChild.props)\n        updateChildren(newChild.dom, [], newChild.children)\n        domParent.appendChild(newChild.dom)\n      }\n    }\n  }\n}\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  return updateChildrenByIndex(domParent, oldChildren, newChildren)\n}\n</code>\n<p>Top level API</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet currentRoot = []\nfunction render(element, container=o) {\n  updateChildren(container, currentRoot, [element])\n  currentRoot = [element]\n}\n// internal: cleanup on recompile\nonclear(() => updateChildren(o,currentRoot,[]))\n// make virtual dom the default for e(\"div\",{},...)\ne = createVirtualElement\n</code>\n<h3>Reconciliation by Key, with Animation</h3>\n<p>We add reconciliation by key, and some hooks for\nanimation.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let oldByKey = {}\n  let newByKey = {}\n  for (let c of oldChildren) if (c.props.key) oldByKey[c.props.key] = c\n  for (let c of newChildren) if (c.props.key) newByKey[c.props.key] = c\n  let byKey = Object.keys(newByKey).length > 0\n  if (!byKey) return updateChildrenByIndex(domParent, oldChildren, newChildren)\n  for (let c of oldChildren) if (c.props.key) {\n    c.box = c.dom.getBoundingClientRect()\n  }\n  for (let newChild of newChildren) {\n    let oldChild = oldByKey[newChild.props.key]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      delete oldByKey[newChild.props.key]\n      newChild.dom = oldChild.dom\n      updateProperties(newChild.dom, oldChild.props, newChild.props)\n      updateChildren(newChild.dom, oldChild.children, newChild.children)\n      if (newChild.props.key)\n        animateMove(domParent, oldChild, newChild)\n      else\n        domParent.appendChild(newChild.dom)\n    } else {\n      newChild.dom = createDom(newChild.type)\n      updateProperties(newChild.dom, {}, newChild.props)\n      updateChildren(newChild.dom, [], newChild.children)\n      if (newChild.props.key)\n        animateEnter(domParent, newChild)\n      else\n        domParent.appendChild(newChild.dom)\n    }\n  }\n  for (let key in oldByKey) {\n    let oldChild = oldByKey[key]\n      if (oldChild.props.key)\n        animateExit(domParent, oldChild)\n      else\n        domParent.removeChild(oldChild.dom)\n  }\n}\n</code>\n<p>Now we provide some sensible defaults for those hooks.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction animateMove(domParent, oldChild, newChild) {\n  domParent.appendChild(newChild.dom)\n  setTimeout(() => {\n    let b = oldChild.box\n    let b2 = newChild.dom.getBoundingClientRect()\n    let dx = b.x - b2.x\n    newChild.dom.animate([\n      // keyframes\n      { transform: 'translateX('+dx+'px)' },\n      { transform: 'translateX(0px)'  }\n    ], {\n      duration: 400,\n      easing: \"ease\"\n    })\n  },0)\n}\nfunction animateEnter(domParent, newChild) {\n  domParent.appendChild(newChild.dom)\n  setTimeout(() => {\n    let midx = o.getBoundingClientRect().x+o.getBoundingClientRect().width/2\n    let b2 = newChild.dom.getBoundingClientRect()\n    let dx = midx-b2.x\n    newChild.dom.animate([\n      // keyframes\n      { opacity: '0%', transform: 'translateX('+dx+'px) scale(0)' },\n      { opacity: '100%', transform: 'translateX(0px) scale(1.0)' },\n    ], {\n      duration: 400,\n      easing: \"ease\"\n    })\n  }, 0)\n}\nfunction animateExit(domParent, oldChild) {\n  let b = oldChild.box\n  oldChild.dom.style[\"position\"] = \"absolute\"\n  oldChild.dom.style[\"opacity\"] = \"0%\"\n  setTimeout(() => {\n    let b2 = oldChild.dom.getBoundingClientRect()\n    let dx = b.x - b2.x\n    let dy = b.y - b2.y\n    let midx = o.getBoundingClientRect().x+o.getBoundingClientRect().width/2\n    let dx2 = midx-b2.x\n    oldChild.dom.style[\"transform\"] = \"translate(\"+dx+\"px,\"+dy+\"px)\"\n    let a = oldChild.dom.animate([\n      // keyframes\n      { opacity: '100%', transform: 'translate('+dx+'px,'+dy+'px) scale(1.0)' },\n      { opacity: '0%', transform: 'translate('+dx2+'px,'+dy+'px) scale(0)' }\n    ], {\n      duration: 400,\n      easing: \"ease\"\n    })\n    a.addEventListener(\"finish\", ev =>\n      domParent.removeChild(oldChild.dom))\n  }, 0)\n}\n</code>\n<h3>Some Examples</h3>\n<p>Let‚Äôs define some example components.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet cssLine = {\n  border: \"3px solid black\",\n  borderRadius: \"50px\",\n  display: \"inline-block\",\n  margin: \"10px\",\n  width: \"50px\",\n  textAlign: \"center\",\n  padding: \"10px\",\n}\nfunction renderLine(g) {\n  let words = []\n  for (let h of g) {\n    let w = e(\"span\",{style:cssLine,key:h},h)\n    words.push(w)\n  }\n  return e(\"div\",{style:{textAlign:\"center\"}},...words)\n}\nlet data = [1]\nlet selected = 0\nfunction renderAll() {\n  let out = []\n  let line = renderLine(data[selected])\n  out.push(line)\n  out.push(e(\"div\",{},\n    e(\"button\",{onClick: e =>\n      update(selected = (data.length+selected-1)%data.length)},\"<<\"),\n    selected+\"/\"+data.length,\n    e(\"button\",{onClick: e =>\n      update(selected = (selected+1)%data.length)},\">>\")))\n  return e(\"div\",{},...out)\n}\nfunction App(init) {\n  if (init) data = init\n  return e(\"div\", {},\n    renderAll())\n}\nfunction update() {\n  render(App(),o)\n}\nfunction displayChart(init) {\n  render(App(init),o)\n}\n</code>\n<p>Let‚Äôs run it. Layout changes are fully determined by the data.\nNone of the transitions are explicitly programmed (insert this\nnode, remove this other one):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ndisplayChart([\n[1,2,3],\n[3,2,1],\n[3,5,6,2,1],\n])\n</code>\n<p>Another view of the same data</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet scaleFactor = 30\ncssLine = {\n  border: \"3px solid black\",\n  //borderRadius: \"50px\",\n  display: \"inline-block\",\n  margin: \"10px\",\n  width: \"50px\",\n  textAlign: \"center\",\n  //padding: \"2px\",\n}\nfunction renderLine(g) {\n  let words = []\n  for (let h of g) {\n    let s = {...cssLine}\n    s.height = h*scaleFactor+\"px\"\n    let w = e(\"span\",{style:s,key:h},h)\n    words.push(w)\n  }\n  return e(\"div\",{style:{\n    display:\"flex\",\n    height: \"200px\",\n    //border: \"1px solid green\",\n    alignItems:\"flex-end\",\n    justifyContent:\"center\"\n  }},...words)\n}\n//let data = [1]\n//let selected = 0\nfunction renderAll() {\n  let out = []\n  let line = renderLine(data[selected])\n  out.push(line)\n  out.push(e(\"div\",{},\n    e(\"button\",{onClick: e =>\n      update(selected = (data.length+selected-1)%data.length)},\"<<\"),\n    selected+\"/\"+data.length,\n    e(\"button\",{onClick: e =>\n      update(selected = (selected+1)%data.length)},\">>\")\n  ))\n  if (data.length > 5)\n    out.push(e(\"div\",{},\n      e(\"input\",{type: \"range\", value: selected, max: data.length-1, onInput: e =>\n        update(selected = e.target.value)})\n    ))\n  return e(\"div\",{},...out)\n}\n</code>\n<p>Let‚Äôs run it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ndisplayChart([\n[1,2,3],\n[3,2,1],\n[3,5,6,2,1],\n])\n</code>\n<p>Second example: sort/shuffle</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction shuffling(array) {\n  scaleFactor = 20 // todo: compute dynamically\n  let steps = []\n  let m = array.length, t, i;\n  steps.push([...array])\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    if (i == m) continue\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n    steps.push([...array])\n  }\n  displayChart([...steps.reverse(),...steps.reverse()])\n}\n</code>\n<p>Let‚Äôs run it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nshuffling([1,2,3,4,5,6,7,8,9])\n</code>\n</aside>\n<aside>\n<p>Virtual DOM with Tree Reconciliation</p>\n<h3>The Problem: Shallow Reconciliation</h3>\n<p>What we‚Äôve seen so far works fine with sequential data. We can extend it to nested data in an entirely straightforward way:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction renderLine(g) {\n  let groups = []\n  for (let k of g) {\n    let words = []\n    for (let h of k) {\n      let s = {...cssLine}\n      s.height = h*scaleFactor+\"px\"\n      let w = e(\"span\",{style:s, key:h},h)\n      words.push(w)\n    }\n    groups.push(e(\"div\",{style:{\n      display:\"flex\",\n      //height: \"200px\",\n      border: \"3px solid green\",\n      margin: \"5px\",\n      alignItems:\"flex-end\",\n      justifyContent:\"center\"\n    }},...words))\n  }\n  return e(\"div\",{style:{\n    display:\"flex\",\n    height: \"200px\",\n    //border: \"1px solid green\",\n    alignItems:\"flex-end\",\n    justifyContent:\"center\"\n  }},...groups)\n}\ndisplayChart([\n  [[1,2],[3,4]],\n  [[2,1],[4,3]],\n  [[4,3],[2,1]],\n])\n</code>\n<p>However, this isn‚Äôt as smooth as we would like it!</p>\n<p>Moves are only recognized within an immediate parent.\nSo there are a lot of inserts and deletes that should\nreally be moves!</p>\n<h3>Deep Reconciliation</h3>\n<p>Let‚Äôs see how we can implement a more general VDOM\ndiffing approach that handles theses cases!</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  try {\n    return updateChildren1(domParent, oldChildren, newChildren)\n  } catch(ex) {\n    print(ex)\n  }\n}\nfunction dfs(nodes, f) {\n  for (let c of nodes) {\n    f(c); dfs(c.children, f)\n  }\n}\nfunction dfs1(nodes, init, f) {\n  for (let c of nodes) {\n    let s = f(c,init); dfs1(c.children, s, f)\n  }\n}\nfunction updateChildren1(domParent, oldChildren, newChildren) {\n  let oldByKey = {}\n  dfs(oldChildren, c => {\n    if (c.props.key) {\n      oldByKey[c.props.key] = oldByKey[c.props.key] || []\n      oldByKey[c.props.key].push(c)\n      c.box = c.dom.getBoundingClientRect()\n    }\n  })\n  recurse(domParent, oldChildren, newChildren)\n  function recurse(domParent, oldChildren, newChildren) {\n    let oldChildrenByIndex = oldChildren.filter(c => !c.props.key)\n    for (let newChild of newChildren) {\n      let oldChild = (newChild.props.key ? oldByKey[newChild.props.key]: oldChildrenByIndex)?.shift()\n      const sameType =\n        oldChild &&\n        newChild &&\n        newChild.type == oldChild.type\n      if (sameType) {\n        //delete oldByKey[newChild.props.key]\n        newChild.dom = oldChild.dom\n        newChild.dom.remove() // possible hierarchy change!\n        updateProperties(newChild.dom, oldChild.props, newChild.props)\n        recurse(newChild.dom, oldChild.children, newChild.children)\n        if (newChild.props.key)\n          animateMove1(domParent, oldChild, newChild)\n        else\n          domParent.appendChild(newChild.dom)\n      } else {\n        if (oldChild) {\n          // non-matching child, may be using index\n          // or key (in which case parent is different!)\n          if (oldChild.props.key)\n            animateExit1(oldChild.dom.parentElement, oldChild)\n          else\n            domParent.removeChild(oldChild.dom)\n        }\n        newChild.dom = createDom(newChild.type)\n        updateProperties(newChild.dom, {}, newChild.props)\n        recurse(newChild.dom, [], newChild.children)\n        if (newChild.props.key)\n          animateEnter1(domParent, newChild)\n        else\n          domParent.appendChild(newChild.dom)\n      }\n    }\n    // remove any old by-index elems (local)\n    for (let oldChild of oldChildrenByIndex) {\n      domParent.removeChild(oldChild.dom)\n    }\n  }\n  // remove any old by-key elems (global)\n  for (let key in oldByKey) {\n    for (let oldChild of oldByKey[key]) {\n      let domParent = oldChild.dom.parentElement\n      if (oldChild.props.key)\n        animateExit1(domParent, oldChild)\n      else\n        domParent.removeChild(oldChild.dom)\n    }\n  }\n  // finish animations!\n  // XXX order dependent? exited items seem hidden for\n  // ~500ms when done first\n  dfs1(newChildren,{x:0,y:0}, animateMoveOrEnter2)//,0)\n  dfs1(oldChildren,{x:0,y:0}, animateExit2)//,0)\n}\n</code>\n<p>Animation behaviors</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction animateMove1(domParent, oldChild, newChild) {\n  domParent.appendChild(newChild.dom)\n  newChild.box = oldChild.box\n}\nfunction animateEnter1(domParent, newChild) {\n  domParent.appendChild(newChild.dom)\n}\nfunction animateExit1(domParent, oldChild) {\n  oldChild.dom.style[\"position\"] = \"absolute\"\n  oldChild.dom.style[\"width\"] = oldChild.box.width+\"px\"\n  oldChild.dom.style[\"height\"] = oldChild.box.height+\"px\"\n  oldChild.delete = true\n}\nfunction enterExitOrigin(b) {\n  let outer = o.getBoundingClientRect()\n  return {x:outer.x+outer.width/2, y:b.y+b.height/2}\n}\nfunction enterExitScale(e) {\n  return 0.1\n}\nfunction animateMoveOrEnter2(newChild,parentDelta) {\n  if (!newChild.props.key) return parentDelta\n  if (!newChild.box) {\n    // no prior state: enter\n    return animateEnter2(newChild,parentDelta)\n  } {\n    // else: move\n    return animateMove2(newChild,parentDelta)\n  }\n}\nfunction animateEnter2(newChild,parentDelta) {\n  // TODO: manage parentDelta!\n  let b2 = newChild.dom.getBoundingClientRect()\n  let or = enterExitOrigin(b2)\n  let sc = enterExitScale(newChild)\n  let dx = or.x - b2.x\n  let dy = or.y - b2.y\n  newChild.dom.animate({\n    //background: [\"lightgreen\",\"none\"],\n    opacity: [\"0%\",\"100%\"],\n    transform: ['translate('+dx+'px,'+dy+'px) scale('+sc+','+sc+')','translate(0px,0px)' ]\n  }, {\n    duration: 400,\n    easing: \"ease\",\n    //composite: \"accumulate\",\n  })\n  return parentDelta // needed??\n}\nfunction animateMove2(newChild,parentDelta) {\n  // prefer snappy over smooth: avoid speed change due to cancel\n  //newChild.dom.getAnimations().forEach(a => a.cancel())\n  let b = newChild.box\n  let b2 = newChild.dom.getBoundingClientRect()\n  let dx = b.x - b2.x\n  let dy = b.y - b2.y\n  let rw = b.width / b2.width\n  let rh = b.height / b2.height\n  let p = parentDelta\n  if (!p.w) p.w = 1\n  if (!p.h) p.h = 1\n  dx /= p.w\n  dy /= p.h\n  newChild.dom.animate([\n    { transform: 'translate('+dx+'px,'+dy+'px) scale('+rw+','+rh+')',\n    transformOrigin: 'top left' },\n    { transform: 'translate(0px,0px) scale(1,1)'  }\n  ], {\n    duration: 400,\n    easing: \"ease\",\n    //composite: \"accumulate\",\n  })\n  return {x:dx, y:dy, w:rw*p.w, h:rh*p.h}\n}\nfunction animateExit2(oldChild,parentDelta) {\n  // TODO: manage parentDelta?\n  if (!oldChild.props.key || !oldChild.delete) return\n  // prefer snappy over smooth: avoid speed change due to cancel\n  //oldChild.dom.getAnimations().forEach(a => a.cancel())\n  let b = oldChild.box\n  let b2 = oldChild.dom.getBoundingClientRect()\n  let dx = b.left - b2.left\n  let dy = b.top - b2.top\n  let or = enterExitOrigin(b)\n  let sc = enterExitScale(oldChild)\n  let dx2 = dx + (or.x - b.x)\n  let dy2 = dy + (or.y - b.y)\n  oldChild.dom.style[\"transform\"] = \"translate(\"+dx+\"px,\"+dy+\"px)\"\n  let a = oldChild.dom.animate({\n    //background: [\"pink\",\"pink\",\"none\"],\n    opacity: [\"100%\",\"0%\"],\n    transform: [\"translate(\"+dx+\"px,\"+dy+\"px)\",\"translate(\"+dx2+\"px,\"+dy2+\"px) scale(\"+sc+\",\"+sc+\")\"],\n    transformOrigin: dx2+\"px \"+dy2+\"px\"\n  }, {\n    duration: 400,\n    easing: \"ease-out\",\n    //composite: \"accumulate\",\n  })\n  a.addEventListener(\"finish\", ev => {\n    // let domParent = oldChild.dom.parentElement\n    // domParent.removeChild(oldChild.dom)\n    oldChild.dom.remove()\n  })\n}\n</code>\n<p>Example</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// example\nfunction renderItem(g) {\n  if (g instanceof Array) {\n    let items = g.map(renderItem)\n    return e(\"div\",{style:{\n      display:\"flex\",\n      //height: \"200px\",\n      border: \"3px solid green\",\n      margin: \"5px\",\n      alignItems:\"flex-end\",\n      justifyContent:\"center\"\n    }}, ...items)\n  } else {\n    assert(typeof(g) == \"number\", \"not a number: \"+g)\n    let s = {...cssLine}\n    s.height = g*scaleFactor+\"px\"\n    return e(\"span\",{style:s, key:g},g)\n  }\n}\nfunction renderLine(g) {\n  assert(g instanceof Array, \"not an array: \"+g)\n  let items = g.map(renderItem)\n  return e(\"div\",{style:{\n    display:\"flex\",\n    height: \"200px\",\n    //border: \"1px solid green\",\n    alignItems:\"flex-end\",\n    justifyContent:\"center\"\n  }},...items)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndisplayChart([\n  [1,2,[3,4]],\n  [[2,1],[4,3]],\n  [[4,3],[[2],1]],\n])\n</code>\n<p>That works pretty well! But notice jumpiness of containers</p>\n<p>What‚Äôs next?</p>\n<h3>Nested Animation</h3>\n<p>Right now only leaves have their key set, and are animated. What if we have keyed items inside keyed items? Do we need to synchronize child and parent animations?</p>\n<p>It seems like we‚Äôre (mostly) ok: one remaining question is how to\nassign ids for grouping nodes. In our example, there aren‚Äôt\nreally meaningful ids beyond the individual numbers. Making\nup group ids based on the group‚Äôs <em>content</em> isn‚Äôt what we want,\nbecause then items can‚Äôt move between persistent groups. So\nwe just go ahead and assign keys sequentially, based on a\ngroup‚Äôs position in the depth-first traversal of the tree.\nIn most use cases we‚Äôd expect to have semantically meaninful\ngroup keys.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// example\nlet count = 100\nfunction renderItem(g) {\n  if (g instanceof Array) {\n    let key = count++\n    let items = g.map(renderItem)\n    return e(\"div\",{style:{\n      display:\"flex\",\n      //height: \"200px\",\n      border: \"3px solid green\",\n      margin: \"5px\",\n      alignItems:\"flex-end\",\n      justifyContent:\"center\"\n    }, key:key}, ...items)\n  } else {\n    assert(typeof(g) == \"number\", \"not a number: \"+g)\n    let s = {...cssLine}\n    s.height = g*scaleFactor+\"px\"\n    return e(\"span\",{style:s, key:g},g)\n  }\n}\nfunction renderLine(g) {\n  count = 100\n  assert(g instanceof Array, \"not an array: \"+g)\n  let items = g.map(renderItem)\n  return e(\"div\",{style:{\n    display:\"flex\",\n    height: \"200px\",\n    //border: \"1px solid green\",\n    alignItems:\"flex-end\",\n    justifyContent:\"center\"\n  }},...items)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndisplayChart([\n  [1,[2,[3,4]]],\n  [[[2,1],4],3],\n  [[[4,3],2],1],\n])\n</code>\n<p>This pretty much looks like what we wanted!</p>\n<h3>Notes &#x26; References</h3>\n<p>References:</p>\n<ul>\n<li><a href=\"https://github.com/aholachek/react-flip-toolkit\">https://github.com/aholachek/react-flip-toolkit</a></li>\n<li><a href=\"https://github.com/joshwcomeau/react-flip-move\">https://github.com/joshwcomeau/react-flip-move</a></li>\n<li><a href=\"https://github.com/jlkiri/react-easy-flip\">https://github.com/jlkiri/react-easy-flip</a></li>\n</ul>\n</aside>\n<h3>Example</h3>\n<p>Here is a simple animated bar chart. Layout changes are\nfully determined by the data. None of the transitions are\nexplicitly programmed (insert this node, remove this\nother one):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ndisplayChart([\n[1,2,3],\n[3,2,1],\n[3,5,6,2,1],\n])\n</code>\n<h3>Red-Black Trees</h3>\n<aside>\n<p>Steps</p>\n<p>Let‚Äôs build a standard binary tree and\ndraw it by mapping to DOM nodes.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// binary tree insertion\n//\nfunction insert(root, key) {\n  if (!root) return {key}\n  if (key < root.key)\n    return {...root, left: insert(root.left,key)}\n  else\n    return {...root, right: insert(root.right,key)}\n}\n//\n// dom output\n//\nlet nodeStyle = {\n  display: \"inline-block\",\n  border: \"1px solid black\",\n  textAlign: \"center\",\n  verticalAlign: \"top\",\n  padding: \"2px\",\n  margin: \"2px\",\n}\nlet leafStyle = {\n  display: \"inline-block\",\n  border: \"1px solid lightgrey\",\n  margin: \"2px\",\n}\nfunction walk(elem) {\n  if (elem) {\n    return e(\"div\",{ style: nodeStyle },\n      e(\"div\",{},elem.key),\n      e(\"div\",{},walk(elem.left),walk(elem.right)))\n  } else {\n    return e(\"span\",{ style: leafStyle },\"¬†¬†\")\n  }\n}\n//\n// example\n//\nlet root\nroot = insert(root, 6)\nroot = insert(root,3)\nroot = insert(root,12)\nroot = insert(root,8)\nroot = insert(root,9)\nroot = insert(root,18)\nroot = insert(root,24)\nroot = insert(root,29)\nroot = insert(root,34)\nrender(walk(root))\n</code>\n<p>Now do the same for a Red-Black tree (left-leaning variant)\nthat automatically rebalances.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// LLRB tree insertion\n//\nfunction insert(elem, key) {\n  if (!elem) return {key,red:true}\n  if (key < elem.key)\n    elem = {...elem, left: insert(elem.left,key)}\n  else\n    elem = {...elem, right: insert(elem.right,key)}\n  if (isRed(elem.right))\n    elem = rotateLeft(elem)\n  if (isRed(elem.left) && isRed(elem.left.left))\n    elem = rotateRight(elem)\n  if (isRed(elem.left) && isRed(elem.right))\n    elem = colorFlip(elem)\n  return elem\n}\nfunction isRed(elem) {\n  return elem && elem.red\n}\nfunction colorFlip(elem) {\n  // we know both children are red\n  elem.red = !elem.red\n  elem.left.red = !elem.left.red\n  elem.right.red = !elem.right.red\n  return elem\n}\nfunction rotateLeft(elem) {\n  // assert(isRed(elem.right))\n  let x = elem.right\n  elem.right = x.left\n  x.left = elem\n  x.red = elem.red//!x.left.red\n  //x.left.red = true\n  elem.red = true\n  return x\n}\nfunction rotateRight(elem) {\n  // assert(isRed(elem.left) && isRed(elem.left.left))\n  let x = elem.left\n  elem.left = x.right\n  x.right = elem\n  x.red = elem.red//x.right.red\n  //x.right.red = true\n  elem.red = true\n  return x\n}\n//\n// dom output\n//\nlet nodeStyle = red => ({\n  display: \"inline-block\",\n  border: \"1px solid \" + (red ? \"red\" : \"black\"),\n  textAlign: \"center\",\n  verticalAlign: \"top\",\n  padding: \"2px\",\n  margin: \"2px\",\n})\nlet leafStyle = {\n  display: \"inline-block\",\n  border: \"1px solid lightgrey\",\n  margin: \"2px\",\n}\nfunction walk(elem) {\n  if (elem) {\n    return e(\"div\",{ style: nodeStyle(elem.red) },\n      e(\"div\",{},elem.key),\n      e(\"div\",{},walk(elem.left),walk(elem.right)))\n  } else {\n    return e(\"span\",{ style: leafStyle },\"¬†¬†\")\n  }\n}\n//\n// example\n//\nlet root\nroot = insert(root,1)\nroot = insert(root,2)\nroot = insert(root,3)\nroot = insert(root,4)\nroot = insert(root,5)\nroot = insert(root,6)\nroot = insert(root,7)\nroot = insert(root,8)\nroot = insert(root,9)\nroot = insert(root,10)\nroot = insert(root,11)\nroot = insert(root,12)\nroot = insert(root,13)\nroot = insert(root,14)\nroot = insert(root,15)\nroot = insert(root,16)\nroot = insert(root,17)\nroot = insert(root,18)\nroot = insert(root,19)\nroot = insert(root,20)\nrender(walk(root))\n</code>\n<p>Next, we‚Äôre going to animate the tree layout.</p>\n<p>Some utilities first:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// slider ui\n//\nlet playDelay = 1000\nlet playIncr = 1\nfunction interactiveWithSlider(min,max,value,style,func) {\n  let pe = createElement\n  /*let*/ selected = value\n  o.appendChild(pe(\"button\",{onClick: ev => update(selected = Math.max(selected-1,min))},\"<<\"))\n  o.appendChild(pe(\"button\",{onClick: ev => update(selected = Math.min(selected+1,max))},\">>\"))\n  let playing = false\n  o.appendChild(pe(\"button\",{onClick: ev => {\n    playing = !playing\n    if (playing && selected >= max)\n      update(selected = min)\n    else\n      update(selected += 1)\n    function next() {\n      if (selected >= max) playing = false\n      if (!playing) return\n      update(selected += playIncr)\n      setTimeout(next,playDelay)\n    }\n    setTimeout(next,playDelay)\n  }},\"‚ñ∂Ô∏é\"))\n  let sl = pe(\"input\",{type: \"range\", min: min, max: max, value: selected, style: {width: \"50%\"}, onInput: e => update(selected = Number(e.target.value))})\n  o.appendChild(sl)\n  let panel = pe(\"div\",{style})\n  function update() {\n    if (sl.value != selected) sl.value = selected\n    let d = func(selected)\n    if (d instanceof Array)\n      d = e(\"div\",{},...d)\n    render(d,panel)\n  }\n  o.appendChild(panel)\n  update()\n}\n</code>\n</aside>\n<p>Let‚Äôs insert some numbers into a Red-Back Tree\n(Sedgewick‚Äôs leaft-leaning variant), and watch\nit automatically maintain its balance:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// LLRB tree insertion\n//\nfunction insert(elem, key) {\n  if (!elem) return {key,red:true}\n  if (key < elem.key)\n    elem = {...elem, left: insert(elem.left,key)}\n  else\n    elem = {...elem, right: insert(elem.right,key)}\n  if (isRed(elem.right))\n    elem = rotateLeft(elem)\n  if (isRed(elem.left) && isRed(elem.left.left))\n    elem = rotateRight(elem)\n  if (isRed(elem.left) && isRed(elem.right))\n    elem = colorFlip(elem)\n  return elem\n}\nfunction isRed(elem) {\n  return elem && elem.red\n}\nfunction colorFlip(elem) {\n  // we know both children are red\n  elem.red = !elem.red\n  elem.left.red = !elem.left.red\n  elem.right.red = !elem.right.red\n  return elem\n}\nfunction rotateLeft(elem) {\n  // assert(isRed(elem.right))\n  let x = elem.right\n  elem.right = x.left\n  x.left = elem\n  x.red = elem.red//!x.left.red\n  //x.left.red = true\n  elem.red = true\n  return x\n}\nfunction rotateRight(elem) {\n  // assert(isRed(elem.left) && isRed(elem.left.left))\n  let x = elem.left\n  elem.left = x.right\n  x.right = elem\n  x.red = elem.red//x.right.red\n  //x.right.red = true\n  elem.red = true\n  return x\n}\n//\n// dom output\n//\nlet nodeStyle = {\n  display: \"inline-block\",\n  verticalAlign: \"top\"\n}\nlet keyStyle = isRed => ({\n  display: \"inline-block\",\n  //border: \"1px solid lightgrey\",\n  //width: \"50%\",\n  marginLeft: \"8px\",\n  marginRight: \"8px\",\n})\nlet barStyle = isRed => ({\n  display: \"inline-block\",\n  backgroundColor: isRed ? \"red\" : \"black\",\n  width: \"50%\",\n  height: \"3px\",\n  marginLeft: \"8px\",\n  marginRight: \"8px\",\n})\nfunction walk(elem) {\n  if (elem && (elem.left || elem.right)) {\n    return e(\"div\",{ style: nodeStyle },\n      e(\"div\",{style:keyStyle(elem.red),key:\"M\"+elem.key},elem.key),\n      e(\"div\",{},e(\"div\",{style:barStyle(elem.red),key:\"L\"+elem.key})),\n      e(\"div\",{},walk(elem.left),walk(elem.right)))\n  } else if (elem) {\n    return e(\"div\",{ style: nodeStyle },\n      e(\"div\",{style:keyStyle(elem.red),key:\"M\"+elem.key},elem.key))\n  } else {\n    return e(\"span\",{},\"\")\n  }\n}\n//\n// animation specifics\n//\nlet loaded = false\nfunction enterExitOrigin(b) {\n  if (loaded)\n    return {x:b.x+300,y:b.y}\n  let outer = o.getBoundingClientRect()\n  return {x:outer.x+outer.width/2, y:b.y}\n}\n//\n// example\n//\nlet style = {\n  fontSize: \"12px\",\n  minHeight: \"180px\",\n  textAlign: \"center\",\n}\ninteractiveWithSlider(0, 30, 30, style, sel => {\n  let root\n  for (let j = 0; j < selected; j++) {\n    root = insert(root, j)\n  }\n  return walk(root)\n})\nloaded = true\n</code>\n<h3>Bar Chart Race</h3>\n<aside>\n<p>Steps</p>\n<p>Load and extract data:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// data prep\n//\nlet url = \"https://gist.githubusercontent.com/johnburnmurdoch/4199dbe55095c3e13de8d5b2e5e5307a/raw/fa018b25c24b7b5f47fd0568937ff6c04e384786/city_populations\"\n// name already used!\ndata = await new Promise((succ,fail) => {\n  let req = new XMLHttpRequest();\n  req.addEventListener(\"load\", (e) => succ(req.response))\n  req.addEventListener(\"error\", (e) => fail(req.statusText))\n  req.addEventListener(\"abort\", (e) => fail(req.statusText))\n  req.open(\"GET\", url);\n  req.send();\n})\nlet lines = data.split('\\n')\nprint(lines[0].split(','))\nlet indexByYear = new Array(2020)\nlet len = lines.length\nlet schema = lines[0].split(',')\nlet filter = [0,2,3] // name, year, value\nfor (let j = 1; j < len; j++) {\n  let cols = lines[j].split(',')\n  let [name,year,value] = [cols[0],Number(cols[2]),Number(cols[3])]\n  if (!indexByYear[year]) indexByYear[year] = []\n  indexByYear[year].push({name, value})\n}\nfor (let j = 1500; j <= 2020; j++) {\n  indexByYear[j].sort((a,b) => a.value <= b.value ? 1 : -1)\n}\n//\n// example\n//\nprint(\"1980:\")\nfor (let a of indexByYear[1980])\n  print(a.name+\" \"+a.value)\n</code>\n<p>Make it interactive:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// data prep\n//\nlet url = \"https://gist.githubusercontent.com/johnburnmurdoch/4199dbe55095c3e13de8d5b2e5e5307a/raw/fa018b25c24b7b5f47fd0568937ff6c04e384786/city_populations\"\n// name already used!\ndata = await new Promise((succ,fail) => {\n  let req = new XMLHttpRequest();\n  req.addEventListener(\"load\", (e) => succ(req.response))\n  req.addEventListener(\"error\", (e) => fail(req.statusText))\n  req.addEventListener(\"abort\", (e) => fail(req.statusText))\n  req.open(\"GET\", url);\n  req.send();\n})\nlet lines = data.split('\\n')\nlet indexByYear = new Array(2020)\nlet len = lines.length\nlet schema = lines[0].split(',')\nlet filter = [0,2,3] // name, year, value\nfor (let j = 1; j < len; j++) {\n  let cols = lines[j].split(',')\n  let [name,year,value] = [cols[0],Number(cols[2]),Number(cols[3])]\n  if (!indexByYear[year]) indexByYear[year] = []\n  indexByYear[year].push({name, value})\n}\nfor (let j = 1500; j <= 2020; j++) {\n  indexByYear[j].sort((a,b) => a.value <= b.value ? 1 : -1)\n}\n//\n// example\n//\ninteractiveWithSlider(1500, 2020, 1980, {}, year => {\n  return [e(\"b\",{},year),\n     ...indexByYear[year].map(a =>\n       e(\"div\",{},a.name+\": \"+a.value))]\n})\n</code>\n<p>Draw a bar chart:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// data prep\n//\nlet url = \"https://gist.githubusercontent.com/johnburnmurdoch/4199dbe55095c3e13de8d5b2e5e5307a/raw/fa018b25c24b7b5f47fd0568937ff6c04e384786/city_populations\"\n// name already used!\ndata = await new Promise((succ,fail) => {\n  let req = new XMLHttpRequest();\n  req.addEventListener(\"load\", (e) => succ(req.response))\n  req.addEventListener(\"error\", (e) => fail(req.statusText))\n  req.addEventListener(\"abort\", (e) => fail(req.statusText))\n  req.open(\"GET\", url);\n  req.send();\n})\nlet lines = data.split('\\n')\nlet indexByYear = new Array(2020)\nlet len = lines.length\nlet schema = lines[0].split(',')\nlet filter = [0,2,3] // name, year, value\nfor (let j = 1; j < len; j++) {\n  let cols = lines[j].split(',')\n  let [name,year,value] = [cols[0],Number(cols[2]),Number(cols[3])]\n  if (!indexByYear[year]) indexByYear[year] = []\n  indexByYear[year].push({name, value})\n}\nfor (let j = 1500; j <= 2020; j++) {\n  indexByYear[j].sort((a,b) => a.value <= b.value ? 1 : -1)\n}\n//\n// example\n//\nlet labelStyle = {\n  display: \"inline-block\",\n  overflow: \"hidden\",\n  width: \"150px\",\n}\nlet barStyle = ratio => ({\n  display: \"inline-block\",\n  border: \"1px solid black\",\n  width: ratio * 450 + \"px\",\n  textAlign: \"right\",\n  fontSize: \"12px\",\n  padding: \"3px\",\n})\nplayDelay = 400\ninteractiveWithSlider(1500, 2020, 1980, {width:\"600px\"}, year => {\n  let out = [e(\"b\",{},year)]\n  let entries = indexByYear[year]\n  let max = entries[0].value\n  for (let a of entries) {\n    let d = e(\"div\",{style: labelStyle},a.name)\n    let v = e(\"div\",{style: barStyle(a.value/max)},Math.round(a.value))\n    out.push(e(\"div\",{},d,v))\n  }\n  return out\n})\n</code>\n<p>To animate it smoothly, we‚Äôll want to use linear easing for the bar growth. Using the scale attribute is bouncy, so here we‚Äôll use width instead.</p>\n</aside>\n<p>Here is a popular ‚ÄúBar Chart Race‚Äù, animating a chart of\nthe most populous cities since 1500:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// data prep\n//\nlet url = \"https://gist.githubusercontent.com/johnburnmurdoch/4199dbe55095c3e13de8d5b2e5e5307a/raw/fa018b25c24b7b5f47fd0568937ff6c04e384786/city_populations\"\n// name already used!\ndata = await new Promise((succ,fail) => {\n  let req = new XMLHttpRequest();\n  req.addEventListener(\"load\", (e) => succ(req.response))\n  req.addEventListener(\"error\", (e) => fail(req.statusText))\n  req.addEventListener(\"abort\", (e) => fail(req.statusText))\n  req.open(\"GET\", url);\n  req.send();\n})\nlet lines = data.split('\\n')\nlet indexByYear = new Array(2020)\nlet len = lines.length\nlet schema = lines[0].split(',')\nlet filter = [0,2,3] // name, year, value\nfor (let j = 1; j < len; j++) {\n  let cols = lines[j].split(',')\n  let [name,year,value] = [cols[0],Number(cols[2]),Number(cols[3])]\n  if (!indexByYear[year]) indexByYear[year] = []\n  indexByYear[year].push({name, value})\n}\nfor (let j = 1500; j <= 2020; j++) {\n  indexByYear[j].sort((a,b) => a.value <= b.value ? 1 : -1)\n}\n//\n// animation specifics: linear easing and no scaling\n//\nlet loaded = false\nfunction enterExitOrigin(b) {\n  if (loaded)\n    return {x:b.x,y:b.y+100}\n  else\n    return {x:b.x-300,y:b.y}\n}\nfunction enterExitScale(e) {\n  return 1\n}\nfunction animateMove2(newChild,parentDelta) {\n  // snappy vs smooth\n  //newChild.dom.getAnimations().forEach(a => a.cancel())\n  let b = newChild.box\n  let b2 = newChild.dom.getBoundingClientRect()\n  let dx = b.x - b2.x\n  let dy = b.y - b2.y\n  newChild.dom.animate([\n    { transform: 'translate('+dx+'px,'+dy+'px)',\n      width: b.width+\"px\",\n    transformOrigin: 'top left' },\n    { transform: 'translate(0px,0px) scale(1,1)'  }\n  ], {\n    duration: 400,\n    easing: \"linear\",\n    //composite: \"accumulate\",\n  })\n  return parentDelta\n}\n//\n// example\n//\nlet labelStyle = {\n  display: \"inline-block\",\n  overflow: \"hidden\",\n  width: \"100px\",\n}\nlet barStyle = ratio => ({\n  display: \"inline-block\",\n  border: \"1px solid black\",\n  width: ratio * 500 + \"px\",\n  textAlign: \"right\",\n  fontSize: \"12px\",\n  padding: \"3px\",\n})\nplayDelay = 400\ninteractiveWithSlider(1500, 2020, 1980, {fontSize:\"12px\",width:\"600px\"}, year => {\n  let out = [e(\"b\",{},year)]\n  let entries = indexByYear[year]\n  let max = entries[0].value\n  for (let a of entries) {\n    let d = e(\"div\",{key:\"L\"+a.name,style: labelStyle},a.name)\n    let v = e(\"div\",{key:\"B\"+a.name,style: barStyle(a.value/max)},Math.round(a.value))\n    out.push(e(\"div\",{},d,v))\n  }\n  return out\n})\nloaded = true\n</code>\n<p>Inspired by and using data from <a href=\"https://observablehq.com/@johnburnmurdoch/bar-chart-race-the-most-populous-cities-in-the-world\">here</a>.</p>","fields":{"slug":"/Public/Generic/smooth-tree-animation/"},"frontmatter":{"date":"2021-01-13","title":"Smooth DOM Tree Animation","description":"Animating layout changes due to structural DOM tree modifications: enter, exit, move, resize. Physical DOM and virtual DOM with React-style diff/reconciliation.","keywords":"DOM, animation, WAAPI, Web Animations API, FLIP, First Last Invert Play, CSS transitions, Left Leaning Red-Back Trees, Red-Black Tree Balancing, Bar Chart Race, React, virtual DOM, reconciliation","tags":null}}},{"node":{"excerpt":"Implementation Basics DOM utils LCS/core Diff Diff lexer Smooth scrolling UI: takes a sequence of edits, and animates them character by‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p></p>\n<aside>\n<p>Implementation</p>\n<aside>\n<p>Basics</p>\n<p>DOM utils</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction findOffsetInParent(node, pos, top) {\n    if (node == top)\n        return pos;\n    while (node.previousSibling) {\n        node = node.previousSibling;\n        var len = node.nodeType == 3 ? node.length : node.innerText.length;\n        pos = len + pos;\n    }\n    return findOffsetInParent(node.parentNode, pos, top);\n}\nfunction findChildForOffset(node, pos) {\n    var len = node.nodeType == 3 ? node.length : node.innerText.length;\n    if (pos > len)\n        return findChildForOffset(node.nextSibling, pos - len);\n    if (node.firstChild)\n        return findChildForOffset(node.firstChild, pos);\n    return {node: node, pos: pos};\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nfunction slider(min, max, value, eh) {\n  const e = document.createElement(\"input\")\n  e.type = \"range\"\n  e.min = min\n  e.max = max\n  e.value = value\n  e.addEventListener(\"input\",eh)\n  o.appendChild(e)\n  return e\n}\nfunction menu(ks, f) {\n  let os = Object.entries(ks).map(([k,v]) => e(\"option\",{value:k},v))\n  const el = e(\"select\",{onChange:f},...os)\n  o.appendChild(el)\n  return el\n}\nlet panels = {}\nfunction panel(str,d) {\n  let sum = e(\"summary\",{},str)\n  sum.style[\"outline\"] = \"none\"\n  sum.addEventListener(\"click\", ev => panels[str] = !det.open)\n  let det = e(\"details\",{},sum,d)\n  if (str in panels)\n    det.open = panels[str]\n  o.appendChild(det)\n}\n// ------------------------------------------------------------\n// core dom utils\n// ------------------------------------------------------------\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\nfunction dom(...es) {\n  return e(\"span\",{},...es)\n}\n</code>\n<p>LCS/core Diff</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// exercise: use global accumulator for optimization!\nfunction lcs(as, bs, a0, a1, b0, b1) {\n    // skip equivalent items at top and bottom\n    let hs = [], ts = []\n    while (as[a0] == bs[b0] && a0 < a1 && b0 < b1) {\n      hs.push(as[a0]); a0++; b0++\n    }\n    while (as[a1-1] == bs[b1-1] && a0 < a1 && b0 < b1) {\n      ts.push(as[a1-1]); a1--; b1--\n    }\n    ts.reverse()\n    // build histogram\n    let hist = {}\n    for (let i = a0; i < a1; i++) {\n      let rec = hist[as[i]]\n      if (rec) { rec.ac++; rec.ai = i }\n      else hist[as[i]] = { ac: 1, ai: i, bc: 0, bi: -1 }\n    }\n    for (let i = b0; i < b1; i++) {\n      let rec = hist[bs[i]]\n      if (rec) { rec.bc++; rec.bi = i }\n      else hist[bs[i]] = { ac: 0, ai: -1, bc: 1, bi: i }\n    }\n    // find lowest-occurrence item that appears in both\n    let cmp = Number.MAX_VALUE\n    let p = null\n    for (let k in hist) {\n      let rec = hist[k]\n      if (rec.ac > 0 && rec.bc > 0 && rec.ac + rec.bc < cmp) {\n        p = k; cmp = rec.ac + rec.bc\n      }\n    }\n    if (!p) return [...hs,...ts]\n    let rec = hist[p]\n    return [...hs, ...lcs(as,bs,a0,rec.ai,b0,rec.bi),\n                p, ...lcs(as,bs,rec.ai+1,a1,rec.bi+1,b1), ...ts]\n}\nfunction diff(as,bs,sameChunk,diffChunk) {\n  //print(\"A:\"+as.map(o => o.gap+\"/\"+o.val))\n  //print(\"B:\"+bs.map(o => o.gap+\"/\"+o.val))\n  let ds = lcs(as.map(a => a.val), bs.map(a => a.val), 0, as.length, 0, bs.length)\n  let ai = 0\n  let bi = 0\n  for (let di = 0; di < ds.length; di++) {\n    let del = []\n    let ins = []\n    // need to check if beginning gap is same\n    // (default: treat as different) -- could also do this partially\n    if (ai < as.length && bi < bs. length && as[ai].gap == bs[bi].gap) {\n      sameChunk(as[ai].gap); as[ai].gap = \"\"; bs[bi].gap = \"\"\n    }\n    while (ai < as.length && as[ai].val != ds[di]) {\n      del.push(as[ai++])\n    }\n    while (bi < bs.length && bs[bi].val != ds[di]) {\n      ins.push(bs[bi++])\n    }\n    // need to check if beginning gap is different!\n    // (default: treat as same)\n    let gap = \"\"\n    if (ai < as.length && bi < bs.length && as[ai].gap == bs[bi].gap) {\n      gap = bs[bi].gap\n    } else {\n      del.push({gap: as[ai].gap, val: \"\"})\n      ins.push({gap: bs[bi].gap, val: \"\"})\n    }\n    diffChunk(del,ins)\n    sameChunk(gap+ds[di]); ai++; bi++\n  }\n  let del = []\n  let ins = []\n  // check if beginning gap is same\n  if (ai < as.length && bi < bs. length && as[ai].gap == bs[bi].gap) {\n    sameChunk(as[ai].gap); as[ai].gap = \"\"; bs[bi].gap = \"\"\n  }\n  while (ai < as.length) {\n    del.push(as[ai++])\n  }\n  while (bi < bs.length) {\n    ins.push(bs[bi++])\n  }\n  diffChunk(del,ins)\n}\n</code>\n<p>Diff lexer</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction tokenize(input) {\n  let pos = 0\n  let out = []\n  let isAlpha = c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n  let isNum = c => (c >= '0' && c <= '9')\n  let isEOF = c => !c\n  let isGap = c => (!isAlpha(c) && !isNum(c) && !isEOF(c) &&\n(c != '\\n') && (c != '}' && (c != \"{\") && (c != ')' && (c != \"(\")))\n)\n  while(input[pos]) {\n    let gap = \"\"\n    let val = \"\"\n    if (isGap(input[pos])) {\n      while (isGap(input[pos])) gap += input[pos++]\n    }\n    if (isAlpha(input[pos])) {\n      while (isAlpha(input[pos])) val += input[pos++]\n    } else if (isNum(input[pos])) {\n      while (isNum(input[pos])) val += input[pos++]\n    } else if (input[pos]) val += input[pos++]\n    out.push({gap,val})\n  }\n  return out\n}\n</code>\n<p>Smooth scrolling UI: takes a sequence of edits, and animates them character by character</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet p,r,c,q\nlet slido\nlet delay = 100\nlet playing = false\nlet reading = false\nlet waiting = false\nlet wantMusic = true\nlet wantNarration = true\nfunction setupSmooth() {\np = document.createElement(\"pre\")\nr = document.createElement(\"div\")\nc = document.createElement(\"div\")\nq = document.createElement(\"pre\")\np.appendChild(document.createTextNode(\"init\"))\no.appendChild(p)\no.appendChild(r)\no.appendChild(c)\np.setAttribute(\"contenteditable\", false)\np.setAttribute(\"spellcheck\", false)\np.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\np.style[\"border\"] = \"1px solid black\"\np.style[\"width\"] = \"600px\"\np.style[\"minHeight\"] = \"200px\"\np.style[\"outline\"] = \"none\"\np.addEventListener(\"beforeinput\", ev => {\n  ev.preventDefault()\n})\nbutton(\"|<\", rewindHistory)\nbutton(\"<<\", prevEdit)\nbutton(\"<\", prevChar)\nbutton(\">\", nextChar)\nbutton(\">>\", nextEdit)\nbutton(\"‚ñ∂Ô∏é\", ev => { playing = !playing; waiting=false; runNext() })\nslido = slider(0, charMax, charPos, (e) => seekCharPos(Number(e.target.value),true))\nslido.style[\"width\"] = \"50%\"\npanel(\"Internal\",q)\n}\nfunction printq(e) {\n  q.appendChild(document.createTextNode(String(e)))\n}\nfunction edit(start, end, data) {\n  let txt = p.innerText\n  p.innerText = txt.substring(0, start) + data + txt.substring(end, txt.length)\n}\nfunction select(start, end) {\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n  let el = extent.node\n  if (!(el instanceof Element)) {\n    //return\n    el = el.parentElement\n  }\n  el.scrollIntoView({behavior: \"smooth\", block: \"nearest\", inline: \"nearest\"})\n}\nfunction setCaption(data) {\n  c.innerText = data\n}\nlet edits = [] // [{ start: 0, end: 0, old: \"\", data: p.innerText, mode: \"type\" }]\nlet position = 0\nlet charMax = 0\nlet charPos = charMax\nlet charPosWithin = 0\nlet snapshot = \"\"\nfunction rewindHistory() {\n  position = 0\n  charPos = 0\n  charPosWithin = 0\n  p.innerText = \"\"\n  snapshot = \"\"\n  updateQ()\n}\nfunction elimPartialEdit() {\n  if (charPosWithin > 0) {\n    //let e = edits[position]\n    //edit(e.start, charPosWithin, \"\")\n    p.innerText = snapshot\n// TODO: caption\n    charPos -= charPosWithin\n    charPosWithin = 0\n  }\n}\nfunction nextEdit() {\n  if (position < edits.length) {\n    elimPartialEdit()\n    let e = edits[position++]\n    charPos += calcEditLength(e)\n// TODO: caption\n    if (e.mode == \"caption\")\n      setCaption(e.data)\n    else {\n      edit(e.start, e.end, e.data)\n      select(e.start+e.data.length,e.start+e.data.length)\n      snapshot = p.innerText\n    }\n    updateQ()\n  }\n}\nfunction prevEdit() {\n  if (charPosWithin > 0) {\n    elimPartialEdit() // TODO: absorb\n  } else if (position > 0) {\n    let e = edits[--position]\n    charPos -= calcEditLength(e)\n// TODO: caption\n    if (e.mode == \"caption\") {\n    } else {\n      edit(e.start, e.start + e.data.length, e.old)\n      select(e.start,e.end)\n      snapshot = p.innerText\n    }\n    updateQ()\n  }\n}\nfunction nextChar() {\n  seekCharPos(charPos+1,true)\n}\nfunction prevChar() {\n  seekCharPos(charPos-1,true)\n}\nlet time = 0\nlet tickHandler\nfunction tick() {\n  if (tickHandler) {\n    try {\n      tickHandler(time)\n    } catch (ex) {\n      // silent... but disable\n      tickHandler = null\n    }\n  }\n  //time++\n}\nfunction runNext() {\n  if (!playing) return\n  if (charPos >= charMax)\n    seekCharPos(0)\n  if (!(waiting && window.window.speechSynthesis.speaking)) {\n    waiting = false\n    nextChar()\n  }\n  tick()\n  if (charPos < charMax) setTimeout(runNext,delay)\n  else playing = false\n}\nfunction calcEditLength(e) {\n  if (e.mode == \"type\")\n    return e.old.length + e.data.length\n  if (e.mode == \"appear\") // \"appear\" will just appear\n    return 1\n  if (e.mode == \"wait\")\n    return 100 // todo: make adjustable\n  if (e.mode == \"caption\")\n    return 2\n  assert(false, \"unknown edit mode: \"+e.mode)\n}\nfunction calcPartialEdit(e,len) {\n  if (e.mode == \"type\")\n    if (len < e.old.length)\n      return {start:e.start, end:e.end, data:e.old.slice(0,e.old.length-len)}\n    else\n      return {start:e.start, end:e.end, data:e.data.slice(0,len-e.old.length)}\n  if (e.mode == \"appear\")\n    if (len) return e\n    else return {start:e.start, end:e.end, data:e.old}\n  if (e.mode == \"caption\")\n    return e\n  if (e.mode == \"wait\")\n    return e\n  assert(false, \"unknown edit mode: \"+e.mode)\n}\nfunction recalcRangeMax() {\n  charMax = 0\n  for (let e of edits) {\n    charMax += calcEditLength(e)\n  }\n  slido.max = charMax\n}\nfunction seekCharPos(pos,sel) {\n  let scroll = p.scrollTop\n  // TODO: do not rewind all the way!\n  if (pos < charPos) // TODO: use prev!\n    rewindHistory()\n  elimPartialEdit()\n  while (position < edits.length && charPos + calcEditLength(edits[position]) <= pos)\n    nextEdit()\n  if (position < edits.length) {\n    let off = pos - charPos\n    let e = calcPartialEdit(edits[position], off)\n    if (e.mode == \"wait\")\n      time = off\n    else if (e.mode == \"type\")\n      time = 0\n    // do not set for caption, appear: hack! to preserve\n    // last animation step\n    exec() // beginning of frame -- assume this is good\n    if (e.mode == \"caption\") {\n      if (off > 0) setCaption(e.data)\n      if (playing && off == 0 && reading) { waiting = true }\n      if (playing && off == 1) readCaption(e.data)\n      // anti glitch\n      p.innerText = \"\"; p.appendChild(tok(snapshot))\n      p.scrollTop = scroll\n    } else if (e.mode == \"wait\") {\n      // anti glitch\n      p.innerText = \"\"; p.appendChild(tok(snapshot))\n      p.scrollTop = scroll\n    } else {\n      edit(e.start, e.end, e.data)\n      if (sel) {\n        p.scrollTop = scroll // reduce jerkiness\n        select(e.start + e.data.length, e.start + e.data.length)\n      }\n    }\n    if (off == 0) exec() // again??\n    //exec() // too much jerkiness when run on each char\n    charPosWithin = off\n    charPos = pos\n    updateQ()\n  }\n  q.innerText += \"\\n\\nChar pos: \"+charPos\n  slido.value = charPos\n}\nfunction readCaption(data) {\n  if (!wantNarration) return\n  // could require an option to enable tts\n  let msg = new SpeechSynthesisUtterance();\n  msg.pitch = 0.9\n  msg.rate = 1.1\n  msg.text = data\n/*\n  msg.addEventListener(\"pause\", ev => {\n    print(\"(pause speaking)\")\n  })\n  msg.addEventListener(\"error\", ev => {\n    print(\"(error speaking)\")\n  })\n  msg.addEventListener(\"end\", ev => {\n    //print(\"(end speaking)\")\n    setTimeout(() => {\n      reading = false\n      if (playing && waiting) {\n        //print(\"...resume\")\n        waiting = false; runNext()\n      }\n    }, 600)\n  })\n*/\n  window.speechSynthesis.speak(msg)\n  reading = true\n}\nfunction exec() {\n  function print(s) {\n    emit(e(\"div\",{},String(s)))\n  }\n  function emit(e) {\n    r.appendChild(e)\n  }\n  function onTick(f) {\n    tickHandler = f\n  }\n  function done() {\n    let emailField = e(\"input\", {type:\"email\", placeholder:\"Enter your email here\", name:\"entry.1556369182\"})\n    let hiddenField =e(\"input\", {type:\"hidden\", name:\"entry.1724678596\", value:\"It is OK to send me email about related things, such as new blog posts, no more than once every few weeks\"})\n    let submitButton = e(\"input\", {type:\"submit\"})\n    let emailForm = e(\"form\", {method:\"get\", target:\"_fresh\",\n  action:\"https://docs.google.com/forms/d/e/1FAIpQLSeDI5dwvfuKWyqxJEWIrtRZqfQZjPXlQq0LoaYR1_-9sCuIlA/viewform?\"}, emailField, hiddenField, submitButton)\n    let t = e(\"div\",{},\"Comments? Questions? Would you use a tool like this?\",emailForm,\"or reach out on Twitter \", e(\"a\",{target:\"_blank\", href:\"https://twitter.com/tiarkrompf\"}, \"@tiarkrompf\"))\n    r.appendChild(t)\n    t.style.position = \"absolute\"\n    t.style.fontSize = \"14px\"\n    t.style.border = \"1px solid grey\"\n    t.style.padding = \"5px\"\n    t.style.top = \"120px\"\n    t.style.left = \"260px\"\n    t.style.width = \"240px\"\n  }\n  let src = `() => {${p.innerText}}`\n  try {\n    let f = eval(src)\n    r.innerText = \"\"\n    tickHandler = null\n    f()\n  } catch (ex) {\n    // silent atm!\n    //r.innerText = ex\n  }\n}\nfunction updateQ() {\n  let strs = edits.map(e => `  ${e.start}-${e.end} ${e.mode}: ${e.old}->${e.data}`.replaceAll(\"\\n\",\"‚èé\"))\n  strs.push(\" \")\n  strs[position] = \"*\"+strs[position].substring(1)\n  q.innerText = strs.join(\"\\n\")\n  // TODO: update slider\n}\n</code>\n<p>Diff UI: edits a sequence of keyframes, extracts list of edits and provides those to scrolling UI</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet keyframes = [] // init with {mode:\"type\",caption:\"hello\",text:\"init\"}\nlet textboxes = []\nlet selection = null\nlet container\nfunction setupDiff() {\ncontainer = document.createElement(\"div\")\ncontainer.style[\"width\"] = \"600px\"\nlet btn = button(\"export\", () => {\n  o.appendChild(e(\"pre\",{},\"keyframes = \"+JSON.stringify(keyframes)\n    .replaceAll('\"mode\"','mode')\n    .replaceAll('\"text\"','text')\n    .replaceAll('\\\\\"','‚àÇ').replaceAll('\\\"','`').replaceAll('‚àÇ','\"')\n    .replaceAll('\\\\n','\\n')))\n})\npanel(\"Edit\", e(\"div\",{},container,btn))\n}\nfunction patch(txt, start, end, data) {\n  return txt.substring(0, start) + data + txt.substring(end, txt.length)\n}\nfunction render() {\n  if (keyframes.length != textboxes.length) {\n    container.innerHTML = \"\"\n    textboxes = []\n  }\n  edits = []\n  charMax = 0\n  //edits.push({ start, end, old, data })\n  //charMax += data.length // - old.length\n  //charPos = charMax\n  //charPosWithin = 0\n  for (let k in keyframes) {\n    renderKeyframe(k)\n  }\n  recalcRangeMax()\n  let p = charPos\n  rewindHistory()\n  seekCharPos(p,false)\n  if (selection)\n    renderSelection(selection.index, selection.start, selection.end)\n}\nfunction renderKeyframe(kindex) {\n  let p = textboxes[kindex]\n  // ---- extra edit for caption\n  if (keyframes[kindex].caption) {\n    if (keyframes[kindex].caption == \"#wait\")\n      edits.push({start:0, end:0, old: \"\", data: \"\", mode: \"wait\"})\n    else\n      edits.push({start:0, end:0,\n        old:kindex > 0 ? keyframes[kindex-1].caption : \"\",\n        data:keyframes[kindex].caption,\n        mode:\"caption\"})\n    }\n  // ---- diff logic follows ----\n  let editPos = 0\n  function diffChunk(as,bs) {\n    if (as.length == 0 && bs.length == 0) return\n    let u = as.map(o => o.gap+o.val).join(\"\") // TODO: gap!\n    let a = bs.map(o => o.gap+o.val).join(\"\") // TODO: gap!\n    edits.push({start:editPos, end:editPos+u.length,\n      old:u, data:a, mode:keyframes[kindex].mode})\n    editPos += a.length\n    let span = document.createElement(\"span\")\n    span.style[\"background\"] = \"#AAFFAA\"\n    span.style[\"padding\"] = \"2px\"\n    span.setAttribute(\"title\", u)\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert '\"+a+\"' to '\"+u+\"'?\")) {\n        // TODO: do this properly, call recordEdit with the right indices\n        span.style[\"background\"] = \"none\"\n        span.style[\"padding\"] = \"0px\"\n        span.innerText = u\n      }\n    })\n  }\n  function sameChunk(a) {\n    editPos += a.length\n    let span = document.createElement(\"span\")\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n  }\n  // ---- diff logic end ----\n  if (!p) {\n    p = textboxes[kindex] = document.createElement(\"pre\")\n    let div = document.createElement(\"div\")\n    div.style[\"display\"] = \"flex\"\n    container.appendChild(div)\n    let c = document.createElement(\"pre\") // caption\n    container.appendChild(c)\n    container.appendChild(button(\"Remove\", ev => {keyframes.splice(kindex,1); render()}))\n    container.appendChild(button(\"Add\", ev => {keyframes.splice(kindex,0,{...keyframes[kindex]}); render()}))\n    let choices = {\n      type: \"Char-by-char\",\n      appear: \"All at once\",\n    }\n    // TODO: update menu also on update (necessary?)\n    let m = menu(choices, ev => {keyframes[kindex].mode = ev.target.value; render()})\n    m.value = keyframes[kindex].mode\n    container.appendChild(m)\n    div.appendChild(p)\n    // style text entry\n    p.setAttribute(\"contenteditable\", true)\n    p.setAttribute(\"spellcheck\", false)\n    //p.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\n    p.style[\"border\"] = \"1px solid grey\"\n    p.style[\"width\"] = \"600px\"\n    p.style[\"min-height\"] = \"100px\"\n    p.style[\"padding\"] = \"5px\"\n    p.style[\"margin\"] = \"0px\"\n    p.style[\"outline\"] = \"none\"\n    p.style[\"letter-spacing\"] = \"2px\"\n    p.addEventListener(\"beforeinput\", ev => inputEvent(ev,kindex))\n    p.addEventListener(\"focus\", ev => selection = {index:kindex, start:0, end: 0})\n    // style caption entry\n    c.setAttribute(\"contenteditable\", true)\n    c.setAttribute(\"spellcheck\", false)\n    c.style[\"border\"] = \"1px solid grey\"\n    c.style[\"width\"] = \"600px\"\n    //c.style[\"min-height\"] = \"100px\"\n    c.style[\"padding\"] = \"5px\"\n    c.style[\"margin\"] = \"0px\"\n    c.style[\"margin-top\"] = \"3px\"\n    c.style[\"outline\"] = \"none\"\n    c.style[\"letter-spacing\"] = \"2px\"\n    //c.addEventListener(\"input\", ev => {keyframes[kindex].caption = ev.target.textContent; ev.target.focus(); render()})\n    // FIXME: selection update!\n    c.addEventListener(\"input\", ev => {keyframes[kindex].caption = ev.target.textContent })\n    c.addEventListener(\"change\", ev => { render() })\n    c.innerText = keyframes[kindex].caption\n  } else {\n    p.innerHTML = \"\"\n  }\n  let prev = kindex > 0 ? tokenize(keyframes[kindex-1].text) : []\n  let next = tokenize(keyframes[kindex].text)\n  diff(prev, next, sameChunk, diffChunk)\n  p.appendChild(document.createTextNode(\"\\n\"))\n}\nfunction renderSelection(index, start, end) {\n  let p = textboxes[index]\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\nfunction inputEvent(ev, kindex) {\n  let p = textboxes[kindex]\n  ev.preventDefault()\n  let data = ev.data || (ev.dataTransfer && ev.dataTransfer.getData(\"text/plain\")) || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  recordEdit(kindex, start, end, data)\n  render()\n}\nfunction recordEdit(kindex, start, end, data) {\n  keyframes[kindex].text = patch(keyframes[kindex].text, start, end, data)\n  selection = {index: kindex, start: start+data.length, end: start+data.length}\n}\n</code>\n<p>Main program</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ----- main program -----\nfunction run() {\n  setupSmooth()\n  setupDiff()\n  render()\n}\n</code>\n</aside>\n<aside>\n<p>Examples</p>\n<h3>Example 1: Code editing</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nkeyframes = [{mode:`type`,text:`// let's write some code!`},{mode:`type`,text:`// let's write some code!\nfunction foo() {\\n\\n}\n`},{mode:`type`,text:`// let's write some code!\nfunction foo() {\n  print(\"yo\")\n}\n`},{mode:`type`,text:`// let's write some code!\nfunction boo(arg) {\n  print(\"ho\")\n}\n`},{mode:`type`,text:`// let's write some code!\nprint(\"yo\")\n`},{mode:`type`,text:`// we're done!\nprint(\"yo\")\n`}]\nrun()\n</code>\n<h3>Example 2: Shell Interaction</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nkeyframes = [{mode:`appear`,text:`shell> `},{mode:`type`,text:`shell> ls -la`},{mode:`appear`,text:`shell> ls -la\nfoo\nbar\nbaz\nbla\nshell> `},{mode:`appear`,text:`shell> ls -la\nfoo\nbar\nbaz\nbla\nshell> `},{mode:`type`,text:`shell> ls -la\nfoo\nbar\nbaz\nbla\nshell> rm -rf foo`},{mode:`appear`,text:`shell> ls -la\nfoo\nbar\nbaz\nbla\nshell> rm -rf foo\nerror: insufficient permissions\nshell> `},{mode:`type`,text:`shell> ls -la\nfoo\nbar\nbaz\nbla\nshell> rm -rf foo\nerror: insufficient permissions\nshell> chmod a+rw foo`},{mode:`appear`,text:`shell> ls -la\nfoo\nbar\nbaz\nbla\nshell> rm -rf foo\nerror: insufficient permissions\nshell> chmod a+rw foo\nshell> `},{mode:`appear`,text:`shell> `},{mode:`type`,text:`shell> rm -rf foo`},{mode:`appear`,text:`shell> rm -rf foo\nshell> `},{mode:`type`,text:`shell> rm -rf foo\nshell> ls -la`},{mode:`appear`,text:`shell> rm -rf foo\nshell> ls -la\nbar\nbaz\nbla\nshell> `}]\ncharPos = 1\nrun()\n</code>\n</aside>\n<aside>\n<p>Prettify!</p>\n<p>Concept: Inspired by <a href=\"https://carbon.now.sh\">https://carbon.now.sh</a>, Seti color scheme</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet src = `const pluckDeep = key => obj => key.split('.').reduce((accum, key) => accum[key], obj)\n\\n\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res)\n\\n\nconst unfold = (f, seed) => {\n  const go = (f, seed, acc) => {\n    const res = f(seed)\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc\n  }\n  return go(f, seed, [])\n}\n\\n\n`\nlet colors = {\nblue: \"rgb(85,181,219)\",\ngreen: \"rgb(159,202,86)\",\nyellow: \"rgb(230,205,105)\",\nred: \"rgb(205,63,69)\",\npurple: \"rgb(160,116,196)\",\n}\nfunction tok(input) {\n  let pos = 0\n  let out = []\n  let isAlpha = c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n  let isNum = c => (c >= '0' && c <= '9')\n  let isOpr = c => (c == '=' || c == '<' || c == '>' || c == '?')\n  let isGap = c => (c == ' ' || c == '\\n')\n  while(input[pos]) {\n    let start = pos\n    if (isGap(input[pos])) {\n      while (isGap(input[pos])) pos++\n    }\n    out.push(input.slice(start,pos))\n    start = pos\n    let color\n    if (isAlpha(input[pos])) {\n      while (isAlpha(input[pos]) || isNum(input[pos])) pos++\n      let str = input.slice(start,pos)\n      if (str == \"const\" || str == \"return\")\n        color = colors.yellow\n      else if (input[pos] == '.' || input[pos] == '(')\n        color = colors.purple\n      else\n        color = colors.blue\n    } else if (isNum(input[pos])) {\n      while (isNum(input[pos])) pos++\n      color = colors.red\n    } else if (isOpr(input[pos])) {\n      while (isOpr(input[pos])) pos++\n      color = colors.green\n    } else if (input[pos]) {\n      pos++\n    }\n    if (color) {\n      let d = dom(input.slice(start,pos))\n      d.style.color = color\n      out.push(d)\n    } else\n      out.push(input.slice(start,pos))\n  }\n  return dom(...out)\n}\n//\n//\nlet emit = (e) => o.appendChild(e)\nfunction esvg(tag, props, ...children) {\n  let el = document.createElementNS('http://www.w3.org/2000/svg', tag)\n  for (let k in props)\n    el.setAttribute(k,props[k])\n  for (let e of children)\n    el.appendChild(e)\n  return el\n}\n//\n// text pane\n//\nlet inner = e(\"pre\",{},tok(src))\n//inner.style.border = \"1px solid white\"\ninner.style.padding = \"0px\"\ninner.style.margin = \"10px 0px\"\ninner.style.overflow = \"scroll\"\ninner.style.color = \"#aaa\"\n//inner.style.fontFamily = \"courier\"\ninner.style.fontWeight = \"400\"\n//inner.style.fontSize = \"14px\"\ninner.style.textRendering = \"optimizeLegibility\"\ninner.style[\"-webkit-font-smoothing\"] = \"antialiased\"\n//\n// window control buttons\n//\nlet bbb = esvg(\"svg\", {width:54, height:14, viewBox: \"0 0 54 14\"},\nesvg(\"g\",{transform:\"translate(0 0)\"},\nesvg(\"circle\",{cx:6,cy:6,r:6, fill:\"#FF5F56\"}),\nesvg(\"circle\",{cx:26,cy:6,r:6, fill:\"#FFBD2E\"}),\nesvg(\"circle\",{cx:46,cy:6,r:6, fill:\"#27C93F\"})\n))\n//\n//\n//\n//\n//\n//\n//\n//bbb.style.border = \"1px solid white\"\n//bbb.style.position = \"absolute\"\nbbb.style.width = \"64px\"\nbbb.style.marginTop = \"8px\"\n// spacer\nlet ccc = e(\"span\",{}) // occupy space on the right\nccc.style.width = \"54px\"\n//\n// window title\n//\nlet label = e(\"span\",{}, \"./code/source.js\")\n//label.style.border = \"1px solid white\"\n//label.style.display = \"inline-block\"\nlabel.style.textAlign = \"center\"\nlabel.style.width = \"100%\"\nlabel.style.margin = \"0px\"\nlabel.style.padding = \"-10px\"\n// should be height = 24\n//\n// window title bar\n//\nlet title = e(\"div\",{}, bbb, label, ccc)\n//title.style.border = \"1px solid white\"\ntitle.style.display = \"flex\"\ntitle.style.alignItems = \"center\"\ntitle.style.margin = \"0px\"\n//\n// window frame\n//\nlet frame = e(\"div\",{},title,inner)\nframe.style.background = \"rgb(21,23,24)\"\nframe.style.color = \"white\"\n//frame.style.border = \"1px solid white\"\nframe.style.padding = \"2px 12px\"\nframe.style.margin = \"0px\"\nframe.style.borderRadius = \"10px\"\nframe.style.boxShadow = \"0px 20px 40px rgb(53,57,60)\" // offset-x, offset-y, blur-radius\nframe.style.transform = \"rotateY(15deg)\"\n//\n// background\n//\nlet caption = e(\"span\",{},\"Howdy Ho, and welcome to this week's episode of Prof. T's compiler corner.\")\ncaption.style.color = \"white\"\ncaption.style.fontSize = \"24px\"\ncaption.style.textAlign = \"center\"\n//caption.style.padding = \"10px\"\n//caption.style.width = \"10px\"\n//caption.style.borderRadius = \"10px\"\ncaption.style.backgroundColor = \"rgba(0,0,0,0.9)\"\n//caption.style.border = \"5px solid black\"\n//caption.style.boxShadow = \"0px 20px 40px rgb(53,57,60)\" // offset-x, offset-y, blur-radius\ncaption.style.zIndex = \"1000\"\n//caption.style.position = \"absolute\"\n//\nlet caption2 = e(\"div\",{},caption)\ncaption2.style.textAlign = \"center\"\ncaption2.style.marginTop = \"50px\"\ncaption2.style.marginBottom = \"-20px\"\n//\n//\nlet bkgnd = e(\"div\",{},frame,caption2)\n//bkgnd.style.background = \"#ABB8C3\"\nbkgnd.style.background = \"rgb(171,184,195)\" // <--- this one!\n//bkgnd.style.background = \"rgb(207,210,209)\"\nbkgnd.style.padding = \"36px\"\nbkgnd.style.fontSize = \"16px\"\nbkgnd.style.perspective = \"1000px\"\nemit(bkgnd)\n</code>\n</aside>\n<aside>\n<p>Music and text-to-speech</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n// for a convincing loop without break,\n// need to play same clip twice with tiny overlap\nif (window.adLoop) print(window.adLoop.duration)\nbutton(\"-\", ev => { if (window.adLoop) window.adLoop.volume /= 2})\nbutton(\"+\", ev => { if (window.adLoop) window.adLoop.volume *= 2})\nbutton(\"music\", ev => {\nif (window.adLoop) {\n  window.adLoop.pause()\n  window.adLoop2.pause()\n  window.adLoop = undefined\n  window.adLoop2 = undefined\n  return\n}\nwindow.adLoop = new Audio(\"http://tiarkrompf.github.io/notes/img/POL-crime-fighter-short.wav\")\nwindow.adLoop2 = new Audio(\"http://tiarkrompf.github.io/notes/img/POL-crime-fighter-short.wav\")\nwindow.adLoop.addEventListener(\"canplaythrough\", event => {\n  window.adLoop.volume /= 4\n  window.adLoop2.volume /= 4\n  //window.adLoop.loop = true\n  //window.adLoop2.loop = true\nfunction play1() {\n  if (!window.adLoop) return\n  print(\"play1\")\n  window.adLoop.play();\n  setTimeout(play2, window.adLoop.duration * 1000 - 500)\n}\nfunction play2() {\n  if (!window.adLoop2) return\n  print(\"play2\")\n  window.adLoop2.play();\n  setTimeout(play1, window.adLoop2.duration * 1000 - 500)\n}\nplay1()\n})})\nlet sentences = [\n\"Howdyho everyone\",\n\"A very good local time and welcome to this week's episode of Prof. T's live programming corner!\",\n\"This is an experiment in replacing myself with a few hundred lines of JavaScript.\",\n\"Now it's your turn! Make your own cool live programming demo. Peace out and see you soon!\"\n]\nlet senti = 0\nbutton(\"speech\", ev => {\nvar msg = new SpeechSynthesisUtterance();\nmsg.pitch = 0.9\nmsg.text = sentences[senti++]\nmsg.addEventListener(\"end\", ev => {\nprint(\"done\")\n})\nwindow.speechSynthesis.speak(msg);\n})\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction toggleMusic() {\n  if (window.adLoop) {\n    window.adLoop.pause()\n    window.adLoop2.pause()\n    window.adLoop = undefined\n    window.adLoop2 = undefined\n    return\n  }\n  window.adLoop = new Audio(\"http://tiarkrompf.github.io/notes/img/POL-crime-fighter-short.wav\")\n  window.adLoop2 = new Audio(\"http://tiarkrompf.github.io/notes/img/POL-crime-fighter-short.wav\")\n  window.adLoop.addEventListener(\"canplaythrough\", event => {\n    window.adLoop.volume /= 4\n    window.adLoop2.volume /= 4\n    //window.adLoop.loop = true\n    //window.adLoop2.loop = true\n    function play1() {\n      if (!window.adLoop) return\n      window.adLoop.play();\n      setTimeout(play2, window.adLoop.duration * 1000 - 500)\n    }\n    function play2() {\n      if (!window.adLoop2) return\n      window.adLoop2.play();\n      setTimeout(play1, window.adLoop2.duration * 1000 - 500)\n    }\n    play1()\n  })\n}\n</code>\n</aside>\n<aside>\n<p>Putting it together</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet colors = {\nblue: \"rgb(85,181,219)\",\ngreen: \"rgb(159,202,86)\",\nyellow: \"rgb(230,205,105)\",\nred: \"rgb(205,63,69)\",\npurple: \"rgb(160,116,196)\",\n}\nfunction tok(input) {\n  let pos = 0\n  let out = []\n  let isAlpha = c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n  let isNum = c => (c >= '0' && c <= '9')\n  let isOpr = c => (c == '=' || c == '<' || c == '>' || c == '?')\n  let isGap = c => (c == ' ' || c == '\\n')\n  while(input[pos]) {\n    let start = pos\n    if (isGap(input[pos])) {\n      while (isGap(input[pos])) pos++\n    }\n    out.push(input.slice(start,pos))\n    start = pos\n    let color\n    if (isAlpha(input[pos])) {\n      while (isAlpha(input[pos]) || isNum(input[pos])) pos++\n      let str = input.slice(start,pos)\n      if (str == \"const\" || str == \"return\")\n        color = colors.yellow\n      else if (input[pos] == '.' || input[pos] == '(')\n        color = colors.purple\n      else\n        color = colors.blue\n    } else if (isNum(input[pos])) {\n      while (isNum(input[pos])) pos++\n      color = colors.red\n    } else if (isOpr(input[pos])) {\n      while (isOpr(input[pos])) pos++\n      color = colors.green\n    } else if (input[pos]) {\n      pos++\n    }\n    if (color) {\n      let d = dom(input.slice(start,pos))\n      d.style.color = color\n      out.push(d)\n    } else\n      out.push(input.slice(start,pos))\n  }\n  return dom(...out)\n}\n//\n//\nlet emit = (e) => o.appendChild(e)\n//\nfunction setupSmooth() {\nlet inner = e(\"pre\",{},tok(src))\ninner.contentEditable = true\ninner.spellcheck = false\n//inner.style.border = \"1px solid white\"\ninner.style.padding = \"0px\"\ninner.style.margin = \"10px 0px\"\ninner.style.height = \"200px\"\ninner.style.overflow = \"scroll\"\ninner.style.color = \"#aaa\"\n//inner.style.fontFamily = \"courier\"\ninner.style.fontWeight = \"400\"\n//inner.style.fontSize = \"14px\"\ninner.style.textRendering = \"optimizeLegibility\"\ninner.style[\"-webkit-font-smoothing\"] = \"antialiased\"\ninner.style[\"outline\"] = \"none\"\ninner.addEventListener(\"beforeinput\", ev => {\n  ev.preventDefault()\n})\np = inner\nlet cap = caption()\ncap.style.height = \"50px\"\nc = cap.children[0]\nc.innerText = \"\"\nlet res = e(\"div\",{},\"Output goes here\")\nres.style.padding = \"0px\"\nres.style.margin = \"10px 0px\"\nres.style.minHeight = \"200px\"\n//res.style.overflow = \"scroll\"\nr = res\nemit(background(mockWindow(inner,\"./code/source.js\"), gap(), mockWindow(res,\"output\"), gap(), cap))\nq = document.createElement(\"pre\")\nbutton(\"Music\", toggleMusic)\nbutton(\"|<\", ev => seekCharPos(0,true))\n//button(\"<<\", prevEdit)\nbutton(\"<\", prevChar)\nbutton(\">\", nextChar)\n//button(\">>\", nextEdit)\nbutton(\"‚ñ∂Ô∏é\", ev => { playing=!playing; waiting=false; runNext() })\nslido = slider(0, charMax, charPos, (e) => seekCharPos(Number(e.target.value),true))\nslido.style[\"width\"] = \"50%\"\n//o.appendChild(e(\"br\"))\n//button(\"Music\", toggleMusic)\n//button(\"Narration\", toggleNarration)\n//panel(\"Internal\",q)\n}\nfunction edit(start, end, data) {\n  let txt = p.innerText\n  p.innerText = \"\"\n  p.appendChild(tok(txt.substring(0, start) + data + txt.substring(end, txt.length)))\n}\n// -- mock window follows\n/*//\n// text pane\n//\nlet inner = e(\"pre\",{},tok(src))\n//inner.style.border = \"1px solid white\"\ninner.style.padding = \"0px\"\ninner.style.margin = \"10px 0px\"\ninner.style.overflow = \"scroll\"\ninner.style.color = \"#aaa\"\n//inner.style.fontFamily = \"courier\"\ninner.style.fontWeight = \"400\"\n//inner.style.fontSize = \"14px\"\ninner.style.textRendering = \"optimizeLegibility\"\ninner.style[\"-webkit-font-smoothing\"] = \"antialiased\"\n*/\nfunction mockWindow(inner,titleStr) {\n//\n// window control buttons\n//\nfunction esvg(tag, props, ...children) {\n  let el = document.createElementNS('http://www.w3.org/2000/svg', tag)\n  for (let k in props)\n    el.setAttribute(k,props[k])\n  for (let e of children)\n    el.appendChild(e)\n  return el\n}\nlet bbb = esvg(\"svg\", {width:54, height:14, viewBox: \"0 0 54 14\"},\nesvg(\"g\",{transform:\"translate(0 0)\"},\nesvg(\"circle\",{cx:6,cy:6,r:6, fill:\"#FF5F56\"}),\nesvg(\"circle\",{cx:26,cy:6,r:6, fill:\"#FFBD2E\"}),\nesvg(\"circle\",{cx:46,cy:6,r:6, fill:\"#27C93F\"})\n))\n//\n//\n//bbb.style.border = \"1px solid white\"\n//bbb.style.position = \"absolute\"\nbbb.style.width = \"64px\"\nbbb.style.marginTop = \"8px\"\n// spacer\nlet ccc = e(\"span\",{}) // occupy space on the right\nccc.style.width = \"54px\"\n//\n// window title\n//\nlet label = e(\"span\",{}, titleStr)\n//label.style.border = \"1px solid white\"\n//label.style.display = \"inline-block\"\nlabel.style.textAlign = \"center\"\nlabel.style.width = \"100%\"\nlabel.style.margin = \"0px\"\nlabel.style.padding = \"-10px\"\n// should be height = 24\n//\n// window title bar\n//\nlet title = e(\"div\",{}, bbb, label, ccc)\n//title.style.border = \"1px solid white\"\ntitle.style.display = \"flex\"\ntitle.style.alignItems = \"center\"\ntitle.style.margin = \"0px\"\n//\n// window frame\n//\nlet frame = e(\"div\",{},title,inner)\nframe.style.background = \"rgb(21,23,24)\"\nframe.style.color = \"white\"\n//frame.style.border = \"1px solid white\"\nframe.style.padding = \"2px 12px\"\nframe.style.margin = \"0px\"\nframe.style.borderRadius = \"10px\"\nframe.style.boxShadow = \"0px 20px 40px rgb(53,57,60)\" // offset-x, offset-y, blur-radius\nframe.style.transform = \"rotateY(15deg)\"\nreturn frame\n}\n//\n// caption\n//\nfunction gap() {\nlet gap = e(\"div\",{},)\ngap.style.minHeight = \"50px\"\nreturn gap\n}\nfunction caption() {\nlet caption = e(\"span\",{},\"Howdyho everyone, and welcome to this week's episode of Tiark's compiler corner.\")\ncaption.style.color = \"white\"\ncaption.style.fontSize = \"20px\" // 24\ncaption.style.textAlign = \"center\"\n//caption.style.padding = \"10px\"\n//caption.style.width = \"10px\"\n//caption.style.borderRadius = \"10px\"\ncaption.style.backgroundColor = \"rgba(0,0,0,0.9)\"\n//caption.style.border = \"5px solid black\"\n//caption.style.boxShadow = \"0px 20px 40px rgb(53,57,60)\" // offset-x, offset-y, blur-radius\ncaption.style.zIndex = \"1000\"\n//caption.style.position = \"absolute\"\n//\nlet caption2 = e(\"div\",{},caption)\ncaption2.style.textAlign = \"center\"\n//caption2.style.marginTop = \"50px\"\ncaption2.style.marginBottom = \"-20px\"\nreturn caption2\n}\n//\n//\n//\n// background\n//\nfunction background(...elems) {\nlet bkgnd = e(\"div\",{},...elems)\n//bkgnd.style.background = \"#ABB8C3\"\n//bkgnd.style.background = \"rgb(171,184,195)\" // <--- this one!\n//bkgnd.style.background = \"rgb(207,210,209)\"\nbkgnd.style.width = \"600px\"\nbkgnd.style.padding = \"36px\"\nbkgnd.style.fontSize = \"16px\"\n//bkgnd.style.perspective = \"1000px\"\nreturn bkgnd\n}\n</code>\n</aside>\n</aside>\n<p>Hit ‚ñ∂Ô∏é to play</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndelay = 20\nkeyframes = [{\n  mode: \"type\",\n  caption: \"Howdy Ho! A wonderful local time and\",\n  text:`print(\"Hello!\")`\n},{\n  mode: \"type\",\n  caption: \"Welcome to this week's episode of Prof. T's live programming corner.\",\n  text:`print(\"Let's draw something!\")`\n},{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\nr.appendChild(cvs)\nlet ctx = cvs.getContext(\"2d\")\n`\n },{\n  mode: \"type\",\n  caption: \"This is an experiment in replacing myself with a couple hundred lines of JavaScript.\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\nlet ctx = cvs.getContext(\"2d\")\n`\n },{\n  mode: \"type\",\n  caption: \"Everything you see here is scripted, based on diffs between code snippets.\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"white\"\nctx.fillRect(10,10,50,50)\n`\n },{\n  mode: \"type\",\n  caption: \"Click 'Edit' below to make changes.\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"white\"\nctx.fillRect(10,10,50,50)\n`\n },{\n  mode: \"type\",\n  caption: \"All the code is run live as I type it in.\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"white\"\nctx.fillRect(10,10,50,50)\nctx.fillRect(50,50,75,75)\nctx.fillStyle = \"black\"\nctx.fillRect(50,50,10,10)\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"red\"\nctx.fillRect(10,10,50,50)\nctx.fillRect(50,50,75,75)\nctx.fillStyle = \"black\"\nctx.fillRect(50,50,10,10)\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"green\"\nctx.fillRect(10,10,50,50)\nctx.fillRect(50,50,75,75)\nctx.fillStyle = \"black\"\nctx.fillRect(50,50,10,10)\nprint(\"Hope you like it :)\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"lightblue\"\nctx.fillRect(10,10,50,50)\nctx.fillRect(50,50,75,75)\nctx.fillStyle = \"black\"\nctx.fillRect(50,50,10,10)\nprint(\"Hope you like it :)\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"pink\"\nctx.fillRect(10,10,50,50)\nctx.fillRect(50,50,75,75)\nctx.fillStyle = \"black\"\nctx.fillRect(50,50,10,10)\nprint(\"Hope you like it :)\")\n`\n },{\n  mode: \"appear\",\n  caption: \"\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"yellow\"\n`\n },{\n  mode: \"type\",\n  caption: \"Why don't we try something else. How about ... animation!\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"yellow\"\nlet [x,y] = [75,75]\nctx.beginPath()\nctx.arc(x, y, 50, 0, 2 * Math.PI, false)\nctx.fill()\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"yellow\"\nlet [x,y] = [75,75]\nx += 2*time%300\nlet s = [0.1,0.2,0.3,0.2][time%4]\nctx.beginPath()\nctx.arc(x, y, 50, s * Math.PI, (2-s) * Math.PI, false)\nctx.lineTo(x,y)\nctx.fill()\n`\n },{\n  mode: \"type\",\n  caption: \"#wait\",\n  text:`print(\"Let's draw something!\")\n\\n\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 400\ncvs.height = 140\nr.appendChild(cvs)\n\\n\nlet ctx = cvs.getContext(\"2d\")\nctx.fillStyle = \"yellow\"\nlet [x,y] = [75,75]\nx += 2*time%300\nlet s = [0.1,0.2,0.3,0.2][time%4]\nctx.beginPath()\nctx.arc(x, y, 50, s * Math.PI, (2-s) * Math.PI, false)\nctx.lineTo(x,y)\nctx.fill()\n`\n },{\n  mode: \"appear\",\n  caption: \"Thank you for watching. Use the slider any time to go back and forth.\",\n  text:``\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create programming tutorials\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create programming tutorials\")\nprint(\"- That are interactive\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create programming tutorials\")\nprint(\"- That are interactive\")\nprint(\"- Engaging\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create programming tutorials\")\nprint(\"- That are interactive\")\nprint(\"- Engaging\")\nprint(\"- And fun!\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create:\")\nprint(\"- Programming tutorials\")\nprint(\"That are:\")\nprint(\"- Interactive\")\nprint(\"- Engaging\")\nprint(\"- And fun!\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create:\")\nprint(\"- Programming tutorials\")\nprint(\"- Other interactive presentations\")\nprint(\"That are:\")\nprint(\"- Interactive\")\nprint(\"- Engaging\")\nprint(\"- And fun!\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create:\")\nprint(\"- Programming tutorials\")\nprint(\"- Other interactive presentations\")\nprint(\"- ...\")\nprint(\"That are:\")\nprint(\"- Interactive\")\nprint(\"- Engaging\")\nprint(\"- And fun!\")\n`\n },{\n  mode: \"type\",\n  caption: \"\",\n  text:`print(\"Create:\")\nprint(\"- Programming tutorials\")\nprint(\"- Other interactive presentations\")\nprint(\"- ...\")\nprint(\"That are:\")\nprint(\"- Interactive\")\nprint(\"- Engaging\")\nprint(\"- And fun!\")\ndone()\n`\n },{\n  mode: \"type\",\n  caption: \"Peace out and rock on!\",\n  text:`print(\"Create:\")\nprint(\"- Programming tutorials\")\nprint(\"- Other interactive presentations\")\nprint(\"- ...\")\nprint(\"That are:\")\nprint(\"- Interactive\")\nprint(\"- Engaging\")\nprint(\"- And fun!\")\ndone()\n`\n }\n]\nrun()\n</code>\n<p>Background music from <a href=\"https://www.playonloop.com\">PlayOnLoop.com</a>, licensed under <a href=\"https://creativecommons.org/licenses/by/4.0/\">CC BY 4.0</a></p>","fields":{"slug":"/Public/Generic/auto-live-coding/"},"frontmatter":{"date":"2021-01-11","title":"Automatic Live Coding","description":"Tired of giving the same live coding demo over and over again? Spending hours recording it and editing until you're satisfied? No more - script & automate it!","keywords":"Live Coding, Screencast, Streaming, Twitch","tags":null}}},{"node":{"excerpt":"December. Year one of the plague. What better time for some recreational hacking. Why not play with some particle effects? Implementation‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>December. Year one of the plague. What better time for some recreational hacking. Why not play with some particle effects?</p>\n<aside>\n<p>Implementation Notes</p>\n<p>First we need to set up a canvas</p>\n<code class=\"runScript\" filter=\"setPreamble\" popout=\"true\">\nlet cvs = null\nlet ctx = null\nlet sizeX = 300\nlet sizeY = 100\nfunction createCanvas() {\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.width = sizeX\n  cvs.height = sizeY\n  ctx = cvs.getContext(\"2d\")\n}\n</code>\n<p>Now we‚Äôre ready to draw something. Let‚Äôs paint a bunch of circles and gradually vary position, color, etc.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\nlet cx = 0\nlet cy = 50\nlet size = 30\nlet db = size\nlet x = cx\nlet y = cy\nlet vx = 5\nlet vy = 0//-db/2\nlet ay = 1\nlet ax = 1\nlet d = db/2 //+ random(db/2)\nlet red = 255\nlet green = 255\nlet blue = 255\nlet alpha = 1.0\n// stations: white, yellow, red, black\nfunction particle() {\n  let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n  ctx.lineWidth = d;\n  ctx.fillStyle = color\n  ctx.strokeStyle = color\n  ctx.lineCap = \"round\";\n  ctx.beginPath();\n  ctx.moveTo(x,y);\n  ctx.lineTo(x+1,y+1);\n  ctx.stroke();\n  y += vy\n  x += vx\n  if (vy < -1.5) vy *= 0.9\n  d += 0.55\n  if (blue > 15)\n      blue -= 15\n  if (green > 3)\n      green -= 3\n  if (green <= 100 && red > 5)\n      red -= 5\n  alpha -= 0.02\n  if (alpha > 0 && d > 0) {\n      particle()\n  }\n}\nparticle()\n</code>\n<p>How to bring this to life? First step: randomness!</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction random(x) {\n  return Math.random() * x\n}\nfunction choice(x) {\n  return Math.random() < x\n}\n</code>\n<p>Let‚Äôs try again (click ‚Äúdone‚Äù or edit the code to re-run):</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\nlet cx = 0\nlet cy = 50\nlet size = 30\nlet db = size\nlet x = cx\nlet y = cy\nlet vx = 5\nlet vy = 0//-db/2\nlet ay = 1\nlet ax = 1\nlet d = db/2\nlet red = 255\nlet green = 255\nlet blue = 255\nlet alpha = 1.0\n// stations: white, yellow, red, black\nfunction particle() {\n  let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n  ctx.lineWidth = d;\n  ctx.fillStyle = color\n  ctx.strokeStyle = color\n  ctx.lineCap = \"round\";\n  ctx.beginPath();\n  ctx.moveTo(x,y);\n  ctx.lineTo(x+1,y+1);\n  ctx.stroke();\n  y += vy\n  x += vx\n  if (vy < -1.5) vy *= 0.9\n  vy = -db/6 + random(db/3)\n  d = db/2 + random(db/2)\n  if (blue > 15)\n      blue -= 15\n  if (green > 3)\n      green -= 3\n  if (green <= 100 && red > 5)\n      red -= 5\n  alpha -= 0.02\n  if (alpha > 0 && d > 0) {\n      particle()\n  }\n}\nparticle()\n</code>\n<p>What next? Animate!</p>\n<p>We‚Äôll use a pretty generic animation solution, based on a work list for concurrent execution.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet queue = []\nfunction schedule(fun) {\n  queue.push(fun)\n}\nlet time = 0\nlet canvasVisible = false\nfunction animate () {\n  time += 100\n  ctx.clearRect(0,0,sizeX,sizeY)\n  var items = queue\n  queue = []\n  for (i in items) {\n    var fun = items[i]\n    fun.apply(fun)\n  }\n  if (canvasVisible)\n    setTimeout(animate, 0)\n}\n</code>\n<p>Each piece in the animation is a conceptual thread that can schedule itself again for the next frame, as well as create new particles, each one spawned off as a new thread.\nA neat aspect is that state can be maintained across multiple of these threads using closures.</p>\n<p>To draw a niece cozy fire, we‚Äôll use a code skeleton roughly like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">schedule(function fire() {\n  ...\n  // start a new flame at a random position\n  ...\n  schedule(function flame() {\n    ...\n    // emit one or more new fire particles\n    ...\n    schedule(function particle() {\n      ...\n      // move particle up, change color, etc\n      ...\n      if (!burntOut)\n        schedule(particle)\n    }\n    if (!extinguished)\n      schedule(flame) // keep burning\n  })\n  schedule(fire)\n})</code></pre></div>\n<p>To prevent hogging the CPU we want to start/stop the animation based on visibility of the canvas.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction respondToVisibility(element, callback) {\n  let options = {\n    root: document.documentElement\n  }\n  let observer = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      callback(entry.intersectionRatio > 0);\n    })\n  }, options)\n  observer.observe(element);\n}\nfunction createSmallCanvas() {\n  sizeX = 150\n  sizeY = 150\n  createCanvas()\n  respondToVisibility(cvs, visible => {\n    if (!canvasVisible && visible)\n      setTimeout(animate, 0)\n    canvasVisible = visible\n  })\n}\n</code>\n<p>Now we‚Äôre ready to draw our first animated flame. Be sure to play with the parameters (color, position, etc)!</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateSmallCanvas()\nlet cx = sizeX/2\nlet cy = sizeY\nlet size = sizeY/10\nlet t0 = time\nschedule(function burn() {\n  let db = size// * Math.log((time-t0))\n  let x = cx\n  let y = cy\n  let vx = 0\n  let vy = -db/2\n  let ay = 1\n  let ax = 1\n  let d = db/2 + random(db/2)\n  let red = 255\n  let green = 255\n  let blue = 255\n  let alpha = 1.0\n  // stations: white, yellow, red, black\n  schedule(function particle() {\n    let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n    ctx.lineWidth = d;\n    ctx.fillStyle = color\n    ctx.strokeStyle = color\n    ctx.lineCap = \"round\";\n    ctx.beginPath();\n    ctx.moveTo(x,y);\n    ctx.lineTo(x+1,y+1);\n    ctx.stroke();\n    y += vy\n    x += vx\n    vx = -db/6 + random(db/3)\n    if (vy < -1.5) vy *= 0.9\n    d -= 0.03\n    if (blue > 15)\n        blue -= 15\n    if (green > 3)\n        green -= 3\n    if (green <= 100 && red > 5)\n        red -= 5\n    alpha -= 0.02\n    if (alpha > 0 && d > 0)\n        schedule(this)\n  })\n  schedule(burn)\n})\n</code>\n<p>Now let‚Äôs draw our water jet. The setup is the same. A minor difference is that we chose to emit not one but ten new particles in each animation step. Yes, it really is a high-pressure jet:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateSmallCanvas()\nlet mx = sizeX/2\nlet my = sizeY-10;\nschedule(function spray() {\n  function emit() {\n    let red = 0\n    let green = 255\n    let blue = 255\n    let alpha = 1.0\n    let angle = 0.3*Math.PI + random(0.4 * Math.PI)\n    let vx =  Math.cos(angle)\n    let vy = (6)*-Math.sin(angle)\n    let x = mx\n    let y = my\n    let d = 5 + random(15)\n    schedule(function particle() {\n      let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n      ctx.lineWidth = d;\n      ctx.fillStyle = color\n      ctx.strokeStyle = color\n      ctx.lineCap = \"round\";\n      ctx.beginPath();\n      ctx.moveTo(x,y);\n      ctx.lineTo(x+1,y+1);\n      ctx.stroke();\n      y += vy\n      x += vx\n      alpha -= 0.05\n      if (alpha > 0 && d > 0)\n        schedule(this)\n    })\n  }\n  for (var i = 0; i < 10; i++)\n    schedule(emit)\n  schedule(this)\n})\n</code>\n<p>Now it‚Äôs time to put everything together. Add some event listeners and we‚Äôre ready to play:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nsizeX = 600\nsizeY = 300\ncreateCanvas()\nvar dimx = sizeX\nvar dimy = sizeY\nvar score = 0\nvar draw= false;\nvar mx = 0\nvar my = 0\ncvs.style.touchAction=\"none\" // prevent scrolling\ncvs.addEventListener(\"pointerdown\", ev => {\n  draw = true\n  cvs.setPointerCapture(ev.pointerId)\n  ev.preventDefault()\n  ev.stopPropagation()\n  // ev.stopImmediatePropagation() // necessary?\n})\ncvs.addEventListener(\"pointermove\", ev => {\n  mx = e.offsetX\n  my = e.offsetY\n  ev.preventDefault()\n  ev.stopPropagation()\n})\ncvs.addEventListener(\"pointerup\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"pointercancel\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"mousedown\", e => draw=true)\ncvs.addEventListener(\"mouseup\", e => draw=false)\ncvs.addEventListener(\"mousemove\", e => {\n    mx = e.offsetX\n    my = e.offsetY\n})\nrespondToVisibility(cvs, visible => {\n  if (!canvasVisible && visible)\n    setTimeout(animate, 0)\n  canvasVisible = visible\n})\nschedule(function spray() {\n  if (draw) {\n    function emit() {\n      let red = 0\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      let angle = 0.3*Math.PI + random(0.4 * Math.PI)\n      let vx =  Math.cos(angle)\n      let vy = (6)*-Math.sin(angle)\n      let x = mx\n      let y = my\n      let d = 5 + random(15)\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        alpha -= 0.05\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n    }\n    for (var i = 0; i < 10; i++)\n      schedule(emit)\n  }\n  schedule(this)\n})\nschedule(function fire() {\n  if (choice(0.1)) {\n    let cx = random(dimx)\n    let cy = dimy/2+random(dimy/2)\n    let size = 3 + random(10)\n    let t0 = time\n    schedule(function burn() {\n      let db = size// * Math.log((time-t0))\n      let x = cx\n      let y = cy\n      let vx = 0\n      let vy = -db/2\n      let ay = 1\n      let ax = 1\n      let d = db/2 + random(db/2)\n      let red = 255\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      // stations: white, yellow, red, black\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        vx = -db/6 + random(db/3)\n        if (vy < -1.5) vy *= 0.9\n        d -= 0.03\n        if (blue > 15)\n            blue -= 15\n        if (green > 3)\n            green -= 3\n        if (green <= 100 && red > 5)\n            red -= 5\n        alpha -= 0.02\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n      if (draw && (my-cy) > 0 && (my-cy) < 20 && Math.abs(mx-cx) < 10)\n        score += Math.round(db)\n      else\n        schedule(burn)\n    })\n  }\n  schedule(fire)\n})\n</code>\n<p>The code is editable. Go ahead and adjust the parameters to adjust the level of difficulty!</p>\n</aside>\n<p>Oh no, this has gotten out of hand. Quick, quick! Get the fire extinguisher and put out those flames!</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nsizeX = 400\nsizeY = 400\ncreateCanvas()\ncvs.style.backgroundImage=\"url(http://tiarkrompf.github.io/notes/img/xmas-tree.jpg)\"\ncvs.style.backgroundSize=\"cover\"\nlet q = document.createElement(\"div\")\nq.innerText = \"Score: 0\"\nq.style.backgroundColor = \"black\"\nq.style.marginTop = \"-10px\"\nq.style.color = \"white\"\nlet p = document.createElement(\"div\")\np.style.width=\"400px\"\np.appendChild(cvs)\np.appendChild(q)\no.appendChild(p)\nvar dimx = sizeX\nvar dimy = sizeY\nvar score = 0\nvar draw= false;\nvar mx = 0\nvar my = 0\ncvs.style.touchAction=\"none\" // prevent scrolling\ncvs.addEventListener(\"pointerdown\", ev => {\n  draw = true\n  cvs.setPointerCapture(ev.pointerId)\n  ev.preventDefault()\n  ev.stopPropagation()\n  // ev.stopImmediatePropagation() // necessary?\n})\ncvs.addEventListener(\"pointermove\", ev => {\n  mx = ev.offsetX\n  my = ev.offsetY\n  ev.preventDefault()\n  ev.stopPropagation()\n})\ncvs.addEventListener(\"pointerup\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"pointercancel\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"mousedown\", e => draw=true)\ncvs.addEventListener(\"mouseup\", e => draw=false)\ncvs.addEventListener(\"mousemove\", e => {\n    mx = e.offsetX\n    my = e.offsetY\n})\nrespondToVisibility(cvs, visible => {\n  if (!canvasVisible && visible)\n    setTimeout(animate, 0)\n  canvasVisible = visible\n})\nschedule(function spray() {\n  if (draw) {\n    function emit() {\n      let red = 0\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      let angle = 0.3*Math.PI + random(0.4 * Math.PI)\n      let vx =  Math.cos(angle)\n      let vy = (6)*-Math.sin(angle)\n      let x = mx\n      let y = my\n      let d = 5 + random(15)\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        alpha -= 0.05\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n    }\n    for (var i = 0; i < 10; i++)\n      schedule(emit)\n  }\n  schedule(this)\n})\nschedule(function fire() {\n  if (choice(0.02)) {\n    let cx = random(dimx)\n    let cy = random(dimy)\n    let size = 3 + random(10)\n    let t0 = time\n    schedule(function burn() {\n      let db = size// * Math.log((time-t0))\n      let x = cx\n      let y = cy\n      let vx = 0\n      let vy = -db/2\n      let ay = 1\n      let ax = 1\n      let d = db/2 + random(db/2)\n      let red = 255\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      // stations: white, yellow, red, black\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        vx = -db/6 + random(db/3)\n        if (vy < -1.5) vy *= 0.9\n        d -= 0.03\n        if (blue > 15)\n            blue -= 15\n        if (green > 3)\n            green -= 3\n        if (green <= 100 && red > 5)\n            red -= 5\n        alpha -= 0.02\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n      if (draw && (my-cy) > 0 && (my-cy) < 20 && Math.abs(mx-cx) < 10) {\n        score += Math.round(db)\n        q.innerText = \"Score: \"+score\n      } else\n        schedule(burn)\n    })\n  }\n  schedule(fire)\n})\n</code>\n<p>Photo from <a href=\"https://unsplash.com\">Unsplash</a></p>\n<p>Happy Holidays and Merry Christmas everyone. Stay safe out there (and in there!)</p>","fields":{"slug":"/Public/Generic/particles/"},"frontmatter":{"date":"2020-12-20","title":"Fun With Particle Animation","description":"","keywords":null,"tags":null}}},{"node":{"excerpt":"Why? Designing a CPU, just like writing an OS or a compiler, is one of those things that is often thought to require fundamentally different‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Why? Designing a CPU, just like writing an OS or a compiler, is one of those things that is often thought to require fundamentally different skills from, say, writing front-end code in JavaScript.</p>\n<p>We‚Äôll show below that this is not the case. In fact, JavaScript makes a fine HDL (hardware description language) and some very modest programming skills are all we need to generate and simulate circuits in the browser, all the way to a simple but functional RISC CPU.</p>\n<p>Before we dive in, it is worth reflecting on some of the big ideas in computing: analog computers, digital computers, stored programs, metaprogramming.</p>\n<aside>\n<p>Big ideas in computing</p>\n<p>Analog computers, digital computers, stored programs, metaprogramming</p>\n<h3>Computing by machine</h3>\n<p>To build a machine that can compute things, map those things to physical quantities (mass, force, pressure, current, voltage) and design a device whose physics correspond to the desired computation. Read out the results by measurement. This is the idea of an analog computer.</p>\n<h3>Discretized computation</h3>\n<p>While analog computers had and still have their uses, there are issues with precision and range of values. In particular, it is difficult to robustly encode non-numerical data as analog physical quantities. To solve this, discretize continuous quantities to bits (two states, on or off) and continuous time to a clock signal. This is the idea of a digital computer.</p>\n<h3>Stored programs</h3>\n<p>Instead of building a computer to execute a specific fixed program, treat instructions as data. Load the program from memory, just like the data it operates on. Then make the computer <em>interpret</em> program instructions one by one. This is the idea of a universal computer that can compute any function that‚Äôs computable in principle.</p>\n<h3>Metaprogramming</h3>\n<p>Instead of drawing circuits or encoding instructions by hand, write a program that generates primitive circuits or instructions from a higher-level description or program. This is the idea behind compilers and behind modern generative programming approaches that use a high-level programming language as a macro system to generate programs or circuits in highly parameterized ways.</p>\n</aside>\n<p>With that, let‚Äôs get started:</p>\n<aside>\n<p>Defining and simulating circuits</p>\n<p>Circuits consist of wires and gates.</p>\n<p>Wires can hold a single bit of information (low voltage or high voltage) and as we will see, we‚Äôll only need one type of gate, the almighty NAND.</p>\n<p>We‚Äôll use a form of generative programming to define circuits, similar in style to state-of-the-art tools like <a href=\"https://www.chisel-lang.org\">Chisel</a> or <a href=\"https://www.spatial-lang.org\">Spatial</a>.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet wires = []\nlet gates = []\nfunction input() {\n  let n = wires.length\n  wires.push(0)\n  return n\n}\nfunction nand(a,b) {\n  let c = wires.length\n  wires.push(0)\n  gates.push({a,b,c})\n  return c\n}\nfunction simulate() {\n  for (let g of gates) {\n    let a = wires[g.a]\n    let b = wires[g.b]\n    wires[g.c] = (~(a&b))&1\n  }\n}\n</code>\n<p>Here‚Äôs how to define and simulate our first circuit, consisting of a single NAND gate:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// create circuit:\nlet a = input()\nlet b = input()\nlet c = nand(a,b)\n// and simulate it!\nwires[a] = 0\nwires[b] = 0\nsimulate()\nprint(`NAND(${wires[a]},${wires[b]}) = ${wires[c]}`)\n</code>\n<p><strong>Exercise:</strong> change the wire assignments above to try different\ninputs and observe how the result changes.</p>\n<p>In fact, let‚Äôs factor out some useful testing code\nto print truth tables:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction test(s,a,b,c) {\n  for (let u of [0,1]) {\n    for (let v of [0,1]) {\n      wires[a] = u\n      wires[b] = v\n      simulate()\n      print(`${s}(${u},${v}) = ${wires[c]}`)\n    }\n  }\n}\n</code>\n<p>Here we go, the truth table of our simple\nNAND circuit at a single glance:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = input()\nlet c = nand(a,b)\ntest(\"NAND\",a,b,c)\n</code>\n</aside>\n<p>Wires and gates, and how to use JS as a HDL</p>\n<aside>\n<p>Binary logic</p>\n<h3>1-Bit Logic</h3>\n<p>With NAND as a built-in:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = input()\nlet c = nand(a,b)\ntest(\"NAND\",a,b,c)\n</code>\n<p>We can derive all other logical operations:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// !a = !(a&a)\nfunction not(a) {\n  return nand(a,a)\n}\n// a&b = !!(a&b)\nfunction and(a,b) {\n  return not(nand(a,b))\n}\n// a|b = !!(a|b) = !(!a&!b)\nfunction or(a,b) {\n  return nand(not(a),not(b))\n}\n// a^b = a|b & !(a&b) = ...\nfunction xor(a,b) {\n  let c = nand(a,b)\n  return nand(nand(a,c),nand(b,c))\n}\n</code>\n<p>To see how, first realize that logical negation\n!a is !(a&#x26;a). With negation, we obtain AND\nand then, via de Morgan‚Äôs rules, OR.</p>\n<p>Let‚Äôs test the derived operations:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = input()\nlet c = and(a,b)\nlet d = or(a,b)\nlet e = xor(a,b)\ntest(\"AND\",a,b,c)\ntest(\"OR\",a,b,d)\ntest(\"XOR\",a,b,e)\n</code>\n<h3>N-Bit Logic</h3>\n<p>The basic logic operations extend straightforwardly to\nmultiple bits at a time. We use JS arrays to represent\nmulti-bit wires and values:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction inputN(n) {\n  return Array.from(Array(n), () => input())\n}\nfunction orN(as) {\n  return as.reduce(or)\n}\nfunction andN(as) {\n  return as.reduce(and)\n}\n</code>\n<p>For convenience we also provide functions to initialize and read\nthe value of multiple wires at the same time from and to a\nbitstring. Note that by convention, these bitstrings are ordered\nright to left:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction readDigits(as) {\n  return as.map(i => wires[i]).reverse().join(\"\")\n}\nfunction writeDigits(as,digits) {\n  assert(digits.length == as.length)\n  for (let j in as) {\n    wires[as[j]] = parseInt(digits[as.length-j-1])\n  }\n}\n</code>\n<p>Let‚Äôs try it out:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet as = inputN(8)\nlet b = andN(as)\nlet c = orN(as)\nwriteDigits(as, \"11001011\")\nsimulate()\nprint(\"AND: \"+wires[b])\nprint(\"OR:  \"+wires[c])\n</code>\n<p><strong>Exercise:</strong> implement versions of AND and OR operating pairwise on n-bit bitstrings.</p>\n</aside>\n<p>Nand is built-in, everything else is derived</p>\n<aside>\n<h2>Binary arithmetic</h2>\n<h3>Binary Numbers</h3>\n<p>Let‚Äôs recap binary numbers. First, recall that decimal numbers are composed of powers of ten:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">12345 = 1*10000 + 2*1000 + 3*100  + 4*10   + 5*1\n      = 1*10^5  + 2*10^4 + 3*10^3 + 4*10^1 + 5*10^0</code></pre></div>\n<p>Likewise, binary numbers are composed of powers of two:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">11000000111001 = 1*2^13 + 1*2^12 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^0</code></pre></div>\n<p>Let‚Äôs verify our understanding, recalling that <code class=\"language-text\">2^n</code> is a bit shift <code class=\"language-text\">1&lt;&lt;n</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint((1<<13) + (1<<12) + (1<<5) + (1<<4) + (1<<3) + (1<<0))\nprint((12345).toString(2))\n</code>\n<p>We could implement the conversion to and from binary numbers ourselves but JS provides some handy conversion function that we can use directly:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction readInt(as) {\n  let digits = readDigits(as)\n  return parseInt(digits,2)\n}\nfunction writeInt(as,n) {\n  let digits = n.toString(2).padStart(as.length,\"0\")\n  writeDigits(as,digits)\n}\n</code>\n<h3>Two‚Äôs Complement</h3>\n<p>How do we deal with negative numbers? We‚Äôll use the standard two‚Äôs complement representation. The highest bit is the sign bit (1 means negative), and to negate a number, flip all the bits and add one.</p>\n<p>Sometimes it is necessary to stretch, say, an 8-bit number to 16 bits. For positive numbers we can just add zeros, but if the number is negative that would be wrong; we‚Äôd have to pad with ones instead. So in the general case, we pad with whatever is the highest bit (sign extension).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction signExtend(as,n) {\n  assert(as.length <= n)\n  return [...as,...Array(n-as.length).fill(as[as.length-1])]\n}\n</code>\n<h3>1-Bit Addition</h3>\n<p>How to add binary numbers? Just like decimals: for each digit we compute the single-digit sum and a potential carry.</p>\n<p>For single-digit binary numbers, we compute the 1-bit sum using XOR, and the carry using AND, i.e., we have an overflow if both inputs are one. This circuit is called a half adder.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction halfAdder(a,b) {\n  let sum = xor(a,b)\n  let carry = and(a,b)\n  return {sum,carry}\n}\n</code>\n<p>A full adder adds three inputs (the last one is typically an input carry from another digit). The result is again two bits, sum and carry.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction fullAdder(a,b,c) {\n  let ab = halfAdder(a,b)\n  let abc = halfAdder(ab.sum,c)\n  let sum = abc.sum\n  let carry = or (ab.carry, abc.carry)\n  return {sum,carry}\n}\n</code>\n<h3>N-Bit Addition</h3>\n<p>To extend binary addition to n bits, we chain full adders and propagate the carry bit from digit to digit:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction zero() {\n  let z = input(); return xor(z,z)\n}\nfunction nBitParallelAdder(as,bs,c) {\n  let carry = c || zero()\n  let sum = []\n  for (let i in as) {\n    let temp = fullAdder(as[i],bs[i],carry)\n    sum.push(temp.sum)\n    carry = temp.carry\n  }\n  return {sum,carry}\n}\n</code>\n<p>Let‚Äôs test it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet as = inputN(4)\nlet bs = inputN(4)\nlet cs = nBitParallelAdder(as,bs).sum\n// compute 4 + 5 = 9\nwriteInt(as,4)\nwriteInt(bs,5)\nsimulate()\n// 4 + 5 = 9  -->  0100 + 0101 = 1001\")\nprint(readInt(as)+\" + \"+readInt(bs)+\" = \"+readInt(cs))\nprint(readDigits(as)+\" + \"+readDigits(bs)+\" = \"+readDigits(cs))\n</code>\n<p><strong>Exercise:</strong> refactor nBitParallelAdder to use the reduce combinator.</p>\n<p><strong>Exercise:</strong> refactor nBitParallelAdder to perform tree reduction instead of linear reduction (result: log-depth circuit instead of linear depth). Read up on\nripple-carry, carry-lookahead, and carry-select adders.</p>\n<p><strong>Exercise:</strong> implement subtraction. Hint: recall two‚Äôs complement representation. To negate, flip all bits and add one. Implement <code class=\"language-text\">a-b</code> as <code class=\"language-text\">a+(-b)</code>. Can you do better than two additions? Hint: use carry input.</p>\n<p><strong>Exercise:</strong> think about how to implement multiplication (hints: <a href=\"http://www.andraka.com/multipli.php\">http://www.andraka.com/multipli.php</a>).</p>\n</aside>\n<p>Binary numbers, two‚Äôs complement, adder circuits</p>\n<aside>\n<p>Structured data</p>\n<p>In addition to flat bitstrings and n-bit numbers we want to operate on structured and compound data. Lookup tables are a key example, which can be queried given a numeric index or a binary search key. We‚Äôll build up to facilities to select from and update such tables below.</p>\n<h3>1-Bit Mux and Demux</h3>\n<p>The basic circuit to select between alternatives\nis the multiplexer. This is basically an if-then-else\noperation, which selects one of two inputs a,b based\non a flag s:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction mux(a,b,s) {\n  return or(and(a,not(s)),and(b,s))\n}\n</code>\n<p>The inverse is the demultiplexer, which forwards\nan input signal to one of two outputs:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction demux(a,s) {\n  return [and(a,not(s)), and(a,s)]\n}\n</code>\n<h3>N-Bit Mux and Select</h3>\n<p>How can we extend the binary mux to select from four\ninstead of two inputs? We add another control wire\nand arrange three binary muxes in a tree shape:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction select4(a,b,c,d,s1,s2) {\n  let ab = mux(a,b,s1)\n  let cd = mux(c,d,s1)\n  return mux(ab,cd,s2)\n}\n</code>\n<p>This pattern generalizes to larger sizes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction selectM(as,ix) {\n  assert(as.length == 1 << ix.length)\n  if (as.length > 1) {\n    let as1 = selectM(as.slice(0, as.length/2),ix.slice(0,-1))\n    let as2 = selectM(as.slice(as.length/2),ix.slice(0,-1))\n    return mux(as1,as2,ix[ix.length-1])\n  } else\n    return as[0]\n}\n</code>\n<p>In another dimension, we can select between n-bit strings:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction select2N(as,bs,s) {\n  return zipWith(as,bs, (a,b) => mux(a,b,s))\n}\nfunction zipWith(as,bs,f) {\n  assert(as.length == bs.length)\n  let cs = []\n  for (let j in as)\n    cs.push(f(as[j],bs[j]))\n  return cs\n}\n</code>\n<p>Putting these two together, we can select between m n-bit strings:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction selectMN(as,ix) {\n  assert(as.length == 1 << ix.length)\n  if (as.length > 1) {\n    let as1 = selectMN(as.slice(0, as.length/2),ix.slice(0,-1))\n    let as2 = selectMN(as.slice(as.length/2),ix.slice(0,-1))\n    return select2N(as1,as2,ix[ix.length-1])\n  } else\n    return as[0]\n}\nfunction select(as,ix) {\n  let w = as[0].length\n  assert(as.length == 1 << ix.length)\n  as.forEach(x => assert(x.length == w))\n  return selectMN(as,ix)\n}\n</code>\n<h3>N-Bit Demux and Update</h3>\n<p>We proceed in a similar way for demuxes, first of size 4,\nthen of size n:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction demux2(a,s) {\n  return [and(a,not(s)), and(a,s)]\n}\nfunction demux4(a,s1,s2) {\n  let [a1,a2] = demux2(a,s2)\n  return [demux2(a1,s1),demux2(a2,s1)].flat()\n}\nfunction demuxN(a,ix) {\n  if (ix.length == 0)\n    return [a]\n  let [a1,a2] = demux(a,ix[ix.length-1])\n  let ix1 = ix.slice(0,ix.length-1)\n  return [demuxN(a1,ix1),demuxN(a2,ix1)].flat()\n}\n</code>\n<p>Let‚Äôs try those.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a  = input()\nlet ix = inputN(4)\nlet cs = demuxN(a,ix)\nwires[a] = 1\nfor (let n of [0,1,2,3,4,5,6,7]) {\n  writeInt(ix,n)\n  simulate()\n  print(\"2^\"+n+\" = \"+readInt(cs))\n}\n</code>\n<p>Demuxes give us an update facility:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction updateN(as,ix,a1,e) {\n  let bs = demuxN(e,ix) // 'enable' flag\n  return zipWith(as,bs, (a0,b) => mux(a0,a1,b)) // select old or new\n}\nfunction updateMN(as,ix,a1,e) {\n  let bs = demuxN(e,ix) // 'enable' flag\n  return zipWith(as,bs, (a0,b) => select2N(a0,a1,b)) // select old or new\n}\n</code>\n<h3>Select and Update Example</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\n// selectively set a bit to 0\nlet as = inputN(8)\nlet ix = inputN(3)\nlet a  = input(1)\nlet bs = updateN(as, ix, a, not(a))\nwriteInt(ix,7) // <-- which bit to flip\nwriteInt(as,255)\nprint(readInt(as))\nsimulate()\nprint(readInt(bs))\n</code>\n<p><strong>Exercise:</strong> implement a multiplier circuit that has a complete multiplication table hardwired in a lookup table (LUT).</p>\n</aside>\n<p>Mux and demux, selecting and updating parts of compound data</p>\n<aside>\n<p>State and mutation</p>\n<p>So far our circuits were connected unidirectionally. Data flows in one direction. Evaluating the same circuit multiple times with the same inputs always produces the same result: mathematically, a pure function from inputs to outputs. Such circuits are called <em>combinational</em>. Below, we will make the step to <em>sequential</em> logic, which allows us to implement memory components and other time- and history-dependent computation.</p>\n<h3>State via Recursion</h3>\n<p>What happens if we create cycles? Let‚Äôs add functionality to do that.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction rewire(c,b) {\n  let g = gates[gates.length-1]\n  assert(g.c == c, \"can only rewire last gate created!\")\n  g.c = b\n  return b\n}\nfunction cycle(f) {\n  let b = input()\n  let c = f(b)\n  return rewire(c, b)\n}\n//\n// debugging utils\n//\nlet waveforms = {}\nfunction logWires(kvs) {\n  for (let k in kvs) {\n    let w = kvs[k]\n    if (!waveforms[k]) waveforms[k] = []\n    waveforms[k].push(wires[w])\n  }\n}\nfunction printWaveforms() {\n  for (let k in waveforms)\n    print(k+\": \"+waveforms[k].join(\"\"))\n}\n</code>\n<p>Now we wire up the output of an OR gate back to its input:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = cycle(b => or(a,b))\n// simulate 20 steps, and pulse a=1 once at step 5\nfor (let i = 0; i < 20; i++) {\n  wires[a] = i == 5 ? \"1\" : \"0\"\n  simulate()\n  logWires({a,b})\n}\nprintWaveforms()\n</code>\n<p>We can see that the 1 pulse on input a triggered\na permanent state change, flipping b to 1.\nIntuitively the result of the circuit is the OR\nover all past inputs a.</p>\n<p>Creating cycles is the key idea behind stateful circuits.</p>\n<p>Note: In real hardware, cycles are a bit tricky and need\nto be synchronized with a central clock signal. For us, each\ncall to <code class=\"language-text\">simulate</code> is an implicit clock tick so we don‚Äôt\nneed to worry about this (but see aside below for more).</p>\n<aside>\n<h3>Flip Flop Basics, From Async Logic to Sync Logic</h3>\n<p>Cycles in real hardware are tricky because of timing.\nChanges in voltage propagate asynchronously so additional\nmeasures are needed for deterministic behavior.\nThat‚Äôs why most computer chips use a central clock signal\n(010101010101 etc.) to sychronize state changes.</p>\n<p>Our simulator is synchronous so we don‚Äôt have to worry\nabout these issues here. Every step is a tick of the clock\nsignal, and our <code class=\"language-text\">cycle</code> abstraction implicitly delays the\nresult by one iteration. In a physical circuit this\nbehavior can be implemented using NAND gates as well.</p>\n<p>We‚Äôll explore the basics below.</p>\n<p><strong>Exercise:</strong> change the simulator code to introduce\nnondeterminism and observe the effect on circuits\ndefined here. Hint: randomize the order of gates\nbefore computing wire values. Use a worklist\nand convergence checks to observe how values\nstabilize.</p>\n<p>Going back to our OR loop, how can we turn the output\nback to 0 after we flipped it to 1? Let‚Äôs build a\nset-reset latch (SR latch).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction setResetNandLatch(s,r) {\n  let q = input()\n  let notq = input()\n  let q1 = nand(s,notq)\n  rewire(q1,q)\n  let notq1 = nand(r,q)\n  rewire(notq1,notq)\n  return {q,notq}\n}\nfunction setResetLatch(s,r) {\n  return setResetNandLatch(not(s),not(r)).q\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet s = input()\nlet r = input()\nlet q = setResetLatch(s,r)\n// simulate 20 steps\nfor (let i = 0; i < 20; i++) {\n  wires[s] = i % 5 == 0 ? \"1\" : \"0\"\n  wires[r] = i % 5 == 2 ? \"1\" : \"0\"\n  simulate()\n  logWires({S:s,R:r,Q:q})\n}\nprintWaveforms()\n</code>\n<p>Neat. What else could we want? A flip flop that stores a value from one input when given a signal on another input.</p>\n<p>This is the D Latch.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction dataLatch(d,e) {\n  let s = and(d,e)\n  let r = and(not(d),e)\n  return setResetLatch(s,r)\n}\n</code>\n<p>We introduce a clock c and switch on the rising clock edge. One clock cycle takes 8 simulation steps (4 high, 4 low). This needs to be large enough to allow the propagation through all cycles in the circuit to settle (timing analysis):</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet d = input()\nlet clock = input()\nlet q = dataLatch(d,clock)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 5 ? \"1\" : \"0\"\n  if (i % 4 == 0)wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,q})\n}\nprintWaveforms()\n</code>\n<p>Remaining issue: while the clock signal is on, the circuit is ‚Äúopen‚Äù and directly propagates D to Q. So if D changes during a clock cycle the output will change as well (we say that the D-Latch is transparent and level-sensitive).</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet d = input()\nlet clock = input()\nlet q = dataLatch(d,clock)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 9 ? \"1\" : \"0\"\n  if (i % 4 == 0)wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,q})\n}\nprintWaveforms()\n</code>\n<p>Fix: remember the value until the next cycle. Use two latches: the result is the D Flip-Flop (or D Register).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction dFlipFlop(d,e) {\n  let q1 = dataLatch(d,not(e))\n  let q2 = dataLatch(q1,e)\n  return q2\n}\n</code>\n<p>Now switches in both directions are stable and synchronized with the rising edge of the clock signal:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet d = input()\nlet clock = input()\nlet q = dFlipFlop(d,clock)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 5 ? \"1\" : \"0\"\n  if (i % 4 == 0)wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,q})\n}\nprintWaveforms()\n</code>\n<p>We have our desired stable memory cell: a 1-bit register.</p>\n<h3>Abstract One Step</h3>\n<p>Let‚Äôs do an alternative. Treat the delay latch as built-in. Our simulation is discrete, so we can obtain the desired behavior directly. Benefit: more clarity, disregard timing issues, one clock cycle corresponds to one simulation step.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction delay(a) {\n  let b0 = input()\n  let b = or(b0,b0)\n  let b1 = or(a,a)\n  rewire(b1,b0)\n  return b\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet clock = input()\nlet d = delay(clock)\nlet e = delay(d)\nfor (let i = 0; i < 20; i++) {\n  wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,e})\n}\nprintWaveforms()\n</code>\n<p>The way our cycle construct is implemented it already has a delay built in. This means that we can implement a 1-bit register directly by selecting (using a mux) whether we want to keep the previous value or use the new one.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction register(d,e) {\n  return cycle(r => mux(r,d,e))\n}\n</code>\n<p>As we would expect, the register updates its value whenever the e input gets a pulse:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet clock = input()\nlet d = input()\nlet e = input()\nlet q = register(d,e)\nfor (let i = 0; i < 20; i++) {\n  wires[clock] = 1-wires[clock]\n  wires[d] = i < 5 || i > 12 ? \"0\" : \"1\"\n  wires[e] = i == 9 || i == 15 ? \"1\" : \"0\"\n  simulate()\n  logWires({c:clock,d,e,q})\n}\nprintWaveforms()\n</code>\n</aside>\n<p>How can we turn the output back to 0 after we flipped it to 1? Let‚Äôs build a register cell (a flip-flip). We use an additional input line to decide whether we want to keep the previous value or use the new one, and a mux to implement the switch.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction register(d,e) {\n  return cycle(r => mux(r,d,e))\n}\n</code>\n<p>The register updates its value to d whenever input e gets a pulse:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet d = input()\nlet e = input()\nlet q = register(d,e)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 5 || i > 12 ? \"0\" : \"1\"\n  wires[e] = i == 9 || i == 15 ? \"1\" : \"0\"\n  simulate()\n  logWires({d,e,q})\n}\nprintWaveforms()\n</code>\n<h3>Feedback Loops with Structured Data</h3>\n<p>Cycles extend straightforwardly to n-bit data:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction cycleN(n,f) {\n  let bs = inputN(n)\n  let cs = f(bs)\n  for (let i in cs) {\n    rewire(or(cs[i],cs[i]), bs[i])\n  }\n  return bs\n}\n</code>\n<p>And we can go even further, adding an automatic\nlayer of flattening and unflattening based on\na given data descriptor (an array that contains\nthe size in bits of each field):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction flatten(ns,as) {\n  return as.flat()\n}\nfunction unflatten(ns,as) {\n  let bs = []\n  let k = 0\n  for (let j in ns) {\n    bs.push(as.slice(k,k+ns[j]))\n    k += ns[j]\n  }\n  assert(k == as.length)\n  return bs\n}\nfunction cycleS(ns,f) {\n  let n = ns.reduce((a,b)=>a+b)\n  return unflatten(ns,cycleN(n,\n    a => flatten(ns,f(unflatten(ns,a)))))\n}\n</code>\n<p>Although not done here, it would be straightforward\nto support multiple levels of nesting and\nflatten/unflatten recursively.</p>\n<p><strong>Exercise:</strong> implement recursive flatten/unflatten.</p>\n</aside>\n<p>Implementing state using recursion (feedback loops)</p>\n<aside>\n<p>Translating programs to circuits</p>\n<h3>From Programs to Hardware</h3>\n<p>By now we have built up a rich set of circuit structures, so\nwe can translate many kinds of programs to hardware:</p>\n<ul>\n<li>Numbers are encoded in binary, we‚Äôve seen circuits for arithmetic</li>\n<li>Mutable variables become registers</li>\n<li>Arrays becomes register banks (structured sets of registers)</li>\n<li>Loops are expressed through sequential logic</li>\n</ul>\n<p><strong>Exercise:</strong> how to implement functions?</p>\n<p>To go as far and implement functions, we can follow one of the following ideas (listed by increasing complexity):</p>\n<ol>\n<li>Inline all function calls, i.e., treat functions as macros (leads to size blowup, and only works for non-recursive functions)</li>\n<li>Allocate one register for each function to store an identifier of the calling function (solves the circuit size problem at the expense of latency, but still cannot support recursion)</li>\n<li>Use a memory component / register bank to represent a call stack (supports first-order recursive functions)</li>\n<li>Use a memory component to represent a heap and allocate functions as closures (supports higher-order functions)</li>\n</ol>\n<h3>Example: Counters using Sequential Logic</h3>\n<p>Without going into the details of all these, let‚Äôs consider a tractable but interesting example: a loop that independently increments two counters of different bit-widths:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet d = inputN(3)\nlet [c8,c1] = cycleS([3,1], ([c8,c1]) =>\n  [nBitParallelAdder(c8,d).sum,\n   nBitParallelAdder(c1,d).sum])\nwriteInt(d,1)\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"C8: \"+readInt(c8) + \" C1: \"+ readInt(c1))\n}\n</code>\n<p><strong>Exercise:</strong> increment one of the counters at a fractional speed, i.e., only every second (or third, or fourth) iteration.</p>\n<p><strong>Exercise:</strong> implement a multiplication circuit using sequential logic.</p>\n</aside>\n<p>Putting things together</p>\n<aside>\n<p>The CPU</p>\n<p>We‚Äôve discussed how to translate more or less arbitrary programs to circuits. We‚Äôll now apply this idea to a special kind of program: an interpreter for computing instructions encoded in binary.</p>\n<h3>Basic Control Loop</h3>\n<p>We‚Äôll use a helper function to create a chunk of memory:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction readOnlyMemory(memsize,wordsize) {\n  let shape = Array(memsize).fill(wordsize)\n  return unflatten(shape, inputN(memsize*wordsize))\n}\n</code>\n<p>The basic control loop for our CPU will look as follows.\nIn every cycle we fetch an instruction from memory at the\naddress indicated by the PC (program counter), execute\nit (left for later), and increment the PC to point to the\nnext instruction:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet pcsize = 8\n// inputs/aux\nlet one = inputN(pcsize)\nwriteInt(one,1)\n// control loop\nlet [pc] = cycleS([pcsize], ([pc]) => {\n  // fetch instruction\n  let instr = select(memory,pc)\n  //\n  // TODO: decode and execute instruction!\n  //\n  // update pc\n  let pc1 = nBitParallelAdder(pc,one).sum\n  return [pc1]\n})\n// simulation\nfor (let i = 0; i < 5; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc))\n}\n</code>\n<h3>Add a Register File</h3>\n<p>In addition to the PC register, our CPU has a\nregister file consisting of 8 16-bit registers which\ncan be inspected and modified by CPU instructions:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet nregs = 8\nlet pcsize = 8\nlet wordsize = 16\n// inputs/aux\nlet memory = readOnlyMemory(256,wordsize)\nlet regshape = Array(nregs).fill(wordsize)\nlet one = inputN(pcsize)\nwriteInt(one,1)\n// control loop\nlet [pc,regfile] = cycleS([pcsize,nregs*wordsize], ([pc,regfile]) => {\n  // fetch instruction\n  let instr = select(memory,pc)\n  // load registers\n  let regs = unflatten(regshape, regfile)\n  //\n  // TODO: decode and execute instruction!\n  //       (arithmetic + update registers)\n  //\n  // store registers\n  let regfile1 = flatten(regshape,regs)\n  // update pc: either inc or jmp\n  let pc1 = nBitParallelAdder(pc,one).sum\n  return [pc1,regfile1]\n})\nlet regs = unflatten(regshape, regfile)\n// simulation\nfor (let i = 0; i < 5; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1]))\n}\n</code>\n<h3>Code is Data: Defining the ISA</h3>\n<p>With the basic control logic set up it‚Äôs time to define\nour ISA (Instruction Set Architecture), i.e., the language\nof instructions our CPU will interpret.</p>\n<p>Our CPU supports only four instructions, given below as\nassembly mnemomics and specifying their semantics in\npseudocode:</p>\n<ul>\n<li>\n<p>add rd ra</p>\n<p><code class=\"language-text\">regs(rd) += regs(ra); pc += 1</code></p>\n</li>\n<li>\n<p>sub rd ra</p>\n<p><code class=\"language-text\">regs(rd) -= regs(ra); pc += 1</code></p>\n</li>\n<li>\n<p>li rd imm</p>\n<p><code class=\"language-text\">regs(rd) = imm; pc += 1</code></p>\n</li>\n<li>\n<p>bnz rd imm</p>\n<p><code class=\"language-text\">if (regs(rd) != 0) pc = imm else pc += 1</code></p>\n</li>\n</ul>\n<p>All four instructions are encoded using the\nfollowing binary format:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">16               8      5      2    0\n+-----------------------------------+\n|       imm      |  ra  |  rd  | op |\n+-----------------------------------+</code></pre></div>\n<p>The field <code class=\"language-text\">op</code> contains the binary ‚Äúopcode‚Äù: 0 for add, 1 for sub, 2 for li (‚Äúload immediate‚Äù), 3 for bnz (‚Äúbranch if non-zero‚Äù). Field <code class=\"language-text\">rd</code> specifies the destination register (3-bits, i.e. 0..8), field <code class=\"language-text\">ra</code> the source register, field <code class=\"language-text\">imm</code> an immediate numeric value encoded in the instruction.</p>\n<h3>The CPU</h3>\n<p>With the ISA spec‚Äôed out, we‚Äôre ready to fill in the logic that interprets individual instructions, which completes the full CPU:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction cpu() {\n  let nregs = 8\n  let pcsize = 8\n  let wordsize = 16\n  // inputs/aux\n  let regshape = Array(nregs).fill(wordsize)\n  let one = inputN(pcsize)\n  writeInt(one,1)\n  // control loop\n  let [pc,regfile] = cycleS([pcsize,nregs*wordsize], ([pc,regfile]) => {\n    // fetch instruction\n    let instr = select(memory,pc)\n    let [opc,rd,ra,imm] = unflatten([2,3,3,8],instr)\n    // load registers\n    let regs = unflatten(regshape, regfile)\n    let vrd = select(regs,rd)\n    let vra = select(regs,ra)\n    // arithmetic computation\n    let neg = opc[0] // add or sub?\n    let vra1 = select2N(vra, vra.map(a => not(a)), neg)\n    let vadd = nBitParallelAdder(vrd,vra1,neg).sum // add/sub use same adder\n    let vimm = signExtend(imm,wordsize)\n    // update registers\n    let vrd1 = select([vadd,vadd,vimm,vrd],opc)\n    let regs1 = updateMN(regs,rd,vrd1,one[0])\n    let regfile1 = flatten(regshape,regs1)\n    // update pc: either inc or jmp\n    let pc1 = nBitParallelAdder(pc,one).sum\n    let jmp = select2N(pc1,imm,vrd.reduce(or)) // branch if non zero\n    let pc2 = select([pc1,pc1,pc1,jmp],opc)\n    return [pc2,regfile1]\n  })\n  let regs = unflatten(regshape, regfile)\n  return [pc,regs]\n}\n</code>\n<h3>Example: Countdown</h3>\n<p>Let‚Äôs try our CPU on a simple but nontrivial example program that counts down from 8 by 2 until reaching 0 and then starts over:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet [pc,regs] = cpu(memory)\n// program in machine language\nwriteDigits(memory[0],\"00001000\"+\"000\"+\"000\"+\"10\") // li r0 8\nwriteDigits(memory[1],\"00000010\"+\"000\"+\"001\"+\"10\") // li r1 2\nwriteDigits(memory[2],\"00000000\"+\"001\"+\"000\"+\"01\") // sub r0 r1\nwriteDigits(memory[3],\"00000010\"+\"000\"+\"000\"+\"11\") // bnz r0 2\nwriteDigits(memory[4],\"00000000\"+\"000\"+\"001\"+\"11\") // bnz r1 0\n// simulation\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1]))\n}\n</code>\n<p>Nice!!! Now where are we and what‚Äôs missing?</p>\n<h3>Where are we?</h3>\n<p>We‚Äôve gotten far for a tutorial and simulated a CPU from the ground up using nothing but NAND gates. But of course we‚Äôve barely scratched the space of CPU design yet.</p>\n<p>The most immediate limitation right now is that memory is currently read-only, and only used to load instructions (we have ROM, but no RAM).</p>\n<p><strong>Exercise:</strong> make memory accessible for user programs using load/store instructions.</p>\n<p>There are some complications if we don‚Äôt want to duplicate the memory access logic. This is one reason why real CPUs split instruction execution into multiple phases, so that the memory controller can be used through different paths in each phase.</p>\n<p>Apart from that, there is a host of additional functionality that could be implemented, for example:</p>\n<ul>\n<li>memory loads/stores, bitshifts, logical operations, multiplication, division, interrupts, privileged mode, virtual memory, floating point, SIMD, multicore, ‚Ä¶</li>\n</ul>\n<p>There are also important optimizations in real-word CPU designs that could be implemented here:</p>\n<ul>\n<li>pipelining, caches, out-of-order execution, branch prediction, ‚Ä¶</li>\n</ul>\n<p>Another fun exercise would be to synthesize the CPU and run it on an FPGA instead of simulating it in the browser.</p>\n<p><strong>Exercise:</strong> implement a code generator that takes a circuit definition (wires and gates) and emits Verilog code, suitable for FPGA synthesis (or perhaps <a href=\"https://www.chisel-lang.org/firrtl/\">FIRRTL</a> as alternative).</p>\n<p>The other big limitation is that programming our CPU in binary is no fun. This is something we can fix rather easily, so let‚Äôs move on and build an assembler and a simple compiler.</p>\n</aside>\n<p>There we are</p>\n<aside>\n<p>Assembler and Compiler</p>\n<p>Programming our CPU in binary is a pain. Let‚Äôs build an assembler!</p>\n<h3>Building an Assembler</h3>\n<p>Again we use a form of generative\nprogramming, so that we can use assembly instructions as if\nwe were writing normal code.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet label = 0\nfunction digits(n,width) {\n  assert(n < (1 << width))\n  return n.toString(2).padStart(width,\"0\")\n}\nfunction emitInstr(opc,rd,ra,imm) {\n  let ds = digits(imm,8)+digits(ra,3)+digits(rd,3)+digits(opc,2)\n  writeDigits(memory[label++],ds)\n}\nlet asm = {\n  add: function(rd, ra) {\n    emitInstr(0,rd,ra,0)\n  },\n  sub: function(rd, ra) {\n    emitInstr(1,rd,ra,0)\n  },\n  li: function(rd, imm) {\n    emitInstr(2,rd,0,imm)\n  },\n  bnz: function(rd, imm) {\n    emitInstr(3,rd,0,imm)\n  }\n}\n</code>\n<p>Let‚Äôs run our countdown program again, this\ntime written using proper assembly instructions:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet [pc,regs] = cpu(memory)\n// assembly program\nasm.li(0,8)\nasm.li(1,2)\nasm.sub(0,1)\nasm.bnz(0,2)\nasm.bnz(1,0)\n// simulation\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1]))\n}\n</code>\n<p>Sweet! Can we do something else? Why don‚Äôt we multiply\nsome numbers.</p>\n<h3>Example: Multiplication in ASM</h3>\n<p>Let‚Äôs compute the equivalent of <code class=\"language-text\">r0 = r1 * r2</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet [pc,regs] = cpu(memory)\n// assembly program\nasm.li(0,0) // r0 holds result\nasm.li(1,3) // r1 = 3\nasm.li(2,4) // r2 = 4\nasm.li(3,1)\nlet loop = label\nasm.add(0,1) // r0 += r1\nasm.sub(2,3) // r2 -= 1\nasm.bnz(2,loop)\nasm.bnz(3,label) // inf loop to stop\n// simulation\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1])+\n       \" R2: \"+readInt(regs[2]))\n}\n</code>\n<p>Cool. But can we still go higher level?</p>\n<h3>Building a (Simple) Compiler</h3>\n<p>Writing assembly code is still a bit annoying: we have to remember\nwhich register we stored some value in, we have to use the right\nlabels for branches etc. Wouldn‚Äôt it be nice to have a higher\nlevel language, with proper variable names and structured loops?</p>\n<p>No problem. We‚Äôll again use generative programming to ‚Äúcompile‚Äù\nfrom a higher-level language, embedded as an API in JS, down to\nassembly.</p>\n<p>Here is what we‚Äôll need:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet used = 0\nlet newvar = x => { asm.li(used, x); return used++ }\nlet popvar = () => --used\nfunction whileNZ(body) {\n  let start = label\n  let c = body()\n  asm.bnz(c,start)\n}\n</code>\n<p>To keep things simple, we only implement facilities for ‚Äòlocal‚Äô\nvariables and structured loops, but others could be added easily.</p>\n<p><strong>Exercise:</strong> implement structured arithmetic expressions so that we can write, e.g., <code class=\"language-text\">plus(a,minus(b,c))</code>. Hint: treat registers as a stack. You will need to extend the ISA/CPU to support a new instruction, <code class=\"language-text\">mr rd ra</code>, with the semantics <code class=\"language-text\">rd = ra</code>. You can free up an opcode by making <code class=\"language-text\">sub</code> use the same opcode as <code class=\"language-text\">add</code> and using the <code class=\"language-text\">imm</code> field to express negation of <code class=\"language-text\">ra</code>.</p>\n<h3>Example: Multiplication, Compiled</h3>\n<p>Now we can implement multiplication at an even higher\nlevel:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction mult(r,a,b) {\n  let one = newvar(1)\n  whileNZ(() => {\n    asm.add(r,a)\n    asm.sub(b,one)\n    return b\n  })\n  popvar() // 'one' no longer needed\n}\n</code>\n<p>And use it, for example, as part of a larger\nprogram:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction main() {\n  let res = newvar(0)\n  let a   = newvar(3)\n  let b   = newvar(4)\n  mult(res,a,b)\n  // infinite loop to halt\n  let one = newvar(1)\n  whileNZ(() => one)\n  return res\n}\n</code>\n<p>Let‚Äôs run it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet [pc,regs] = cpu(memory)\n// program\nlet res = main()\n// simulation\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" Res: \"+readInt(regs[res]))\n}\n</code>\n<p>Neato. Of course we can go all the way and add a <a href=\"/Public/Generic/just-write-the-parser\">parser</a>, <a href=\"/Public/Generic/dependent-types\">type checking</a>, <a href=\"/Public/Generic/graph-ir\">intermediate languages</a>, optimizations, etc.</p>\n</aside>\n<p>‚ÄúDraw the rest of the f-ing owl‚Äù</p>\n<aside>\n<p>Appendix</p>\n<h3>Where to go from here</h3>\n<p>Important take-aways: code is data, hardware is the new software.</p>\n<ul>\n<li>Translate programs to circuits</li>\n<li>Special case: ISA interpreter = CPU</li>\n<li>Generative programming, like in Chisel or Spatial</li>\n</ul>\n<p>Things to try next:</p>\n<ul>\n<li>Add features, use a standard ISA (e.g. RISV-V)</li>\n<li>Optimizations: pipelining, caches, etc.</li>\n<li>Build a SoC (System on Chip), add IO, etc</li>\n<li>Run on an FPGA</li>\n</ul>\n<h3>Resources</h3>\n<p>Hardware design</p>\n<ul>\n<li><a href=\"https://computationstructures.org\">MIT 6.004 Computation Structures (2017)</a></li>\n<li><a href=\"https://eater.net\">Build an 8-bit CPU from scratch</a></li>\n<li><a href=\"https://eater.net\">NAND game</a></li>\n</ul>\n<p>Tiny CPUs</p>\n<ul>\n<li><a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/assignments/optional.pdf\">MIT 6.189 CPU design assignment</a></li>\n<li><a href=\"http://people.inf.ethz.ch/wirth/FPGA-relatedWork/\">Niklaus Wirth: Experiments in Computer System Design</a></li>\n<li><a href=\"https://www.cl.cam.ac.uk/teaching/1112/ECAD+Arch/files/Thacker-A_Tiny_Computer-3.pdf\">Chuck Thacker: A Tiny Computer</a></li>\n<li><a href=\"http://www.vaxman.de/publications/nice_can.pdf\">NICE</a>,<a href=\"http://qnice.sourceforge.net\">QNICE</a></li>\n</ul>\n<p>Full-system design</p>\n<ul>\n<li><a href=\"https://www.nand2tetris.org\">Nand to Tetris</a></li>\n<li><a href=\"http://selfie.cs.uni-salzburg.at\">Selfie</a></li>\n<li><a href=\"https://people.inf.ethz.ch/wirth/ProjectOberon/index.html\">Oberon</a></li>\n</ul>\n<p>Modern HDL tools</p>\n<ul>\n<li><a href=\"https://www.chisel-lang.org\">Chisel</a></li>\n<li><a href=\"https://www.spatial-lang.org\">Spatial</a></li>\n</ul>\n<p>RISC-V</p>\n<ul>\n<li><a href=\"https://gitlab.com/nedopc/npc5/blob/master/emu-rv32i.c\">RISC-V emulator in one file</a></li>\n<li><a href=\"https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/\">RISC-V online</a></li>\n<li><a href=\"https://bellard.org/tinyemu/\">Fabrice Bellard: TinyEmu</a></li>\n<li><a href=\"https://inst.eecs.berkeley.edu//~cs61c/resources/RISCV_Green_Sheet.pdf\">RISC-V Green Sheet</a></li>\n<li><a href=\"https://msyksphinz-self.github.io/riscv-isadoc/\">RISC-V ISA docs</a></li>\n<li><a href=\"https://erik-engheim.medium.com/the-genius-of-risc-v-microprocessors-b19d735abaa6\">What Is Innovative About RISC-V</a></li>\n</ul>\n</aside>\n<p>Resources, and where to go next</p>","fields":{"slug":"/Public/Generic/lets-build-a-microprocessor/"},"frontmatter":{"date":"2020-12-14","title":"Let's Build a Microprocessor!","description":"From NAND to RISC, using JavaScript as a HDL","keywords":"circuits, HDL, high-level synthesis, staging, metaprogamming, mux, adder, CPU design, flip-flop, NAND-to-X, RISC-V","tags":null}}},{"node":{"excerpt":"How to implement a minimalistic language with dependent types? Quite a few good and concise tutorials already exist (see resources) but‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>How to implement a minimalistic language with dependent types? Quite a few good and concise tutorials already exist (see resources) but certain aspects still appear as a source of accidental complexity in other write-ups. Most prominent among those are:</p>\n<ol>\n<li>How to deal with bindings/substitution</li>\n<li>How to perform normalization</li>\n</ol>\n<p>We sidestep most of these thorny issues by aggressively reusing the metalanguage (JS) and we focus on what appears as the essence: the property that dependent types blur the stage distinction between compile time (type checking) and run time (evaluation), because terms need to be evaluated (normalized) to compare types ‚Äî at least to some degree, to make type comparisons meaningful. Hence, dependently typed languages can be viewed from two angles:</p>\n<ul>\n<li>Static angle: compute during typechecking</li>\n<li>Dynamic angle: check types during computation</li>\n</ul>\n<p>So, depending where one stands, languages with full dependent types can be viewed as either statically typed languages with compile-time computation taken to the extreme or dynamically typed languages with runtime type checking taken to the extreme.</p>\n<p>Of course, some languages implement other facilities to separate the computational (dynamic) from the logical (static) fragment and re-introduce a compile time vs. run time distinction.</p>\n<p>Embedding dependently typed sub-languages in an expressive dynamically typed host language like JS may be of independent interest, e.g., using JS as a tactic language to metaprogram proof terms or adding safety checks to JS frameworks.</p>\n<h3>Implementation</h3>\n<p>Warmup:</p>\n<aside>\n<h3>Untyped Lambda Calculus</h3>\n<p>The first choice we need to make is how to represent terms of the language we want to implement (the object language) in our implementation language of choice (the meta language), in our case JS. There are a number of options, outlined below.</p>\n<p>Shallow embedding (no suprise):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet test = (x => (y => y)(x))\nprint(test(7))\n</code>\n<p>Deep embedding (here: s-expressions; JSON would be another option):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet test = [\"fun\", \"x\", [\"app\", [\"fun\", \"y\", \"y\"], \"x\"]]\nprint(JSON.stringify(test))\n</code>\n<p>Basic HOAS (higher-order abstract syntax):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet nVars = 0\nfunction fresh() { return \"x\"+(nVars++) }\nfunction struct(e) {\n  if (e instanceof Array) return e.map(struct)\n  if (e instanceof Function) { let x = fresh(); return [x,struct(e(x))] }\n  return e\n}\nfunction stringify(e) {\n  let save = nVars\n  try { return JSON.stringify(struct(e)) }\n  finally { nVars = save }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet test = [\"fun\", x => [\"app\", [\"fun\", y => y], x]]\nprint(stringify(test))\n</code>\n<p><strong>Exercise:</strong> implement <code class=\"language-text\">hoas</code> as inverse of <code class=\"language-text\">struct</code>. Hint: use substitution.</p>\n<p>Tagless-final:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction fun(f) { return [\"fun\", f] }\nfunction app(f,a) { return [\"app\", f, a] }\nlet test = fun(x => app(fun(y => y), x))\nprint(stringify(test))\n</code>\n<p>Tagless-final with normalization by evaluation:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction fun(f) { return [\"fun\", f] }\nfunction app(f,a) {\n  if (f[0] == \"fun\") return f[1](a)\n  else return [\"app\", f, a]\n}\nlet test = fun(x => app(fun(y => y), x))\nprint(stringify(test))\n</code>\n<p>A slightly more compact variant that removes\nexplicit ‚Äúfun‚Äù and ‚Äúapp‚Äù tags, representing\nfunctions as themselves:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction struct(e) {\n  if (e instanceof Array) return e.map(struct)\n  if (e instanceof Function) { let x = fresh(); return [\"=>\", x,struct(e(x))] }\n  return e\n}\nfunction fun(f) { return f }\nfunction app(f,a) {\n  if (f instanceof Function) return f(a)\n  else return [f, a]\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet test = fun(x => app(x, fun(y => y)))\nprint(stringify(test))\n</code>\n</aside>\n<aside>\n<p>Simply-typed Lambda Calculus (STLC)</p>\n<p>Based on our normalizing implementation of untyped lambda calculus, let‚Äôs add type checking.</p>\n<p>The basis is an untyped kernel:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction isfun0(f) { return f instanceof Function }\nfunction fun0(f) { assert(isfun0(f)); return f }\nfunction app0(f,a) {\n  if (isfun0(f)) { return f(a) }\n  else return [f, a]\n}\n</code>\n<p>Let‚Äôs define our language of types. We need base types and function types. For base types we just use strings.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction funtype(atp,rtp) {\n  assert(istype(atp), \"illegal arg type: \"+atp)\n  assert(istype(rtp), \"illegal res type: \"+rtp)\n  return [\"->\", atp, rtp]\n}\nfunction isbasetype(t) { return typeof(t) == \"string\" }\nfunction isfuntype(t) { return t instanceof Array && t[0] == \"->\" }\nfunction istype(t) { return isfuntype(t) || isbasetype(t) }\n</code>\n<p>We represent typed terms by pairing an untyped term with its type. We also define some useful extractors:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction typed(e,t) { return [\"typed\", e, t] }\nfunction istyped(f) { return f instanceof Array && f[0] == \"typed\" }\nfunction untyped(e) { assert(istyped(e),\"no type: \"+e); return e.slice(1) }\n</code>\n<p>It‚Äôll be useful to print out terms and their types:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction printt(e) {\n  let [tm,ty] = untyped(e)\n  print(\"term: \"+stringify(tm))\n  print(\"type: \"+stringify(ty))\n}\n</code>\n<p>Finally we‚Äôre ready to implement typed abstraction, application, and constants:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction fun(atp,f) {\n  assert(istype(atp), \"illegal arg type: \"+atp)\n  return typed(\n    fun0(x => untyped(f(typed(x,atp)))[0]),\n    funtype(atp, untyped(f(typed(\"x?\",atp)))[1]))\n}\nfunction app(f,a) {\n  let [f1,ftp] = untyped(f)\n  let [a1,atp] = untyped(a)\n  assert(isfuntype(ftp), \"not a function: \"+f)\n  let [,ptp,rtp] = ftp\n  assert(stringify(atp) == stringify(ptp),\n    \"type mismatch: \"+stringify(atp)+\" != \"+stringify(ptp))\n  let res = app0(f1, a1)\n  return typed(res,rtp)\n}\nfunction constant(tm,ty) {\n  assert(istype(ty), \"illegal type: \"+ty)\n  return typed(tm,ty)\n}\n</code>\n<p>Some notes:</p>\n<ul>\n<li>In ‚Äòfun‚Äô, the result type must not depend on the argument. Hence, it is safe to call f with a synthetic argument ‚Äúx?‚Äù</li>\n<li>In ‚Äòapp‚Äô, we compare types by comparing their string representations. This is a bit crude but works.</li>\n</ul>\n<p>Examples:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet intId = fun(\"Int\", x => x)\nprintt(intId)\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet eta = fun(funtype(\"Int\",\"Int\"), f => fun(\"Int\", x => app(f,x)))\nprintt(eta)\nlet etaIntId = app(eta, fun(\"Int\", x => x))\nprintt(etaIntId)\n</code>\n</aside>\n<p>The real deal:</p>\n<aside>\n<p>Dependently-typed Lambda Calculus</p>\n<p>We start again with our familiar untyped kernel:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction isfun0(f) { return f instanceof Function }\nfunction fun0(f) { assert(isfun0(f)); return f }\nfunction app0(f,a) {\n  if (isfun0(f)) { return f(a) }\n  else return [f, a]\n}\n</code>\n<p>In constrast to languages with simpler type systems, we no longer have a separate syntactic category of types. Instead, we unify the term and type syntax: a type is a term with type ‚ÄúType‚Äù. The term ‚ÄúType‚Äù is a constant of type ‚ÄúKind‚Äù. In our implementation, ‚ÄúKind‚Äù is not a user-accessible term, although that would be possible to add (with a proper system of ‚Äúuniverses‚Äù).</p>\n<p>Function types A -> B are generalized to dependent function types (x:A) -> B where the result type B is allowed to refer to x. Due to the logical interpretation we‚Äôll call these forall types, with the following untyped/unchecked primitive representation:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction forall0(atp,f) { return [\"forall\", atp, f] }\nfunction isforall0(f) { return f instanceof Array && f[0] == \"forall\" }\n</code>\n<p>Again, we represent typed terms by pairing an untyped term with its type. However, we chose to eta-expand on the JS level, so that we can use standard function call syntax <code class=\"language-text\">f(a)</code> instead of <code class=\"language-text\">app(f,a)</code>:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction typed(e,t) {\n  let o = (a => app(o,a))\n  o.untyped = e; o.type = t\n  return o\n}\nfunction istyped(e) { return e.untyped && e.type }\nfunction untyped(e) { assert(istyped(e),\"no type: \"+e); return [e.untyped,e.type] }</code>\n<p>Note that we could do this selectively, only for function types, by inspecting t. We could further chose to eta-expand all functions at the object-language level as well (eta-long normal form), which is what many implementations of typed normalization-by-evaluation do.</p>\n<p>Finally we‚Äôre ready to implement the user-facing API for dependently-typed abstraction, application, as well as dependent function types and constants:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction forall(atp,f) {\n  let [atpt,atpk] = untyped(atp)\n  assert(atpk == \"Type\" || atpk == \"Kind\", \"illegal arg type/kind: \"+atpk)\n  let [res,tpe] = untyped(f(typed(\"x?\",atpt)))\n  return typed(forall0(atpt, x => untyped(f(typed(x,atpt)))[0]), tpe)\n}\nfunction fun(atp,f) {\n  let [atpt,atpk] = untyped(atp)\n  assert(atpk == \"Type\" || atpk == \"Kind\", \"illegal arg type/kind: \"+atpk)\n  return typed(\n    fun0(x => untyped(f(typed(x,atpt)))[0]),\n    forall0(atpt, x => untyped(f(typed(x,atpt)))[1]))\n}\nfunction app(f,a) {\n  let [f1,ftp] = untyped(f)\n  let [a1,atp] = untyped(a)\n  assert(isforall0(ftp), \"not a function: \"+f)\n  let [key,ptp,frtp] = ftp\n  assert(stringify(atp) == stringify(ptp),\n    \"type mismatch: \"+stringify(atp)+\" != \"+stringify(ptp))\n  let res = app0(f1, a1)\n  let rtp = frtp(a1)\n  return typed(res,rtp)\n}\nfunction constant(tm,ty) {\n  let [tyt,tyk] = untyped(ty)\n  assert(tyk == \"Type\" || tyk == \"Kind\", \"illegal arg type/kind: \"+tyk)\n  return typed(tm,tyt)\n}\nType = typed(\"Type\",\"Kind\")\n</code>\n<p>That‚Äôs it!</p>\n<p><strong>Exercise:</strong> add syntactic sugar for multi-argument functions and applications.</p>\n</aside>\n<p>Also known as the Calculus of Constructions (CoC), located in the corner opposite of STLC in <a href=\"https://en.wikipedia.org/wiki/Lambda_cube\">Barendregt‚Äôs Lambda Cube</a></p>\n<h3>Basic Examples</h3>\n<p>The type-level identity function: (t:Type) => t</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet typeId = fun(Type, t=>t)\nprintt(typeId)\n</code>\n<p>The polymorphic identity function: (t:Type) => (x:t) => x</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet polyId = fun(Type, t => fun(t, x => x))\nprintt(polyId)\n</code>\n<p>The same function, eta-expanded to demonstrate reduction under lambda:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet polyId = fun(Type, t => fun(t, x => fun(t, y => y)(x)))\nprintt(polyId)\n</code>\n<h3>Numbers and Arithmetic</h3>\n<p>Peano numbers, axiomatized as constants:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet N = constant(\"N\",Type)\nlet z = constant(\"z\",N)\nlet s = constant(\"s\",forall(N,x=>N))\n</code>\n<p>Example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet three = s(s(s(z)))\nprintt(three)\n</code>\n<p>Church numerals:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet ff = T => forall(T, x => T) // fun type T->T\nlet ChurchT = forall(Type, N => forall(N, z => forall(ff(N), s => N)))\nlet ChurchN = f => fun(Type, N => fun(N, z => fun(ff(N), s => f(N)(z)(s))))\n</code>\n<p>Conversion to Peano:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet peano = fun(ChurchT, n => n(N)(z)(s))\n</code>\n<p>Example:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet three = ChurchN(N => z => s =>\n    s(s(s(z))))\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nprintt(three)\n</code>\n<p>It looks much nicer in Peano format:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprintt(peano(three))\n</code>\n<p>Addition on church numerals:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet plus = fun(ChurchT, a => fun(ChurchT, b =>\n  ChurchN(N => z => s => {\n     let b1 = b(N)(z)(s)\n     return a(N)(b1)(s)})))\n</code>\n<p>Example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet six = plus(three)(three)\nprint(\"3+3=6:\")\nprintt(peano(six))\n</code>\n<p><strong>Exercise:</strong> implement multiplication and exponentiation on Church numerals.</p>\n<p><strong>Exercise:</strong> implement length-indexed lists (vectors) and concatenation.</p>\n<h3>Appendix</h3>\n<aside>\n<h2>Resources</h2>\n<p>Related tutorials:</p>\n<ul>\n<li><a href=\"http://davidchristiansen.dk/tutorials/nbe/\">Checking Dependent Types with Normalization by Evaluation: A Tutorial</a> David Thrane Christiansen 2018</li>\n<li><a href=\"https://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html\">Simpler, Easier! An Implementation of a Dependently Typed Lambda Calculus</a> Lennart Augustsson 2007</li>\n<li><a href=\"https://www.andres-loeh.de/LambdaPi/\">A Tutorial Implementation of a Dependently Typed Lambda Calculus</a> Andres L√∂h, Conor McBride, Wouter Swierstra 2007</li>\n<li><a href=\"https://github.com/sweirich/pi-forall\">OPLSS Tutorial Notes and Lectures</a> Stephanie Weirich 2014</li>\n<li><a href=\"http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/\">How to Implement Dependent Type Theory</a> Andrej Bauer 2012</li>\n</ul>\n<p>Selected other resources:</p>\n<ul>\n<li><a href=\"http://thelittletyper.com\">The Little Typer</a> Dan Friedman, David Thrane Christiansen 2018</li>\n<li><a href=\"https://www.manning.com/books/type-driven-development-with-idris\">Type-Driven Development with Idris</a>, <a href=\"http://docs.idris-lang.org/en/latest/tutorial/index.html\">The Idris Tutorial</a> Edwin Brady 2017</li>\n<li><a href=\"https://repository.ubn.ru.nl/handle/2066/17240\">Introduction to generalized type systems</a> (the lambda cube) Henk Barendregt 1991</li>\n<li><a href=\"https://doi.org/10.1016/0167-6423(95)00021-6\">An algorithm for type-checking dependent types</a> Thierry Coquand 1996</li>\n</ul>\n</aside>","fields":{"slug":"/Public/Generic/dependent-types/"},"frontmatter":{"date":"2020-10-26","title":"Implementing Dependent Types","description":"A minimal embedding of a dependently-typed language in JavaScript","keywords":"dependent types, type theory, calculus of constructions, higher-order abstract syntax, HOAS, normalization by evaluation, NBE, tagless final, finally tagless, church numerals","tags":null}}},{"node":{"excerpt":"This is a whirlwind tour of writing parsers by hand. Why would you want to do that, when tools like Yacc exist to do it for you? It‚Äôs highly‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>This is a whirlwind tour of writing parsers by hand. Why would you want to do that, when tools like Yacc exist to do it for you?</p>\n<ul>\n<li>It‚Äôs highly instructive, in a way that using a parser generator is not. To quote Feynman: ‚ÄúWhat I cannot create, I do not understand‚Äù</li>\n<li>It‚Äôs an important skill: most real-world compilers use hand-written parsers because they provide more control over error handling, significant whitespace, and so on.</li>\n<li>It‚Äôs not actually difficult!</li>\n</ul>\n<p>If you‚Äôre an educator, here are some additional thoughts:</p>\n<aside>\n<p>The role of parsing in compiler classes</p>\n<p>Nothing gets CS academics and amateur compiler <a href=\"https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/\">astronauts</a> more excited than the zoo of parsing techniques and their relative strengths and weaknesses.</p>\n<p>Your average compiler class? Expect several weeks of grammar formalisms (LL, LR, LALR, SLR, etc) and automata construction. Instructors love it because it feels ‚Äúdeep‚Äù and because students don‚Äôt <em>really</em> have to understand it. In fact, students never <em>actually</em> have to implement a parser! Instead, they use a parser generator such as Yacc, and all they have to do is hack their grammar definition file until the tool stops complaining about shift/reduce conflicts. <!-- In the end, they can just hack their grammar definition until Yacc (or the instructor's equivalent tool of choice) stops complaining about shift/reduce conflicts.--></p>\n<p>My take? The theory of formal languages and their relation to automata, logic, and complexity is beautiful. But if the goal is to convey practical compiler-building skills I believe we should forget about most of the formalisms focused on subclasses of context-free languages and instead teach students straightforward methods to write parsers by hand:</p>\n<ul>\n<li>Very few compiler classes treat formal languages at an <em>actual</em> rigorous level (theorems, proofs, etc.) so this topic is best served by a dedicated theory of computation class (think Myhill-Nerode, Chomsky-Sch√ºtzenberger, LBA theorem, etc.).</li>\n<li>The large focus on parsing takes away time and space from teaching other interesting (and arguably more relevant) aspects of compilers: compiling expressive language features, optimizations, advanced static checking, or dynamic runtimes.</li>\n<li>Context-free grammar formalisms are less relevant than one might think. Most realistic compilers need degrees of context-sensitivity and thus use hand-written parsers: either because the core language grammar is context-sensitive (e.g., significant whitespace as in Python) or because the general user experience profits from context-sensitivity (e.g., error handling, feedback in IDEs).</li>\n</ul>\n<p>So should we just not teach parsing at all? Just use a tool and be done with it? Absolutely not. Parsing is an important topic and can be quite insightful when taught the right way.</p>\n<p>But blindly using a tool without understanding what it does is never a good idea.\nBy contrast, writing a recursive-descent parser from scratch:</p>\n<ul>\n<li>is highly instructive, in a way that using a parser generator is not (Feynman: ‚ÄúWhat I cannot create, I do not understand‚Äù)</li>\n<li>is a highly relevant practical skill, given that most real-world compilers use hand-written parsers (for reasons noted above; see also [1] for a recent survey)</li>\n<li>is not actually difficult!</li>\n</ul>\n<p>Let‚Äôs address some foreseeable criticism right away:</p>\n<ul>\n<li>\n<p><em>‚Äù‚Ä¶ but ambiguity! ‚Ä¶ dangling else!‚Äù</em></p>\n<p>Wrong! A recursive-descent parser written in a deterministic implementation language is deterministic, period. It has to resolve ambiguity one way or another. So the underlying\n<em>grammar</em> may be ambiguous, but the parser is not.</p>\n</li>\n<li>\n<p><em>‚Äù‚Ä¶ but LR can parse more programs! ‚Ä¶ left recursion!‚Äù</em></p>\n<p>Wrong! It‚Äôs actually the other way round. You‚Äôre thinking of LL grammars, but recursive-descent parsers are not at all restricted to that class. We can easily parse context-sensitive languages, which is <em>more</em> than LR can do. And potentially, we could include any Turing-complete logic in our parser, even though that might be of dubious use. Left recursion can be implemented using a form of ‚Äúrecursive ascent‚Äù, quite similar to how it‚Äôs done in LR (parse a list, collapse it to the left). This logic is typically only needed in one place where it‚Äôs easily generalized, namely to support binary and unary operators with arbitrary precedence and left/right associativity.</p>\n</li>\n<li>\n<p><em>‚Äù‚Ä¶ but I tried and it was a mess!‚Äù</em></p>\n<p>Well, my friend, that‚Äôs because you hadn‚Äôt seen this article! Read it thoroughly, and then tell me about complexity again. My guess is that you didn‚Äôt know how to deal with generic operator precedence and spent a lot of time manually adding auxiliary productions and left-factoring your grammars. That‚Äôs something easily avoided.</p>\n</li>\n</ul>\n<p>Clearly, there is more to be said about teaching effective compiler classes (topic for another post!). But finding the right angle to cover parsing appears to be a key ingredient ‚Äî it certainly has been for me in redesigning <a href=\"https://tiarkrompf.github.io/cs502/\">my classes at Purdue</a>.</p>\n<p>[1] Parser generators vs. handwritten parsers: surveying major language implementations in 2021 <a href=\"https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html\">https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html</a></p>\n</aside>\n<h3>The Result</h3>\n<p>We focus on arithmetic expressions, but the concepts and techniques immediately generalize to richer languages.</p>\n<p>Enter an expression on the left and see the parse tree change!</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// core dom utils\n//\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\n//\n// text selection utils\n//\nfunction findOffsetInParent(node, pos, top) {\n  if (node == top)\n    return pos;\n  while (node.previousSibling) {\n    node = node.previousSibling;\n    var len = node.nodeType == 3 ? node.length : node.innerText.length;\n    pos = len + pos;\n  }\n  return findOffsetInParent(node.parentNode, pos, top);\n}\nfunction findChildForOffset(node, pos) {\n  var len = node.nodeType == 3 ? node.length : node.innerText.length;\n  if (pos > len)\n    return findChildForOffset(node.nextSibling, pos - len);\n  if (node.firstChild)\n    return findChildForOffset(node.firstChild, pos);\n  return {node: node, pos: pos};\n}\n//\n// text editor\n//\nlet text\nlet p = document.createElement(\"pre\")\nlet d = document.createElement(\"pre\")\nlet row = document.createElement(\"div\")\nd.style[\"border\"] = \"1px solid black\"\nrow.style[\"display\"] = \"flex\"\nrow.appendChild(p)\nrow.appendChild(d)\no.appendChild(row)\np.setAttribute(\"contenteditable\", true)\np.setAttribute(\"spellcheck\", false)\n//p.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\np.style[\"border\"] = \"1px solid black\"\np.style[\"width\"] = \"250px\"\np.style[\"height\"] = \"200px\"\np.style[\"outline\"] = \"none\"\np.style[\"overflow\"] = \"scroll\"\nd.style[\"width\"] = \"250px\"\nd.style[\"height\"] = \"200px\"\nd.style[\"margin-left\"] = \"10px\"\nd.style[\"overflow\"] = \"scroll\"\np.addEventListener(\"beforeinput\", ev => {\n  ev.preventDefault()\n  let data = ev.data || (ev.dataTransfer && ev.dataTransfer.getData(\"text/plain\")) || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  edit(start, end, data)\n  select(start + data.length, start + data.length)\n})\nfunction edit(start, end, data) {\n  text = text.substring(0, start) + data + text.substring(end, text.length)\n  p.innerText = \"\"\n  d.innerText = \"\"\n  try {\n    let txt = parse(text)\n    let ast = walk(txt)\n    p.appendChild(txt)\n    d.appendChild(ast)\n  } catch(ex) {\n    print(ex)\n  }\n}\nfunction select(start, end) {\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\n//\n// parser state & lexer\n//\nlet input, pos, peek\nlet gap\nlet str\nlet indent\nlet seq\nfunction init(s) {\n  seq = []\n  input = s;\n  pos = 0;\n  indent = gap = whitespace();\n  read()\n}\nfunction next() {\n  if (gap > 0) seq.push(\"\".padStart(gap, ' ')) // FIXME: comments!\n  if (peek != str && peek != '\\n')\n    seq.push(dom(peek, \"\", str))\n  else\n    seq.push(str)\n  let c = peek;\n  gap = whitespace();\n  read()\n  return c\n}\nfunction read() {\n  let isdigit = () => '0' <= input[pos] && input[pos] <= '9'\n  let isletter = () => 'a' <= input[pos] && input[pos] <= 'z' || 'A' <= input[pos] && input[pos] <= 'Z'\n  let start = pos\n  if (isdigit()) {\n    while (isdigit()) pos++\n    peek = \"num\"\n  } else if (isletter()) {\n    while (isletter() || isdigit()) pos++\n    peek = \"ident\"\n  } else if (input[pos] == '\\n') {\n    while (input[pos] == '\\n') {\n      peek = input[pos++]\n      indent = whitespace()\n    }\n  } else {\n    peek = input[pos++]\n  }\n  str = input.substring(start,pos)\n}\nfunction whitespace() {\n  let start = pos\n  while (input[pos] == ' ') ++pos\n  if (input[pos] == '/' && input[pos+1] == '/') {\n    pos += 2\n    while (input[pos] && input[pos] != '\\n') ++pos\n  }\n  return pos - start\n}\n//\n// parser aux\n//\nfunction dom(key, info, children) {\n  let d = e(\"span\",{key,info},...children)\n  if (key == \"error\") {\n    d.style[\"padding\"] = \"1px\"\n    d.style[\"background\"] = \"red\"\n  }\n  return d\n}\nfunction collect(k,f) {\n  let save = seq\n  let res = []\n  seq = res\n  try { f() } finally {\n  seq = save\n  let d = dom(k,\"\",res)\n  seq.push(d)\n  }\n  return res\n}\nfunction error(msg) {\n  seq.push(dom(\"error\", msg, []))\n  collect(\"skip\", () => {\n    while (peek && peek != '\\n' && peek != '*' && peek != '+' && peek != ')')\n      next()\n  })\n  throw new Error(msg)\n}\nfunction expect(d) {\n  if (peek == d) {\n    next()\n  } else {\n    try { error(d+\" expected\") }\n    catch (ex) {\n      if (peek == d) next(); else throw ex\n    }\n  }\n}\n//\n// main parser logic\n//\nfunction split(d,f) {\n  collect(d, () => {\n    for (;;) { try { f(); } catch (ex) {}; if (peek == d) next(); else break }    })\n}\nfunction splitNL(d,f) {\n    for (;;) { f(); if (peek == '\\n' && indent == d) next(); else break }\n}\nfunction block(ind) {\n  function expr() {\n    split('=', () => {\n      split('+', () => {\n        split('*', () => {\n          if (peek == '\\n' && indent > ind) {\n            collect('I'+indent, () => {\n              next()\n              block(indent)\n              if (peek == '\\n' && indent == ind) next()\n            })\n          } else if (peek == '(') {\n            collect('()', () => {\n              next()\n              try { expr() } catch(ex) {} // could rethrow if no match\n              expect(')')\n            })\n          } else if (peek == \"num\" || peek == \"ident\") {\n            next()\n          } else {\n            error(\"atom expected\")\n          }\n        })\n      })\n    })\n  }\n  splitNL(ind, () => {\n    if (peek && peek != '\\n')\n      expr()\n  })\n}\n//\n// string -> cst (concrete syntax tree: structured text as html dom)\n//\nfunction parse(text) {\n  try {\n    init(text)\n    block(indent)\n    let max = 20\n    while (peek && max--) {\n      try { error(\"unexpected \"+peek) } catch(ex) {}\n      //if (isDelimiter(peek))\n        next()\n      block(indent)\n    }\n    if (peek) error(\"unexpected \"+peek)\n    // Q: need to emit last gap?\n  } catch (ex) {}\n  if (pos-1 < text.length) {\n    seq.push(dom(\"skipped\",\"\",[text.substring(pos-1,text.length)]))\n  }\n  return dom(\"P\",\"\",seq)\n}\n//\n// cst -> ast (abstract syntax tree: html dom formatted as tree)\n//\nfunction walk(a) {\n  let ch = []\n  for (let c of a.children) ch.push(walk(c))\n  //if (a.key in {'+':0,'*':0,'‚èé':0,'=':0,'T':0} && ch.length == 1) return ch[0]\n  if (ch.length == 1) return ch[0]\n  let l = (a.key + \" \\\"\"+ (a.info||a.textContent) + \"\\\"\").replaceAll(\"\\n\",\"‚èé\");    let d = e(\"div\", {}, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  return d\n}\n//\n// main\n//\n{\n  text = \"3+4*5*(1+2)\\n\"\n  let txt = parse(text)\n  let ast = walk(txt)\n  p.appendChild(txt)\n  d.appendChild(ast)\n}\n</code>\n<h3>Step by Step</h3>\n<aside>\n<h3>Step 1 - Arithmetic Expressions and Operator Precedence</h3>\n<p>One thing that‚Äôs often thought to be a challenge for hand-written parsers is parsing arithmetic expressions with the proper operator precedence, e.g., parsing <code class=\"language-text\">2*6+4*5</code> as <code class=\"language-text\">(2*6)+(4*5)</code>.</p>\n<p>But faster than you can say recursive descent, LL(1), factoring, left recursion, Pratt parsing, etc., I‚Äôll show you how to do it in 10 lines of JavaScript.</p>\n<p>Ready? Here you go (imperative style):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet input = \"2*6+4*5\"\nlet sum = 0\nfor (let term of input.split(\"+\")) {\n  let prod = 1\n  for (let factor of term.split(\"*\")) {\n    prod *= Number.parseInt(factor)\n  }\n  sum += prod\n}\nprint(sum + \" == \" + (2*6+4*5))\n</code>\n<p>Oh, you prefer a functional style? Bam, 2 lines.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet prod = s => s.split(\"*\").map(Number).reduce((x,y)=>x*y)\nlet sum  = s => s.split(\"+\").map(prod).reduce((x,y)=>x+y)\nprint(sum(\"2*6+4*5\") + \" == \" + (2*6+4*5))\n</code>\n<p>The code snippets above are editable, so feel free to play around!</p>\n<p>Clearly this is not the end of the road. But if parsing simple expressions with the right precedence (‚Äù<code class=\"language-text\">*</code>‚Äù before ‚Äù<code class=\"language-text\">+</code>‚Äù) is all you wanted to do <em>you can stop right here!</em> Nothing else is needed.</p>\n<p>Even if you want to go further, it‚Äôs important to realize that the basic idea behind operator precedence and in fact most other parsing tasks is <em>right there</em>:</p>\n<blockquote>\n<p>Repeatedly group the input based on delimiter characters</p>\n</blockquote>\n<p><strong>Exercise:</strong> the code above is editable - change it to build an AST instead of computing the result directly. Hint: use JS arrays to build S-expressions such as <code class=\"language-text\">[\"+\", [\"*\", 2, 6], [\"*\", 4, 5]]</code>.</p>\n<p><strong>Exercise:</strong> prove that the input language is a regular language (corollary: no context-free grammar or parsing approach is necessary so far, a deterministic finite automaton (DFA) is sufficient). Hint: provide a regular expression that describes the input language or a DFA that parses it.</p>\n</aside>\n<aside>\n<h3>Step 2 - Parsing in a Single Pass</h3>\n<p>The first implementation above is inefficient: it traverses and copies the input string multiple times. This may not actually matter in practice, but sometimes it does. It also makes it a bit harder to add certain other features, some of which are important.</p>\n<p><strong>Exercise:</strong> think about how you‚Äôd add support for parentheses (‚Äù<code class=\"language-text\">(...)</code>‚Äù) above. Will your idea deal with <code class=\"language-text\">(1+2)+7*((3+4)*7)+5</code> correctly?</p>\n<p>Let‚Äôs change the code to process the input strictly left to right. What‚Äôs the best way to guarantee this? We‚Äôll use an iterator interface that only allows to inspect the current character and advance to the next.</p>\n<code class=\"runScript\" filter=\"setPreamble\">\nlet input, pos, peek\nfunction init(s) { input = s; pos = 0; peek = input[pos++] }\nfunction next() { let c = peek; peek = input[pos++]; return c }\n</code>\n<p>Instead of using JS‚Äôs built-in <code class=\"language-text\">String.split</code> function, we implement our own replacement. Since we don‚Äôt want to return a string (which would need to be traversed again) we take a callback function as argument:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction split(d,f) {\n  for (;;) { f(); if (peek == d) next(); else break }\n}\n</code>\n<p>The way we use <code class=\"language-text\">split</code> is as follows. It‚Äôs really similar to what we had before ‚Äî the main difference is that the string to be split is now implicit.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction expr() {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\n</code>\n<p>We‚Äôre modularizing things a little bit on the way. The core expression parsing logic has moved to its own function <code class=\"language-text\">expr</code>, and we add a driver function <code class=\"language-text\">parse</code> to run it.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction parse(s) {\n  init(s)\n  let res = expr()\n  assert(!peek, \"unexpected input: \"+peek)\n  return res\n}\n</code>\n<p>The top-level function <code class=\"language-text\">parse</code> also checks that we‚Äôve consumed the entire input. This is important, because:</p>\n<blockquote>\n<p>Internal routines are set up to stop consuming input when they can‚Äôt make sense of the next character.</p>\n</blockquote>\n<p>The last missing piece is our own function to parse numbers:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction number() {\n  let isdigit = () => '0' <= peek && peek <= '9'\n  assert(isdigit(), \"expected a number: \"+peek)\n  let n = Number(next())\n  while (isdigit())\n    n = n * 10 + Number(next())\n  return n\n}\n</code>\n<p>The <code class=\"language-text\">assert</code> serves to assure that there is at least one digit.</p>\n<p>Now we‚Äôre ready to run examples:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"2*6+4*5\") + \" == \" + (2*6+4*5))\n</code>\n<p><strong>Exercise:</strong> how much faster is this version? (a) asymptotically, in big-O terms (b) experimentally, in milliseconds on sufficiently large inputs.</p>\n</aside>\n<aside>\n<h3>Step 3 - Parentheses and Recursive Grouping</h3>\n<p>Let‚Äôs add parentheses! These can be arbitrarily nested, so our parser becomes recursive. Hence, the approach is called ‚Äúrecursive descent‚Äù:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction expr() {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      if (peek == '(') {\n        next()           // consume opening paren\n        prod *= expr()   // parse nested expression\n        assert(peek == ')', \"expected ')': \"+peek)\n        next()           // consume closing paren\n      } else\n        prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\n</code>\n<p>Done!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"2*(6+4)*5\") + \" == \" + (2*(6+4)*5))\n</code>\n<p>Looking at the formal language side of things, recursion without parameters means that the grammar is <em>context-free</em>: an expression is always parsed the same way, independent of the context it appears in.</p>\n</aside>\n<aside>\n<h3>Step 4 - Whitespace and Tokenization</h3>\n<p>One limitation of our parser is that it doesn‚Äôt permit\nspaces, line breaks, or comments (‚Äúwhitespace‚Äù).</p>\n<p>Wouldn‚Äôt it be nice if we could add spaces anywhere?</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction whitespace() {\n  while (input[pos] == ' ' || input[pos] == '\\n') pos++\n}\nfunction init(s) { input = s; pos = 0; read() }\nfunction read() { whitespace(); peek = input[pos++] }\nfunction next() { let c = peek; read(); return c }\n</code>\n<p>Done! We no longer return every character but chose to skip some we want to ignore.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"2 * ( 6 + 4 ) * 5\") + \" == \" + (2*(6+4)*5))\n</code>\n<p>Our handling of whitespace is an instance of an important pattern: lexical scanning or <em>tokenization</em>. Instead of blindly iterating over raw characters, iterate over meaningful chunks of characters (‚Äútokens‚Äù). In essence:</p>\n<blockquote>\n<p>Read word-for-word, not letter-by-letter</p>\n</blockquote>\n<p><strong>Exercise:</strong> add line comments: skip to end of line when seeing <code class=\"language-text\">#</code> or <code class=\"language-text\">//</code></p>\n<p><strong>Exercise:</strong> add delimited comments: skip parts enclosed between <code class=\"language-text\">/*</code> and <code class=\"language-text\">*/</code>. There is a design choice whether these should be nestable. Try both versions!</p>\n<p>Note that the current implementation literally allows spaces <em>everywhere</em>, including as part of a number. This may or may not be what we want!</p>\n<p><strong>Exercise:</strong> treat numbers as atomic <em>tokens</em>. Hint: modify <code class=\"language-text\">number</code> so that it can be invoked from <code class=\"language-text\">read</code>.</p>\n<aside>\n<p>Solution</p>\n<p>Here is a fairly complete tokenizer solution that also recognizes identifiers and line comments, for good measure:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet str\nfunction read() {\n  let isdigit = () => '0' <= input[pos] && input[pos] <= '9'\n  let isletter = () => 'a' <= input[pos] && input[pos] <= 'z' || 'A' <= input[pos] && input[pos] <= 'Z'\n  let start = pos\n  if (isdigit()) {\n    while (isdigit()) pos++\n    peek = \"num\"\n  } else if (isletter()) {\n    while (isletter() || isdigit()) pos++\n    peek = \"ident\"\n  } else if (input[pos] == '\\n') {\n    while (input[pos] == '\\n') {\n      peek = input[pos++]\n      indent = whitespace()\n    }\n  } else {\n    peek = input[pos++]\n  }\n  str = input.substring(start,pos)\n}\nfunction whitespace() {\n  let start = pos\n  while (input[pos] == ' ') ++pos\n  if (input[pos] == '/' && input[pos+1] == '/') {\n    pos += 2\n    while (input[pos] && input[pos] != '\\n') ++pos\n  }\n  return pos - start\n}\n</code>\n<p>Note that <code class=\"language-text\">peek</code> will be set to string literals <code class=\"language-text\">\"num\"</code> or <code class=\"language-text\">\"ident\"</code>, whereas <code class=\"language-text\">str</code> will hold the data actually read. Conversion to an actual number is elided in the snippet above.</p>\n</aside>\n<p>Tokenization is not essential (‚Äúscannerless‚Äù parsers exist), but it is a useful design pattern and can be seen as an optimization. In particular it enables distinguishing between keywords (e.g., <code class=\"language-text\">if</code>,<code class=\"language-text\">else</code>, etc.) and identifiers (i.e., potential variable names) without backtracking.</p>\n</aside>\n<aside>\n<h3>Step 5 - Significant Whitespace</h3>\n<p>Some languages like Python attach meaning to whitespace and use indentation to indicate grouping, much like braces or parantheses in other languages.</p>\n<p>How can we achieve this in our parser? We need two small changes. First, we no longer skip newlines (only spaces) and we keep track of the number of spaces at the beginning of a line:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction whitespace() {\n  let start = pos\n  while (input[pos] == ' ') pos++\n  return pos - start\n}\nlet indent\nfunction init(s) { input = s; pos = 0; indent = whitespace(); read() }\nfunction next() { let c = peek; read(); return c }\nfunction read() {\n  whitespace(); peek = input[pos++]\n  if (peek == '\\n') indent = whitespace()\n}\n</code>\n<p>Second, we keep track of the current indentation of each expression and proceed much like we do for parentheses when we detect a newline with increased indentation:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction expr(ind) {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      if (peek == '\\n' && indent > ind) {\n        next()\n        prod *= expr(indent)\n        if (peek == '\\n' && indent == ind) next()\n      } else if (peek == '(') {\n        next()\n        prod *= expr(ind)\n        assert(peek == ')', \"expected ')': \"+peek); next()\n      } else\n        prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\nfunction parse(s) {\n  init(s)\n  let res = expr(indent)\n  assert(!peek, \"unexpected input: \"+peek)\n  return res\n}\n</code>\n<p>Now we can parse indented blocks as an alternative grouping mechanism to parentheses, or both in combination. An example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet inp = `3*(\n 1+4*\n  2\n+2)`\nprint(parse(inp) + \" == \" + (3*((1+4*(2))+2)))\n</code>\n<p>From a formal language perspective, our input language is now <em>context-sensitive</em>: how exactly an expression is parsed depends on the context it occurs in. Note how this is easily and efficiently implemented by parameterizing the recursive function <code class=\"language-text\">expr</code> with a context abstraction <code class=\"language-text\">ind</code>.</p>\n<p><strong>Exercise</strong>: observe that our parser always requires a closing paranthesis but leaves ‚Äúexdentation‚Äù optional. Why is this a reasonable choice, and what would change if exdentation were required? Try it out!</p>\n</aside>\n<aside>\n<h3>Step 6 - Error Handling and Recovery</h3>\n<p>Right now our parser immediately throws an exception and aborts when\nencountering an error in the program.</p>\n<p>This can be a reasonable strategy, but it‚Äôs often more useful to see if there are additional errors in a program so that the programmer can decide which one to fix first (clearly, there are trade-offs!).</p>\n<p>A useful strategy is to skip input until the next known delimiter whenever we hit an error:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction error(msg) {\n  while (peek && peek != '\\n' && peek != '*' && peek != '+' && peek != ')')\n    next()\n  throw new Error(msg)\n}\n</code>\n<p>We now want to unwind the stack as much as necessary to pick up the right case (<code class=\"language-text\">*</code> or <code class=\"language-text\">+</code> or <code class=\"language-text\">)</code> etc.)</p>\n<p>To achieve this, the code that deals with delimiters is modified to try proceeding normally after an error:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction split(d,f) {\n  for (;;) {\n    try { f() } catch (ex) { }\n    // we know that we stopped at a delimiter,\n    // let's see if it was possibly ours\n    if (peek == d) next(); else break\n  }\n}\n</code>\n<p>Note how this strategy maps very closely to standard exception handling patterns in a recursive-descent context.</p>\n<p>For cases where we expect a specific token such as a closing parenthesis, we can implement a helper function <code class=\"language-text\">expect</code> that tries to skip ahead if the token is not found immediately and either continues if the token is found in this way or propagates the error if a non-matching delimiter was found instead:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction expect(d) {\n  if (peek == d) {\n    next()\n  } else {\n    try { error(d+\" expected\") }\n    catch (ex) {\n      if (peek == d) next(); else throw ex\n    }\n  }\n}\n</code>\n<p>Another missing piece is that we might hit an error after parsing a perfectly valid prefix of the program. This means that we terminate early with some input left over. To deal with such situations, we need to insert pieces of retry logic in critical places, including at the very top:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction parse(text) {\n  init(text)\n  expr(indent)\n  let max = 20\n  while (peek && max--) {\n    try { error(\"unexpected input:\"+peek) } catch(ex) {};\n    if (isDelimiter(peek)) next()\n    expr(indent)\n  }\n  if (peek) error(\"unexpected input:\"+peek) // exceeded max, skip rest\n}\n</code>\n<!--\n\n  NOTE: first time that \"parse\" deals with multiple expressions!\n\n  Should introduce earlier?\n\n-->\n<p>In general, it‚Äôs a good idea to impose an upper bound on the number of such retries.</p>\n<p>These forms of error handling are all included in the example on the front page of this post.</p>\n</code>\n</aside>\n<aside>\n<p>Step 7 - Scaling Up - Generic Operator Precedence</p>\n<!-- This is really about generic operator precedence -->\n<p>The language we‚Äôve considered has remained simple on purpose, but the techniques we discussed scale to much more complicated scenarios.</p>\n<p>To conclude, let‚Äôs discuss one very important extension, namely a general design pattern to support many more operators with varying precedence levels and left- or right associativity (commonly attributed to Vaughan Pratt).</p>\n<p>Recall our initial implementation of <code class=\"language-text\">expr</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction expr() {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      if (peek == '(') {\n        next()\n        prod *= expr()\n        assert(peek == ')', \"expected ')': \"+peek)\n        next()\n      } else\n        prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\n</code>\n<p>How should we add support for <code class=\"language-text\">-</code>, <code class=\"language-text\">/</code>, and potentially many others? Clearly we can extend <code class=\"language-text\">split</code> to look for sets of operators but we still have to list all possible precedence levels explicitly and implement the right evaluation logic in one place. This could get hairy!</p>\n<p>Let‚Äôs refactor:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet eval = {\n  '+': (x,y) => x+y,\n  '-': (x,y) => x-y,\n  '*': (x,y) => x*y,\n  '/': (x,y) => x/y\n}\nfunction factor() {\n  if (peek == '(') {\n    next()\n    let res = expr()\n    assert(peek == ')', \"expected ')': \"+peek)\n    next()\n    return res\n  } else\n    return number()\n}\nfunction term() {\n  let res = factor()\n  while (peek == '*' || peek == '/')\n    res = eval[next()](res, factor())\n  return res\n}\nfunction expr() {\n  let res = term()\n  while (peek == '+' || peek == '-')\n    res = eval[next()](res, term())\n  return res\n}\n</code>\n<p>On the surface we haven‚Äôt gained much as we still have only two levels of precedence ‚Äî but it turns out that we can actually use a single function if we extract the current level of precedence as a parameter:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// precedence: higher binds tighter\nlet prec = {\n  '+': 100,\n  '-': 100,\n  '*': 200,\n  '/': 200\n}\n// associativity: 1 for left, 0 for right\nlet assoc = {\n  '+': 1,\n  '-': 1,\n  '*': 1,\n  '/': 1\n}\nfunction binop(min) {\n  let res = factor()\n  while (peek in prec && prec[peek] >= min) {\n    let nextMin = prec[peek] + assoc[peek] // + 1 for left assoc\n    res = eval[next()](res, binop(nextMin))\n  }\n  return res\n}\nfunction expr() {\n  return binop(0)\n}\n</code>\n<p>Voil√†, now we can support an arbitrary number of operators with varying precedence levels and associativity behavior.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"8-12/3\") + \" == \" + (8-12/3))\n</code>\n<p>Importantly, we can specify our input language in a more declarative way, talking\nabout operators and their properties, rather than how each individual operator\nis parsed.</p>\n</aside>\n<!--\n\nPart 2: More Mechanics and Extensions (left for a future update!)\n\nStep 6 - Tokenization<br/>\nStep 7 - Error Handling<br/>\nStep 8 - Statements<br/>\nStep 9 - Arbitrary Operators<br/>\n\n\n<aside>\n\n### Step 6 - Tokenization\n\n\nAdd let, perhaps prints\n\n</aside>\n\n\n\n<aside>\n\n### Step 7 - Error Handling\n\nKeep stack of delimiters, skip ahead to next one. Need to return to right enclosing one.\n\n</aside>\n\n\n<aside>\n\n### Step 8 - Statements\n\nLet's add statements, delimited by newlines.\n\nTODO: idents, def, let, call, etc?\n\nSo far: as part of an indented block, consume the \"exdent\", the closing newline with parent indent. This means that we can continue reading input on that line as part of the starting expression.\n\nWhen we use newlines also to delimit statements this means that we won't \"see\" the same newline as delimiter because it is already consumed as exdent.\n\nExample:\n\n<pre>\ndef foo(x) =\n  3 + 4\nprint(7)\n</pre>\n\nWould currently be parsed as:\n\n<pre>\ndef foo(x) = (3 + 4) print(7)\n</pre>\n\nSo we'll need to rewrite it with an additional newline as\n\n<pre>\ndef foo(x) =\n  3 + 4\n\nprint(7)\n</pre>\n\nto get it parsed correctly.\n\nIf this is not what we want, there is a simple fix: just don't consume the exdent newline. Instead, leave it to be picked up as statement delimiter.\n\nThis rules out\n\n<pre>\n3 *\n  1 + 2\n+ 5\n</pre>\n\nwhich is unavoidable, but it also rules out\n\n<pre>\n3 * (\n  1 + 2\n) + 5\n</pre>\n\nforcing it to be written as\n\n<pre>\n3 * (\n  1 + 2) + 5\n</pre>\n\nwhich is less desirable.\n\nFortunately there is again a simple fix by allowing an optional exdent before a closing paren.\n\nCode:\n\n\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction splitNL(d,f) {\n    for (;;) { f(); if (peek == '\\n' && indent == d) next(); else break }\n}\nfunction expr(ind) {\n  function expr1() { // single line\n    let sum = 0\n    split('+', () => {\n      let prod = 1\n      split('*', () => {\n        if (peek == '\\n' && indent > ind) {\n          next()\n          prod *= expr(indent)\n          // do not consume exdent\n          //if (peek == '\\n' && indent == ind) next()\n        } else if (peek == '(') {\n          next()\n          prod *= expr1()\n          // allow exdented closing paren\n          if (peek == '\\n' && indent == ind) next()\n          assert(peek == ')', \"expected ')': \"+peek); next()\n        } else\n          prod *= number()\n      })\n      sum += prod\n    })\n    return sum\n  }\n  let last = 0\n  splitNL(ind, () => {\n    last = expr1()\n    print(ind+\": \"+last)\n  })\n  return last\n}\n</code>\n\nExample:\n\n<code class=\"runScript\" filter=\"coolEditor\">\nlet inp = `1\n2\n3+(\n 9\n 8+\n   7\n)+\n   9\n   2\n5`\nprint(parse(inp) + \" == \" + (3*((1+4*(2))+2)))\n</code>\n\n\n</aside>\n\n\n\n\n\n<aside>\n\n### Step 9 - Arbitrary Operators\n\nPrecedence and associativity tables\n\n</aside>\n\n-->","fields":{"slug":"/Public/Generic/just-write-the-parser/"},"frontmatter":{"date":"2020-10-19","title":"Just write the #!%/* parser","description":"Writing parsers from scratch. Why simpler is better and why you don't need a parser generator.","keywords":"parsing, grammar, operator precedence, associativity, whitespace, Python, indentation, LL(1), LR(1), LALR(1), recursive descent","tags":null}}},{"node":{"excerpt":"We propose a generic system of qualified types as unifying basis for traditionally disparate features, including regions, borrowing, non‚Ä¶","html":"<p>We propose a generic system of qualified types as unifying basis for traditionally disparate features, including regions, borrowing, non-escaping, stack allocation, aliasing, effect tracking, etc.</p>\n<h3>Intuition</h3>\n<p>The key idea is to reflect the qualifiers of variables a function closes over in the type of the function. An example:</p>\n<code>\n<p>val u = ‚Ä¶            // type: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">Œ±</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\tt A^Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathtt\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span></span></span><br/>\nval v = ‚Ä¶            // type: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"monospace\">B</mi><mi mathvariant=\"monospace\">Œ≤</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\tt B^Œ≤</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathtt\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span></span></span></span><br/>\ndef f(x:T):U =\n‚Ä¶ use u and v ‚Ä¶  // type <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"monospace\">T</mi><mo>‚Üí</mo><mi mathvariant=\"monospace\">U</mi><msup><mo stretchy=\"false\">)</mo><mrow><mi mathvariant=\"monospace\">Œ±</mi><mo>‚®Ü</mo><mi mathvariant=\"monospace\">Œ≤</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\tt (T \\to U)^{Œ± ‚®Ü Œ≤}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mopen\">(</span><span class=\"mord mathtt\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathtt\">U</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mop op-symbol small-op mtight\" style=\"position:relative;top:-0.0000050000000000050004em;\">‚®Ü</span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span></span></span></span></span><br/></p>\n</code>\n<p>Qualifiers on T and U are possible as well but not used here.</p>\n<p>The system is a generalization of the type system for ‚Äú2nd-class values‚Äù presented in the following paper:</p>\n<ul>\n<li><a href=\"https://www.cs.purdue.edu/homes/rompf/papers/osvald-oopsla16.pdf\">Gentrification Gone too Far? Affordable 2nd-Class Values for Fun and (Co-)Effect</a>.</li>\n</ul>\n<p>Leo Osvald, GreÃÅgory Essertel, Xilun Wu, Lilliam I. GonzaÃÅlez-AlayoÃÅn, Tiark Rompf. OOPSLA ‚Äò16</p>\n<h3>Applications</h3>\n<ul>\n<li><aside>\n<h2>Region-Based Memory</h2>\n<p>Type qualifiers can denote a separation of the heap into disjoint memory regions. The type system ensures that closures are allocated in the same region as the values they close over. Closing over multiple values from different regions would be prohibited in the simplest model.</p>\n<p>A partial ordering between regions relaxes this constraint, and permits references to region <code class=\"language-text\">Œ±</code> from region <code class=\"language-text\">Œ≤</code> iff <code class=\"language-text\">Œ± ‚â§ Œ≤</code> (meaning <code class=\"language-text\">Œ±</code> has a lifetime at least as long as <code class=\"language-text\">Œ≤</code>). The default region <code class=\"language-text\">‚ä•</code> is the smallest according to this order (with the longest lifetime), allowing incoming references from all other regions but no outgoing references.</p>\n<p><strong>Exercise</strong>: relate formally to Tofte &#x26; Talpin‚Äôs stack-of-regions system (and/or others from the literature).</p>\n<p><strong>Exercise</strong>: recast region system case study from OOPSLA‚Äô16 in the formalism presented here.</p>\n</aside>\n<p>Warm-up</p>\n<li><aside>\n<h2>Guaranteed Stack Allocation</h2>\n<p>Consider two regions <code class=\"language-text\">heap</code> and <code class=\"language-text\">stack</code>, with <code class=\"language-text\">heap ‚â§ stack</code>. Now restrict function types to <code class=\"language-text\">T1^Œ± -> T2^heap</code>.</p>\n<p>See OOPSLA‚Äô16 paper (Osvald et al.) for formalization and proof.</p>\n<p>Note that by subsumption, we can treat any <code class=\"language-text\">T^heap</code> value as <code class=\"language-text\">T^stack</code>, so the approximation is one-sided (‚Äúmay stack‚Äù but not ‚Äúmust stack‚Äù).</p>\n<p>But if an allocation statement (e.g., a Œª-expression or other introduction form) is typed as <code class=\"language-text\">stack</code> we know that we can indeed safely allocate it on the stack. Since functions can never return <code class=\"language-text\">stack</code> values, we can safely deallocate the ones created during a function call on function exit.</p>\n<p>See further down below for a refinement of this idea!</p>\n</aside>\n<p>OOPSLA‚Äô16</p>\n<li><aside>\n<h2>Non-Escaping (‚ÄúBorrowed‚Äù) Effect Capabilities (Co-Effects)</h2>\n<p>Stack allocation is a useful optimization if the language runtime supports it, but there are other uses for non-escaping guarantees as well. Identifying ‚Äúheap‚Äù values as 1st-class (unrestricted) and ‚Äústack‚Äù values as 2nd-class (with some restrictions) turns out to enable a range of interesting programming patterns. A particularly attractive use case is to use 2nd-class values as <em>effect capabilities</em> that are guaranteed to be valid only during the dynamic extent of a particular function call.</p>\n<p>Such capabilities represent a new take on checked effect systems (co-effects, in the terminology of Petricek et al.). A key benefit compared to standard type-and-effect systems is a more flexible approach to effect polymorphism that requires fewer user-facing annotations.</p>\n<!-- **TODO:** explain map example -->\n<p>See OOPSLA‚Äô16 paper (Osvald et al.) for details.</p>\n<p>The paper includes a large case study on adding checked exceptions to the Scala standard library. Of particular interest are higher-order functions like <code class=\"language-text\">map</code>, <code class=\"language-text\">flatMap</code>, etc. in the collections library, especially variants for parallel and non-strict collections.</p>\n<p>Qualifier polymorphism elegantly supports all these different variants. The implementation (and formalism) permits arbitrary Scala types (incl. abstract, bounded, etc. types) as qualifiers and thus unifies the Scala type lattice with the qualifier lattice.</p>\n</aside>\n<p>OOPSLA‚Äô16</p>\n<li><aside>\n<h2>Non-Escaping Continuations that are Compiled to Jumps</h2>\n<p>Traditionally, converting a program into continuation-passing style (CPS) turns blocks into closures and jumps into function calls. Since functions no longer return, the notion of a call stack disappears, and the program relies on heap allocation exclusively.</p>\n<p>Using our system of qualified types, we can introduce continuations with stack-bounded lifetimes, meaning that a stack discipline of function calls is preserved across CPS conversion (similar to earlier work by Kennedy, but more flexible).</p>\n<p>See ICFP‚Äô19 paper (Cong et al.) for details.</p>\n<p>The formal model includes returning and non-returning functions and combines a type-directed selective CPS transform with the present type sytem for escaping and non-escaping values.</p>\n<p><strong>Exercise</strong>: extend the formal model (the available control operators and the selective CPS transform) to the full CPS hierarchy, including multiple levels of delimited continuations.</p>\n</aside>\n<p>ICFP‚Äô19</p>\n<li><aside>\n<h2>More Stack Allocation, and Currying for Co-Effect Systems</h2>\n<p>The 1st- and 2nd class model as presented so far is clearly useful, both for stack allocation as optimization and as a general programming model with strong guarantees.</p>\n<p>However, there are some limitations: since function types are restricted to always return 1st-class (heap) values, a function that takes a 2nd-class (stack) value as argument cannot be curried. It is not permitted to return a function that would close over this argument, as that function would need to be typed as 2nd-class as well!</p>\n<p>What would happen if we relax this constraint and just permit arbitrary qualifiers for function return types?</p>\n<p>Nothing bad happens at the type level, but clearly we can‚Äôt perform actual stack allocation anymore. And moreover, it is not really clear anymore in a formal sense what precise guarantees the type sytems provides - so what is the right soundness theorem to prove?</p>\n<p>In practice, we found ourselves often converting pieces of code to CPS when we wanted to ‚Äúreturn‚Äù 2nd-class values, which allowed us to keep growing the stack.</p>\n<p>This lead to a very interesting new idea: what if - in direct style - we just don‚Äôt pop the stack? Let‚Äôs keep allocating 2nd-class values on the stack, and if a function returns a 2nd-class value, then we simply don‚Äôt pop the stack frame. We keep growing the stack, until we reach a caller that returns a 1st-class value. At that point we pop the stack, potentially discarding multiple stack frames at once.</p>\n<p>With that insight, we keep a precise and useful safety guarantee (stack allocation, non-escape behavior subject to qualifiers). And moreover, we obtain a more flexible and powerful stack allocation strategy: now that we have a mechanism to return freshly stack-allocated values up the call chain, we can allocate many more values on the stack!</p>\n<p>And of course we now support currying of 2nd-class functions.\nAnother interesting observation is that we can now eta-expand an equivalent of C‚Äôs <code class=\"language-text\">alloca</code> primitive into a proper function.</p>\n<p><strong>Exercise</strong>: adapt proofs from OOPSLA‚Äô16 paper to support ‚Äúlazy-popping‚Äù strategy.</p>\n<p><strong>Exercise</strong>: prove lockstep-equivalence with CPS transform (ICFP‚Äô19 paper).</p>\n<p><strong>Exercise</strong>: experimentally evaluate the benefits (time, space) of extended stack allocation on a range of benchmarks, using a runtime that supports both stack allocation and GC (e.g., Scala Offheap, Go, Swift, C++ Boehm GC).</p>\n<p><strong>Exercise</strong>: there are good reasons why allocating large amounts of data on the actual call stack might not be the best idea. An alternative is to use a shadow stack, and for some (uncooperative) environments this is in fact the only choice (e.g., Scala Offheap). Compare using the physical call stack with using a shadow stack in suitable environments.</p>\n<p><strong>Exercise</strong>: what is the operational model if we add (potentially an unbounded number of) qualifiers beyond ‚Äústack‚Äù and ‚Äúheap‚Äù? Many (nested?) regions that each operate as a stack?</p>\n<p><strong>Exercise</strong>: under what conditions can we support storing stack-allocated values in mutable stack-allocated variables? Variables further down the stack appear to be OK, but what about variables further up in situations where we don‚Äôt pop the stack right away?</p>\n<!-- **TODO:** effect polymorphism: currying 2nd class arg will always return 2nd class, even if called with 1st class arg. Polymorphism: it may be desirable to return a 1st class value in this case (could be done by saying \"return region like that of arg\"). It's less clear how to implement it: the returned function must be allocated somewhere! -->\n</aside>\n<p>NEW! ‚ÄúWhat if we don‚Äôt Pop the Stack?‚Äù</p>\n<li><aside>\n<h2>Isolating Nonterminating Fragments in Dependently-Typed Programs</h2>\n<p>Based on the observation that non-termination is a side effect, why don‚Äôt we guard potential non-termination by a 2nd-class capability, just like other effects (exceptions, IO)?</p>\n<p>A key use case where non-termination must be ruled out is in dependently-typed languages, where computations may forms parts of types but these computations are required to be pure (= terminating) for logical consistency.</p>\n<p>At the same time, it is attractive to support non-termination and potentially other side effects in parts of the program that are <em>not</em> executed at type-checking time.</p>\n<p>The simplest proof-of-concept model provides recursive functions, where the recursive binding is wrapped in a type <code class=\"language-text\">Rec</code> which needs to be explicitly unwrapped (using <code class=\"language-text\">unrec</code>) with a ‚ÄúTuring Capability‚Äù (<code class=\"language-text\">CanDiverge</code>) as parameter. The result of <code class=\"language-text\">unrec</code> is a 2nd-class value (can‚Äôt escape, can‚Äôt be stored).</p>\n<pre>\nTerms\n  e ::= n | x | Œªf(x).e | e e | unrec e e\n\nTypes\n  T ::= Nat | T1^Œ± -> T2^Œ≤ | Rec T | CanDiverge\n\nType qualifiers\n  Œ±,Œ≤,Œ≥ ::= 1 | 2\n\nType assigment:\n\n  Œì^Œ≥, f: Rec(T1^Œ± -> T2^Œ≤)^Œ≥, x:T1^Œ± ‚ä¢ e: T2^Œ≤\n  --------------------------------------------- (abs)\n  Œì ‚ä¢ Œªf(x).e: (T1^Œ±)^Œ≥\n\n\n  Œì ‚ä¢ e1: Rec(T)^Œ±  Œì ‚ä¢ e2: CanDiverge^2\n  --------------------------------------- (unrec)\n  Œì ‚ä¢ unrec e1 e2: T^2\n</pre>\n<p><strong>Exercise</strong>: write a few simple recursive programs (e.g., fac, fib) as examples. Assume that the main program gets passed a Turing capability as 2nd-class argument.</p>\n<p><strong>Exercise</strong>: complete the proof for a combined soundness/termination theorem, depending on whether a Turing capability is present in the environment. Proof setup based on combined logical relation and step-indexed logical relation, as described in the Zombie paper (Casinghino et al. POPL‚Äô14).</p>\n<p><strong>Exercise</strong>: extend a full dependently-typed language with Turing capabilities, and potentially other side effects. Perhaps based directly on the Zombie artifacts (Casinghino et al. POPL‚Äô14).</p>\n<p><strong>Exercise</strong>: extend DOT / Scala with full dependent types, using Turing capabilities to ensure termination of path expressions in type selections (<code class=\"language-text\">e.T</code>) which is necessary for type soundness.</p>\n</aside>\n<p>NEW! ‚ÄúTuring Capabilities - Non-Termination as a Co-Effect‚Äù</p>\n<li><aside>\n<h2>Tracking Aliasing and Separation</h2>\n<p>Knowing that two values must be <em>separate</em>, i.e., that they may not <em>alias</em>, enables powerful optimizations. In particular, the two values can be modified independently, without synchronization, and potentially in parallel.</p>\n<p>Regions can provide a (fine-grained) approximation: if values belong to regions that are separate, the values must be separate.</p>\n<p>In a region-monmorphic system this is straightforward. But what if regions can be abstracted over?</p>\n<!-- **XXX:** closures and self types as second ingredient? relate to Tofte and Talpin? -->\n<h3>Key Idea: A ‚ÄúFor All Separate Regions‚Äù Quantifier</h3>\n<p>We introduce a quantifer that can only be instantiated with regions that are separate from the regions used by the epression quantified over.</p>\n<p>This is enabled crucially by the fact that the region assigned to an abstraction subsumes all the regions it accesses from the definition-site environment.</p>\n<p>Hence, checking separation of the argument from the region of the abstraction is enough to guarantee separation from everything used at the definition site.</p>\n<h3>Formalization</h3>\n<pre>\nTerms\n  e ::= n | x | Œªf(x).e | e e\n\n              | ŒõŒ±.e | e[Œ±]\n\nTypes\n  T ::= Nat | T1^Œ± -> T2^Œ≤\n\n            | ‚àÄŒ±.T^Œ≤\n\nType assigment:\n\n  Function abstraction (standard):\n\n  Œì^Œ≥, x:T1^Œ± ‚ä¢ e: T2^Œ≤\n  -------------------------------- (abs)\n  Œì ‚ä¢ Œªf(x).e: (T1^Œ± -> T2^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e1: (T1^Œ± -> T2^Œ≤)^Œ≥    Œì ‚ä¢ e1: T1^Œ±\n  ------------------------------------------- (app)\n  Œì ‚ä¢ e1 e2: T2^Œ≤\n\n  Region abstraction (new):\n\n  Œì^Œ≥, Œ±::Region ‚ä¢ e: T^Œ≤\n  ------------------------ (rabs)\n  Œì ‚ä¢ ŒõŒ±.e: (‚àÄŒ±.T^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e: (‚àÄ(Œ±‚â§Œ±').T^Œ≤)^Œ≥    Œ¥‚®ÖŒ≥ = Œ±'\n  ------------------------------------- (rapp)\n  Œì ‚ä¢ e[Œ¥]: [Œ¥/Œ±]T^Œ≤\n\n</pre>\n<p>Bounded quantification can be added to enable partial overlap. With this extension the last two rules become the following:</p>\n<pre>\n  Œì, Œ±‚â§Œ±' ‚ä¢ e: T^Œ≤\n  ------------------------ (rabs)\n  Œì ‚ä¢ ŒõŒ±‚â§Œ±'.e: (‚àÄŒ±.T)^Œ≤\n\n  Œì ‚ä¢ e: ‚àÄŒ±‚â§Œ±'.T^Œ≤    Œ¥‚®ÖŒ≤ ‚â§ Œ±'\n  ------------------------------- (rapp)\n  Œì ‚ä¢ e[Œ¥]: [Œ¥/Œ±]T^Œ≤\n</pre>\n<p>Typically we want to be able to create new regions as well.\nIt is straightforward to add a <code class=\"language-text\">letregion</code> construct in the\nstyle of Milner &#x26; Tofte:</p>\n<pre>\n  Œì, Œ±::Region ‚ä¢ e: T^Œ≤   Œ± not in FV(Œ≤)\n  ---------------------------------------- (rapp)\n  Œì ‚ä¢ letregion Œ± in e: T^Œ≤\n</pre>\n<p><strong>Exercise:</strong> work through some examples.</p>\n<p><strong>Exercise:</strong> establish metatheory.</p>\n<!--\n\n### Example\n\n<pre>\n  let x = e1 in e2\n  (Œªx.e2)e1\n\n\nMotivation:\n\n<pre>\n  let f = (Œª().\n    let c = alloc()\n    Œª().c)\n  let g = f()\n  let h = g()\n</pre>\n\nTyping:\n\n<pre>\n  alloc\n     : ‚àÄŒ±.()->R^Œ±\n  c' = ŒõŒ±.Œªc.Œª().c\n     : ‚àÄŒ±.R^Œ± -> (() -> R^Œ±)^Œ±\n  f  = ŒõŒ±.Œª().c'[Œ±](alloc[Œ±]())\n     : ‚àÄŒ±.() -> (() -> R^Œ±)^Œ±\n  f' = ŒõŒ±.Œªf.g'[Œ±](f[Œ±]()\n  g  : ‚àÄŒ±.(() -> R^Œ±)^Œ±  // can't be ‚àÄŒ±.(() -> R^Œ±)^Œ± !!\n  h  :\n</pre>\n\n\n<pre>\n  Œªf:(‚àÄŒ±.R^Œ±).\n   f[Œ±](alloc[Œ±]())\n</pre>\n\n-->\n</aside>\n<p>NEW! A quantifier for regions that are separate</p>\n<li><aside>\n<h2>Dependency Tracking for Graph IRs</h2>\n<p>TODO</p>\n</aside>\n<p>NEW! A region for every variable</p>\n<li><aside>\n<h2>Dependency Tracking for Graph IRs</h2>\n<p>Graph IRs are powerful because program expressions can float around freely (code motion), be easily merged together with equivalent ones (CSE), dropped when never used (DCE), or replaced with a cheaper implementation (rewriting, strength reduction).</p>\n<p>This works really well for functional programs, but things get more complicated when side effects need to be supported. Tracking dependencies between side-effecting statements accurately is a challenge. Modeling affected state too coarsely (in the limit, distinguishing only between yes/no effects) means one won‚Äôt be able to move stuff around anymore. Modeling state too finely imposes heavy computational demands on the dependency analysis and risks overlooking some dependencies which may lead to incorrect transformations.</p>\n<p>The goal of this work is to develop a new foundation for effects and dependency analysis in the LMS compiler framework.\nLMS is built around a sophisticated Graph IR that includes pure and effectful statements as well as structured expressions such as lambdas which pose additional challenges. Building dependency analysis on a type system based on lambda calculus immediately extends the Graph IR model from first-order to higher-order programs.</p>\n<!-- Our first thrust is to infer precise dependencies between side-effecting statements, given a model of 2nd-class mutable variables. Variables can be created and passed around freely in a program, but there are no indirect references, i.e., variables cannot contain other variables. This is a reasonable model for many AI and HPC workloads based on flat tensors or arrays. -->\n<p>See also: <a href=\"/Public/Generic/graph-ir\">Prototype Implementation</a></p>\n<h3>One Variable, One Region</h3>\n<p>Our solution is to use sets of program variables as type qualifiers.</p>\n<p>A type <code class=\"language-text\">T^{}</code> means the value may not (directly or indirectly) refer to any tracked variable in context, <code class=\"language-text\">T^{x,y}</code> means it may refer to tracked variables <code class=\"language-text\">x</code> or <code class=\"language-text\">y</code>. We use the standard subset relation as partial order.</p>\n<!-- TODO: Example here? -->\n<p>We first consider a model where all variables are tracked. It is straightforward to add a distinction that also supports non-tracked values, with a separate qualifer <code class=\"language-text\">T^0</code> and taking either <code class=\"language-text\">0 &lt; {}</code> or <code class=\"language-text\">0 ‚â† {}</code> (allowing non-tracked values to become temporarily tracked or not). We consider this extension at the bottom of this note.</p>\n<p>Type assignment: let us consider the <code class=\"language-text\">let</code>-rule first.</p>\n<pre>\n  Œì ‚ä¢ e1: T1^Œ±\n  Œì, x:T1^(Œ±,x) ‚ä¢ e: T2^Œ≤\n  -------------------------------- (let)\n  Œì ‚ä¢ let x = e1 in e2: T2^(Œ≤\\{x})\n</pre>\n<p>When binding an expression to a name, the name is added to the type qualifer. When a variable goes out of scope, the name is removed from the qualifier of the result expression.</p>\n<p>Example:</p>\n<pre>\n(let x = e in  // e: T^{}\n ...           // x: T^{x}\n )             // result: T^{}\n</pre>\n<p>For functions, the same idea applies to the argument type, but we allow the return expression to depend on the argument name (possible extension: add the function name to the type, and allow both argument and result types to refer to it). This means that we‚Äôre dealing with dependent function types, and need to perform a corresponding substitution in the application case.</p>\n<p>A first cut would be this:</p>\n<pre>\n  Œì^Œ≥, x:T1^(Œ±,x) ‚ä¢ e: T2^Œ≤\n  ---------------------------- (abs)\n  Œì ‚ä¢ Œªx.e: (x:T1^Œ± -> T2^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e1: (x:T1^Œ± -> T2^Œ≤)^Œ≥   Œì ‚ä¢ e2: T1^Œ±\n  ------------------------------------------ (app)\n  Œì ‚ä¢ e1 e2: [Œ±/x]T2^Œ≤\n</pre>\n<p>However the app rule isn‚Äôt quite right: first, the substitution doesn‚Äôt appear to make a lot of sense (why not include <code class=\"language-text\">Œ±</code> right away in <code class=\"language-text\">Œ≤</code>?) and second, we can‚Äôt expect <code class=\"language-text\">e2</code> to have the same or a smaller <code class=\"language-text\">Œ±</code> as the one expected by the parameter type. If the argument type is <code class=\"language-text\">T1^{}</code>, we wouldn‚Äôt be able to pass anything bound to a variable at the call site - but what we‚Äôre actually concerned about is the definition site!</p>\n<p>The key insight is that what we <em>really</em> want in this case is that the argument is different from any variable the function <em>closes over</em>. And these are precisely the names tracked by the qualifer of the function type, <code class=\"language-text\">Œ≥</code>!</p>\n<p>So in our new rule, we demand that the argument may only overlap with the function in the names mentioned explicitly in <code class=\"language-text\">Œ±</code>:</p>\n<pre>\n  Œì ‚ä¢ e1: (x:T1^Œ± -> T2^Œ≤)^Œ≥   Œì ‚ä¢ e2: T1^Œ¥    Œ≥‚à©Œ¥ = Œ±\n  ---------------------------------------------------- (app)\n  Œì ‚ä¢ e1 e2: [Œ¥/x]T2^Œ≤\n</pre>\n<p><strong>Exercise:</strong> show that this derives let rule</p>\n<p>Note how closely the typing rules mirror those in the ‚ÄúTracking Aliasing and Separation‚Äù section on more traditional regions.</p>\n<h3>Example 1: Function Argument Separation</h3>\n<p>We assume a primitive operation <code class=\"language-text\">alloc(): V^{}</code> that produces a new reference cell (type <code class=\"language-text\">V</code>). We only consider a single side-effecting operation on variables, <code class=\"language-text\">inc: V^{} -> I^{}</code>, which returns an integer (type <code class=\"language-text\">I</code>).</p>\n<p>We further assume that all intermediate expressions are let-bound (this is a given in a graph IR).</p>\n<p>Let‚Äôs consider our first example:</p>\n<pre>\nfunction test(s) {   // s: placeholder for block start\n  let v1 = alloc()     // V^{v1}  dep {s: s}\n  let v2 = alloc()     // V^{v2}  dep {s: s}\n  let i1 = inc(v1)     //         dep {v1: v1}\n  let i2 = inc(v2)     //         dep {v2: v2}\n  let f1 = fun(v => {  // v: V^{v}\n    let i3 = inc(v)      //         dep {v: v}\n    let i4 = inc(v1)     //         dep {v1: v} // dep on v as start of block\n    return 1             //         dep {v: i3, v1: i4}\n  })                   // f1: ( (v:V^{}) -> I{} )^{f1,v1}\n  let a1 = f1(v1)      // error:  {f1,v1}‚à©{v1} = {v1} ‚â† {}\n  let a2 = f1(v2)      // ok:     {f1,v1}‚à©{v2} = {}\n  let i5 = inc(v1)     //         dep {v1: a2}\n  let i6 = inc(v2)     //         dep {v2: a2}\n  return 1\n}\n</pre>\n<p>We can make two key observations:</p>\n<ul>\n<li>Type system successfully prevents calling f1(v1), since f1 uses v1 internally and didn‚Äôt declare that v may alias v1. On the other hand, calling f1(v2) is fine, since f1 doesn‚Äôt use v2.</li>\n<li>The assigned types enable us to infer precise dependencies between statements in a given block (shown on the right).</li>\n</ul>\n<p>Another example:</p>\n<pre>\nfunction counter() {\n  let v1 = alloc()         // v1: V^{v1}\n  let f1 = fun(() => {     // f1: (U^{} -> I^{})^{v1}\n    let i1 = inc(v1)\n    return 1\n  })\n  return f1\n}\nlet g1 = counter()       // g1: ( U^{} -> I^{} )^{g1}\nlet h1 = g1()            // dep {g1: g1}\nlet h2 = g1()            // dep {g1: h1}\n                         // dep {g1: h2} // block end\n</pre>\n<p>When calling <code class=\"language-text\">counter</code>, we must make sure that the result remains being tracked, and indeed we do - because everything is tracked!</p>\n<h3>Example 2: Escaping Tracked Variables</h3>\n<p>When a function creates a mutable variable that escapes\n(directly or indirectly via another function), the identity\nof that variable is tracked, even though it does not have\nany externally visible identifier.</p>\n<p>The mechanism to achieve this is by logically subsuming\nthe escaping variable into the function via which it\nescapes, and tracking the identity of that function\nwith a self-type (just like in DOT).</p>\n<pre>\ndef f(a: Int) = {\n  let c = alloc()\n                      // f(b:Int) -> Ref^{c}\n  (fun(b: Int) => c)  //     --close-->\n                      // f(b:Int) -> Ref^{f}\n}\nlet h0 = f(0)\nlet h1 = f(1)\nlet c0 = h0(0)\nlet c1 = h0(1) // same as c0\nlet c3 = h1(0)\nlet c4 = h1(1) // same as c3\ninc(c0)\ninc(c1) // serialize with prev\ninc(c3)\ninc(c4) // serialize with prev\nget(c0)\n// expected result:\n// - ops on c0 and c1 are serialized\n// - c3 and c4 are never read and hence\n//   dce'd along with all their ops\n</pre>\n<h3>Extension 1: Tracked and Untracked Variables</h3>\n<p>In practice, the base model induces too many dependencies in realistic programs.</p>\n<p>Hence, we add a type qualifer that permits non-tracked variables, <code class=\"language-text\">T^0</code>.</p>\n<p>It is important that tracked values never become untracked. So <code class=\"language-text\">counter</code> above must remain typed as it is.</p>\n<p>But in other cases, we can gain considerable flexibility for code motion and other optimizations. In the example below we return a pure function, and we can correctly deduce that no dependencies need to be inserted between calls:</p>\n<pre>\nfunction pure() {\n  let f1 = fun(() => {     // f1: (U^0 -> I^0)^0\n    let v1 = alloc(s)        // v1: V{v1}\n    // can use local side effects here\n    return 1\n  })\n  return f1\n}\nlet g1 = counter()       // g1: ( U^0 -> I^0 )^0\nlet h1 = g1()            // dep {}\nlet h2 = g1()            // dep {}\n                         // dep {} // block end\n</pre>\n<p>This model allows us to effectively combine pure functional and side-effecting expressions in a graph IR based on dependencies.</p>\n<h3>Extension 2: Read and Write Effects, Soft and Hard Dependencies</h3>\n<p>Keep track of the last write and the set of reads after the last write.</p>\n<p>Write-after-read and write-after-write dependencies are anti-dependencies or <em>soft</em> dependencies: the subsequent write does not prevent any of the earlier statements from being DCE‚Äôd. But if the earlier statements are not DCE‚Äôd, they must ‚Äúhappen-before‚Äù the following write.</p>\n<p>Most reads can be subject to CSE, and some of the writes as well (overwriting a variable with its current value is a no-op). However, some reads are not idempotent and hence should not be subjected to CSE: reading a random number generator, or reading the next allocation address, if an <code class=\"language-text\">alloc</code> operation is modeled as a read on a global store variable. So an additional flag is needed for reads to mark non-idempotent ones, and writes require further analysis for CSE.</p>\n<h3>Extension 3: Consume Effects, Flow-Sensitivity</h3>\n<p>Tracking effects in a flow-sensitive way enables us to observe state changes of tracked variables in the type system (‚Äúsequential effects‚Äù, ‚Äútypestate‚Äù).</p>\n<p>A simple but powerful flow-sensitive effect is freeing a variable, or otherwise consuming or destroying it. Such an operation may typically be used no more than once (‚Äúaffine‚Äù) on any given value and generally renders the value inaccessible to any other operations that follow.</p>\n<p>Ownership transfer for nested mutable variables is another potential consume effect.</p>\n<h3>Discussion</h3>\n<p>Key points:</p>\n<ul>\n<li>Tracked expressions remain tracked, even though they may be returned from a function or passed through a let that removes the name from the type qualifier</li>\n<li>Unless otherwise noted, function arguments are guaranteed to be physically separate from any other value reachable from the function. This enables fine-grained dependency tracking inside the function.</li>\n</ul>\n<p>Some questions:</p>\n<ul>\n<li>What is the right safety theorem to prove?\n<ul>\n<li>What would an instrumented semantics look like against which we could prove a type soundness theorem?</li>\n<li>Or is it interesting enough to give a soundness proof with respect to the standard STLC reduction semantics?</li>\n<li>It is most likely more interesting to directly show a correctness preservation theorem for graph modifications subject to dependency constraints: reordering, eliminating, etc. does not change result as long as dependencies are preserved. This sounds like a syntactic confluence property.</li>\n</ul>\n</li>\n<li>How to support reference cells that can hold other (tracked) reference cells?\n<ul>\n<li>It seems relatively straightforward to prevent merging of separate heap regions, but supporting such merging (or ownership transfer) may be more interesting</li>\n<li>A useful starting point may be thinking about what restrictions are necessary between Œ± and Œ≤ in <code class=\"language-text\">(Ref T^Œ±)^Œ≤</code>. Is Œ± ‚â§ Œ≤ the right model?</li>\n<li>Or a notion of ownership transfer (or ‚Äúcapture‚Äù) that disables all aliases of x when x is to be stored in a ref cell (how to do that across parent scopes)? It seems that ‚Äúconsume‚Äù effects are the right way to think about this.</li>\n</ul>\n</li>\n<li>How to support control effects (delimited continuations)?</li>\n</ul>\n<h3>Formalization</h3>\n<p>Type system:</p>\n<ol>\n<li>Type assignment for direct-style terms.</li>\n<li>Type assignment for ANF expressions extended with effect dependencies. Typing rules ensure that dependencies are sufficient.</li>\n</ol>\n<p>Operational semantics:</p>\n<p>Conceptually, represent values (functions and variables) uniformly as store locations. Represent the store as a sequence of let binding on the ‚Äúoutside‚Äù of the program and use variables to denote store locations (typical context formulation, see e.g. Call by Need Lambda Calculus and Wadlerfest DOT).\nTechnically, we maintain the syntactic ANF/graph representation.</p>\n<p>In addition to standard reduction rules, provide a list of equality-preserving rewrites that can be read directionally as optimization rules.</p>\n<p>Metatheory: preservation, progress, confluence for typed terms.</p>\n<p>Corollary: compiler safety for optimizations subject to dependencies.</p>\n<!--\n### Semantics and Soundness\n\nOperational semantics: represent values (functions and variables) uniformly as store locations. Represent the store as a sequence of let binding on the \"outside\" of the program and use variables to denote store locations (typical context formulation, see e.g. Call by Need Lambda Calculus and Wadlerfest DOT paper).\n\nEvaluation rules:\n\n<pre>\nlet x = Œªz.e in E[x y] - -> let x = Œªz.e in E[[y/z]e]\nlet x = y in e - -> [y/x]e\nlet x = (let y = e1 in e2) in e3 - -> let y = e1 in let x = e2 in e3\nE[e1] - -> E[e2] if e1 - -> e2\n\nE ::= [] | let x = [] in e | let x = nf in e\n\nnf ::= Œªz.e | alloc() | inc(x)\n</pre>\n\nSubstitution lemma (may need some tweaks):\n<pre>\nIf Œì,x:S^(Œ±‚à™{x}) ‚ä¢ e: T^Œ≤ and Œì ‚ä¢ y: S^Œ± then Œì ‚ä¢ [y/x]e: [y/x]T^Œ≤\n</pre>\n\nSoundness theorem:\n<pre>\nIf Œì ‚ä¢ E[e]: T^Œ± then either e is an answer (e = x) or\nthere exists Œì', E', e' such that E[e] - -> E'[e'] and\nŒì,Œì' ‚ä¢ E'[e']: T^Œ±\n</pre>\n\nNote the concatenation of Œì,Œì' (we're adding store bindings but do not change types in the store).\n\nThe standard progress and preservation lemmas follow as corollaries.\n\n-->\n</aside>\n<p>NEW! LMS effect &#x26; mutation tracking</p>\n<li> <aside>\n<h2>More ideas</h2>\n<p>Potential other use cases:</p>\n<ul>\n<li>constexpr/macros/staging: result of a function call is constant only if the function is constant and arg is constant (belong to a ‚Äúknown at compile time‚Äù region)</li>\n<li>noninterference: restrict information flow from ‚Äúhigh-security‚Äù to ‚Äúlow-security‚Äù values/regions</li>\n<li>program slicing: split a complex program into specific parts, delineated by region assignment</li>\n</ul>\n</aside>\n</ul>\n<h3>General Formulation</h3>\n<p>Type judgements take the form <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>x</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow><annotation encoding=\"application/x-tex\">Œì ‚ä¢ x: T^Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span></span> for a type qualifier <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ±</mi></mrow><annotation encoding=\"application/x-tex\">Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span>. Function types take the form <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">T_1^Œ± \\to T_2^Œ≤</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.931438em;vertical-align:-0.24810799999999997em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2333239999999999em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span></span>. The type assignment rule for functions is the following, with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup></mrow><annotation encoding=\"application/x-tex\">Œì^Œ≥</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span></span></span> denoting an environment restricted to bindings qualified with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ≥</mi></mrow><annotation encoding=\"application/x-tex\">Œ≥</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span>.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>Œª</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì^Œ≥, x:T_1^Œ± ‚ä¢ e: T_2^Œ≤\n}{\n  Œì ‚ä¢ Œªx.e: (T_1^Œ± \\to T_2^Œ≤)^Œ≥\n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6461920000000001em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.0448000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26630799999999993em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></div>\n<p>It is often useful to assume a partial order <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚â§</mo></mrow><annotation encoding=\"application/x-tex\">‚â§</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">‚â§</span></span></span></span></span> on type qualifiers. Sometimes it is also useful to assume a smallest element <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>‚ä•</mtext></mrow><annotation encoding=\"application/x-tex\">‚ä•</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">‚ä•</span></span></span></span></span>, which typically means ‚Äúno restrictions‚Äù, i.e., denotes 1st-class values.</p>\n<aside>\n<p>General Formalization - Details</p>\n<p>We use a variant of simply-typed Œª-calculus as a basis. The core idea extends naturally to System F and beyond (the OOPSLA‚Äô16 paper presents a model based on System D&#x3C;:>).</p>\n<!-- Œ±Œ≤Œ≥ -->\n<h3>Syntax</h3>\n<pre>\nTerms\n  e ::= n | x | Œªx.e | e e\n\nTypes\n  T ::= Nat | T1^Œ± -> T2^Œ≤\n\nType qualifiers\n  Œ±,Œ≤,Œ≥ ::= ...\n\nEnvironments\n  Œì ::= x:T^Œ±, ...\n</pre>\n<p>Type assigment: <code class=\"language-text\">Œì ‚ä¢ e: T^Œ±</code></p>\n<pre>\n  Œì(x) = T^Œ±\n  ---------- (var)\n  Œì ‚ä¢ x:T^Œ±\n\n  Œì^Œ≥, x:T1^Œ± ‚ä¢ e: T2^Œ≤\n  -------------------------- (abs)\n  Œì ‚ä¢ Œªx.e: (T1^Œ± -> T2^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e1: (T1^Œ± -> T2^Œ≤)^Œ≥   Œì ‚ä¢ e2: T1^Œ±\n  ---------------------------------------- (app)\n  Œì ‚ä¢ e1 e2: T2^Œ≤\n</pre>\n<h3>Notes</h3>\n<!-- **TODO:** add alternative version based on free vars -->\n<p>Notes:</p>\n<ul>\n<li>Restricted environment in rule (abs): restricting the environment removes all non-matching bindings, so we obtain a guarantee that the function can only access <code class=\"language-text\">Œ≥</code>-qualified bindings from the outer scope.\n<ul>\n<li>\n<p>Of course, non-<code class=\"language-text\">Œ≥</code>-qualified bindings can still be added in an inner scope.</p>\n</li>\n<li>\n<p>An alternative way to express this is to relate <code class=\"language-text\">Œ≥</code> explicitly to the qualifiers of <code class=\"language-text\">e</code>‚Äôs free variables (see below).</p>\n<aside>\n  Alternative type assignment (tracking free vars)\n<p>Alternative type assignment (tracking free vars): <code class=\"language-text\">Œì ‚ä¢ e: T^Œ± / x,y,z,...</code></p>\n  <pre>\n    Œì(x) = T^Œ±\n    -------------- (var)\n    Œì ‚ä¢ x:T^Œ± / x\n\n    Œì, x:T1^Œ± ‚ä¢ e: T2^Œ≤ / ys     Œ≥ = ‚®Ü Œì(ys-x)\n    --------------------------------------------- (abs)\n    Œì ‚ä¢ Œªx.e: (T1^Œ± -> T2^Œ≤)^Œ≥ / ys-x\n\n    Œì ‚ä¢ e1: (T1^Œ± -> T2^Œ≤)^Œ≥ / xs1    Œì ‚ä¢ e2: T1^Œ± / xs2\n    ------------------------------------------------------- (app)\n    Œì ‚ä¢ e1 e2: T2^Œ≤ / xs1+xs2\n  </pre>\n</aside>\n</li>\n</ul>\n</li>\n<li>Qualifier for functions in rule (app): as stated, rule (app) ignores the qualifier of the function, <code class=\"language-text\">Œ≥</code>, and does not constrain it in any way. This is consistent with the expectation that even 2nd-class functions can be called without restrictions. However, several instantiations of the system require certain refinements:\n<ul>\n<li>Recursive functions: may impose restrictions on function itself, e.g., preventing the function itself from escaping during the call</li>\n<li>Separation: may require that the function argument is separate from (i.e., does not alias) the function itself (and anything the function closes over)</li>\n<li>Information flow, staging: certain function may not be called with tainted/high-security or not-yet-available values</li>\n</ul>\n</li>\n</ul>\n<p>Notes:</p>\n<ul>\n<li>Relation Œ≤,Œ≥ (rule abs):\n<ul>\n<li>Œ≤ may refer to x/Œ± (leak arg)</li>\n<li>Œ≥ contains all free vars (used + leaked), Œ≤ only leaked</li>\n</ul>\n</li>\n</ul>\n<p>Extensions:</p>\n<ul>\n<li>Subtyping (qualifier equivalence vs. inclusion): as stated, qualifiers need to match exactly.\n<ul>\n<li>It is often useful to relax this, and assume a partial ordering among qualifiers, which extends the system to a subtyping system in a straightforward way.</li>\n<li>A unique smallest qualifier <code class=\"language-text\">‚ä•</code> is useful to denote 1st-class, i.e., unrestricted values.</li>\n<li>Depending on the instantiation, it can be desirable to require least-upper-bounds <code class=\"language-text\">‚®Ü</code> on qualifiers, so that it is always possible for a function to close over different qualifiers. In other cases, this may not be desirable.</li>\n</ul>\n</li>\n<li>Parametricity: qualifier abstraction can be added in a straightforward way. It is especially useful to support bounded qualifier abstraction, assuming qualifiers are partially ordered.</li>\n<li>Dependent function types: if qualifiers can refer to program variables, the application rule needs to be extended to support dependent application. This comes up, e.g., when qualifiers track aliasing/separation of program variables.</li>\n</ul>\n<p>As a concrete example of such extensions, the OOPSLA‚Äô16 Scala implementation uses standard Scala types as qualifiers, and hence the subtyping lattice as qualifier lattice, providing bounded quantification, functional dependencies, etc.</p>\n</aside>","fields":{"slug":"/Public/Generic/regions-backup/"},"frontmatter":{"date":"2020-09-27","title":"Regions, Separation, Stackability, Borrowing, Effect Capabilities, etc","description":"","keywords":"Regions, region-based memory, ownership, borrowing, stack allocation, effects, co-effects, algebraic effects, capabilities, dependent types, graph IR, sea of nodes","tags":null}}},{"node":{"excerpt":"We propose a generic system of qualified types as unifying basis for traditionally disparate features, including regions, borrowing, non‚Ä¶","html":"<p>We propose a generic system of qualified types as unifying basis for traditionally disparate features, including regions, borrowing, non-escaping, stack allocation, aliasing/separation, effect tracking, etc.</p>\n<h3>Intuition</h3>\n<p>The key idea is to reflect the qualifiers of variables a function closes over in the type of the function. An example:</p>\n<code>\n<p>val u = ‚Ä¶            <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mspace width=\"2em\"></mspace><mspace width=\"1em\"></mspace><mrow><mi mathvariant=\"monospace\">/</mi><mi mathvariant=\"monospace\">/</mi><mtext>¬†</mtext><mi mathvariant=\"monospace\">t</mi><mi mathvariant=\"monospace\">y</mi><mi mathvariant=\"monospace\">p</mi><mi mathvariant=\"monospace\">e</mi><mo>:</mo><msup><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">Œ±</mi></msup></mrow></mrow><annotation encoding=\"application/x-tex\">\\qquad\\quad\\tt//\\ type: A^Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9166599999999999em;vertical-align:-0.22222em;\"></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">//</span><span class=\"mspace\">¬†</span><span class=\"mord mathtt\">type</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span></span></span><br/>\nval v = ‚Ä¶            <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mspace width=\"2em\"></mspace><mspace width=\"1em\"></mspace><mrow><mi mathvariant=\"monospace\">/</mi><mi mathvariant=\"monospace\">/</mi><mtext>¬†</mtext><mi mathvariant=\"monospace\">t</mi><mi mathvariant=\"monospace\">y</mi><mi mathvariant=\"monospace\">p</mi><mi mathvariant=\"monospace\">e</mi><mo>:</mo><msup><mi mathvariant=\"monospace\">B</mi><mi mathvariant=\"monospace\">Œ≤</mi></msup></mrow></mrow><annotation encoding=\"application/x-tex\">\\qquad\\quad\\tt//\\ type: B^Œ≤</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0713279999999998em;vertical-align:-0.22222em;\"></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">//</span><span class=\"mspace\">¬†</span><span class=\"mord mathtt\">type</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span></span></span></span><br/>\ndef f(x:T):U =<br/>\n‚Ä¶ use u and v ‚Ä¶  <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mspace width=\"1em\"></mspace><mrow><mi mathvariant=\"monospace\">/</mi><mi mathvariant=\"monospace\">/</mi><mtext>¬†</mtext><mi mathvariant=\"monospace\">t</mi><mi mathvariant=\"monospace\">y</mi><mi mathvariant=\"monospace\">p</mi><mi mathvariant=\"monospace\">e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"monospace\">T</mi><mo>‚Üí</mo><mi mathvariant=\"monospace\">U</mi><msup><mo stretchy=\"false\">)</mo><mrow><mi mathvariant=\"monospace\">Œ±</mi><mo>‚®Ü</mo><mi mathvariant=\"monospace\">Œ≤</mi></mrow></msup></mrow></mrow><annotation encoding=\"application/x-tex\">\\quad\\tt//\\ type: (T \\to U)^{Œ± ‚®Ü Œ≤}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\"><span class=\"mord mathtt\">//</span><span class=\"mspace\">¬†</span><span class=\"mord mathtt\">type</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathtt\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathtt\">U</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mop op-symbol small-op mtight\" style=\"position:relative;top:-0.0000050000000000050004em;\">‚®Ü</span><span class=\"mspace mtight\" style=\"margin-right:0.19516666666666668em;\"></span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span></span></span></span></span><br/></p>\n</code>\n<p>Qualifiers on T and U are possible as well but not used here.</p>\n<p>The system is a generalization of the type system for ‚Äú2nd-class values‚Äù presented in the following paper:</p>\n<ul>\n<li><a href=\"https://www.cs.purdue.edu/homes/rompf/papers/osvald-oopsla16.pdf\">Gentrification Gone too Far? Affordable 2nd-Class Values for Fun and (Co-)Effect</a>.</li>\n</ul>\n<p>Leo Osvald, GreÃÅgory Essertel, Xilun Wu, Lilliam I. GonzaÃÅlez-AlayoÃÅn, Tiark Rompf. OOPSLA ‚Äò16</p>\n<h3>Applications</h3>\n<ul>\n<li><aside>\n<h2>Region-Based Memory</h2>\n<p>Type qualifiers can denote a separation of the heap into disjoint memory regions. The type system ensures that closures are allocated in the same region as the values they close over. Closing over multiple values from different regions would be prohibited in the simplest model.</p>\n<p>A partial ordering between regions relaxes this constraint, and permits references to region <code class=\"language-text\">Œ±</code> from region <code class=\"language-text\">Œ≤</code> iff <code class=\"language-text\">Œ± ‚â§ Œ≤</code> (meaning <code class=\"language-text\">Œ±</code> has a lifetime at least as long as <code class=\"language-text\">Œ≤</code>). The default region <code class=\"language-text\">‚ä•</code> is the smallest according to this order (with the longest lifetime), allowing incoming references from all other regions but no outgoing references.</p>\n<p><strong>Exercise</strong>: relate formally to Tofte &#x26; Talpin‚Äôs stack-of-regions system (and/or others from the literature).</p>\n<p><strong>Exercise</strong>: recast region system case study from OOPSLA‚Äô16 in the formalism presented here.</p>\n</aside>\n<p>Warm-up</p>\n<li><aside>\n<h2>Guaranteed Stack Allocation</h2>\n<p>Consider two regions <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">heap</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{heap}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.22222em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">heap</span></span></span></span></span></span> and <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">stack</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{stack}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">stack</span></span></span></span></span></span>, with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">heap</mtext><mo>‚â§</mo><mtext mathvariant=\"monospace\">stack</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{heap} ‚â§ \\texttt{stack}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85819em;vertical-align:-0.22222em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">heap</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">stack</span></span></span></span></span></span>. Now restrict function types to <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mtext mathvariant=\"monospace\">heap</mtext></msubsup></mrow><annotation encoding=\"application/x-tex\">T_1^Œ± \\to T_2^{\\texttt{heap}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.931438em;vertical-align:-0.24810799999999997em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.194439em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.928131em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.2003540000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord texttt mtight\">heap</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span></span>.</p>\n<p>See OOPSLA‚Äô16 paper (Osvald et al.) for formalization and proof.</p>\n<p>Note that by subsumption, we can treat any <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>T</mi><mtext mathvariant=\"monospace\">heap</mtext></msup></mrow><annotation encoding=\"application/x-tex\">T^{\\texttt{heap}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7907770000000001em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7907770000000001em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord texttt mtight\">heap</span></span></span></span></span></span></span></span></span></span></span></span></span></span> value as <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>T</mi><mtext mathvariant=\"monospace\">stack</mtext></msup></mrow><annotation encoding=\"application/x-tex\">T^\\texttt{stack}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7907770000000001em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7907770000000001em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord texttt mtight\">stack</span></span></span></span></span></span></span></span></span></span></span></span></span>, so the approximation is one-sided (‚Äúmay stack‚Äù but not ‚Äúmust stack‚Äù).</p>\n<p>But if an allocation statement (e.g., a Œª-expression or other introduction form) is typed as <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">stack</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{stack}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">stack</span></span></span></span></span></span> we know that we can indeed safely allocate it on the stack. Since functions can never return <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">stack</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{stack}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61111em;vertical-align:0em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">stack</span></span></span></span></span></span> values, we can safely deallocate the ones created during a function call on function exit.</p>\n<p>See further down below for a refinement of this idea (‚Äúdon‚Äôt pop the stack‚Äù)!</p>\n</aside>\n<p>OOPSLA‚Äô16</p>\n<li><aside>\n<h2>Non-Escaping (‚ÄúBorrowed‚Äù) Effect Capabilities (Co-Effects)</h2>\n<p>Stack allocation is a useful optimization if the language runtime supports it, but there are other uses for non-escaping guarantees as well. Identifying ‚Äúheap‚Äù values as 1st-class (unrestricted) and ‚Äústack‚Äù values as 2nd-class (with some restrictions) turns out to enable a range of interesting programming patterns. A particularly attractive use case is to use 2nd-class values as <em>effect capabilities</em> that are guaranteed to be valid only during the dynamic extent of a particular function call.</p>\n<p>Such capabilities represent a new take on checked effect systems (co-effects, in the terminology of Petricek et al.). A key benefit compared to standard type-and-effect systems is a more flexible approach to effect polymorphism that requires fewer user-facing annotations.</p>\n<!-- **TODO:** explain map example -->\n<p>See OOPSLA‚Äô16 paper (Osvald et al.) for details.</p>\n<!-- TODO: note on using types as privilege lattice insted of fixed 1/2 -->\n<p>The paper includes a large case study on adding checked exceptions to the Scala standard library. Of particular interest are higher-order functions like <code class=\"language-text\">map</code>, <code class=\"language-text\">flatMap</code>, etc. in the collections library, especially variants for parallel and non-strict collections.</p>\n<p>Qualifier polymorphism elegantly supports all these different variants. The implementation (and formalism) permits arbitrary Scala types (incl. abstract, bounded, etc. types) as qualifiers and thus unifies the Scala type lattice with the qualifier lattice. This enables arbitrary user-defined privilege levels beyond the rigid 1st/2nd distinction, e.g., to distinguish ‚Äúread‚Äù- and ‚Äúwrite‚Äù-level capabilities for safe parallelism.</p>\n<p>It is worth noting that there are several possible choices regarding whether non-first-class values may be returned from functions: the calculus as presented in the paper prevents this and adheres to a strict stack discipline (its main safety result), but it is also perfectly possible to allow returning non-first-class values, and the system remains sound as long as their status is tracked. However, for a long time it was less clear what would be a semantically meaningful safety theorem in this setting (see Section ‚Äúdon‚Äôt pop the stack‚Äù for a new take on this and a satisfactory solution).</p>\n</aside>\n<p>OOPSLA‚Äô16</p>\n<li><aside>\n<h2>Non-Escaping Continuations that are Compiled to Jumps</h2>\n<p>Traditionally, converting a program into continuation-passing style (CPS) turns blocks into closures and jumps into function calls. Since functions no longer return, the notion of a call stack disappears, and the program relies on heap allocation exclusively.</p>\n<p>Using our system of qualified types, we can introduce continuations with stack-bounded lifetimes, meaning that a stack discipline of function calls is preserved across CPS conversion (similar to earlier work by Kennedy, but more flexible).</p>\n<p>See ICFP‚Äô19 paper (Cong et al.) for details.</p>\n<p>The formal model includes returning and non-returning functions and combines a type-directed selective CPS transform with the present type sytem for escaping and non-escaping values.</p>\n<p>By nature of the CPS hierarchy, the approach scales to multi-level delimited continuations through iterated CPS transform.</p>\n<p><strong>Exercise</strong>: extend the formal model (the available control operators and the selective CPS transform) directly to the full CPS hierarchy, including multiple levels of delimited continuations.</p>\n</aside>\n<p>NEW! ‚ÄúCompiling With Continuations or Without? Whatever.‚Äù</p>\n<p>ICFP‚Äô19</p>\n<li><aside>\n<h2>More Stack Allocation, and Currying for Co-Effect Systems</h2>\n<p>The 1st- and 2nd class model as presented so far is clearly useful, both for stack allocation as optimization and as a general programming model with strong guarantees.</p>\n<p>However, there are some limitations: since function types are restricted to always return 1st-class (heap) values, a function that takes a 2nd-class (stack) value as argument cannot be curried. It is not permitted to return a function that would close over this argument, as that function would need to be typed as 2nd-class as well!</p>\n<p>What would happen if we relax this constraint and just permit arbitrary qualifiers for function return types?</p>\n<p>Nothing bad happens at the type level, but clearly we can‚Äôt perform actual stack allocation anymore. And moreover, it is not really clear anymore in a formal sense what precise guarantees the type sytems provides - so what is the right soundness theorem to prove?</p>\n<p>In practice, we found ourselves often converting pieces of code to CPS when we wanted to ‚Äúreturn‚Äù 2nd-class values, which allowed us to keep growing the stack.</p>\n<p>This lead to a very interesting new idea: what if - in direct style - we just don‚Äôt pop the stack? Let‚Äôs keep allocating 2nd-class values on the stack, and if a function returns a 2nd-class value, then we simply don‚Äôt pop the stack frame. We keep growing the stack, until we reach a caller that returns a 1st-class value. At that point we pop the stack, potentially discarding multiple stack frames at once.</p>\n<p>With that insight, we keep a precise and useful safety guarantee (stack allocation, non-escape behavior subject to qualifiers). And moreover, we obtain a more flexible and powerful stack allocation strategy: now that we have a mechanism to return freshly stack-allocated values up the call chain, we can allocate many more values on the stack!</p>\n<p>And of course we now support currying of 2nd-class functions.\nAnother interesting observation is that we can now eta-expand an equivalent of C‚Äôs <code class=\"language-text\">alloca</code> primitive into a proper function.</p>\n<p><strong>Exercise</strong>: adapt proofs from OOPSLA‚Äô16 paper to support ‚Äúlazy-popping‚Äù strategy.</p>\n<p><strong>Exercise</strong>: prove lockstep-equivalence with CPS transform (ICFP‚Äô19 paper).</p>\n<p><strong>Exercise</strong>: experimentally evaluate the benefits (time, space) of extended stack allocation on a range of benchmarks, using a runtime that supports both stack allocation and GC (e.g., Scala Offheap, Go, Swift, C++ Boehm GC).</p>\n<p><strong>Exercise</strong>: there are good reasons why allocating large amounts of data on the actual call stack might not be the best idea. An alternative is to use a shadow stack, and for some (uncooperative) environments this is in fact the only choice (e.g., Scala Offheap). Compare using the physical call stack with using a shadow stack in suitable environments.</p>\n<p><strong>Exercise</strong>: what is the operational model if we add (potentially an unbounded number of) qualifiers beyond ‚Äústack‚Äù and ‚Äúheap‚Äù? Many (nested?) regions that each operate as a stack?</p>\n<p><strong>Exercise</strong>: under what conditions can we support storing stack-allocated values in mutable stack-allocated variables? Variables further down the stack appear to be OK, but what about variables further up in situations where we don‚Äôt pop the stack right away?</p>\n<p>See ECOOP‚Äô22 paper (Xhebraj et al.) for details.</p>\n<!-- **TODO:** effect polymorphism: currying 2nd class arg will always return 2nd class, even if called with 1st class arg. Polymorphism: it may be desirable to return a 1st class value in this case (could be done by saying \"return region like that of arg\"). It's less clear how to implement it: the returned function must be allocated somewhere! -->\n</aside>\n<p>NEW! ‚ÄúWhat if we don‚Äôt Pop the Stack?‚Äù</p>\n<p>ECOOP‚Äô22</p>\n<li><aside>\n<h2>Isolating Nonterminating Fragments in Dependently-Typed Programs</h2>\n<p>Based on the observation that non-termination is a side effect, why don‚Äôt we guard potential non-termination by a 2nd-class capability, just like other effects (exceptions, IO)?</p>\n<p>A key use case where non-termination must be ruled out is in dependently-typed languages, where computations may forms parts of types but these computations are required to be pure (= terminating) for logical consistency.</p>\n<p>At the same time, it is attractive to support non-termination and potentially other side effects in parts of the program that are <em>not</em> executed at type-checking time.</p>\n<p>The simplest proof-of-concept model provides recursive functions, where the recursive binding is wrapped in a type <code class=\"language-text\">Rec</code> which needs to be explicitly unwrapped (using <code class=\"language-text\">unrec</code>) with a ‚ÄúTuring Capability‚Äù (<code class=\"language-text\">CanDiverge</code>) as parameter. The result of <code class=\"language-text\">unrec</code> is a 2nd-class value (can‚Äôt escape, can‚Äôt be stored).</p>\n<p>Terms</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>n</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>x</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>Œª</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>e</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>e</mi><mtext>¬†</mtext><mi>e</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†unrec¬†</mtext><mi>e</mi><mtext>¬†</mtext><mi>e</mi></mrow><annotation encoding=\"application/x-tex\"> e ::= n\\ |\\ x\\ |\\ Œªf(x).e\\ |\\ e\\ e\\ |\\ \\text{unrec}\\ e\\ e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord text\"><span class=\"mord\">unrec</span></span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span></span></span></span></span></p>\n<p>Types</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>:</mo><mo>:</mo><mo>=</mo><mtext>Nat¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†Rec¬†</mtext><mi>T</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†CanDiverge</mtext></mrow><annotation encoding=\"application/x-tex\"> T ::= \\text{Nat}\\ |\\ T_1^Œ± \\to T_2^Œ≤\\ |\\ \\text{Rec}\\ T\\ |\\ \\text{CanDiverge} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Nat</span></span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2333239999999999em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord text\"><span class=\"mord\">Rec</span></span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord text\"><span class=\"mord\">CanDiverge</span></span></span></span></span></span></p>\n<p>Type qualifiers</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ±</mi><mo separator=\"true\">,</mo><mi>Œ≤</mi><mo separator=\"true\">,</mo><mi>Œ≥</mi><mo>:</mo><mo>:</mo><mo>=</mo><mn>1</mn><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mn>2</mn></mrow><annotation encoding=\"application/x-tex\"> Œ±,Œ≤,Œ≥ ::= 1\\ |\\ 2 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">Œ≤</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord\">2</span></span></span></span></span></p>\n<p>Type assigment:</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>f</mi><mo>:</mo><mtext>Rec¬†</mtext><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>Œª</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(abs)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì^Œ≥, f: \\text{Rec}\\ (T_1^Œ± \\to T_2^Œ≤)^Œ≥, x: T_1^Œ± ‚ä¢ e: T_2^Œ≤\n}{\n  Œì ‚ä¢ Œªf(x).e: (T_1^Œ± \\to T_2^Œ≤)^Œ≥\n} \\quad\\text{(abs)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6461920000000001em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.0448000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26630799999999993em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord text\"><span class=\"mord\">Rec</span></span><span class=\"mspace\">¬†</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(abs)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><mtext>Rec¬†</mtext><msup><mi>T</mi><mi>Œ±</mi></msup><mspace width=\"2em\"></mspace><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msup><mtext>CanDiverge</mtext><mn>2</mn></msup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mtext>unrec¬†</mtext><msub><mi>e</mi><mn>1</mn></msub><mtext>¬†</mtext><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msup><mi>T</mi><mn>2</mn></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(unrec)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì ‚ä¢ e_1: \\text{Rec}\\ T^Œ±  \\qquad\n  Œì ‚ä¢ e_2: \\text{CanDiverge}^2\n}{\n  Œì ‚ä¢ \\text{unrec}\\ e_1\\ e_2: T^2\n} \\quad\\text{(unrec)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4003379999999996em;vertical-align:-0.8360000000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5643379999999998em;\"><span style=\"top:-2.3139999999999996em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord text\"><span class=\"mord\">unrec</span></span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.740108em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord text\"><span class=\"mord\">Rec</span></span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">CanDiverge</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.887338em;\"><span style=\"top:-3.1362300000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8360000000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(unrec)</span></span></span></span></span></span></div>\n<!-- <pre>\n  Œì^Œ≥, f: Rec(T1^Œ± -> T2^Œ≤)^Œ≥, x:T1^Œ± ‚ä¢ e: T2^Œ≤\n  --------------------------------------------- (abs)\n  Œì ‚ä¢ Œªf(x).e: (T1^Œ± -> T2^Œ≤)^Œ≥\n\n\n  Œì ‚ä¢ e1: Rec(T)^Œ±  Œì ‚ä¢ e2: CanDiverge^2\n  --------------------------------------- (unrec)\n  Œì ‚ä¢ unrec e1 e2: T^2\n</pre>\n-->\n<p><strong>Exercise</strong>: write a few simple recursive programs (e.g., fac, fib) as examples. Assume that the main program gets passed a Turing capability as 2nd-class argument.</p>\n<p><strong>Exercise</strong>: complete the proof for a combined soundness/termination theorem, depending on whether a Turing capability is present in the environment. Proof setup based on combined logical relation and step-indexed logical relation, as described in the Zombie paper (Casinghino et al. POPL‚Äô14).</p>\n<p><strong>Exercise</strong>: extend a full dependently-typed language with Turing capabilities, and potentially other side effects. Perhaps based directly on the Zombie artifacts (Casinghino et al. POPL‚Äô14).</p>\n<p><strong>Exercise</strong>: extend DOT / Scala with full dependent types, using Turing capabilities to ensure termination of path expressions in type selections (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi mathvariant=\"normal\">.</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">e.T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>) which is necessary for type soundness.</p>\n</aside>\n<p>NEW! ‚ÄúTuring Capabilities - Non-Termination as a Co-Effect‚Äù</p>\n<li><aside>\n<h2>Tracking Aliasing and Separation</h2>\n<p>Knowing that two values must be <em>separate</em>, i.e., that they may not <em>alias</em>, enables powerful optimizations. In particular, the two values can be modified independently, without synchronization, and potentially in parallel.</p>\n<p>Regions can provide a (fine-grained) approximation: if values belong to regions that are separate, the values must be separate.</p>\n<p>In a region-monomorphic system this is straightforward. But what if regions can be abstracted over?</p>\n<!-- **XXX:** closures and self types as second ingredient? relate to Tofte and Talpin? -->\n<h3>Key Idea: A ‚ÄúFor All Separate Regions‚Äù Quantifier</h3>\n<p>We introduce a quantifer that can only be instantiated with regions that are separate from the regions used by the epression quantified over.</p>\n<p>This is enabled crucially by the fact that the region assigned to an abstraction subsumes all the regions it accesses from the definition-site environment.</p>\n<p>Hence, checking separation of the argument from the region of the abstraction is enough to guarantee separation from everything used at the definition site.</p>\n<h3>Syntax</h3>\n<p>Terms</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>n</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>x</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>Œª</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>e</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>e</mi><mtext>¬†</mtext><mi>e</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">Œõ</mi><mi>Œ±</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>e</mi><mo stretchy=\"false\">[</mo><mi>Œ±</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\"> e ::= n\\ |\\ x\\ |\\ Œªf(x).e\\ |\\ e\\ e\\ |\\ ŒõŒ±.e\\ |\\ e[Œ±]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord\">Œõ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p>Types</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>:</mo><mo>:</mo><mo>=</mo><mtext>Nat¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚àÄ</mi><mi>Œ±</mi><mi mathvariant=\"normal\">.</mi><msup><mi>T</mi><mi>Œ≤</mi></msup></mrow><annotation encoding=\"application/x-tex\"> T ::= \\text{Nat}\\ |\\ T_1^Œ± \\to T_2^Œ≤\\ |\\ ‚àÄŒ±.T^Œ≤</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Nat</span></span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2333239999999999em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<h3>Type assigment</h3>\n<p>Function abstraction (standard):</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>Œª</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(abs)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì^Œ≥, x:T_1^Œ± ‚ä¢ e: T_2^Œ≤\n}{\n  Œì ‚ä¢ Œªx.e: (T_1^Œ± \\to T_2^Œ≤)^Œ≥\n} \\quad\\text{(abs)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6461920000000001em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.0448000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26630799999999993em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(abs)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mspace width=\"2em\"></mspace><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mtext>¬†</mtext><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(app)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì ‚ä¢ e_1: (T_1^Œ± \\to T_2^Œ≤)^Œ≥ \\qquad\n  Œì ‚ä¢ e_2: T_1^Œ±\n}{\n  Œì ‚ä¢ e_1\\ e_2: T_2^Œ≤\n} \\quad\\text{(app)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(app)</span></span></span></span></span></span></div>\n<p>Region abstraction (new):</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>Œ±</mi><mo>:</mo><mo>:</mo><mtext>Region</mtext><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msup><mi>T</mi><mi>Œ≤</mi></msup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi mathvariant=\"normal\">Œõ</mi><mi>Œ±</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">‚àÄ</mi><mi>Œ±</mi><mi mathvariant=\"normal\">.</mi><msup><mi>T</mi><mi>Œ≤</mi></msup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(rabs)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì^Œ≥, Œ±::\\text{Region} ‚ä¢ e: T^Œ≤\n}{\n  Œì ‚ä¢ ŒõŒ±.e: (‚àÄŒ±.T^Œ≤)^Œ≥\n} \\quad\\text{(rabs)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4621079999999997em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5261079999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">Œõ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord text\"><span class=\"mord\">Region</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(rabs)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">‚àÄ</mi><mi>Œ±</mi><mi mathvariant=\"normal\">.</mi><msup><mi>T</mi><mi>Œ≤</mi></msup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mspace width=\"2em\"></mspace><mi>Œ¥</mi><mtext>‚®Ö</mtext><mi>Œ≥</mi><mo>=</mo><mtext>‚ä•</mtext></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>e</mi><mo stretchy=\"false\">[</mo><mi>Œ¥</mi><mo stretchy=\"false\">]</mo><mo>:</mo><mo stretchy=\"false\">[</mo><mi>Œ¥</mi><mi mathvariant=\"normal\">/</mi><mi>Œ±</mi><mo stretchy=\"false\">]</mo><msup><mi>T</mi><mi>Œ≤</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(rapp)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì ‚ä¢ e: (‚àÄŒ±.T^Œ≤)^Œ≥ \\qquad\n  Œ¥‚®ÖŒ≥ = ‚ä•\n}{\n  Œì ‚ä¢ e[Œ¥]: [Œ¥/Œ±]T^Œ≤\n} \\quad\\text{(rapp)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4621079999999997em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5261079999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mclose\">]</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span><span class=\"mord\">‚®Ö</span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">‚ä•</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(rapp)</span></span></span></span></span></span></div>\n<!-- <pre>\n\n  Function abstraction (standard):\n\n  Œì^Œ≥, x:T1^Œ± ‚ä¢ e: T2^Œ≤\n  -------------------------------- (abs)\n  Œì ‚ä¢ Œªf(x).e: (T1^Œ± -> T2^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e1: (T1^Œ± -> T2^Œ≤)^Œ≥    Œì ‚ä¢ e1: T1^Œ±\n  ------------------------------------------- (app)\n  Œì ‚ä¢ e1 e2: T2^Œ≤\n\n  Region abstraction (new):\n\n  Œì^Œ≥, Œ±::Region ‚ä¢ e: T^Œ≤\n  ------------------------ (rabs)\n  Œì ‚ä¢ ŒõŒ±.e: (‚àÄŒ±.T^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e: (‚àÄŒ±.T^Œ≤)^Œ≥    Œ¥‚®ÖŒ≥ = ‚ä•\n  ------------------------------------- (rapp)\n  Œì ‚ä¢ e[Œ¥]: [Œ¥/Œ±]T^Œ≤\n\n</pre> -->\n<p>Bounded quantification can be added to enable partial overlap. With this extension the last two rules become the following:</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>Œ±</mi><mo>‚â§</mo><msup><mi>Œ±</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msup><mi>T</mi><mi>Œ≤</mi></msup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi mathvariant=\"normal\">Œõ</mi><mi>Œ±</mi><mo>‚â§</mo><msup><mi>Œ±</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">‚àÄ</mi><mi>Œ±</mi><mo>‚â§</mo><msup><mi>Œ±</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup><mi mathvariant=\"normal\">.</mi><msup><mi>T</mi><mi>Œ≤</mi></msup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(rbabs)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì^Œ≥, Œ±‚â§Œ±' ‚ä¢ e: T^Œ≤\n}{\n  Œì ‚ä¢ ŒõŒ±‚â§Œ±'.e: (‚àÄŒ±‚â§Œ±'.T^Œ≤)^Œ≥\n} \\quad\\text{(rbabs)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4621079999999997em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5261079999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\">Œõ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6778919999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6778919999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(rbabs)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">‚àÄ</mi><mi>Œ±</mi><mo>‚â§</mo><msup><mi>Œ±</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup><mi mathvariant=\"normal\">.</mi><msup><mi>T</mi><mi>Œ≤</mi></msup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mspace width=\"2em\"></mspace><mi>Œ¥</mi><mtext>‚®Ö</mtext><mi>Œ≥</mi><mo>‚â§</mo><msup><mi>Œ±</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚Ä≤</mo></msup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>e</mi><mo stretchy=\"false\">[</mo><mi>Œ¥</mi><mo stretchy=\"false\">]</mo><mo>:</mo><mo stretchy=\"false\">[</mo><mi>Œ¥</mi><mi mathvariant=\"normal\">/</mi><mi>Œ±</mi><mo stretchy=\"false\">]</mo><msup><mi>T</mi><mi>Œ≤</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(rbapp)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì ‚ä¢ e: (‚àÄŒ±‚â§Œ±'.T^Œ≤)^Œ≥ \\qquad\n  Œ¥‚®ÖŒ≥ ‚â§ Œ±'\n}{\n  Œì ‚ä¢ e[Œ¥]: [Œ¥/Œ±]T^Œ≤\n} \\quad\\text{(rbapp)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4621079999999997em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5261079999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mclose\">]</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">Œ¥</span><span class=\"mord\">‚®Ö</span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚â§</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(rbapp)</span></span></span></span></span></span></div>\n<!-- <pre>\n  Œì^Œ≥, Œ±‚â§Œ±' ‚ä¢ e: T^Œ≤\n  ------------------------ (rbabs)\n  Œì ‚ä¢ ŒõŒ±‚â§Œ±'.e: (‚àÄŒ±.T^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e: ‚àÄŒ±‚â§Œ±'.T^Œ≤    Œ¥‚®ÖŒ≤ ‚â§ Œ±'\n  ------------------------------- (rbapp)\n  Œì ‚ä¢ e[Œ¥]: [Œ¥/Œ±]T^Œ≤\n</pre>\n-->\n<p>Typically we want to be able to create new regions as well.\nIt is straightforward to add a ‚Äúletregion‚Äù construct in the\nstyle of Milner &#x26; Tofte:</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo separator=\"true\">,</mo><mi>Œ±</mi><mo>:</mo><mo>:</mo><mtext>Region</mtext><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msup><mi>T</mi><mi>Œ≤</mi></msup><mspace width=\"2em\"></mspace><mi>Œ±</mi><mo mathvariant=\"normal\">‚â†</mo><mi>F</mi><mi>V</mi><mo stretchy=\"false\">(</mo><mi>Œ≤</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mtext>letregion¬†</mtext><mi>Œ±</mi><mtext>¬†in¬†</mtext><mi>e</mi><mo>:</mo><msup><mi>T</mi><mi>Œ≤</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(rlet)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì, Œ±::\\text{Region} ‚ä¢ e: T^Œ≤ \\qquad Œ± \\ne FV(Œ≤)\n}{\n  Œì ‚ä¢ \\text{letregion}\\ Œ±\\ \\text{in}\\ e: T^Œ≤\n} \\quad\\text{(rlet)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.406548em;vertical-align:-0.8804400000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.5261079999999998em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord text\"><span class=\"mord\">letregion</span></span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\">¬†</span><span class=\"mord text\"><span class=\"mord\">in</span></span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7751079999999999em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord text\"><span class=\"mord\">Region</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\">ÓÄ†</span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">Œ≤</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8804400000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(rlet)</span></span></span></span></span></span></div>\n<!-- <pre>\n  Œì, Œ±::Region ‚ä¢ e: T^Œ≤   Œ± not in FV(Œ≤)\n  ---------------------------------------- (rlet)\n  Œì ‚ä¢ letregion Œ± in e: T^Œ≤\n</pre>\n-->\n<p>We still assume that regions have well-scoped lifetimes,\ndefined by the ‚Äúletregion‚Äù construct. Adding a ‚Äúralloc‚Äù\noperation that creates regions in a non-scoped way is\nsignificantly more work, mainly because regions could\nescape from their declaring scope. We‚Äôll tackle this\nproblem in the next section, essentially treating every\nvariable as its own region.</p>\n<p><strong>Exercise:</strong> work through more examples.</p>\n<p><strong>Exercise:</strong> establish metatheory.</p>\n<!--\n\n### Example\n\n<pre>\n  let x = e1 in e2\n  (Œªx.e2)e1\n\n\nMotivation:\n\n<pre>\n  let f = (Œª().\n    let c = alloc()\n    Œª().c)\n  let g = f()\n  let h = g()\n</pre>\n\nTyping:\n\n<pre>\n  alloc\n     : ‚àÄŒ±.()->R^Œ±\n  c' = ŒõŒ±.Œªc.Œª().c\n     : ‚àÄŒ±.R^Œ± -> (() -> R^Œ±)^Œ±\n  f  = ŒõŒ±.Œª().c'[Œ±](alloc[Œ±]())\n     : ‚àÄŒ±.() -> (() -> R^Œ±)^Œ±\n  f' = ŒõŒ±.Œªf.g'[Œ±](f[Œ±]()\n  g  : ‚àÄŒ±.(() -> R^Œ±)^Œ±  // can't be ‚àÄŒ±.(() -> R^Œ±)^Œ± !!\n  h  :\n</pre>\n\n\n<pre>\n  Œªf:(‚àÄŒ±.R^Œ±).\n   f[Œ±](alloc[Œ±]())\n</pre>\n\n-->\n</aside>\n<p>NEW! A quantifier for regions that are separate</p>\n<li><aside>\n<h2>Sets of Variables as Regions</h2>\n<p>In short:</p>\n<ul>\n<li>Type qualifiers track alias sets (as logical region)</li>\n<li>Functions close over and logically subsume tracked vars:\n<ul>\n<li>\n<p>Function argument separate from function</p>\n<p>-> must be separate from any outer var the function uses</p>\n</li>\n<li>\n<p>Tracked outer var escapes through function</p>\n<p>-> make it alias function using self type</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>Analogy: separation logic in types, and for a higher-order language</p>\n<p>Can we track aliasing, separation, and lifetimes for individual variables?</p>\n<p>Our solution is to use sets of program variables as type qualifiers.</p>\n<p>A type <code class=\"language-text\">T^{}</code> means the value may not (directly or indirectly) refer to any tracked variable in context, <code class=\"language-text\">T^{x,y}</code> means it may refer to tracked variables <code class=\"language-text\">x</code> or <code class=\"language-text\">y</code>. We use the standard subset relation as partial order.</p>\n<!-- TODO: Example here? -->\n<p>We consider a model where all variables are tracked first, and look at an extension with untracked variables further down. <!-- It is straightforward to add a distinction that also supports non-tracked values, with a separate qualifer `T^0` and taking either `0 < {}` or `0 ‚â† {}` (allowing non-tracked values to become temporarily tracked or not). We consider this extension at the bottom of this note. --></p>\n<p>Note: it‚Äôs also possible to use sets of variables as regions without separation/closing, but this does not appear very useful on its own (one benefit is perhaps to obtain polymorphism over other region qualifiers).</p>\n<h3>Function Argument Separation</h3>\n<p>Type assignment: let us consider the <code class=\"language-text\">let</code>-rule first.</p>\n<pre>\n  Œì ‚ä¢ e1: T1^Œ±\n  Œì, x:T1^(Œ±,x) ‚ä¢ e: T2^Œ≤\n  -------------------------------- (let)\n  Œì ‚ä¢ let x = e1 in e2: T2^(Œ≤\\{x})\n</pre>\n<p>When binding an expression to a name, the name is added to the type qualifer. When a variable goes out of scope, the name is removed from the qualifier of the result expression.</p>\n<p>Example:</p>\n<pre>\n(let x = e in  // e: T^{}\n ...           // x: T^{x}\n )             // result: T^{}\n</pre>\n<p>For functions, the same idea applies to the argument type, but we allow the return expression to depend on the argument name (possible extension: add the function name to the type, and allow both argument and result types to refer to it). This means that we‚Äôre dealing with dependent function types, and need to perform a corresponding substitution in the application case.</p>\n<p>A first cut would be this:</p>\n<pre>\n  Œì^Œ≥, x:T1^(Œ±,x) ‚ä¢ e: T2^Œ≤\n  ---------------------------- (abs)\n  Œì ‚ä¢ Œªx.e: (x:T1^Œ± -> T2^Œ≤)^Œ≥\n\n  Œì ‚ä¢ e1: (x:T1^Œ± -> T2^Œ≤)^Œ≥   Œì ‚ä¢ e2: T1^Œ±\n  ------------------------------------------ (app)\n  Œì ‚ä¢ e1 e2: [Œ±/x]T2^Œ≤\n</pre>\n<p>However the app rule isn‚Äôt quite right: first, the substitution doesn‚Äôt appear to make a lot of sense (why not include <code class=\"language-text\">Œ±</code> right away in <code class=\"language-text\">Œ≤</code>?) and second, we can‚Äôt expect <code class=\"language-text\">e2</code> to have the same or a smaller <code class=\"language-text\">Œ±</code> as the one expected by the parameter type. If the argument type is <code class=\"language-text\">T1^{}</code>, we wouldn‚Äôt be able to pass anything bound to a variable at the call site - but what we‚Äôre actually concerned about is the definition site!</p>\n<p>The key insight is that what we <em>really</em> want in this case is that the argument is different from any variable the function <em>closes over</em>. And these are precisely the names tracked by the qualifer of the function type, <code class=\"language-text\">Œ≥</code>!</p>\n<p>So in our new rule, we demand that the argument may only overlap with the function in the names mentioned explicitly in <code class=\"language-text\">Œ±</code>:</p>\n<pre>\n  Œì ‚ä¢ e1: (x:T1^Œ± -> T2^Œ≤)^Œ≥   Œì ‚ä¢ e2: T1^Œ¥    Œ≥‚à©Œ¥ = Œ±\n  ---------------------------------------------------- (app)\n  Œì ‚ä¢ e1 e2: [Œ¥/x]T2^Œ≤\n</pre>\n<p><strong>Exercise:</strong> show that this derives let rule</p>\n<p>Note how closely the typing rules mirror those in the ‚ÄúTracking Aliasing and Separation‚Äù section on more traditional regions.</p>\n<h3>Escaping Tracked Variables</h3>\n<p>Self types. Describe how it works.</p>\n<h3>Example 1: Function Argument Separation</h3>\n<p>We assume a primitive operation <code class=\"language-text\">alloc(): V^{}</code> that produces a new reference cell (type <code class=\"language-text\">V</code>). We only consider a single side-effecting operation on variables, <code class=\"language-text\">inc: V^{} -> I^{}</code>, which returns an integer (type <code class=\"language-text\">I</code>).</p>\n<p>We further assume that all intermediate expressions are let-bound (this is a given in a graph IR).</p>\n<p>Let‚Äôs consider our first example:</p>\n<pre>\nfunction test() {\n  let v1 = alloc()     // V^{v1}\n  let v2 = alloc()     // V^{v2}\n  let i1 = inc(v1)     //\n  let i2 = inc(v2)     //\n  let f1 = fun(v => {  // v: V^{v}\n    let i3 = inc(v)      //\n    let i4 = inc(v1)     //\n    return 1             //\n  })                   // f1: ( (v:V^{}) -> I{} )^{f1,v1}\n  let a1 = f1(v1)      // error:  {f1,v1}‚à©{v1} = {v1} ‚â† {}\n  let a2 = f1(v2)      // ok:     {f1,v1}‚à©{v2} = {}\n  let i5 = inc(v1)     //\n  let i6 = inc(v2)     //\n  return 1\n}\n</pre>\n<p>We can make two key observations:</p>\n<ul>\n<li>Type system successfully prevents calling f1(v1), since f1 uses v1 internally and didn‚Äôt declare that v may alias v1. On the other hand, calling f1(v2) is fine, since f1 doesn‚Äôt use v2.</li>\n</ul>\n<p>Another example:</p>\n<pre>\nfunction counter() {\n  let v1 = alloc()         // v1: V^{v1}\n  let f1 = fun(() => {     // f1: (U^{} -> I^{})^{v1}\n    let i1 = inc(v1)\n    return 1\n  })\n  return f1\n}\nlet g1 = counter()       // g1: ( U^{} -> I^{} )^{g1}\nlet h1 = g1()            //\nlet h2 = g1()            //\n</pre>\n<p>When calling <code class=\"language-text\">counter</code>, we must make sure that the result remains being tracked, and indeed we do - because everything is tracked!</p>\n<h3>Example 2: Escaping Tracked Variables</h3>\n<p>When a function creates a mutable variable that escapes\n(directly or indirectly via another function), the identity\nof that variable is tracked, even though it does not have\nany externally visible identifier.</p>\n<p>The mechanism to achieve this is by logically subsuming\nthe escaping variable into the function via which it\nescapes, and tracking the identity of that function\nwith a self-type (just like in DOT).</p>\n<pre>\ndef f(a: Int) = {\n  let c = alloc()\n                      // f(b:Int) -> Ref^{c}\n  (fun(b: Int) => c)  //     --close-->\n                      // f(b:Int) -> Ref^{f}\n}\nlet h0 = f(0)\nlet h1 = f(1)\nlet c0 = h0(0)\nlet c1 = h0(1) // same as c0\nlet c3 = h1(0)\nlet c4 = h1(1) // same as c3\ninc(c0)\ninc(c1) // serialize with prev\ninc(c3)\ninc(c4) // serialize with prev\nget(c0)\n</pre>\n<h3>Extension 1: Tracked and Untracked Variables</h3>\n<p>In practice, the base model induces too many dependencies in realistic programs.</p>\n<p>Hence, we add a type qualifer that permits non-tracked variables, <code class=\"language-text\">T^0</code>.</p>\n<p>It is important that tracked values never become untracked. So <code class=\"language-text\">counter</code> above must remain typed as it is.</p>\n<p>But in other cases, we can gain considerable flexibility for code motion and other optimizations. In the example below we return a pure function, and we can correctly deduce that no dependencies need to be inserted between calls:</p>\n<pre>\nfunction pure() {\n  let f1 = fun(() => {     // f1: (U^0 -> I^0)^0\n    let v1 = alloc(s)        // v1: V{v1}\n    // can use local side effects here\n    return 1\n  })\n  return f1\n}\nlet g1 = counter()       // g1: ( U^0 -> I^0 )^0\nlet h1 = g1()            // dep {}\nlet h2 = g1()            // dep {}\n                         // dep {} // block end\n</pre>\n<p>This model allows us to effectively combine pure functional and side-effecting expressions in a graph IR based on dependencies.</p>\n<h3>Extension 2: Nested Refs (Require Flow-Sensitivity: Linearity/Ownership or Merging)</h3>\n<p>Tracking effects in a flow-sensitive way enables us to observe state changes of tracked variables in the type system (‚Äúsequential effects‚Äù, ‚Äútypestate‚Äù).</p>\n<p>A simple but powerful flow-sensitive effect is freeing a variable, or otherwise consuming or destroying it. Such an operation may typically be used no more than once (‚Äúaffine‚Äù) on any given value and generally renders the value inaccessible to any other operations that follow.</p>\n<p>Ownership transfer for nested mutable variables is another potential consume effect.</p>\n<p>See next section.</p>\n<h3>Discussion</h3>\n<p>Key points:</p>\n<ul>\n<li>Tracked expressions remain tracked, even though they may be returned from a function or passed through a let that removes the name from the type qualifier</li>\n<li>Unless otherwise noted, function arguments are guaranteed to be physically separate from any other value reachable from the function. This enables fine-grained dependency tracking inside the function.</li>\n<li>Escaping values are tracked using self types</li>\n<li>Flow-sensitivity: TODO</li>\n</ul>\n<p>Questions:</p>\n<ul>\n<li>How to support reference cells that can hold other (tracked) reference cells?\n<ul>\n<li>It seems relatively straightforward to prevent merging of separate heap regions, but supporting such merging (or ownership transfer) may be more interesting</li>\n<li>A useful starting point may be thinking about what restrictions are necessary between Œ± and Œ≤ in <code class=\"language-text\">(Ref T^Œ±)^Œ≤</code>. Is Œ± ‚â§ Œ≤ the right model?</li>\n<li>Or a notion of ownership transfer (or ‚Äúcapture‚Äù) that disables all aliases of x when x is to be stored in a ref cell (how to do that across parent scopes)? It seems that ‚Äúconsume‚Äù effects are the right way to think about this.</li>\n</ul>\n</li>\n<li>How to support control effects (delimited continuations)?</li>\n</ul>\n<h3>Formalization</h3>\n<p>Type assignment: direct-style terms or ANF?</p>\n<p>Operational semantics: store allocation for all values (refs and lambdas)</p>\n<p>Question (preservation): fresh ref (Ref^{}) allocated at l becomes Ref^{l}?</p>\n<p>Instrumented semantics: perform deallocation (with tombstones), reads/writes/dealloc\ncheck that ref hasn‚Äôt been deleted.</p>\n<p>This provides an actual safety theorem.</p>\n<p>Extension: higher-order refs.</p>\n</aside>\n<p>NEW! Tracking aliasing, separation, and lifetimes for individual variables</p>\n<p>Reachability Types</p>\n<p>OOPSLA‚Äô21</p>\n<li><aside>\n<h2>Effects, Linearity, Flow-Sensitivity</h2>\n<p>Co-effect capabilities are a useful model for controlled side effects but not always precise enough. This has been described as the use/mention distinction. Especially in the case of destructive effects, we often want to know precisely if and when an effect has occured, not just that it might have potentially occured anywhere a corresponding capability is in scope.</p>\n<p>A key example are flow-sensitive effects: the simplest case is supporting linear or affine uses of capabilities, where we want to disable a capability once it has been used.</p>\n<p>Goal 0 (concrete): use-once capabilities</p>\n<ul>\n<li>implement resource/communication protocols (typestate, session types)</li>\n<li>examples: open/close files/sockets, TCP SYN/ACK</li>\n</ul>\n<p>Goal 1 (concrete): memory management with higher-order (nested) references</p>\n<ul>\n<li>Store ref in a ref: two options, both are flow-sensitive\n<ul>\n<li>Consume and disable stored ref (ownership transfer)</li>\n<li>Track new alias relationship</li>\n</ul>\n</li>\n<li>Detect if not deallocated when leaving block\n<ul>\n<li>Warn, or deallocate automatically</li>\n<li>Desirable to also support explicit free (?)</li>\n</ul>\n</li>\n</ul>\n<p>Goal 2 (abstract): flow-sensitive region classifiers</p>\n<ul>\n<li>Simplest case: linearity, e.g., use-once capabilities</li>\n<li>Next interesting case: merge regions</li>\n</ul>\n<p>Implemented in prototype:</p>\n<ul>\n<li>read/write/kill effects</li>\n<li>lightweight effect polymorphism</li>\n</ul>\n<p>Note that we can use CPS to map flow-sensitive reasoning to context-sensitive reasoning. Disable a variable: continue in a scope in which the variable isn‚Äôt accessible.</p>\n</aside>\n<p>NEW! Tracking read/write/kill effects, linear/affine uses, ownership transfer, nested mutable data</p>\n<p>Reachability Types &#x26; Effects</p>\n<p>OOPSLA‚Äô21</p>\n<li><aside>\n<h2>Dependency Tracking for Graph IRs</h2>\n<p>Graph IRs are powerful because program expressions can float around freely (code motion), be easily merged together with equivalent ones (CSE), dropped when never used (DCE), or replaced with a cheaper implementation (rewriting, strength reduction).</p>\n<p>This works really well for functional programs, but things get more complicated when side effects need to be supported. Tracking dependencies between side-effecting statements accurately is a challenge. Modeling affected state too coarsely (in the limit, distinguishing only between yes/no effects) means one won‚Äôt be able to move stuff around anymore. Modeling state too finely imposes heavy computational demands on the dependency analysis and risks overlooking some dependencies which may lead to incorrect transformations.</p>\n<p>The goal of this work is to develop a new foundation for effects and dependency analysis in the LMS compiler framework.\nLMS is built around a sophisticated Graph IR that includes pure and effectful statements as well as structured expressions such as lambdas which pose additional challenges. Building dependency analysis on a type system based on lambda calculus immediately extends the Graph IR model from first-order to higher-order programs.</p>\n<!-- Our first thrust is to infer precise dependencies between side-effecting statements, given a model of 2nd-class mutable variables. Variables can be created and passed around freely in a program, but there are no indirect references, i.e., variables cannot contain other variables. This is a reasonable model for many AI and HPC workloads based on flat tensors or arrays. -->\n<p>See: <a href=\"/Public/Generic/graph-ir\">Prototype Implementation</a></p>\n<h3>One Variable, One Region</h3>\n<p>See previous section. Examples that follow are adapted from that section and\nextended with a discussion of graph dependencies.</p>\n<h3>Primitive Effects on Tracked Variables</h3>\n<p>Discuss. Serialize operations on variables that share state. Later: distinguish read/write, soft/hard dependencies. Flow sensitivity. Optimizations: CSE, DCE, rewriting, code motion.</p>\n<aside>\n<p>Examples, reloaded</p>\n<h3>Example 1: Function Argument Separation</h3>\n<p>We assume a primitive operation <code class=\"language-text\">alloc(): V^{}</code> that produces a new reference cell (type <code class=\"language-text\">V</code>). We only consider a single side-effecting operation on variables, <code class=\"language-text\">inc: V^{} -> I^{}</code>, which returns an integer (type <code class=\"language-text\">I</code>).</p>\n<p>We further assume that all intermediate expressions are let-bound (this is a given in a graph IR).</p>\n<p>Let‚Äôs consider our first example:</p>\n<pre>\nfunction test(s) {   // s: placeholder for block start\n  let v1 = alloc()     // V^{v1}  dep {s: s}\n  let v2 = alloc()     // V^{v2}  dep {s: s}\n  let i1 = inc(v1)     //         dep {v1: v1}\n  let i2 = inc(v2)     //         dep {v2: v2}\n  let f1 = fun(v => {  // v: V^{v}\n    let i3 = inc(v)      //         dep {v: v}\n    let i4 = inc(v1)     //         dep {v1: v} // dep on v as start of block\n    return 1             //         dep {v: i3, v1: i4}\n  })                   // f1: ( (v:V^{}) -> I{} )^{f1,v1}\n  let a1 = f1(v1)      // error:  {f1,v1}‚à©{v1} = {v1} ‚â† {}\n  let a2 = f1(v2)      // ok:     {f1,v1}‚à©{v2} = {}\n  let i5 = inc(v1)     //         dep {v1: a2}\n  let i6 = inc(v2)     //         dep {v2: a2}\n  return 1\n}\n</pre>\n<p>We can make two key observations:</p>\n<ul>\n<li>Type system successfully prevents calling f1(v1), since f1 uses v1 internally and didn‚Äôt declare that v may alias v1. On the other hand, calling f1(v2) is fine, since f1 doesn‚Äôt use v2.</li>\n<li>The assigned types enable us to infer precise dependencies between statements in a given block (shown on the right).</li>\n</ul>\n<p>Another example:</p>\n<pre>\nfunction counter() {\n  let v1 = alloc()         // v1: V^{v1}\n  let f1 = fun(() => {     // f1: (U^{} -> I^{})^{v1}\n    let i1 = inc(v1)\n    return 1\n  })\n  return f1\n}\nlet g1 = counter()       // g1: ( U^{} -> I^{} )^{g1}\nlet h1 = g1()            // dep {g1: g1}\nlet h2 = g1()            // dep {g1: h1}\n                         // dep {g1: h2} // block end\n</pre>\n<p>When calling <code class=\"language-text\">counter</code>, we must make sure that the result remains being tracked, and indeed we do - because everything is tracked!</p>\n<h3>Example 2: Escaping Tracked Variables</h3>\n<p>When a function creates a mutable variable that escapes\n(directly or indirectly via another function), the identity\nof that variable is tracked, even though it does not have\nany externally visible identifier.</p>\n<p>The mechanism to achieve this is by logically subsuming\nthe escaping variable into the function via which it\nescapes, and tracking the identity of that function\nwith a self-type (just like in DOT).</p>\n<pre>\ndef f(a: Int) = {\n  let c = alloc()\n                      // f(b:Int) -> Ref^{c}\n  (fun(b: Int) => c)  //     --close-->\n                      // f(b:Int) -> Ref^{f}\n}\nlet h0 = f(0)\nlet h1 = f(1)\nlet c0 = h0(0)\nlet c1 = h0(1) // same as c0\nlet c3 = h1(0)\nlet c4 = h1(1) // same as c3\ninc(c0)\ninc(c1) // serialize with prev\ninc(c3)\ninc(c4) // serialize with prev\nget(c0)\n// expected result:\n// - ops on c0 and c1 are serialized\n// - c3 and c4 are never read and hence\n//   dce'd along with all their ops\n</pre>\n</aside>\n<h3>Read and Write Effects, Soft and Hard Dependencies</h3>\n<p>Keep track of the last write and the set of reads after the last write.</p>\n<p>Write-after-read and write-after-write dependencies are anti-dependencies or <em>soft</em> dependencies: the subsequent write does not prevent any of the earlier statements from being DCE‚Äôd. But if the earlier statements are not DCE‚Äôd, they must ‚Äúhappen-before‚Äù the following write.</p>\n<p>Most reads can be subject to CSE, and some of the writes as well (overwriting a variable with its current value is a no-op). However, some reads are not idempotent and hence should not be subjected to CSE: reading a random number generator, or reading the next allocation address, if an <code class=\"language-text\">alloc</code> operation is modeled as a read on a global store variable. So an additional flag is needed for reads to mark non-idempotent ones, and writes require further analysis for CSE.</p>\n<h3>Discussion</h3>\n<p>Does flow-sensitivity need special treatment? (local vs. global, global for sure)</p>\n<p>We have soft dependencies. Do we also need soft effects (not incurred if target not needed)?</p>\n<p>We have may-effects (read, write, kill). Do we also need must effects?</p>\n<p>Dataflow properties (loops, recursion)?</p>\n<p>Control effects (delimited continuations)?</p>\n<h3>Formalization</h3>\n<p>Note: Is a standard type soundness theorem enough? Most likely, it is more interesting to directly show a correctness preservation theorem for graph modifications subject to dependency constraints: reordering, eliminating, etc. does not change result as long as dependencies are preserved. This sounds like a syntactic confluence property.</p>\n<p>Type assignment for graph (ANF) expressions extended with effect dependencies. Typing rules ensure that dependencies are sufficient.</p>\n<p>Alternative formulation that computes dependencies bottom up.</p>\n<p>Consistency with direct style from previous section.</p>\n<p>Semantics:</p>\n<p>In addition to standard reduction rules, provide a list of equality-preserving rewrites that can be read directionally as optimization rules. Everything operates on graph representation.</p>\n<p>Metatheory: preservation, progress, confluence for typed terms.</p>\n<p>Corollary: compiler safety for optimizations subject to dependencies.</p>\n<!-- Type system:\n\n1. Type assignment for direct-style terms.\n2. Type assignment for ANF expressions extended with effect dependencies. Typing rules ensure that dependencies are sufficient.\n\nOperational semantics:\n\nConceptually, represent values (functions and variables) uniformly as store locations. Represent the store as a sequence of let binding on the \"outside\" of the program and use variables to denote store locations (typical context formulation, see e.g. Call by Need Lambda Calculus and Wadlerfest DOT).\nTechnically, we maintain the syntactic ANF/graph representation.\n\nIn addition to standard reduction rules, provide a list of equality-preserving rewrites that can be read directionally as optimization rules.\n\nMetatheory: preservation, progress, confluence for typed terms.\n\nCorollary: compiler safety for optimizations subject to dependencies.\n -->\n<!--\n### Semantics and Soundness\n\nOperational semantics: represent values (functions and variables) uniformly as store locations. Represent the store as a sequence of let binding on the \"outside\" of the program and use variables to denote store locations (typical context formulation, see e.g. Call by Need Lambda Calculus and Wadlerfest DOT paper).\n\nEvaluation rules:\n\n<pre>\nlet x = Œªz.e in E[x y] - -> let x = Œªz.e in E[[y/z]e]\nlet x = y in e - -> [y/x]e\nlet x = (let y = e1 in e2) in e3 - -> let y = e1 in let x = e2 in e3\nE[e1] - -> E[e2] if e1 - -> e2\n\nE ::= [] | let x = [] in e | let x = nf in e\n\nnf ::= Œªz.e | alloc() | inc(x)\n</pre>\n\nSubstitution lemma (may need some tweaks):\n<pre>\nIf Œì,x:S^(Œ±‚à™{x}) ‚ä¢ e: T^Œ≤ and Œì ‚ä¢ y: S^Œ± then Œì ‚ä¢ [y/x]e: [y/x]T^Œ≤\n</pre>\n\nSoundness theorem:\n<pre>\nIf Œì ‚ä¢ E[e]: T^Œ± then either e is an answer (e = x) or\nthere exists Œì', E', e' such that E[e] - -> E'[e'] and\nŒì,Œì' ‚ä¢ E'[e']: T^Œ±\n</pre>\n\nNote the concatenation of Œì,Œì' (we're adding store bindings but do not change types in the store).\n\nThe standard progress and preservation lemmas follow as corollaries.\n\n-->\n</aside>\n<p>NEW! LMS effect &#x26; mutation tracking</p>\n<li> <aside>\n<h2>More ideas</h2>\n<p>Potential other use cases:</p>\n<ul>\n<li>constexpr/macros/staging: result of a function call is constant only if the function is constant and arg is constant (belong to a ‚Äúknown at compile time‚Äù region)</li>\n<li>noninterference: restrict information flow from ‚Äúhigh-security‚Äù to ‚Äúlow-security‚Äù values/regions</li>\n<li>program slicing: split a complex program into specific parts, delineated by region assignment</li>\n</ul>\n</aside>\n</ul>\n<h3>General Formulation</h3>\n<p>Type judgements take the form <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>x</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow><annotation encoding=\"application/x-tex\">Œì ‚ä¢ x: T^Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span></span> for a type qualifier <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ±</mi></mrow><annotation encoding=\"application/x-tex\">Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span>. Function types take the form <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">T_1^Œ± \\to T_2^Œ≤</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.931438em;vertical-align:-0.24810799999999997em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2333239999999999em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span></span>. The type assignment rule for functions is the following, with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup></mrow><annotation encoding=\"application/x-tex\">Œì^Œ≥</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span></span></span> denoting an environment restricted to bindings qualified with <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ≥</mi></mrow><annotation encoding=\"application/x-tex\">Œ≥</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span>.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>Œª</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì^Œ≥, x:T_1^Œ± ‚ä¢ e: T_2^Œ≤\n}{\n  Œì ‚ä¢ Œªx.e: (T_1^Œ± \\to T_2^Œ≤)^Œ≥\n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6461920000000001em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.0448000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26630799999999993em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></div>\n<p>It is often useful to assume a partial order <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>‚â§</mo></mrow><annotation encoding=\"application/x-tex\">‚â§</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">‚â§</span></span></span></span></span> on type qualifiers. Sometimes it is also useful to assume a smallest element <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>‚ä•</mtext></mrow><annotation encoding=\"application/x-tex\">‚ä•</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">‚ä•</span></span></span></span></span>, which typically means ‚Äúno restrictions‚Äù, i.e., denotes 1st-class values.</p>\n<aside>\n<p>General Formalization - Details</p>\n<p>We use a variant of simply-typed Œª-calculus as a basis. The core idea extends naturally to System F and beyond (the OOPSLA‚Äô16 paper presents a model based on System D&#x3C;:>).</p>\n<!-- Œ±Œ≤Œ≥ -->\n<h3>Syntax</h3>\n<p>Terms</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>n</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>x</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>Œª</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mtext>¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><mi>e</mi><mtext>¬†</mtext><mi>e</mi></mrow><annotation encoding=\"application/x-tex\"> e ::= n\\ |\\ x\\ |\\ Œªx.e\\ |\\ e\\ e </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\">¬†</span><span class=\"mord mathnormal\">e</span></span></span></span></span></p>\n<p>Types</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>:</mo><mo>:</mo><mo>=</mo><mtext>Nat¬†</mtext><mi mathvariant=\"normal\">‚à£</mi><mtext>¬†</mtext><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><annotation encoding=\"application/x-tex\"> T ::= \\text{Nat}\\ |\\ T_1^Œ± \\to T_2^Œ≤ </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Nat</span></span><span class=\"mspace\">¬†</span><span class=\"mord\">‚à£</span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2333239999999999em;vertical-align:-0.266308em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>Type qualifiers</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Œ±</mi><mo separator=\"true\">,</mo><mi>Œ≤</mi><mo separator=\"true\">,</mo><mi>Œ≥</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\"> Œ±,Œ≤,Œ≥ ::= ... </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">Œ±</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">Œ≤</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.10556em;vertical-align:0em;\"></span><span class=\"mord\">...</span></span></span></span></span></p>\n<p>Environments</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>:</mo><mo>:</mo><mo>=</mo><mi>x</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\"> Œì ::= x:T^Œ±, ... </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">::=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">...</span></span></span></span></span></p>\n<h3>Type assigment</h3>\n<p>General form: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow><annotation encoding=\"application/x-tex\">Œì ‚ä¢ e: T^Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>x</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(var)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì(x) = T^Œ±\n}{\n  Œì ‚ä¢ x:T^Œ±\n} \\quad\\text{(var)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(var)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><msup><mi mathvariant=\"normal\">Œì</mi><mi>Œ≥</mi></msup><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>Œª</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(abs)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì^Œ≥, x:T_1^Œ± ‚ä¢ e: T_2^Œ≤\n}{\n  Œì ‚ä¢ Œªx.e: (T_1^Œ± \\to T_2^Œ≤)^Œ≥\n} \\quad\\text{(abs)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6461920000000001em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.0448000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26630799999999993em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(abs)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mspace width=\"2em\"></mspace><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mtext>¬†</mtext><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(app)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì ‚ä¢ e_1: (T_1^Œ± \\to T_2^Œ≤)^Œ≥ \\qquad\n  Œì ‚ä¢ e_2: T_1^Œ±\n}{\n  Œì ‚ä¢ e_1\\ e_2: T_2^Œ≤\n} \\quad\\text{(app)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(app)</span></span></span></span></span></span></div>\n<h3>Notes</h3>\n<!-- **TODO:** add alternative version based on free vars -->\n<p>Notes:</p>\n<ul>\n<li>Restricted environment in rule (abs): restricting the environment removes all non-matching bindings, so we obtain a guarantee that the function can only access <code class=\"language-text\">Œ≥</code>-qualified bindings from the outer scope.\n<ul>\n<li>\n<p>Of course, non-<code class=\"language-text\">Œ≥</code>-qualified bindings can still be added in an inner scope.</p>\n</li>\n<li>\n<p>An alternative way to express this is to relate <code class=\"language-text\">Œ≥</code> explicitly to the qualifiers of <code class=\"language-text\">e</code>‚Äôs free variables (see below).</p>\n<aside>\n  Alternative type assignment (tracking free vars)\n<p>Alternative type assignment (tracking free vars): <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow><annotation encoding=\"application/x-tex\">Œì ‚ä¢ e: T^Œ±</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>x</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(var)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì(x) = T^Œ±\n}{\n  Œì ‚ä¢ x:T^Œ±\n} \\quad\\text{(var)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.113em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(var)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><mspace width=\"2em\"></mspace><mi>Œ≥</mi><mo>=</mo><mo>‚®Ü</mo><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mi>V</mi><mo stretchy=\"false\">(</mo><mi>e</mi><mo stretchy=\"false\">)</mo><mo>‚àí</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>Œª</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(abs)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì, x:T_1^Œ± ‚ä¢ e: T_2^Œ≤ \\qquad\n  Œ≥ = ‚®Ü Œì(FV(e)-x)\n}{\n  Œì ‚ä¢ Œªx.e: (T_1^Œ± \\to T_2^Œ≤)^Œ≥\n} \\quad\\text{(abs)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6461920000000001em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.0448000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26630799999999993em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">‚®Ü</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">Œì</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(abs)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mspace width=\"2em\"></mspace><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mtext>¬†</mtext><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(app)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì ‚ä¢ e_1: (T_1^Œ± \\to T_2^Œ≤)^Œ≥ \\qquad\n  Œì ‚ä¢ e_2: T_1^Œ±\n}{\n  Œì ‚ä¢ e_1\\ e_2: T_2^Œ≤\n} \\quad\\text{(app)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(app)</span></span></span></span></span></span></div>\n<p>Alternative type assignment (tracking free vars as effects): <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup><mi mathvariant=\"normal\">/</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo separator=\"true\">,</mo><mi>z</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">Œì ‚ä¢ e: T^Œ± / x,y,z,...</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">...</span></span></span></span></span></p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>T</mi><mi>Œ±</mi></msup></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>x</mi><mo>:</mo><msup><mi>T</mi><mi>Œ±</mi></msup><mi mathvariant=\"normal\">/</mi><mi>x</mi></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(var)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì(x) = T^Œ±\n}{\n  Œì ‚ä¢ x:T^Œ± / x\n} \\quad\\text{(var)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(var)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚ä¢</mo><mi>e</mi><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><mi mathvariant=\"normal\">/</mi><mi>y</mi><mi>s</mi><mspace width=\"2em\"></mspace><mi>Œ≥</mi><mo>=</mo><mo>‚®Ü</mo><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mi>s</mi><mo>‚àí</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>Œª</mi><mi>x</mi><mi mathvariant=\"normal\">.</mi><mi>e</mi><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mi mathvariant=\"normal\">/</mi><mi>y</mi><mi>s</mi><mo>‚àí</mo><mi>x</mi></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(abs)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì, x:T_1^Œ± ‚ä¢ e: T_2^Œ≤ / ys \\qquad\n  Œ≥ = ‚®Ü Œì(ys-x)\n}{\n  Œì ‚ä¢ Œªx.e: (T_1^Œ± \\to T_2^Œ≤)^Œ≥ / ys-x\n} \\quad\\text{(abs)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">Œª</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6461920000000001em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.0448000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.26630799999999993em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">ys</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">ys</span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">Œ≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">‚®Ü</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">Œì</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ys</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(abs)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><mo stretchy=\"false\">(</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mo>‚Üí</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><msup><mo stretchy=\"false\">)</mo><mi>Œ≥</mi></msup><mi mathvariant=\"normal\">/</mi><mi>x</mi><msub><mi>s</mi><mn>1</mn></msub><mspace width=\"2em\"></mspace><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>1</mn><mi>Œ±</mi></msubsup><mi mathvariant=\"normal\">/</mi><mi>x</mi><msub><mi>s</mi><mn>2</mn></msub></mrow><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><msub><mi>e</mi><mn>1</mn></msub><mtext>¬†</mtext><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msubsup><mi>T</mi><mn>2</mn><mi>Œ≤</mi></msubsup><mi mathvariant=\"normal\">/</mi><mi>x</mi><msub><mi>s</mi><mn>1</mn></msub><mo>‚®Ü</mo><mi>x</mi><msub><mi>s</mi><mn>2</mn></msub></mrow></mfrac><mspace width=\"1em\"></mspace><mtext>(app)</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Œì ‚ä¢ e_1: (T_1^Œ± \\to T_2^Œ≤)^Œ≥ / xs_1 \\qquad\n  Œì ‚ä¢ e_2: T_1^Œ± / xs_2\n}{\n  Œì ‚ä¢ e_1\\ e_2: T_2^Œ≤ / xs_1 ‚®Ü xs_2\n} \\quad\\text{(app)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.76734em;vertical-align:-1.1233239999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.644016em;\"><span style=\"top:-2.142984em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\">¬†</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">‚®Ü</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9670159999999999em;\"><span style=\"top:-2.433692em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.1809080000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">Œ≤</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.266308em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">Œ≥</span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">Œ±</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.24810799999999997em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1233239999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord text\"><span class=\"mord\">(app)</span></span></span></span></span></span></div>\n  <pre>\n    Œì(x) = T^Œ±\n    -------------- (var)\n    Œì ‚ä¢ x:T^Œ± / x\n\n    Œì, x:T1^Œ± ‚ä¢ e: T2^Œ≤ / ys     Œ≥ = ‚®Ü Œì(ys-x)\n    --------------------------------------------- (abs)\n    Œì ‚ä¢ Œªx.e: (T1^Œ± -> T2^Œ≤)^Œ≥ / ys-x\n\n    Œì ‚ä¢ e1: (T1^Œ± -> T2^Œ≤)^Œ≥ / xs1    Œì ‚ä¢ e2: T1^Œ± / xs2\n    ------------------------------------------------------- (app)\n    Œì ‚ä¢ e1 e2: T2^Œ≤ / xs1+xs2\n  </pre>\n</aside>\n</li>\n<li>\n<p>Yet another alternative is to demand that the entire environment conforms to <code class=\"language-text\">Œ≥</code> in rule (abs) and add a ‚Äúframe rule‚Äù (as in separation logic) that allows extending the environment (essentially, a weakening axiom). This can be pushed even further by demanding a singleton environmet in (var) and joining environments bottom-up in (app)</p>\n</li>\n</ul>\n</li>\n<li>Qualifier for functions in rule (app): as stated, rule (app) ignores the qualifier of the function, <code class=\"language-text\">Œ≥</code>, and does not constrain it in any way. This is consistent with the expectation that even 2nd-class functions can be called without restrictions. However, several instantiations of the system require certain refinements:\n<ul>\n<li>Recursive functions: may impose restrictions on function itself, e.g., preventing the function itself from escaping during the call</li>\n<li>Separation: may require that the function argument is separate from (i.e., does not alias) the function itself (and anything the function closes over)</li>\n<li>Information flow, staging: certain function may not be called with tainted/high-security or not-yet-available values</li>\n</ul>\n</li>\n</ul>\n<p>Notes:</p>\n<ul>\n<li>Relation of Œ≤,Œ≥ (in rule abs):\n<ul>\n<li>Œ≤ may refer to x/Œ± (leak arg)</li>\n<li>Œ≥ contains all free vars (used + leaked), Œ≤ only leaked</li>\n</ul>\n</li>\n</ul>\n<p>Extensions:</p>\n<ul>\n<li>Subtyping (qualifier equivalence vs. inclusion): as stated, qualifiers need to match exactly.\n<ul>\n<li>It is often useful to relax this, and assume a partial ordering among qualifiers, which extends the system to a subtyping system in a straightforward way.</li>\n<li>A unique smallest qualifier <code class=\"language-text\">‚ä•</code> is useful to denote 1st-class, i.e., unrestricted values.</li>\n<li>Depending on the instantiation, it can be desirable to require least-upper-bounds <code class=\"language-text\">‚®Ü</code> on qualifiers, so that it is always possible for a function to close over different qualifiers. In other cases, this may not be desirable.</li>\n</ul>\n</li>\n<li>Parametricity: qualifier abstraction can be added in a straightforward way. It is especially useful to support bounded qualifier abstraction, assuming qualifiers are partially ordered.</li>\n<li>Dependent function types: if qualifiers can refer to program variables, the application rule needs to be extended to support dependent application. This comes up, e.g., when qualifiers track aliasing/separation of program variables.</li>\n<li>Dependent qualifiers: it is possible to allow sets of term variables in qualifiers, with the intention that variable references expand to the qualifiers assigned to those variables via subtyping and substitution.</li>\n</ul>\n<p>As a concrete example of such extensions, the OOPSLA‚Äô16 Scala implementation uses standard Scala types as qualifiers, and hence the subtyping lattice as qualifier lattice, providing bounded quantification, functional dependencies, etc.</p>\n</aside>","fields":{"slug":"/Public/Generic/regions-borrowing-coeffects/"},"frontmatter":{"date":"2020-09-27","title":"Regions, Separation, Stackability, Borrowing, Linearity, Effects, Capabilities, etc.","description":"","keywords":"Regions, region-based memory, linear types, affine types, move semantics, ownership, borrowing, stack allocation, effects, co-effects, algebraic effects, capabilities, dependent types, graph IR, sea of nodes","tags":null}}},{"node":{"excerpt":"We present a program optimizer for a higher-order impure functional language based on a novel expressive graph IR. Graph IRs are ideally‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>We present a program optimizer for a higher-order impure functional language based on a novel expressive graph IR.</p>\n<p>Graph IRs are ideally suited for purely functional code (no ordering, just dependencies!) and also widely used intra-procedurally for imperative code (e.g. ‚ÄúSea-of-Nodes‚Äù IRs in VMs for <a href=\"https://2019.jokerconf.com/en/2019/talks/7awcra2dd8cnxs6oi9dxhi/\">Java</a> <a href=\"https://chrisseaton.com/truffleruby/basic-graal-graphs/\">or</a> <a href=\"https://v8.dev/docs/turbofan\">JavaScript</a>).\nHowever, the combination of state and higher-order control flow makes it extremely difficult to infer and manage useful dependency information, at a granularity that enables aggressive optimization.</p>\n<p>What if we had a Sea-of-Nodes-like IR that natively supported closures and other higher-order structured expressions, as well as heap-allocated data?</p>\n<p>Our prototype below explores this question. It supports structured and scoped expressions (importantly, higher order functions), soft and hard dependencies, mutable references, and various forms of effects (e.g., read/write/kill). The basis is a <a href=\"/Public/Generic/regions-borrowing-coeffects\">novel ‚Äúreachability type and effect system‚Äù</a> that tracks aliasing and separation properties of program values, with degrees of flow-sensitivity. Similar in a sense, but more general, than Rust.</p>\n<p><strong>Note:</strong> the implementation below is a proof of concept, deliberately focused on exploring new ways for tracking effects and dependencies. Compared to full systems <a href=\"https://github.com/TiarkRompf/lms-clean\">like</a> <a href=\"https://scala-lms.github.io\">LMS</a>, it intentionally limits features and disregards many possible optimizations. We may or may not add more of them here in the future.</p>\n<aside>\n<h2>Implementation, more examples, and test cases</h2>\n<h3>TEMP: May 2022</h3>\n<ul>\n<li><del>Add tests for known bugs (nested min eligible, ‚Ä¶)</del></li>\n<li><del>Backport UX improvements from dependent types version (clickable syms, graph ir panel, ‚Ä¶)</del></li>\n<li><del>Add proper overlap computation (check if needed? &#x3C;‚Äî seems ok)</del></li>\n<li><del>Switch to lazy saturation</del></li>\n<li><del>Reachability polymorphism (soft-track)</del></li>\n<li><del>Fix MinEligible for multiple levels and other known bugs</del></li>\n<li>Test all the above!</li>\n<li>(Maybe) improve ‚Äúcall effect‚Äù handling (but not call(f(a)) yet?)</li>\n<li>(Maybe) allow returning killed values (self ref in function codomain)</li>\n<li>July: bring up to date with theory from POPL submission</li>\n</ul>\n<h3>Staged graph construction API</h3>\n<aside>\n<p>Implementation code</p>\n<p>Graph State</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Options\n// ------------------------------------------------------------\nlet flags = {\n  targetSugar:  false,\n  softKill:     true\n}\n// ------------------------------------------------------------\n// Internals\n// ------------------------------------------------------------\n// global state: monotonous, add-only\nlet nVars = 0       // number of symbols used\nlet code = []       // list of all definitions (as let stms)\nlet cnstPool = {}   // for cse\n//   the following are all indexed by sym\nlet nameHint = {}\nlet errorLog = {}\nlet infoLog  = {}\nlet symToDef = {}\nlet symToTpe = {}\nlet boundDeps = {}  // the bound syms each node depends on\n// XXX trackStatus --- TODO\nlet trackStatus = {} // the track state of each sym (0,1,2)\nlet alias = {}      // the tracked syms each sym may refer to ('-') if untracked\n// local state: per-block, add-only\nlet blockStart      // symbol representing current block start\nlet effects = {}    // record effects in current block\n// local state: flow-sensitive, change per statement\nlet state = {}      // last read/write for each tracked sym\n                    // (summarizes local effect history)\nlet effStms = {}    // log of local effectful stms (effect history)\n                    // (used for minEligible computation)\n//\n// Format of state: for given tracked sym\n//   .init:  set to self if node created in this block\n//   .write: symbol of last write, if any\n//   .reads: list of reads after last write, or block start if no write\n//   .kill:  symbol of kill, if any\n//\nfunction fresh() {\n  return nVars++\n}\nfunction reset() {\n  nVars = 0\n  code = []\n  cnstPool = {}\n  nameHint = {}\n  errorLog = {}\n  infoLog  = {}\n  symToDef = {}\n  symToTpe = {}\n  boundDeps = {}\n  trackStatus = {}\n  alias = {}\n  blockStart = undefined\n  effects = {}\n  state = {}\n  effStms = {}\n}\n</code>\n<p>Errors and Logging</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// note: calls into front-end for rendering & UX\nfunction logInteractive(...es) {\n  let ds = []\n  function rec(e) {\n    if (typeof(e) == \"number\") // treat as sym\n      ds.push(\" \",prettyDomSym(e),\" \")\n    else if (e instanceof Array) {\n      ds.push(\"[\")\n      e.forEach(rec) // should collapse into dom node?\n      ds.push(\"]\")\n    } else\n      ds.push(e)\n  }\n  es.forEach(rec)\n  //oo.appendChild(e(\"div\",{},...ds))\n  print(...ds)\n}\nfunction logError(x,...es) {\n  let el = dom(\"¬†\")\n  registerSymRef(x,el,true)\n  logInteractive(el,\" \",\"Error at node \",x,\": \",...es)\n  let str = es.join(\" \")\n  if (!errorLog[x]) errorLog[x] = []\n  // do not record same error twice\n  for (let es1 of errorLog[x]) {\n    if (es1.join(\" \") == str)\n      return\n  }\n  errorLog[x].push(es)\n  highlightSymError(x)\n}\n</code>\n<p>Stateful Node Construction (reflect)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction reflect(...ss) {\n  // TODO: move CSE logic to reflect0, shouldn't be\n  // restricted to literal constants\n  if (ss.length == 1 && typeof(ss[0]) == \"number\") {\n    if (cnstPool[ss[0]]) return cnstPool[ss[0]]\n    let r = reflect0(fresh(), ss)\n    cnstPool[ss[0]] = r\n    symToTpe[r] = \"Int\"\n    return r\n  } else if (ss.length == 1 && ss[0] == \"()\") {\n    if (cnstPool[ss[0]]) return cnstPool[ss[0]]\n    let r = reflect0(fresh(), ss)\n    cnstPool[ss[0]] = r\n    symToTpe[r] = \"Unit\"\n    return r\n  }\n  return reflect0(fresh(), ss)\n}\nfunction reflect0(x,exp,extra) {\n  // options\n  let bound = []\n  let syms = exp.slice(1).filter(s => typeof(s) === \"number\") // XXX FROM DEP need recursion?\n  let als = [] // untracked by default\n  let alsQ = 0 // XXX SOFT TRACK\n  let read = []\n  let write = []\n  let kill = []\n  let self = [] // latent call effects\n  let tpe = []\n  if (extra) {\n    if (extra.bound) bound = extra.bound\n    if (extra.syms) syms = extra.syms\n    if (extra.alias) als = extra.alias\n    if (extra.trackStatus) alsQ = extra.trackStatus // XXX SOFT TRACK\n    if (extra.effect) {\n      if (extra.effect.write) write = extra.effect.write\n      if (extra.effect.read) read = extra.effect.read\n      if (extra.effect.kill) kill = extra.effect.kill\n      if (extra.effect.self) self = extra.effect.self\n    }\n    if (extra.write) write = extra.write\n    if (extra.read) read = extra.read\n    if (extra.kill) kill = extra.kill\n    if (extra.tpe) tpe = extra.tpe\n  }\n  //\n  // record info/error\n  //\n  if (!errorLog[x]) errorLog[x] = []\n  if (!infoLog[x]) infoLog[x] = []\n  //\n  // alias info\n  //\n  trackStatus[x] = alsQ // 0 means fully dependent on aliases, 1 means maybe fresh\n  alias[x] = als.filter(y => trackStatus[y] || alias[y].length)\n  //\n  // effects: first record effects as declared\n  // (previously: with aliases resolved)\n  //\n  if (!effects.read) effects.read = []\n  if (!effects.write) effects.write = []\n  if (!effects.kill) effects.kill = []\n  if (!effects.self) effects.self = []\n  effects.read.push(...read) // was: allread, etc\n  effects.write.push(...write)\n  effects.kill.push(...kill)\n  effects.self.push(...self)\n  //\n  // effects: resolve latent call effects\n  //\n  // basic logic: for a call\n  // - for dependencies: resolve into actual r/w/k\n  // - for recording what happened: leave as call\n  // - (currently: effects on arg are always resolved)\n  //\n  for (let s of self) {\n    let es = resolveLatentEffect(s)\n    if (es.read) read = [...read,...es.read]\n    if (es.write) write = [...write,...es.write]\n    if (es.kill) kill = [...kill,...es.kill]\n  }\n  //\n  // effects: resolve aliases\n  //\n  let allreads = read.map(x => [...transitiveAliases(x)]).flat()\n  let allwrites = write.map(x => [...transitiveAliases(x)]).flat()\n  let allkills = kill.map(x => [...transitiveAliases(x)]).flat()\n  //\n  // now record dependencies\n  //\n  //let deps = {}\n  //for (let e of allwrites)\n  //  deps[e] = state[e] ? state[e] : blockStart\n  let hdeps = {}\n  let sdeps = {}\n  function ensureState(e) {\n    if (!hdeps[e]) hdeps[e] = []\n    if (!sdeps[e]) sdeps[e] = []\n    if (!state[e]) state[e] = { reads: [] }\n  }\n  function checkAccess(e, action) {\n    if (state[e].kill) logError(x, \"can't \"+action+\" dead object: \"+prettySym(e))\n  }\n  function lastWriteOrInit(e) {\n    return state[e].write || state[e].init || blockStart\n  }\n  for (let e of allreads) {\n    ensureState(e)\n    checkAccess(e, \"read\")\n    hdeps[e].push(lastWriteOrInit(e))\n    state[e].reads.push(x)\n  }\n  for (let e of allwrites) {\n    ensureState(e)\n    checkAccess(e, \"write\") // design choice: write could resurrect\n    sdeps[e].push(lastWriteOrInit(e))\n    for (let r of state[e].reads) if (r != x) sdeps[e].push(r)\n    state[e] = { write: x, reads: [] }\n  }\n  for (let e of allkills) {\n    ensureState(e)\n    checkAccess(e, \"kill\") // design choice: kill could be idempotent\n    if (state[e].write != x) sdeps[e].push(lastWriteOrInit(e))\n    for (let r of state[e].reads) if (r != x) sdeps[e].push(r)\n    state[e] = { write: x, reads: [], kill: x }\n  }\n  if (trackStatus[x] || alias[x].length) // every tracked value should have an entry\n    state[x] = { init: x, reads: [] }\n  // XXX SOFT TRACK\n      // if (trackStatus[x]) // every tracked value should have an entry\n      //  state[x] = { init: x, reads: [] }\n  //\n  // bound info (include effect deps)\n  //\n  let allsyms = [...syms]\n  for (let e in hdeps) allsyms.push(...hdeps[e])\n  for (let e in sdeps) allsyms.push(...sdeps[e]) // nothing special about soft deps -- TODO: \"soft bound\"??? not sure how...\n  let bs = new Set(bound)\n  boundDeps[x] = new Set()\n  for (let s of allsyms) {\n    if (!boundDeps[s]) {\n      logInteractive(\"error: \",s,\" has no bound deps array (while reflecting new sym \",x,\"=\"+exp+\" tpe \",tpe,\")\")\n      continue\n    }\n    for (let b of boundDeps[s])\n      if (!bs.has(b)) // lambda should not dep on its own bound var\n        boundDeps[x].add(b)\n  }\n  //\n  // remember node if dep on block start\n  //\n  if (boundDeps[x].has(blockStart))\n    effStms[x] = 1\n  //\n  // create node\n  //\n  let ss = [\"let\", x, exp, [hdeps,sdeps]]\n  code.push(ss)\n  symToDef[x] = ss\n  //\n  // set type\n  //\n  if (tpe) symToTpe[x] = tpe\n  return x\n}\nfunction transitiveAliases(x) {\n  let res = new Set()\n  function rec(x) {\n    if (res.has(x)) return\n    if (!(alias[x] instanceof Array)) return\n    res.add(x)\n    alias[x].forEach(rec)\n  }\n  if (alias[x] instanceof Array)\n    rec(x)\n  return res\n}\n// the effect a function has on the\n// environment (not its arg, may incl self)\n// Q: do we need to resolve aliases?\n//    before and/or after lookup?\nfunction resolveLatentEffect(f) {\n  let [argInfo, frtp] = extractFunTypeFlat(symToTpe[f])\n  let resInfo = frtp(f,nVars) // fresh var without consumption\n  // TODO: need transitive??\n  let es = filterEffect(resInfo.effect, y => y != nVars)\n  if (es.self)\n    print(\"WARNING: transitive 'self' effects currently not handled (at x\"+f+\")\")\n  return es\n}\nfunction filterEffect(es,f) {\n  let res = {}\n  for (let k in es) {\n    let e = es[k].filter(f)\n    if (e.length > 0)\n      res[k] = e\n  }\n  return res\n}\n// XXX previous\n//function logError(x,...es) {\n//  let str = es.join(\" \")\n//  print(\"Error at node \" + prettySym(x) + \": \" + str)\n//  if (!errorLog[x]) errorLog[x] = []\n//  // do not record same error twice\n//  for (let es1 of errorLog[x]) {\n//    if (es1.join(\" \") == str)\n//      return\n//  }\n//  errorLog[x].push(es)\n//  highlightSymError(x)\n//}\nfunction isTracked(x) {\n  return trackStatus[x] || alias[x].length\n}\n </code>\n<h3>Core Language</h3>\n<p>Basic Expressions</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Expression API (without lambda/app)\n// ------------------------------------------------------------\nfunction plus(a,b) {\n  typeCheckUnflat(a, \"Int\"); typeCheckUnflat(b, \"Int\")\n  return reflect0(fresh(),[\"+\", a, b], {tpe:\"Int\"})\n}\nfunction minus(a,b) {\n  typeCheckUnflat(a, \"Int\"); typeCheckUnflat(b, \"Int\")\n  return reflect0(fresh(),[\"-\", a, b], {tpe:\"Int\"})\n}\nfunction times(a,b) {\n  typeCheckUnflat(a, \"Int\"); typeCheckUnflat(b, \"Int\")\n  return reflect0(fresh(),[\"*\", a, b], {tpe:\"Int\"})\n}\n//\n// NOTE: there is a general question on what type checks\n// are needed and possible for effectful primitive operations\n// (e.g. check that refs are writable, tracked, etc).\n//\n// There isn't much use in checking that a var is tracked,\n// because untracked vars can always be up-cast to tracked\n// (T <: T @tracked).\n//\n// For Ref types, soundness relies on the fact that the sole\n// introduction form, alloc, returns a tracked value.\n// It's entirely possible to declare functions with untracked\n// Ref args, but they can never be called.\n//\n// Alloc and println do check for tracked status -- this is\n// our current crutch to signal an error if main's arg isn't\n// tracked!\n//\n// The bottom line is that ops on references mainly\n// check base types and ignore tracking status.\n//\nfunction println(a,b) {\n  typeCheckBase(a, \"IO\"); typeCheckBase(b, \"?\")\n  // check base type only (see note above)\n  if (!isTracked(a)) // crutch for top-level\n    logError(a, \"not a tracked value: \"+prettySym(a))\n  let res = reflect0(fresh(), [\"print\", a, b], {\n    read: [a],\n    write: [a],\n    tpe: \"Unit\"\n  })\n  nameHint[res] = \"p\"\n  return res\n}\nfunction alloc(a,b) {\n  typeCheckBase(a, \"IO\")\n  // check base type only (see note above)\n  if (!isTracked(a)) // crutch for top-level\n    logError(a, \"not a tracked value: \"+prettySym(a))\n  // second arg: initial value\n  if (!b) b = reflect(0) // could move to AST->IR layer\n  let einfo = symToTpeFlat(b)\n  let res = reflect0(fresh(), [\"alloc\", a, b], {\n    trackStatus: 1, // always tracked\n    alias: [b], // always tracked\n    read: [a],\n    tpe: reftype(tpeUnflatten(einfo))\n  })\n  nameHint[res] = \"c\"\n  return res\n}\nfunction get(a) {\n  typeCheckBase(a, reftype(\"Int\"))\n  let ainfo = symToTpeFlat(a)\n  let einfo = extractRefTypeFlat(ainfo.base)\n  // note on tracking/alias status: if the elem type is untracked,\n  // then the result is untracked. otherwise the result type\n  // tracks the var (and transitively its aliases -- assume\n  // that this subsumes declared elem aliases)\n  // XXX unsure\n  let resAlias = einfo.track.alias ? [a] : []\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"get\", a], {\n    alias: resAlias, read: [a], write: [], tpe: einfo.base\n  })\n  return res\n}\nfunction set(a,b) {\n  let ainfo = symToTpeFlat(a)\n  let einfo = extractRefTypeFlat(ainfo.base)\n  typeCheckFlat(b, einfo)\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"set\", a, b], {\n    read: [], write: [a], tpe: \"Unit\"\n  })\n  return res\n}\nfunction inc(a) {\n  typeCheckBase(a, reftype(\"Int\"))\n  // note: inc is defined only for Ref(Int)\n  let res = reflect0(fresh(), [\"inc\", a], {\n    read: [a], write: [a], tpe: \"Int\"\n  })\n  return res\n}\nfunction free(a) {\n  let ainfo = symToTpeFlat(a)\n  let einfo = extractRefTypeFlat(ainfo.base)\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"free\", a], {\n    read: [], write: [], kill: [a], tpe: \"Unit\"\n  })\n  return res\n}\n// explicit move operation: if the arg is tracked, kill all\n// current aliases, and return the arg as fresh, non-aliased,\n// but tracked value\nfunction move(a) {\n  let ainfo = symToTpeFlat(a)\n  // if (!ainfo.track.alias) return a // no-op if untracked\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"move\", a], {\n    trackStatus: 1, alias: [], read: [], write: [], kill: [a], tpe: ainfo.base\n  })\n  return res\n}\n// swap operation: swap the value of a ref cell, returning the\n// old value as fresh, non-aliased, but tracked value\n// NOTE: this is incompatible with a general \"get\" operation\nfunction swap(a,b) {\n  let ainfo = symToTpeFlat(a)\n  let einfo = extractRefTypeFlat(ainfo.base)\n  typeCheckBase(b, einfo.base) // only base, b/c kill!\n  // let resAlias = einfo.track.alias ? [] : \"-\"\n  // check base type only (see note above)\n  let res = reflect0(fresh(), [\"swap\", a, b], {\n    trackStatus: 1, alias: [], read: [a], write: [a], kill: [b], tpe: einfo.base\n  })\n  return res\n}\n</code>\n<p>Function Expressions (fun &#x26; app)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Public API for app & fun\n// ------------------------------------------------------------\nfunction app(fun, arg) {\n  assert(symToTpe[fun], \"fun doesn't have type\")\n  let [argInfo, frtp] = extractFunTypeFlat(symToTpe[fun])\n  let resInfo = frtp(fun,arg)\n  //\n  // check arg tpe\n  // XXX: may want to add more sanity checks for alias/effects?\n  //\n  typeCheckBase(arg,argInfo.base)\n  //\n  // check fun and arg are separate / overlap only in permitted ways\n  //\n  checkFunArgOverlap(fun,arg,argInfo.track.alias||[],argInfo.track.status ? argInfo.track.status.length : 0)\n  //\n  // Effect polymorphism\n  // - any calls to a function arg should record\n  //   effect @self(arg) instead of the effects\n  //   from the type. Exception: effects of arg on\n  //   its own arg - we can't in general\n  // - if res effect includes @self(arg), replace\n  //   with actual latent self effect of arg\n  //\n  // Alternative design:\n  // - result effect is always @call(f,arg)\n  // - resolve it during subtype checking and\n  //   when converting to self type (minEligible)\n  let resEffect = resInfo.effect\n  if (!symToDef[fun]) { // calling a bound sym (a fun arg)\n    // only count effects on the argument\n    resEffect = filterEffect(resEffect, y => y == arg)\n    if (!resEffect.self) resEffect.self = []\n    resEffect.self.push(fun)\n  }\n  //\n  // create node and set result type/alias info\n  //\n  let res = reflect0(fresh(), [\"@\", fun, arg], {\n    trackStatus: resInfo.track.status ? resInfo.track.status.length : 0,\n    alias: resInfo.track.alias ? resInfo.track.alias : [],\n    effect: resEffect,\n    tpe: resInfo.base\n  })\n  //symToTpe[res] = resTpe\n  return res\n}\nfunction fun(ftp,f) {\n  let [argInfo, frtp] = extractFunTypeFlat(ftp)\n  let argTpe = argInfo.base\n  let argAlias = argInfo.track.alias\n  let argTrackStatus = argInfo.track.status\n  //\n  // initialize arg and self ref\n  //\n  let ff = fresh()\n  let xx = fresh()\n  // expected type components (may be wildcards \"?\")\n  let expectedResInfo = frtp(ff,xx)\n  let [expectedResTpe, expectedResAlias, expectedResEffect] =\n    [expectedResInfo.base, expectedResInfo.track.alias, expectedResInfo.effect]\n  symToTpe[ff] = ftp\n  symToTpe[xx] = argTpe\n  nameHint[ff] = \"fun\"\n  nameHint[xx] = \"arg\"\n  boundDeps[ff] = new Set() // mark fun? XXX\n  boundDeps[xx] = new Set([xx]) // mark arg as bound\n  alias[xx] = argAlias ? [...argAlias] : [] // mark arg as tracked\n  trackStatus[xx] = argTrackStatus ? argTrackStatus.length : 0\n  // XXX XXX SOFT TRACK\n  // what about ff?\n  //\n  // execute body in fresh state, mapping all entries to arg symbol\n  //\n  let codeWatermark = code.length\n  let save = {blockStart,state,effects,effStms}\n  state = {} // will pick up blockStart as default\n  effects = {}\n  effStms = {}\n  state[xx] = { reads: [] } // must be in as marker that it belongs to this block\n  blockStart = xx\n  let yy = f(ff,xx)\n  let localState = state\n  let localEffects = effects\n  let localEffStms = effStms\n  state = save.state\n  effects = save.effects\n  effStms = save.effStms\n  blockStart = save.blockStart\n  //\n  // collect effect dependencies on nodes in block\n  //\n  let esc = transitiveAliases(yy)\n  let deps = {} // \"dependency\" (last write)\n  let sdeps = {} // soft deps\n  for (let e0 in localState) { // e is a string!\n    let e = Number(e0)\n    let nonlocal = (e == ff || e == xx || e in state || esc.has(e))\n    deps[e] = []\n    sdeps[e] = []\n    if (localState[e].write) {\n      // right now we assume write implies read (see above)\n      if (nonlocal) deps[e].push(localState[e].write)\n      else sdeps[e].push(localState[e].write)\n    }\n    if (localState[e].kill) {\n      // XXX cannot return value after killing it\n      if (esc.has(e))\n        logError(yy, \"cannot return dead object: \"+prettySym(e))\n      if (nonlocal || !flags.softKill) deps[e].push(localState[e].kill)\n      else sdeps[e].push(localState[e].kill)\n    }\n    for (let r of localState[e].reads) {\n      sdeps[e].push(r)\n    }\n  }\n  //\n  // compute result type incl. visible effects\n  //\n  let newResTpe = symToTpe[yy]\n  // XXXX SOFT TRACK generalize!\n  // - want tracked aliases of result\n  // - alternative: just result, resolve/normalize lazily\n  let newResAlias = trackStatus[yy] ? [yy] : alias[yy]\n  let newResEffect = {}\n  for (let k in localEffects) {\n    newResEffect[k] = [...new Set(localEffects[k])]\n  }\n  // NOTE: we need to remove duplicates here (otherwise reflect0\n  // may blow up, e.g. on double-ref to a write), but minEligible\n  // will do the bulk of the work and eliminate references\n  // to local symbols\n  //\n  // type check block result (if given expected type)\n  // Q: do this before or after minEligible?\n  //\n  checkSubType(newResTpe, expectedResTpe, {sym:yy})\n  if (expectedResTpe != \"?\") {\n    checkSubAlias(newResAlias, expectedResAlias, {sym:yy})\n    checkSubEffect(newResEffect, expectedResEffect, {sym:yy})\n  }\n  //\n  // compute new type: externally visible, use minEligible to upcast\n  //\n  let newResInfo = { base: newResTpe }\n  newResInfo.track = /*newResAlias == \"-\" ? {} :*/ { alias: newResAlias }\n  newResInfo.effect = newResEffect\n  let newResInfo1 = minTypeEligibleInParentEnvFlat(newResInfo,[ff,xx],localEffStms)\n  let newArgTpe = tpeUnflatten(argInfo)\n  let newResTpe1 = tpeUnflatten(newResInfo1)\n  // we can use different names in type and expr (but don't have to)\n  //let newFunTpe = funtype(newArgTpe, (f,x) => subst(subst(newResTpe1,xx,x),ff,f) )\n  let newFunTpe = [\"=>\", newArgTpe, ff, xx, newResTpe1]\n  //\n  // compute aliases of function: symbols used by func are\n  // aliases and effects of result expression minus function\n  // and argument. no tracked var used means fun is untracked.\n  //\n  let used = new Set()\n  for (let k in newResInfo1.track)\n    newResInfo1.track[k].forEach(x => used.add(x))\n  for (let k in newResInfo1.effect)\n    newResInfo1.effect[k].forEach(x => used.add(x))\n  used.delete(ff); used.delete(xx); used.delete(\"*\")\n  used = [...used]\n  //if (used.length == 0) used = \"-\"\n  //\n  // create graph node\n  //\n  let ret = reflect0(ff, [\"Œª\", xx, yy, [deps,sdeps], localState], {\n    bound:[xx],\n    syms:[yy,...Object.values(deps).flat()],\n    trackStatus: 0,\n    alias:used,\n    tpe:newFunTpe\n  })\n  return ret\n}\n</code>\n<h3>Type Internals</h3>\n<p>Transitive Aliases / Latent Effects</p>\n<p>TODO: put here</p>\n<ul>\n<li>transitiveAliases, transitiveAliasesList, resolveLatentEffect, filterEffect</li>\n</ul>\n<p>Type Flatten / unflatten</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Type Internals\n// ------------------------------------------------------------\n//\n// We distinguish two form of type representations:\n//  - flat:   internal, normalized (see tpeFlatten)\n//  - unflat: externally visible (see tpeUnflatten)\n//\nfunction tpeFlatten(tpe) {\n  let res = { track: {}, effect: {} }\n  function iter(tpe) {\n    if (tpe instanceof Array) {\n      if (tpe[0] == \"track\") {\n        assert(tpe[2] instanceof Array)\n        if (!res.track.alias) res.track.alias = []\n        res.track.alias.push(...tpe[2])\n        return iter(tpe[1])\n      } else if (tpe[0] == \"fresh\") {\n        if (!res.track.status) res.track.status = []\n        if (!res.track.status.length) res.track.status.push(\"*\")\n        return iter(tpe[1])\n      } else if (tpe[0] == \"effect\") {\n        assert(tpe[3] instanceof Array)\n        let key = tpe[2]\n        if (!res.effect[key]) res.effect[key] = []\n        res.effect[key].push(...tpe[3])\n        return iter(tpe[1])\n      }\n    }\n    res.base = tpe\n  }\n  iter(tpe)\n  return res\n}\nfunction tpeUnflatten(tpe) {\n  assert(tpe.base, \"malformed type (base)\")\n  assert(tpe.track, \"malformed type (track)\")\n  assert(tpe.effect, \"malformed type (effect)\")\n  let res = tpe.base\n  if (tpe.track.status && tpe.track.status.length)\n    res = [\"fresh\",res] // XXX smart constructor?\n  if (tpe.track.alias)\n    res = track(res, ...tpe.track.alias)\n  for (let k in tpe.effect)\n    res = effect(res, k, ...tpe.effect[k])\n  return res\n}\nfunction tpeBaseType(tpe) {\n  if (tpe instanceof Array && (tpe[0] == \"track\" ||\n      tpe[0] == \"fresh\" || tpe[0] == \"effect\")) {\n    return tpeBaseType(tpe[1])\n  }\n  return tpe // untracked\n}\nfunction extractFunTypeFlat(ftp) {\n  let [tc_, atp, ff_, xx_, yy_] = ftp\n  assert(tc_ == \"=>\", \"not a function type: \"+ftp)\n  let atpFlat = tpeFlatten(atp)\n  let frtp = (f,b) => {\n    let rtp = subst(subst(yy_,xx_,b),ff_,f) //frtp(f,b)\n    let rtpFlat = tpeFlatten(rtp)\n    return rtpFlat\n  }\n  return [atpFlat, frtp]\n}\nfunction extractFunTypeUnflat(ftp) {\n  let [tc_, atp, ff_, xx_, yy_] = ftp\n  assert(tc_ == \"=>\", \"not a function type: \"+ftp)\n  let frtp = (f,b) => {\n    let rtp = subst(subst(yy_,xx_,b),ff_,f) //frtp(f,b)\n    return rtp\n  }\n  return [atp, frtp]\n}\nfunction extractRefTypeUnflat(rtp) {\n  let [tc_, etp] = rtp\n  assert(tc_ == \"Ref\", \"not a reference type: \"+rtp)\n  return etp\n}\nfunction extractRefTypeFlat(rtp) {\n  let [tc_, etp] = rtp\n  assert(tc_ == \"Ref\", \"not a reference type: \"+rtp)\n  return tpeFlatten(etp)\n}\n</code>\n<p>Substitution</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Substitution\n// ------------------------------------------------------------\nfunction subst(e,a,b) {\n  if (e instanceof Array) return e.map(g => subst(g,a,b))\n  if (e == a) return b\n  return e\n}\n</code>\n<p>Subtype Checking</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Subtype checks (some bits left as TODO)\n// ------------------------------------------------------------\nfunction symToTpeFlat(s) {\n  return {\n    base: symToTpe[s],\n    track: { alias: alias[s].length? alias[s] : undefined,\n             status: trackStatus[s] ? [\"*\"] : undefined },\n    effect: {} // syms represent values -- results do not have effects!\n               // currently we have no need (and no way) to recover the\n               // effects of individual nodes (fun does this at the block level)\n  }\n}\nfunction typeCheckFlat(e,tpe2) {\n  let tpe1 = symToTpeFlat(e)\n  return checkSubTypeFlat(tpe1,tpe2,{sym:e,isValue:true}) // TODO: mayWildcard?\n}\nfunction typeCheckBase(e,tpe2) {\n  let tpe1 = symToTpe[e]\n  return checkSubBase(tpe1,tpe2,{sym:e,isValue:true}) // TODO: mayWildcard?\n}\nfunction checkSubTypeFlat(tpe1, tpe2, extra) {\n  checkSubBase(tpe1.base, tpe2.base, extra)\n  // XXX: alias & effects is pretty generic right now. OK?\n  if (tpe2.base != \"?\") {\n    checkSubAnnotation(tpe1.track, tpe2.track, extra)\n    checkSubAnnotation(tpe1.effect, tpe2.effect, extra)\n  }\n}\nfunction checkSubBase(tpe1, tpe2, extra) {\n  if (tpe1 == tpe2) return\n  if (tpe2 == \"?\") return // type well formed?\n  if (tpe1 instanceof Array && tpe2 instanceof Array) {\n    if (tpe1[0] == \"=>\" && tpe2[0] == \"=>\") {\n      //let [atp1,frtp1] = extractFunTypeUnflat(tpe1)\n      //let [atp2,frtp2] = extractFunTypeUnflat(tpe2)\n      // ???\n      let [, atp1, ff1, xx1, rtp1] = tpe1\n      let [, atp2, ff2, xx2, rtp2] = tpe2\n      // XXX: We're dealing with bound names here.\n      // Right now we're substituting one for the other.\n      // We might need to do something more in line with\n      // DOT (temp environment during type comparison),\n      // especially for dealing with self types.\n      checkSubTypeUnflat(atp2,atp1,extra) // contravariant\n      checkSubTypeUnflat(rtp1,subst(subst(rtp2,xx2,xx1),ff2,ff1),extra) // OK?\n      return\n    } else if (tpe1[0] == \"Ref\" && tpe2[0] == \"Ref\") {\n      let [, atp1] = tpe1\n      let [, atp2] = tpe2\n      checkSubTypeUnflat(atp1,atp2,extra) // invariant\n      checkSubTypeUnflat(atp2,atp1,extra)\n      return\n    }\n  }\n  logError(extra.sym, \"type check failed: \"+tpe1+\" <: \"+tpe2)\n}\nfunction checkSubAnnotation(ls1, ls2, extra) {\n  function sub(k) {\n    return checkSubList(ls1[k],ls2[k],{...extra,key:k})\n  }\n  sub(\"alias\")\n  sub(\"status\")\n  sub(\"read\")\n  sub(\"write\")\n  sub(\"kill\")\n}\nfunction checkSubList(ls1,ls2, extra) {\n  if (!ls1) return true\n  //if (!ls2) return false\n  if (!ls2) {\n    let s1 = JSON.stringify(ls1)\n    logError(extra.sym, extra.key+\" qualifier check failed: \"+s1+\" <: none\")\n    console.log(new Error)\n    return\n  }\n  // TODO: good enough? can we use 'transitiveAliases'?\n  // (subtly different until we add extra env...)\n  function trans(xs) {\n    let res = new Set()\n    for (let x of xs) {\n     res.add(x)\n     if (alias[x] instanceof Array)\n       for (let a of alias[x]) res.add(a)\n    }\n    return res\n  }\n  // TODO:\n  // - may need to be more precise w.r.t aliasing on either side\n  // - right now we only check the global alias table: this works\n  //   when a function is passed as argument with an expected function\n  //   self type\n  // - probably need an environment of some sorts to track bindings\n  //   introduced as part of the comparison\n  let ala = trans(ls1)\n  let alb = trans(ls2)\n  let ok = true\n  for (let a of ala) {\n    if (!alb.has(a)) {\n      ok = false; break\n    }\n  }\n  //let s1 = JSON.stringify(ls1)\n  //let s2 = JSON.stringify(ls2)\n  //if (s1 == s2) return ls1\n  if (!ok) {\n    let s1 = JSON.stringify(ls1)\n    let s2 = JSON.stringify(ls2)\n    logError(extra.sym, extra.key+\" qualifier check failed: \"+s1+\" <: \"+s2)\n    console.log(new Error)\n  }\n}\nfunction symToTpeUnflat(s) {\n  return tpeFlatten(symToTpeFlat(s))\n}\nfunction typeCheckUnflat(e,tpe2) {\n  return typeCheckFlat(e,tpeFlatten(tpe2))\n}\nfunction checkSubTypeUnflat(tpe1,tpe2,extra) {\n  return checkSubTypeFlat(tpeFlatten(tpe1),tpeFlatten(tpe2),extra)\n}\n//\n// Check separation/permitted overlap: (a intersect b) subset c\n//\nfunction checkFunArgOverlap(fun,arg,maxOverlap,allowFresh) {\n  // XXX SOFT TRACK --- what should be the logic here?\n  if (!allowFresh) {\n    if (isTracked(arg))\n      logError(arg, \"expected an untracked value as arg to \"+prettySym(fun))\n    return\n  }\n  let ala = transitiveAliases(fun)\n  let alb = transitiveAliases(arg)\n  let max = new Set(maxOverlap)\n  for (let aa of ala) {\n    if (alb.has(aa) && !max.has(aa))\n      logError(arg, \"\"+prettySym(fun)+\" and \"+prettySym(arg)+\" overlap with \"+prettySym(aa))\n  }\n}\n//\n// XXX below are stubs -- only used for expected return types\n// in functions. should replace.\n//\nfunction typeCheck(e,tpe) {\n  if (symToTpe[e] != tpe && tpe != \"?\")\n    print(\"---- CHECK TYPE \"+e+\": \"+symToTpe[e]+\" <: \"+tpe)\n}\nfunction checkSubType(tpe1,tpe2) {\n  if (tpe1 != tpe2 && tpe2 != \"?\")\n    print(\"---- CHECK TYPE \"+tpe1+\" <: \"+tpe2)\n}\nfunction checkSubAlias(al1,al2,extra) {\n  if (al1 != al2 && al2 != \"?\")\n    print(\"---- CHECK ALIAS \"+al1+\" <: \"+al2)\n}\nfunction checkSubEffect(al1,al2,extra) {\n  checkSubAnnotation(al1, al2, extra) // XXX need sym\n  //if (al1 != al2 && al2 != \"?\")\n  //  print(\"---- CHECK EFFECT \"+al1+\" <: \"+al2)\n}\n</code>\n<p>Well-formedness and minEligible</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Close off function result type (by introducing self refs)\n// ------------------------------------------------------------\n//\n//  New design: goal oriented.\n//  Given bound variable x, remove references on\n//  **effectful** dependencies of x. These are\n//  eagerly computed and passes as arg 'neg'\n//\n//\nfunction minTypeEligibleInParentEnvFlat(tpe,extra,neg) {\n  // Close off a function result:\n  // (f(x:T1) -> T2^a)^a  -->  (f(x:T1) -> T2^f)\n  //\n  let topSelf\n  let topSelfAls\n  let topSelfFresh = false\n  function drop(als) {\n    let als1 = []\n    for (let e of als)\n      if (neg[e]) {\n         // ignore\n         als1.push(...drop(alias[e])) // go up!\n      } else\n        als1.push(e)\n    return als1\n  }\n  function check(als) {\n    let als1 = []\n    for (let e of als)\n      if (neg[e]) {\n        print(\"ERROR: alias not in env: \"+e)\n      } else\n        als1.push(e)\n    return als1\n  }\n  function replace(als) {\n    let als1 = []\n    for (let e of als)\n      if (neg[e]) {\n        if (topSelf && topSelfAls.indexOf(e) >= 0) {\n          als1.push(topSelf)\n          topSelfFresh = true // XXX depends on status of e?\n          // XXX TODO: alterative - do this on the outside\n          // when removing fresh c at the top level, add *\n        }\n        else\n          print(\"ERROR: alias not in env or self type: \"+e+\" (\"+topSelf+\"/\"+topSelfAls+\")\")\n      } else\n        als1.push(e)\n    return als1\n  }\n  function mapTpe(tpe,f) {\n    let res = { base: tpe.base, track:{}, effect:{}}\n    for (let k in tpe.track)\n      res.track[k] = f(tpe.track[k])\n    for (let k in tpe.effect)\n      res.effect[k] = f(tpe.effect[k])\n    return res\n  }\n  function maxEligible(tpe) {\n    let tpe1 = {...tpe}\n    if (tpe.base instanceof Array) {\n      if (tpe.base[0] == \"=>\") {\n        let [hd, atp, ff, xx, yy] = tpe.base\n        let atp1 = tpeUnflatten(minEligible(tpeFlatten(atp)))\n        let yy1 = tpeUnflatten(maxEligible(tpeFlatten(yy)))\n        tpe1.base = [hd,atp,ff,xx,yy1]\n      } else if (tpe.base[0] == \"Ref\") {\n        let [hd, atp] = tpe.base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        tpe1.base = [hd,atp1]\n      } else {\n        assert(false, \"minEligible: unkown type constructor '\"+tpe.base[0]+\"'\")\n      }\n    }\n    return mapTpe(tpe1,check) // drop? contravariant position\n  }\n  function minEligible(tpe,als,efs) {\n    let tpe1 = {...tpe}\n    if (tpe.base instanceof Array) {\n      if (tpe.base[0] == \"=>\") {\n        let [hd, atp, ff, xx, yy] = tpe.base\n        let atp1 = tpeUnflatten(maxEligible(tpeFlatten(atp)))\n        let yy1 = tpeUnflatten(minEligible(tpeFlatten(yy)))\n        tpe1.base = [hd,atp,ff,xx,yy1]\n      } else if (tpe.base[0] == \"Ref\") {\n        let [hd, atp] = tpe.base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        tpe1.base = [hd,atp1]\n      } else {\n        assert(false, \"minEligible: unkown type constructor '\"+tpe.base[0]+\"'\")\n      }\n    }\n    return mapTpe(tpe1,replace)\n  }\n  function strictEligible(tpe,als,efs) {\n    let tpe1 = {...tpe}\n    if (tpe.base instanceof Array) {\n      if (tpe.base[0] == \"=>\") {\n        let [hd, atp, ff, xx, yy] = tpe.base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        let yy1 = tpeUnflatten(strictEligible(tpeFlatten(yy)))\n        tpe1.base = [hd,atp,ff,xx,yy1]\n      } else if (tpe.base[0] == \"Ref\") {\n        let [hd, atp] = tpe.base\n        let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n        tpe1.base = [hd,atp1]\n      } else {\n        assert(false, \"minEligible: unkown type constructor '\"+tpe.base[0]+\"'\")\n      }\n    }\n    return mapTpe(tpe1,check)\n  }\n  // top level!\n  let tpe1 = tpe\n  if (tpe.base instanceof Array) {\n    if (tpe.base[0] == \"=>\") {\n      let [hd, atp, ff, xx, yy] = tpe.base\n      if (tpe.track.alias)\n        topSelf = ff; topSelfAls = tpe.track.alias\n      if (tpe.track.status)\n        topSelfFresh = tpe.track.status.length > 0\n      let atp1 = tpeUnflatten(maxEligible(tpeFlatten(atp)))\n      let yy1 = tpeUnflatten(minEligible(tpeFlatten(yy)))\n      tpe1.base = [hd,atp,ff,xx,yy1]\n      tpe1.track.status = topSelfFresh ? [\"*\"] : []\n    } else if (tpe.base[0] == \"Ref\") {\n      let [hd, atp] = tpe.base\n      let atp1 = tpeUnflatten(strictEligible(tpeFlatten(atp)))\n      tpe1.base = [hd,atp1]\n    } else {\n      assert(false, \"minEligible: unkown type constructor '\"+tpe.base[0]+\"'\")\n    }\n  }\n  return mapTpe(tpe1,drop)\n}\n</code>\n<p>Type API (move up?)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Type API\n// ------------------------------------------------------------\n/*\nexamples:\n- base types: \"Int\", (previously: \"Ref\")\n- unknown type (to-be-inferred): \"?\"\n- function types: funtype(arg, (f,x) => res)\n- mutable ref cells: reftype(etp)\n- annotated types: track(tpe, \"x\", \"y\"), effect(tpe, \"write\", x\", \"y\")\n*/\nfunction track(tpe, ...xs) { // soft tracked\n  // XXX remove symbols here that aren't tracked?\n  if (!xs.length) return tpe\n  return [\"track\", tpe, xs]\n}\nfunction trackf(tpe, ...xs) { // tracked and maybe fresh\n  return track([\"fresh\", tpe], ...xs)\n}\nfunction effect(tpe, key, ...xs) {\n  if (!xs.length) return tpe\n  return [\"effect\", tpe, key, xs]\n}\nfunction funtype(atp,f) {\n  let ff = fresh()\n  let xx = fresh()\n  nameHint[ff] = \"f\"\n  nameHint[xx] = \"a\"\n  let yy = f(ff,xx)\n  return [\"=>\", atp, ff, xx, yy]\n}\nfunction argtype(atp) {\n  // create a function type with a wildcard result\n  return funtype(atp, (f,x) => \"?\")\n}\nfunction reftype(etp) {\n  return [\"Ref\", etp]\n}\n</code>\n<h3>Traversal &#x26; basic codegen</h3>\n<p>Traversal / Codegen</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Traversal / codegen:\n// ------------------------------------------------------------\nlet path = new Set([])\nlet inner = [] // code\nfunction withScope(p,ns,b) {\n  let [path0, inner0] = [path, inner]\n  path = p; inner = ns\n  try { return b() } finally { path = path0; inner = inner0 }\n}\nfunction traverseBlock(inp, outp) {\n  let path1 = new Set([...inp,...path])\n  withScope(path1, inner, () => {\n    traverseBlock1(outp)})\n}\nfunction traverseBlock1(res) {\n  function available(c) {\n    let [_let, sym, rhs] = c\n    for (let b of boundDeps[sym])\n      if (!path.has(b))\n        return false\n    return true\n  }\n  // this version does not:\n  // - prune by reach(res)\n  // - treat soft deps softly\n  let outer1 = []\n  let inner1 = []\n  for (let c of inner) {\n    if (available(c))\n      outer1.push(c)\n    else\n      inner1.push(c)\n  }\n  withScope(path, inner1, () => {\n    traverseList(outer1, res)})\n}\n</code>\n<p>Core DOM Utils</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// core dom utils\n// ------------------------------------------------------------\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\nfunction dom(...es) {\n  return e(\"span\",{},...es)\n}\n</code>\n<p>Pretty printing / DOM interaction for graph view (XXX no longer used?)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Pretty printing / DOM interaction\n// ------------------------------------------------------------\nfunction prettySym(n) {\n  if (n in nameHint) return nameHint[n]+n\n  return \"x\"+n\n}\nfunction prettyTypeAtom(e) {\n  if (e instanceof Array)\n    return \"(\"+prettyType(e)+\")\"\n  return prettyType(e)\n}\nfunction prettyType(e) {\n  if (e instanceof Array) {\n    if (e[0] == \"fresh\")\n      return prettyTypeAtom(e[1])+\"^*\"\n    if (e[0] == \"track\")\n      return prettyTypeAtom(e[1])+\"^{\"+e[2].map(prettySym)+\"}\"\n    if (e[0] == \"effect\")\n      return prettyTypeAtom(e[1])+\"^^{\"+e[2].map(prettySym)+\"}\"\n    if (e[0] == \"=>\")\n      return prettySym(e[2])+\"(\"+prettySym(e[3])+\":\"+prettyType(e[1]) + \") => \" +\n        prettyType(e[4])\n  }\n  return String(e)\n}\nfunction prettyExpr(e) {\n  let [op, args] = e\n  if (!args.length) return op; else\n  return op+\"(\"+args.map(prettySym)+\")\"\n}\nfunction prettyAliases(es) { // XXX SOFT TRACK\n  if (es instanceof Array) return \"[\"+es.map(prettySym)+\"]\"\n  else return String(es)\n}\nfunction prettyDeps(es) {\n  return JSON.stringify(Object.values(es))\n    .replaceAll(\",\",\"\\n\").replaceAll('\"',\"\")\n    .replaceAll(\"write\",\"w\")\n    .replaceAll(\"read\",\"r\")\n  function prettySummary(e) {\n    if (typeof(e) == \"number\") return prettySym(e)\n    return \"{\"+Object.entries(e).map(([k,v]) =>(k[0]) + \": \" + prettyAliases(v))+\"}\"}  return \"{\"+Object.entries(es).map(([k,v]) => prettySym(k) + \": \" + prettySummary(v)).join(\"\\n\")+\"}\"\n}\nlet seq\nlet nest = 0\nlet symRefs = []\nfunction prettyNode(c) {\n  let [_let, sym, [op,...args], deps] = c\n  if (op == \"Œª\") {\n    let [arg,res,eff] = args\n    let pa = prettySym(arg)+\": \"+prettyType(symToTpe[arg])\n    emit(\"def \"+prettySym(sym)+\"(\"+pa+\") {\",prettyAliases(alias[arg]))\n    let save = seq\n    seq = []; ++nest\n    try { traverseBlock([arg,sym], [res]) }\n    catch (ex) { emit(ex) }\n    emit(\"return \" + prettySym(res), prettyAliases(alias[res]), prettyDeps(eff))\n    let r = e(\"div\", {}, ...seq)\n    //r.style[\"margin-left\"] = \"15px\"\n    seq = save; --nest\n    emit(r)\n    emit(\"} // \"+prettyType(symToTpe[sym]), prettyAliases(alias[sym]), prettyDeps(deps))\n  } else {\n    emit(\"let \"+prettySym(sym)+\" = \"+prettyExpr([op,args]), prettyAliases(alias[sym]), prettyDeps(deps))\n  }\n}\nlet currentHighlight\nfunction highlightSym(n) {\n  if (currentHighlight) {\n    for (let e of symRefs[currentHighlight]) {\n      if (errorLog[currentHighlight] && errorLog[currentHighlight].length)\n        e.style[\"background\"] = \"lightpink\"\n      else\n        e.style[\"background\"] = \"none\"\n    }\n  }\n  if (n && n != currentHighlight) {\n    for (let e of symRefs[n]||[]) {\n      e.style[\"background\"] = \"lightgreen\"\n    }\n    currentHighlight = n\n  } else\n    currentHighlight = undefined\n}\nfunction highlightSymError(n) {\n  if (n == currentHighlight) return\n  for (let e of symRefs[n]||[]) {\n    e.style[\"background\"] = \"lightpink\"\n  }\n}\nfunction registerSymRef(n,d,clickable) {\n  if (!symRefs[n])\n    symRefs[n] = []\n  symRefs[n].push(d)\n  if (errorLog[n] && errorLog[n].length)\n    d.style[\"background\"] = \"lightpink\"\n  if (clickable) {\n    d.style[\"cursor\"] = \"pointer\"\n    // d.addEventListener(\"click\", catchAll(e => {\n    //   highlightSym(n, true)\n    //   e.stopPropagation()\n    // }))\n  }\n  d.addEventListener(\"click\", catchAll(e => {\n    if (e.shiftKey) {\n      if (symToDef[n])\n        logInteractive(\"Clicked on \",n,\"=\",symToDef[n][2],\": \",symToTpe[n])\n      else\n        logInteractive(\"Clicked on \",n,\": \",symToTpe[n])\n    } else //if (clickable || e.ctrlKey)\n      highlightSym(n, true)\n    e.stopPropagation()\n  }))\n  if (d.src)\n    registerSymRef(n,d.src,clickable)\n}\nfunction catchAll(f) {\n  function g(e) {\n    try { return f(e) } catch(ex) { print(ex); throw ex }\n  }\n  return g\n}\nfunction prettyDomSym(n) {\n  let s = n in nameHint ? nameHint[n]+n : \"x\"+n\n  let d = dom(s)\n  registerSymRef(n,d,true)\n  d.style[\"color\"] = \"navy\"\n  // d.style[\"cursor\"] = \"pointer\"\n  // d.addEventListener(\"click\", catchAll(e => {\n  //   highlightSym(n, true)\n  // }))\n  return d\n}\nfunction prettyDomCommaList(es,f) {\n  if (!es.length) return dom()\n  let as = [f(es[0])]\n  for (let a of es.slice(1))\n    as.push(\",\",\" \",f(a))\n  return dom(...as)\n}\nfunction prettyDomExpr(e) {\n  let [op, args] = e\n  if (!args.length) return op\n  let as = [prettyDomSym(args[0])]\n  for (let a of args.slice(1))\n    as.push(\",\",\" \",prettyDomSym(a))\n  return dom(op,\"(\",...as,\")\")\n}\nfunction prettyDomTypeAtom(e) {\n  if (e instanceof Array)\n    return dom(\"(\",prettyDomType(e),\")\")\n  return prettyDomType(e)\n}\nfunction prettyDomType(e) {\n  // TODO: call prettyAlias/Effect methods?\n  if (e instanceof Array) {\n    if (e[0] == \"fresh\")\n      return dom(prettyDomTypeAtom(e[1]),\"^*\")\n    if (e[0] == \"track\")\n      return dom(prettyDomTypeAtom(e[1]),\"^{\",prettyDomCommaList(e[2],prettyDomSym),\"}\")\n    if (e[0] == \"effect\")\n      return dom(prettyDomTypeAtom(e[1]),\"^^\",e[2],\"{\",prettyDomCommaList(e[3],prettyDomSym),\"}\")\n    if (e[0] == \"=>\")\n      return dom(prettyDomSym(e[2]),\"(\",prettyDomSym(e[3]),\":\",prettyDomType(e[1]),\")\",\" \",\"=>\",\" \", prettyDomType(e[4]))\n  }\n  return String(e)\n}\nfunction prettyDomAliases(es,st) {\n  if (es instanceof Array) {\n    if (es.length) {\n      if (st) return dom(\"*\",\", \",prettyDomCommaList(es,prettyDomSym))\n      else    return dom(prettyDomCommaList(es,prettyDomSym))\n    } else return dom(st ? \"*\" : \"-\")\n  } else return String(st+\"|\"+es)\n}\nfunction prettyDomEffects(es) {\n  function prettySummary(es) {\n    let as = []\n    for (let k in es) {\n      as.push(prettyDomSym(k))\n      as.push(\":{\")\n      if (es[k].kill) {\n        as.push(\" \")\n        as.push(\"k:\")\n        as.push(prettyDomSym(es[k].kill))\n      }\n      if (es[k].init) {\n        as.push(\" \")\n        as.push(\"i:\")\n        as.push(prettyDomSym(es[k].init))\n      }\n      if (es[k].write) {\n        as.push(\" \")\n        as.push(\"w:\")\n        as.push(prettyDomSym(es[k].write))\n      }\n      if (es[k].reads.length) {\n        as.push(\" \")\n        as.push(\"r:\")\n        as.push(prettyDomCommaList(es[k].reads, prettyDomSym))\n      }\n      as.push(\" } \")\n    }\n    return dom(...as)\n  }\n  return dom(prettySummary(es))\n}\nfunction prettyDomDeps(es) {\n  function prettySummary(es) {\n    let as = []\n    for (let k in es) {\n      as.push(prettyDomSym(k))\n      as.push(\":[\")\n      as.push(prettyDomCommaList(es[k], prettyDomSym))\n      as.push(\"] \")\n    }\n    return dom(...as)\n  }\n  let [h,s] = es\n  return dom(\"hard: {\",prettySummary(h),\"} soft: {\",prettySummary(s),\"}\")\n}\nfunction emitLine(d) {\n  d.style[\"display\"] = \"block\"\n  d.style[\"border-radius\"] = \"10px\"\n  d.style[\"padding\"] = \"5px\"\n  d.style[\"padding-left\"] = \"10px\"\n  d.style[\"background-color\"] = \"#F2F2F2\"\n  d.style[\"font-weight\"] = \"bold\"\n  seq.push(d)\n}\nfunction emitIndent(d) {\n  d.style[\"display\"] = \"block\"\n  d.style[\"margin-left\"] = \"10px\"\n  seq.push(d)\n}\nfunction emitBox(box) {\n  box.style[\"display\"] = \"block\"\n  //box.style[\"padding\"] = \"5px\"\n  box.style[\"margin-left\"] = \"20px\"\n  box.style[\"font-size\"] = \"10px\"\n  seq.push(box)\n}\nfunction prettyDomNode(c) {\n  let [_let, sym, [op,...args], deps] = c\n  if (op == \"Œª\") {\n    let [arg,res,d,eff] = args\n    let pa = dom(prettyDomSym(arg),\": \",prettyDomType(symToTpe[arg]))\n    emitLine(dom(\"def \",prettyDomSym(sym),\"(\",pa,\") {\"))\n    let save = seq\n    seq = []; ++nest\n    emitBox(dom(\"arg \",prettyDomSym(arg),\":\"))\n    emitBox(dom(\"  aliases:\",\" \",prettyDomAliases(alias[arg],trackStatus[arg])))\n  for (let er of errorLog[arg]||[]) {\n    let d = e(\"div\",{},\"ERROR:  \",\" \",...er) // TODO: map prettyDomSym\n    d.style[\"background-color\"] = \"red\"\n    d.style[\"font-weight\"] = \"bold\"\n    emitBox(d)\n  }\n    try { traverseBlock([arg,sym], [res]) }\n    catch (ex) { emit(ex) }\n    emitLine(dom(\"return \",prettyDomSym(res)))\n    emitBox(dom(\"aliases: \",prettyDomAliases(alias[res],trackStatus[res])))\n    emitBox(dom(\"effects: \",prettyDomEffects(eff)))\n    emitBox(dom(\"deps:    \",prettyDomDeps(d)))\n    let r = e(\"span\", {}, ...seq)\n    //r.style[\"margin-left\"] = \"15px\"\n    seq = save; --nest\n    emitIndent(r)\n    emitLine(dom(\"}\"))\n  } else {\n    let line = e(\"div\", {}, \"let\",\" \",prettyDomSym(sym), \" \", \"=\", \" \", prettyDomExpr([op,args]))\n    emitLine(line)\n  }\n  let as = []\n  as.push(e(\"div\",{},\"type:   \",\" \",prettyDomType(symToTpe[sym])))\n  as.push(e(\"div\",{},\"aliases:\",\" \",prettyDomAliases(alias[sym],trackStatus[sym])))\n  as.push(e(\"div\",{},\"deps:   \",\" \",prettyDomDeps(deps)))\n  for (let er of errorLog[sym]||[]) {\n    let d = e(\"div\",{},\"ERROR:  \",\" \",...er) // TODO: map prettyDomSym\n    d.style[\"background-color\"] = \"red\"\n    d.style[\"font-weight\"] = \"bold\"\n    as.push(d)\n  }\n  let box = e(\"div\",{}, ...as)\n  emitBox(box)\n}\nfunction traverseList(nodes, res) {\n  for (let c of nodes) {\n    prettyDomNode(c)\n  }\n}\n</code>\n<p>Main Program (old - not used)</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction print(...es) {\n  o.appendChild(e(\"div\",{},...es))\n}\nfunction run(test) {\n  // may want to explicitly reset state\n  print(\"--- Staging:\")\n  let tpe = funtype(trackf(\"IO\"),(f,x) => effect(effect(effect(\"Int\",\"read\",x),\"write\",x),\"kill\",x))\n//  let tpe = funtype(trackf(\"IO\"),(f,x) => effect(\"Int\",\"write\",x))\n  let res = fun(tpe,test) // assume 1 tracked arg\n  print(\"--- Traversal / codegen:\")\n  seq = []\n  path = new Set([])\n  inner = code\n  traverseBlock1(res)\n  //emitLine(prettyDomSym(res))\n  //, prettyAliases(alias[res]), prettyDeps(state))\n  o.appendChild(e(\"pre\",{},...seq))\n}\n</code>\n</aside>\n<p>Examples / test cases:</p>\n<ul>\n<li><aside>\n<p>Basic println (pos)</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test2(f,stdout) {\n  let _0 = reflect(0)\n  let _1 = reflect(1)\n  let _2 = reflect(2)\n  println(stdout, _1)\n  println(stdout, _2)\n  return _0\n}\nrun(test2)\n</code>\n</aside></li>\n<li><aside>\n<p>Argument separation failure (neg)</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test1(f,store) {\n  let _1 = reflect(1)\n  let c1 = alloc(store)\n  let c2 = alloc(store)\n  inc(c1)\n  inc(c2)\n  let f1 = fun(argtype(trackf(reftype(\"Int\"))), (f1,c) => {\n    inc(c)\n    inc(c1)\n    return _1\n  })\n  app(f1,c1) // error\n  app(f1,c2) // ok\n  inc(c1) // dep on apps\n  inc(c2) // dep on apps\n  return _1\n}\nrun(test1)\n</code>\n</aside></li>\n<li><aside>\n<p>Escaping ref (neg)</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test3(f,store) {\n  let _0 = reflect(0)\n  let _1 = reflect(1)\n  let _2 = reflect(2)\n  let f1 = fun(argtype(\"Int\"), (f1,a) => {\n    let c1 = alloc(store)\n    return fun(argtype(\"Int\"), (f2,b) => {\n      return c1\n    })\n  })\n  let f2 = app(f1, _0)\n  let f3 = app(f1, _1)\n  let c3 = app(f2, _0)\n  let c4 = app(f2, _1)\n  inc(c3)\n  inc(c4)\n  return _0\n}\nrun(test3)\n</code>\n</aside></li>\n</ul>\n<p>Interaction: click ‚Äúcode>>‚Äù to show source, click on any identifier to highlight references.</p>\n<h3>Complete pipeline (with parser and codegen)</h3>\n<aside>\n<p>Implementation code</p>\n<p>Parser</p>\n<p>Core DOM and text editor</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// text selection utils\n//\nfunction findOffsetInParent(node, pos, top) {\n  if (node == top)\n    return pos;\n  while (node.previousSibling) {\n    node = node.previousSibling;\n    var len = node.nodeType == 3 ? node.length : node.innerText.length;\n    pos = len + pos;\n  }\n  return findOffsetInParent(node.parentNode, pos, top);\n}\nfunction findChildForOffset(node, pos) {\n  var len = node.nodeType == 3 ? node.length : node.innerText.length;\n  if (pos > len)\n    return findChildForOffset(node.nextSibling, pos - len);\n  if (node.firstChild)\n    return findChildForOffset(node.firstChild, pos);\n  return {node: node, pos: pos};\n}\n//\n// text editor\n//\nlet text\nfunction textmodel_get(start, end) {\n  return text.substring(start,end)\n}\nfunction textmodel_edit(start, end, data) {\n  text = text.substring(0, start) + data + text.substring(end, text.length)\n}\n// editor setup\nlet p = document.createElement(\"pre\")\nlet d = document.createElement(\"pre\")\nlet row = document.createElement(\"div\")\nrow.style[\"display\"] = \"flex\"\nrow.appendChild(p)\nrow.appendChild(d)\n//o.appendChild(row)\np.setAttribute(\"contenteditable\", true)\np.setAttribute(\"spellcheck\", false)\np.style[\"border\"] = \"1px solid grey\"\np.style[\"padding\"] = \"3px\"\n//p.style[\"width\"] = \"250px\"\np.style[\"min-height\"] = \"200px\"\np.style[\"outline\"] = \"none\"\np.style[\"overflow\"] = \"scroll\"\nd.style[\"border\"] = \"1px solid grey\"\nd.style[\"padding\"] = \"3px\"\n//d.style[\"width\"] = \"250px\"\n//d.style[\"height\"] = \"200px\"\nd.style[\"overflow\"] = \"scroll\"\np.addEventListener(\"beforeinput\", ev => {\n  ev.preventDefault()\n  let data = ev.data || ev.dataTransfer?.getData(\"text/plain\") || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  historyEditor_edit(start, end, data)\n})\nlet onEdit = () => p.innerText = text\nfunction editor_update() {\n  try {\n    onEdit()\n  } catch(ex) {\n    print(\"[Editor Callback] \"+ex)\n  }\n}\nfunction editor_edit(start, end, data) {\n  textmodel_edit(start, end, data)\n  editor_update()\n  select(start + data.length, start + data.length)\n}\nfunction select(start, end) {\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\n// history setup\nlet historymodel = {\n  edits: [],//[{ start: 0, end: 0, old: \"\", data: text }],\n  position: 0,\n}\np.addEventListener(\"keypress\", ev => {\n  //clear()\n  if (ev.key == \"z\" && ev.metaKey) {\n    if (!ev.shiftKey) prevEdit()\n    else nextEdit()\n    ev.preventDefault()\n  }\n  //print(ev)\n})\nfunction historyEditor_edit(start, end, data) {\n  recordEdit(start, end, data)\n  editor_edit(start, end, data)\n}\nfunction recordEdit(start, end, data) {\n  let old = textmodel_get(start, end)\n  //if (old == data) return // could check prefix/suffix ...\n  if (historymodel.position > 0) {\n    let e = historymodel.edits[historymodel.position-1]\n    // we only fuse pure inserts or deletes\n    // this could be extended to delete+insert\n//print(e.start+\" \"+e.data)\n    if (e.start == e.end && start == end && e.start + e.data.length == start) { // insert at enprint(e.start+\" \"+e.data)\n      e.data = e.data + data\n//print(e.start+\" \"+e.data)\n      return updateHistoryUI()\n    } else if (e.data.length == 0 && data.length == 0 && end == e.start) { // delete at beginning\n      e.start = start\n      e.old = old + e.old\n      return updateHistoryUI()\n    }\n  }\n  historymodel.edits = historymodel.edits.slice(0, historymodel.position++)\n  historymodel.edits.push({ start, end, old, data })\n  updateHistoryUI()\n}\nfunction rewindHistory() {\n  historymodel.position = 0\n  p.innerText = \"\"\n  updateHistoryUI()\n}\nfunction nextEdit() {\n  if (historymodel.position < historymodel.edits.length) {\n    let e = historymodel.edits[historymodel.position++]\n    editor_edit(e.start, e.end, e.data)\n    updateHistoryUI()\n  }\n}\nfunction prevEdit() {\n  if (historymodel.position > 0) {\n    let e = historymodel.edits[--historymodel.position]\n    editor_edit(e.start, e.start + e.data.length, e.old)\n    updateHistoryUI()\n  }\n}\nfunction updateHistoryUI() {\n  // not used\n}\n</code>\n<p>Parser</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// parser state & lexer\n//\nlet pos, peek\nlet gap, skippedNL, pastGap\nlet str\n//let seq\nfunction init(s) {\n  seq = []\n  input = s;\n  pos = 0;\n  whitespace()\n  read()\n}\nfunction processGap() {\n  if (!pastGap) {\n    if (gap.trim()) {\n      seq.push(dom1(\"comment\", \"\", gap))\n    } else {\n      seq.push(gap)\n    }\n    pastGap = true\n  }\n}\nfunction next() {\n  processGap()\n  if (peek != str)\n    seq.push(dom1(peek, \"\", str))\n  else\n    seq.push(str)\n  let c = peek;\n  whitespace()\n  read()\n  return c\n}\nfunction read() {\n  let isdigit = () => '0' <= input[pos] && input[pos] <= '9'\n  let isletter = () => 'a' <= input[pos] && input[pos] <= 'z' || 'A' <= input[pos] && input[pos] <= 'Z'\n  let isopr = () => input[pos] in {'+':1,'-':1,'*':1,'/':1,'%':1,'<':1,'>':1,'=':1,'!':1}\n  let start = pos\n  if (isdigit()) {\n    while (isdigit()) pos++\n    peek = \"num\"\n  } else if (isletter()) {\n    while (isletter() || isdigit()) pos++\n    peek = \"ident\"\n  } else if (isopr()) {\n    // special cases for function arrow sugar:\n    // =r>, =w>, =k>, =1> etc\n    // general shape: =...> (could permit -...>, ~...> etc)\n    let maybeArrow = input[pos] == \"=\"\n    while (isopr()) pos++\n    let opPrefixEnd = pos\n    if (maybeArrow) {\n      while (isopr() || isdigit() || isletter()) pos++\n      if (input[pos-1] != '>') // backtrack if no closing\n        pos = opPrefixEnd\n    }\n    peek = input.substring(start,pos)\n  } else if (input[pos] == '\"') {\n    pos += 1\n    while (input[pos] && input[pos] != '\"') pos++\n    if (input[pos]) pos++ // may be unterminated!\n    peek = \"str\"\n  } else {\n    peek = input[pos++]\n  }\n  str = input.substring(start,pos)\n}\nfunction whitespace() {\n  let start = pos\n  for (;;) {\n    if (input[pos] == '/' && input[pos+1] == '/') {\n      pos += 2\n      while (input[pos] && input[pos] != '\\n') ++pos\n    } else if (input[pos] == ' ') {\n      pos++\n    } else if (input[pos] == '\\n') {\n      pos++\n    } else {\n      break\n    }\n  }\n  gap = input.substring(start,pos)\n  pastGap = false\n}\n//\n// parser aux\n//\nfunction dom1(key, info, children) {\n  let d = e(\"span\",{key,info},...children)\n  if (key == \"error\") {\n    d.style[\"padding\"] = \"1px\"\n    d.style[\"background\"] = \"red\"\n  } else if (key == \"skip\") {\n    d.style[\"background\"] = \"lightpink\"\n  } else if (key == \"comment\") {\n    d.style[\"font-style\"] = \"italic\"\n    d.style[\"color\"] = \"grey\"\n  } else if (key == \"ident\") {\n    d.style[\"color\"] = \"navy\"\n  } else if (key == \"str\") {\n    d.style[\"color\"] = \"purple\"\n  } else {\n    d.style[\"color\"] = \"sienna\"\n  }\n  return d\n}\nfunction collectPT(k,f) {\n  processGap()\n  let save = seq\n  let res = []\n  seq = res\n  try { f() } finally {\n  seq = save\n  let d = dom1(k,\"\",res)\n  seq.push(d)\n  }\n  return res\n}\nfunction collectPT2(k,f) { // detached\n  //processGap() messes up order ...\n  let save = seq\n  let res = []\n  seq = res\n  try { f(); seq = save } catch (ex) {\n  seq = save\n  seq.push(dom1(k,\"\",res)) // can't swallow\n  throw ex\n  }\n  return dom1(k,\"\",res)\n}\n// XXX YYY XXX some pieces missing from dep version!\nfunction clickSrcRef(src) {\n  if (src instanceof Array) return src.map(clickSrcRef)\n  src.highlight = !src.highlight\n  if (src.highlight)\n    src.style[\"background\"] = \"lightgreen\"\n  else\n    src.style[\"background\"] = \"pink\"\n}\nfunction reportSrcInfo(src,msg) {\n  let el = dom(\"¬†\")\n  el.style[\"background\"] = \"pink\"\n  el.style[\"cursor\"] = \"pointer\"\n  el.addEventListener(\"click\", ev => {\n    clickSrcRef([el,src])\n  })\n  print(el,\" \",msg)\n}\nfunction error(msg) {\n  processGap()\n  print(\"Parse error: \"+msg)\n  // alternative logic:\n  // - call markError on skip node\n  seq.push(dom1(\"error\", msg, []))\n  collectPT(\"skip\", () => {\n    while (peek && peek != '\\n' && !(gap.includes('\\n')) &&\n           peek != '*' && peek != '+' && peek != '=>' &&\n           (!(nparens > 0 && peek == ')')) &&\n           (!(nbraces > 0 && peek == '}'))\n    ) {\n      next()\n    }\n  })\n  throw new Error(msg)\n}\nfunction expect(d,s) {\n  if (peek == d && (!s || str == s)) {\n    next()\n  } else {\n    try { error(d+\" expected\") }\n    catch (ex) {\n      if (peek == d && (!s || str == s)) next(); else throw ex\n    }\n  }\n}\n//\n// main parser logic\n//\nfunction split(d,f) {\n  collectPT(d, () => {\n    if (d == ';')\n      for (;;) {\n        let last = pos\n        try { f(); } catch (ex) {};\n        if (peek == d) next(); else if (pos > last && gap.includes('\\n')); else break\n      }\n    else\n      for (;;) {\n        try { f(); } catch (ex) {};\n        if (peek == d && !gap.includes('\\n')) next(); else break\n      }\n  })\n}\nlet nparens = 0\nfunction parens(f) {\n  collectPT('()', () => {\n    expect('(')\n    nparens++\n    if (peek != ')')\n      try { f() } catch(ex) {} // could rethrow if no match\n    expect(')')\n    nparens--\n  })\n}\nlet nbraces = 0\nfunction braces(f) { // could unify\n  collectPT('{}', () => {\n    expect('{')\n    nbraces++\n    if (peek != '}')\n      try { f() } catch(ex) {} // could rethrow if no match\n    expect('}')\n    nbraces--\n  })\n}\nfunction tight() {\n  if (peek == '{') {\n    braces(block)\n  } else if (peek == '(') {\n    parens(expr)\n  } else if (peek == \"num\" || peek == \"str\" || peek == \"ident\") {\n    let res = collectPT2(\"B\",() => next()) // detach and wait\n    while (peek == '(' && !gap.includes('\\n')) {\n      res = collectPT2(\"@@\",() => {\n        seq.push(res)\n        parens(() => split(',', expr))\n      })\n    }\n    seq.push(res)\n//    collectPT('@@', () => {\n//      next()\n//      while (peek == '(' && !gap.includes('\\n'))\n//        parens(() => split(',', expr))\n//    })\n  } else {\n    error(\"atom expected\")\n  }\n}\n// precedence: higher binds tighter\nlet prec = {\n  ':': 10,\n  //'=': 20,\n  '=>': 30,\n  '=r>': 30,\n  '=w>': 30,\n  '=k>': 30,\n  '@': 40,\n  '+': 50,\n  '-': 50,\n  '*': 60,\n  '/': 60\n}\n// associativity: 1 for left, 0 for right\nlet assoc = {\n  ':': 0,\n  //'=': 0,\n  '=>': 0,\n  '=r>': 0,\n  '=w>': 0,\n  '=k>': 0,\n  '@': 1,\n  '+': 1,\n  '-': 1,\n  '*': 1,\n  '/': 1\n}\nfunction binop(min) {\n  let res = collectPT2(\"B\",() => tight()) // detach and wait until op\n  while (peek in prec && prec[peek] >= min) {\n    let nextMin = prec[peek] + assoc[peek] // + 1 for left assoc\n    res = collectPT2(peek,() => {\n      seq.push(res)\n      next()\n      binop(nextMin)\n    })\n  }\n  seq.push(res)\n}\nfunction expr() {\n  binop(0)\n}\nfunction expr0() {\n  split(':', () => {\n  split('=k>', () => {\n  split('=w>', () => {\n  split('=r>', () => {\n  split('=>', () => {\n  split('@', () => {\n  split('+', () => {\n    split('*', () => {\n      if (peek == '{') {\n        braces(block)\n      } else if (peek == '(') {\n        parens(expr)\n      } else if (peek == \"num\" || peek == \"ident\") {\n        collectPT('@@', () => {\n          next()\n          while (peek == '(' && !gap.includes('\\n'))\n            parens(() => split(',', expr))\n        })\n      } else {\n        error(\"atom expected\")\n      }\n    })\n  })\n  })\n  })\n  })\n  })\n  })\n  })\n}\nfunction block() {\n  split(';', () => {\n    if (peek == \"ident\" && str == \"def\") {\n      collectPT(\"D\", () => {\n        expect(\"ident\", \"def\")\n        applyTokenStyle(\"keyword\")\n        expect(\"ident\")\n        applyTokenStyle(\"bound\")\n        parens(() => split(',', () => {\n          expect(\"ident\"); expect(\":\"); expr()\n        }))\n        // do not expect res types atm\n        //expect(\":\")\n        //expr()\n        expect(\"=\")\n        expr()\n      })\n    } else if (peek == \"ident\" && str == \"let\") {\n      collectPT(\"L\", () => {\n        expect(\"ident\", \"let\")\n        applyTokenStyle(\"keyword\")\n        //expect(\"ident\")\n        expr()\n        applyTokenStyle(\"bound\")\n        expect(\"=\")\n        expr()\n      })\n    } else if (peek && peek != '}') {\n      expr()\n    }\n  })\n}\n// more formatting\nfunction applyTokenStyle(key) {\n  let d = seq[seq.length-1]\n  if (key == \"keyword\")\n    d.style[\"color\"] = \"purple\"\n  else if (key == \"bound\")\n    d.style[\"color\"] = \"navy\"\n}\n//\n// string -> cst (concrete syntax tree: structured text as html dom)\n//\nfunction parse(text) {\n  try {\n    init(text)\n    block()\n    let max = 20\n    while (peek && max--) {\n      let last = pos\n      try { error(\"unexpected \"+peek,true) } catch(ex) {}\n      if (last == pos)\n        next()\n      block()\n    }\n    if (peek) error(\"unexpected \"+peek)\n    // Q: need to emit last gap?\n  } catch (ex) {}\n  if (pos-1 < text.length) {\n    seq.push(dom1(\"skipped\",\"\",[text.substring(pos-1,text.length)]))\n  } else if (!pastGap) seq.push(gap)\n  return dom1(\"P\",\"\",seq)\n}\n//\n// cst -> ast (abstract syntax tree: html dom formatted as tree)\n//\n// (trivial version, not used)\n//\nfunction walk(a) {\n  let ch = []\n  for (let c of a.children) ch.push(walk(c))\n  //if (a.key in {'+':0,'*':0,'‚èé':0,'=':0,'T':0} && ch.length == 1) return ch[0]\n  if (ch.length == 1) return ch[0]\n  let l = (a.key + \" \\\"\"+ (a.info||a.textContent) + \"\\\"\").substring(0,30).replaceAll(\"\\n\",\"‚èé\");\n  let d = e(\"div\", {}, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  return d\n}\n</code>\n<p>AST to IR converter</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// convert cst -> ast (throw away some empty grouping)\n//\nfunction convertCstToAst(a) {\n  if (a.key == \"comment\") return\n  let ch = []\n  for (let c of a.children) {\n    let c1 = convertCstToAst(c)\n    if (c1) ch.push(c1)\n  }\n  if (ch.length == 1 && a.key != ';' && a.key != ',') return ch[0]\n  let l = a.key\n  let info = \"\"\n  if (a.key == \"ident\" || a.key == \"num\") {\n    l += \" \\\"\"+ a.textContent + \"\\\"\"\n    info = a.textContent\n  } else if (a.info) { // e.g. errors!\n    l += \" \\\"\"+ a.info + \"\\\"\"\n    info = a.info\n  }\n  let d = e(\"div\", {key: a.key, info: info, src: a }, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  if (a.key == \"error\")\n    d.style[\"background-color\"] = \"red\"\n  if (a.key == \"skip\")\n    d.style[\"background-color\"] = \"lightpink\"\n  return d\n}\n//\n// convert ast -> graph IR via staging\n//\nlet env = {}\nfunction syntaxError(x,...es) {\n  let msg = es.join(\" \")\n  reportSrcInfo(x.src||x,\"Syntax error: \"+msg)\n  x.style[\"background\"] = \"red\"\n  x.setAttribute(\"title\", msg)\n  if (x.src) {\n    x.src.style[\"background\"] = \"lightpink\"\n    x.src.setAttribute(\"title\", msg)\n  }\n}\nfunction assertSyntax(c,x,...es) {\n  if (!c) {\n    syntaxError(x,...es)\n    throw new Error(\"syntax\") // catch and swallow later!\n  }\n}\nfunction walkExpr(expr) {\n  if (expr.key == \"num\") {\n    expr.sym = reflect(Number(expr.info))\n  } else if (expr.key == \"ident\") {\n    assertSyntax(expr.info in env, expr, \"ident not found: \"+expr.info)\n    expr.sym = env[expr.info]\n  } else if (expr.key == \"+\") { // TODO: -,*,/,%, ...\n    assertSyntax(expr.children.length == 2, expr, \"only binary + supported (for now)\")\n    for (let e of expr.children) {\n      walkExpr(e)\n    }\n    expr.sym = plus(...[...expr.children].map(e=>e.sym))\n  } else if (expr.key == \";\") {\n    walkBlock(expr)\n  } else if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"application needs exactly one argument\")\n    let [fun,args] = expr.children\n    // TODO: check n args?\n    // TODO: generalize, have a registry of built-ins?\n    if (fun.key == \"ident\" && fun.info == \"println\") {\n      expr.sym = println(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"alloc\") {\n      expr.sym = alloc(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"set\") {\n      expr.sym = set(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"get\") {\n      expr.sym = get(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"inc\") {\n      expr.sym = inc(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"free\") {\n      expr.sym = free(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"move\") {\n      expr.sym = move(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"swap\") {\n      expr.sym = swap(...[...args.children].map(walkExpr))\n    } else {\n      // TODO: check stuff?\n      assertSyntax(args.children.length <= 1, expr, \"application needs zero or one argument\")\n      walkExpr(fun)\n      //extract expected arg types from fun!! (currently only one!)\n      let [argTpe, frtp] = extractFunTypeUnflat(symToTpe[fun.sym])\n      if (args.children.length > 0) {\n        args.children[0].ept = argTpe\n        expr.sym = app(fun.sym, ...[...args.children].map(walkExpr))\n      } else {\n        expr.sym = app(fun.sym, reflect(\"()\")) // TODO: cse\n      }\n    }\n  } else if (expr.key == \"=>\") {\n    // see DEF case in walkStm for comparison\n    assertSyntax(expr.children.length == 2, expr, \"function literal needs a body\")\n    let ept = expr.ept || \"?\"\n    let [arg,body] = expr.children\n    let [fn,xn,atp0] = walkArgExpr(arg)\n    // TODO: relate given and expected types\n    if (ept == \"?\" && atp0 == \"?\") {\n      assertSyntax(false, xn, \"function literal needs expected type or provided argument type\")\n    }\n    // ignore expected type if arg type given (for now!)\n    let [atp, frtp] = atp0 != \"?\" ? [atp0, (f,x) => \"?\"] : extractFunTypeUnflat(tpeBaseType(ept))\n    expr.sym = fun(argtype(atp), (ff,xx) => {\n      let save = env\n      env = {...save}\n      if (fn != \"?\") {\n        env[fn.info] = ff\n        nameHint[ff] = fn.info\n        registerSymRef(ff,fn)\n      }\n      if (xn != \"?\") {\n        env[xn.info] = xx\n        nameHint[xx] = xn.info\n        registerSymRef(xx,xn)\n      }\n      body.ept = frtp(ff,xx)\n      let res = walkExpr(body)\n      env = save\n      return res\n    })\n  } else if (expr.key == \":\") {\n    let target = expr.children.length > 1 ? expr.children[0] : expr\n    assertSyntax(false, target, \"unexpected type ascription; argument lists require parentheses\")\n  } else {\n    assertSyntax(false, expr, \"unknown expr: \"+expr.key)\n  }\n  registerSymRef(expr.sym,expr)\n  if (expr.ept) {\n    //typeCheckUnflat(expr.sym, expr.ept) // XXX too rigid for fun args!\n    typeCheckBase(expr.sym, tpeFlatten(expr.ept).base)\n  }\n  return expr.sym\n}\n// e.g. f(x:Int)\n// return [f,[x,\"Int\"]]\nfunction walkArgExpr(expr) {\n  function walkArg(expr) {\n    if (expr.key == \"()\") {\n      // Future: support multiple args\n      assertSyntax(expr.children.length == 0, expr, \"need zero or one argument\")\n      return [\"?\",\"Unit\"]\n    } else if (expr.key == \":\") {\n      assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n      let [name,tpe] = expr.children\n      walkIdent(name)\n      return [name, walkTypeExpr(tpe)]\n    } else {\n      walkIdent(expr)\n      return [expr,\"?\"]\n    }\n  }\n  if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [fun,arg] = expr.children\n    walkIdent(fun)\n    assertSyntax(arg.key == \",\", arg, \"malformed argument list\")\n    assertSyntax(arg.children.length == 1, arg, \"expected exactly one function parameter\")\n    return [fun, ...walkArg(arg.children[0])]\n  } else {\n    return [\"?\", ...walkArg(expr)]\n  }\n}\nfunction walkArgTypeExpr(expr) {\n  // cases:\n  // - named fun & arg: f(x:Int)\n  // - named fun:       f(Int)\n  // - named arg:       x:Int\n  // - type only:       Int\n  // TODO: multiple args, without or without arg/fun name(s)\n  function walkArg(expr) {\n    if (expr.key == \":\") {\n      assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n      let [name,tpe] = expr.children\n      walkIdent(name)\n      return [name.info, walkTypeExpr(tpe)]\n    } else {\n      return [\"?\",walkTypeExpr(expr)]\n    }\n  }\n  if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [fun,arg] = expr.children\n    // TODO: support multiple parameters (via arg.key == \",\" ?)\n    walkIdent(fun)\n    assertSyntax(arg.key == \",\", arg, \"malformed argument list\")\n    assertSyntax(arg.children.length == 1, arg, \"expected exactly one function parameter\")\n    return [fun.info, ...walkArg(arg.children[0])]\n  } else\n    return [\"?\",...walkArg(expr)]\n}\nfunction walkTypeExpr(expr) {\n  function isArrowType(k) {\n    return k.startsWith(\"=\") && k.endsWith(\">\")\n  }\n  function getArrowQualifier(k) {\n    return k.slice(1,-1)\n  }\n  if (expr.key == \"ident\") {\n    return expr.info\n  } else if (expr.key == \"@\") {\n    let [base,...rest] = expr.children\n    let tpe = walkTypeExpr(base)\n    for (let e of rest)\n      tpe = walkTypeAnnot(tpe,e)\n    return tpe\n  } else if (expr.key == \"@@\") { // only Ref for now\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [fun,arg] = expr.children\n    walkIdent(fun)\n    assertSyntax(fun.info == \"Ref\", expr, \"unknown type constructor: \"+fun.info)\n    assertSyntax(arg.key == \",\", arg, \"malformed argument list\")\n    assertSyntax(arg.children.length == 1, arg, \"expected exactly one function parameter\")\n    return reftype(walkTypeExpr(arg.children[0]))\n  } else if (isArrowType(expr.key)) { // expr.key == \"=>\"\n    assertSyntax(expr.children.length == 2, expr, \"function type needs a result type\")\n    let qual = getArrowQualifier(expr.key)\n    let [arg,body] = expr.children\n    let [fn,xn,atp] = walkArgTypeExpr(arg)\n    let env1 = env\n    // sugar: Int =r> Int  =  (f(Int) => Int @read(f)) @track\n    function sugarRes(e,f) { // sugar: Int =r> Int  =  f(Int) => Int @read(f)\n      if (qual == \"r\") return effect(e, \"read\", f)\n      if (qual == \"w\") return effect(effect(e, \"read\", f), \"write\", f)\n      if (qual == \"k\") return effect(effect(effect(e, \"read\", f), \"write\", f), \"kill\", f)\n      assert(qual == \"\", expr, \"unknown arrow qualifier: \"+qual)\n      return e\n    }\n    function sugarFun(f) {\n      if (qual == \"\") return f\n      else return trackf(f)\n    }\n    return sugarFun(funtype(atp, (f,x) => {\n      let save = env\n      env = {...env1,[fn]:f,[xn]:x} // XXX do not add \"?\"\n      try { return sugarRes(walkTypeExpr(body),f) } finally {\n        env = save\n      }\n    }))\n  } else {\n    assertSyntax(false, expr, \"unknown type expr: \"+expr.key)\n  }\n}\nfunction walkTypeAnnot(base,expr) {\n  if (expr.key == \"ident\" && expr.info == \"track\") {\n    return trackf(base)\n  } else if (expr.key == \"@@\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let fun = expr.children[0]\n    let args = expr.children[1]\n    walkIdent(fun)\n    let args1 = walkIdentList(args)\n    if (fun.info == \"track\") {\n      return trackf(base, ...args1) // constructor adds \"fresh\"\n    } else if (fun.info == \"read\") {\n      return effect(base, \"read\", ...args1)\n    } else if (fun.info == \"write\") {\n      return effect(base, \"write\", ...args1)\n    } else if (fun.info == \"kill\") {\n      return effect(base, \"kill\", ...args1)\n    // shorthands...\n    } else if (fun.info == \"r\") {\n      return effect(base, \"read\", ...args1)\n    } else if (fun.info == \"w\") {\n      return effect(base, \"write\", ...args1)\n    } else if (fun.info == \"k\") {\n      return effect(base, \"kill\", ...args1)\n    } else if (fun.info == \"rw\") {\n      return effect(effect(base, \"read\", ...args1), \"write\", ...args1)\n    } else if (fun.info == \"wk\") {\n      return effect(effect(base, \"write\", ...args1), \"kill\", ...args1)\n    } else if (fun.info == \"rwk\") {\n      return effect(effect(effect(base, \"read\", ...args1), \"write\", ...args1), \"kill\", ...args1)\n    }\n  }\n  assertSyntax(false, expr, \"unknown type annotation\")\n  return base\n}\nfunction walkIdentList(es) {\n  assertSyntax(es.key == \",\", es, \"malformed argument list\")\n  let as = []\n  for (let a of es.children) {\n    walkIdent(a)\n    assertSyntax(a.info in env, a, \"ident not found: \"+a.info)\n    as.push(env[a.info])\n  }\n  return as\n}\nfunction walkParamList(params) {\n  if (params.key == \"()\") return [\"?\",\"Unit\"]\n  assertSyntax(params.key == \",\", params, \"malformed argument list\")\n  assertSyntax(params.children.length == 2, params, \"expected exactly one declared function parameter\")\n  //assertSyntax(params.children.length == 2, params, \"need exactly one argument\")\n  let [p,ptp] = params.children\n  walkIdent(p)\n  let ptp1 = walkTypeExpr(ptp)\n  return [p,ptp1]\n}\nfunction walkKeyword(k,s) {\n  assertSyntax(k.key == \"ident\" && k.info == s, k, \"expected '\"+s+\"'\")\n}\nfunction walkIdent(k) {\n  assertSyntax(k.key == \"ident\", k, \"expected identifier\")\n}\nfunction walkLhs(expr) {\n  if (expr.key == \"ident\") {\n    walkIdent(expr)\n    return [expr, \"?\"]\n  } else if (expr.key == \":\") {\n    assertSyntax(expr.children.length == 2, expr, \"need exactly one argument\")\n    let [name,tpe] = expr.children\n    walkIdent(name)\n    return [name, walkTypeExpr(tpe)]\n  } else {\n    assertSyntax(false, expr, \"malformed lhs\")\n  }\n}\nfunction walkStm(stm) {\n  if (stm.key == \"D\") {\n    //print(\"DEF\");\n    assertSyntax(stm.children.length == 4, stm, \"malformed def statement\")\n    let [kw, name, params, /*rtp, */body] = stm.children\n    walkKeyword(kw, \"def\")\n    let save = env\n    env = {...save}\n    walkIdent(name)\n    let [xn,ptp1] = walkParamList(params)\n    //let rtp1 = walkTypeExpr(rtp) // TODO: used?\n    let ftp = argtype(ptp1)\n    stm.sym = fun(ftp, (ff,xx) => {\n      env[name.info] = ff\n      nameHint[ff] = name.info\n      //registerSymRef(ff,name)\n      if (xn != \"?\") {\n        env[xn.info] = xx\n        nameHint[xx] = xn.info\n        registerSymRef(xx,xn)\n      }\n      walkExpr(body)\n      env = save\n      return body.sym\n    })\n    env[name.info] = stm.sym\n    nameHint[stm.sym] = name.info\n    registerSymRef(stm.sym,name)\n } else if (stm.key == \"L\") {\n    //print(\"LET\")\n    assertSyntax(stm.children.length == 3, stm, \"malformed let statement\")\n    let [kw, lhs, rhs] = stm.children\n    walkKeyword(kw, \"let\")\n    let [name,tpe] = walkLhs(lhs)\n    rhs.ept = tpe // expected type!!\n    walkExpr(rhs)\n    stm.sym = rhs.sym // needed?\n    env[name.info] = rhs.sym\n    nameHint[rhs.sym] = name.info\n    registerSymRef(rhs.sym,name)\n  } else {\n    walkExpr(stm)\n  }\n}\nfunction walkBlock(block) {\n  // if there were errors, we have have multiple\n  // top level blocks. treat them as one, skipping\n  // parse errors\n  if (block.key == \"P\" && block.children[0]) {\n    for (let s of block.children) {\n      if (s.key == \";\") walkBlock(s)\n    }\n    return\n  }\n  assertSyntax(block.key == \";\", block, \"malformed block statement \"+block.key)\n  for (let s of block.children) {\n    try { walkStm(s) } catch (ex) {\n      if (ex.message != \"syntax\") {\n        print(\"AST to IR \"+ex)\n      }\n      // mark s as having been skipped\n      s.style[\"background\"] = \"lightpink\"\n      //if (s.src) s.src.style[\"background\"] = \"lightpink\"\n    }\n  }\n  let len = block.children.length\n  if (len)\n    block.sym = block.children[len-1].sym\n  if (!block.sym)\n    block.sym = reflect(\"()\")\n}\nfunction walk(a) {\n  let stms = convertCstToAst(a)\n  try { walkBlock(stms) } catch (ex) { print(\"AST to IR \"+ex) }\n  return stms\n}\n</code>\n<p>Compact codegen</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// NOTE: shouldInline itself isn't tight enough\n// to prevent reordering of effectful exprs that also\n// return a value (e.g. var reads).\n//   let c = alloc(1)\n//   let r = get(c)\n//   set(c,2)\n//   println(r) // can't inline r here!\n//              // but could if set/println reordered\n// That's why there's an additional pass to fix it up.\n//\n//let path = new Set([])\n//let inner = code // []\nlet shouldInline\nlet needSymbol\n//function withScope(p,ns,b) {\n//  let [path0, inner0] = [path, inner]\n//  path = p; inner = ns\n//  try { return b() } finally { path = path0; inner = inner0 }\n//}\nfunction symsRec(c) {\n  if (typeof(c) === \"number\") return [c]\n  return Object.values(c).map(symsRec).flat()\n}\nfunction syms(c) {\n  let [_, sym, [op,...args], [hdeps,sdeps]] = c\n  return {v: symsRec(args), h: symsRec(hdeps), s: symsRec(sdeps)}\n}\nfunction symsFreq(c) {\n  let [_, sym, [op,...args], deps] = c\n  if (op == \"Œª\") {\n    let [xx, yy, [hdeps,sdeps], eff] = args\n    return {v: [[yy,100.0]],\n            h: symsRec(hdeps).map(x => [x,100.00]),\n            s: symsRec(sdeps).map(x => [x,100.00])}\n    // XXX ignoring stm deps -- ok???\n  } else if (op == \"?\") {\n    // TODO/FIXME!\n    let [c,xa,[a,yan],xb,[b,ybn]] = args\n    return [[yan,0.5], [ybn,0.5]]\n  } else {\n    let {v,h,s} = syms(c)\n    return {v: v.map(x => [x,1.0]),\n            h: h.map(x => [x,1.0]),\n            s: s.map(x => [x,1.0])}\n  }\n}\nfunction traverseBlockCompact(inp, outp) {\n  let path1 = new Set([...inp,...path])\n  withScope(path1, inner, () => {\n    traverseBlockCompact1(outp)})\n}\nfunction traverseBlockCompact1(res) {\n  function available(c) {\n    let [_let, sym, rhs] = c\n    for (let b of boundDeps[sym])\n      if (!path.has(b))\n        return false\n    return true\n  }\n  // todo: prune harder by reach(res)\n  // todo: soft/hard\n  let reach = new Set()\n  let reachCold = new Set()\n  let df = [] // local definitions\n  let hmo = [] // how many times used outer (as proper val)\n  let hmi = [] // how many times used inner (as proper val)\n  for (let s of res)\n    reach.add(s)\n  hmo[res[0]] = 1 // only first is used as proper val\n  let outer1 = []\n  let inner1 = []\n  inner.reverse()\n  for (let c of inner) {\n    if (reach.has(c[1])) {\n      let sfs = symsFreq(c)\n      if (available(c)) {\n      // XXX careful with successor computation:\n      // XXX we're going bottom up!\n        outer1.push(c)\n        df[c[1]] = c\n        for (let [s,f] of sfs.v) { // value deps\n          if (f > 0.5) reach.add(s)\n          else reachCold.add(s)\n          if (f == 1.0) hmo[s] = (hmo[s]||0)+1 // direct syms, no blocks!\n          else hmi[s] = (hmi[s]||0)+1\n        }\n        for (let [s,f] of sfs.h) { // hard effect deps\n          if (f > 0.5) reach.add(s)\n          else reachCold.add(s)\n        }\n        // soft effect deps: do nothing\n      } else {\n        inner1.push(c)\n        for (let [s,f] of sfs.v) { // value deps\n          reach.add(s)\n          hmi[s] = (hmi[s]||0)+1\n        }\n        for (let [s,f] of sfs.h) { // hard effect deps\n          reach.add(s)\n        }\n      }\n    } else {\n      // XXX it may be cold-only reachable, but\n      // XXX what if not reachable at all?\n      // XXX can we prune more, based on 'reach'??\n      //\n      // YYY ---> doing that now using reachCold!\n      //\n      if (reachCold.has(c[1])) {\n        inner1.push(c)\n        let sfs = symsFreq(c)\n        for (let [s,f] of sfs.v) {\n          reachCold.add(s)\n          hmi[s] = (hmi[s]||0)+1\n        }\n        for (let [s,f] of sfs.h) { // hard effect deps\n          reachCold.add(s)\n        }\n      }\n    }\n  }\n  inner.reverse()\n  outer1.reverse()\n  inner1.reverse()\n  let save = {shouldInline,needSymbol}\n  shouldInline = (s) => {\n    // must not have errors (want to print them)\n    if (errorLog[s] && errorLog[s].length > 0)\n      return null\n    // defined as an atom\n    if (symToDef[s] && (typeof(symToDef[s][2][0]) === \"number\" || symToDef[s][2][0]==\"()\"))\n      return symToDef[s]\n    // locally defined, locally used (as value) exactly once,\n    // not used in nested scopes\n    if (df[s] && hmo[s] == 1 && !hmi[s])\n      return df[s]\n  }\n  needSymbol = (s) => {\n    return hmi[s] || hmo[s] // used as value\n  }\n  // --- Check dependencies for inlined expressions ---\n  // Additional traversals to figure out which exprs\n  // can be safely inlined wrt successor dependencies.\n  //\n  // TODO: can this be optimized? (fewer traversals)\n  // TODO: some tweaks/checks will likely be necessary:\n  //       - do we deal with effect deps correctly?\n  //       - especially, what about soft deps?\n  //\n  // 1. compute local successors (fwd)\n  succ = {}\n  for (let c of outer1) {\n      let sfs = symsFreq(c)\n      let ss = [...sfs.v,...sfs.h,...sfs.s]\n      succ[c[1]] = []\n      for (let [s,f] of ss) {\n        if (df[s]) succ[s].push(c[1])\n      }\n  }\n  // 2. check if all successors are emitted after the point\n  //    considered for inlining, if not disable inlining\n  //    for this node (bwd)\n  outer1.reverse()\n  let seen = {}\n  function processNodeHere(c) {\n    seen[c[1]] = true\n    let sfs = symsFreq(c)\n    let ss = [...sfs.v].reverse() // bwd\n    for (let [s,f] of ss) {\n      if (f == 1.0) // direct\n        checkInline(s)\n    }\n  }\n  function checkInline(s) {\n    let c = shouldInline(s)\n    if (c) {\n      // Note: all local defs have succ[s] defined,\n      // but we also inline global constants. These\n      // don't have effects, so we don't need succs.\n      for (let s1 of succ[s]||[]) {\n        if (!seen[s1]) {// a successor hasn't been seen:\n          delete df[s] // disable inlining (somewhat crude)\n          return\n        }\n      }\n      processNodeHere(c)\n    }\n  }\n  //res.forEach(checkInline)\n  checkInline(res[0]) // only value result, not effects!\n  for (let c of outer1) {\n    if (!shouldInline(c[1]))\n      processNodeHere(c)\n  }\n  outer1.reverse()\n  // 3. actual codegen (fwd)\n  withScope(path, inner1, () => {\n    traverseListCompact(outer1, res)})\n  shouldInline = save.shouldInline\n  needSymbol = save.needSymbol\n}\nlet buf = []\nfunction collectOT(f) {\n  let save = buf\n  buf = []\n  nest++\n  f()\n  nest--\n  let res = buf\n  buf = save\n  return res\n}\nfunction dom2(tag, ...children) {\n  let toDom = x => x instanceof Node ? x : document.createTextNode(String(x))\n  let d = document.createElement(tag)\n  for (let e of children)\n    d.appendChild(toDom(e))\n  return d\n}\nfunction emit(s) {\n  let toDom = x => x instanceof Node ? x : document.createTextNode(String(x))\n  buf.push(toDom(s))\n}\nfunction formatNode(...e) {\n  let d = dom2(\"div\", ...e)\n  return d\n}\nfunction newline(indent) {\n  return \"\\n\"+\"\".padStart(2*(indent-1), \" \")\n}\nfunction emitLine1(...e) {\n   if (buf.length > 0) emit(newline(nest))\n   emit(dom2(\"span\",...e))\n}\nfunction formatBlockCompact(f,topLevel) {\n  let d = collectOT(f)\n  if (d.length > 1) {\n    d = topLevel ? dom2(\"span\", ...d) : dom2(\"span\", newline(nest+1), ...d, newline(nest)) // no indent on top level\n    // d.style[\"border\"] = \"1px solid lightgrey\"\n    // d.style[\"padding-left\"] = \"10px\"\n    // d.style[\"padding-right\"] = \"10px\"\n    return d\n  } else return d[0]\n}\nfunction formatSym(n) {\n  let s = n in nameHint ? nameHint[n] : \"x\"\n  let superscript = dom(n)\n  // superscript.style[\"color\"] = \"grey\"\n  superscript.style[\"vertical-align\"] = \"super\"\n  superscript.style[\"font-size\"] = \"50%\"\n  let d = dom(s,superscript)\n  d.style[\"color\"] = \"navy\"\n  registerSymRef(n,d,true)\n  return d\n}\nfunction walkSym(e) {\n  let de = shouldInline(e)\n  if (de)\n    return walkExpr2(de)\n  else\n    return formatSym(e)\n}\nfunction formatCommaList(es,f) {\n  return prettyDomCommaList(es, f)\n}\nfunction walkExpr2(c) {\n    let [_let, sym, rhs] = c\n    let [op,...args] = rhs\n    let d = []\n    if (op == \"Œª\") {\n      let [arg,res,[hdeps,sdeps],eff] = args\n      let body = formatBlockCompact(() => {\n        // emit any errors attached to argument\n        if (errorLog[arg] && errorLog[arg].length > 0) {\n          let aux = []\n          aux.push(\"// error: \")\n          for (let er of errorLog[arg]) {\n            if (aux.length > 1) aux.push(\"; \")\n            aux.push(dom(...er))\n          }\n          emitLine1(...aux)\n        }\n        return traverseBlockCompact([arg,sym], symsRec([res,hdeps]))\n      })\n      let fn = flags.targetSugar ? dom2(\"span\") : formatSym(sym) // do not show fun name when requesting sugared output...\n      let xn = formatSym(arg)\n      d = dom2(\"span\", fn, \"(\", xn,\")\",\" \", \"=> {\",\n      body, \"}\")\n    } else if (op == \"@\") {\n      d = dom2(\"span\", walkSym(args[0]), \"(\", formatCommaList(args.slice(1),walkSym), \")\")\n    } else if (op == \"?\") {// TODO\n      let [c,xa,ya,xb,yb] = args\n      let thenp = formatBlockCompact(() => { traverseBlockCompact([xa], [ya]) })\n      let elsep = formatBlockCompact(() => { traverseBlockCompact([xb], [yb]) })\n      d = dom2(\"span\", \"if\", \" (\", walkSym(c), \") {\", thenp, \"} else {\", elsep, \"}\")\n    } else if (args.length) {\n      d = dom2(\"span\", op, \"(\", formatCommaList(args,walkSym), \")\")\n    } else\n      d = dom2(\"span\", op)\n    //d.style[\"display\"] = \"inline-block\"\n    //d.style[\"border\"] = \"1px solid lightgrey\"\n    //d.style[\"padding\"] = \"1px\"\n    registerSymRef(sym,d,true)\n    return d\n}\nfunction prettyNodeCompact(c) {\n  let [_let, x, rhs] = c\n  // TODO: special case for functions?\n  let aux = []\n  if (errorLog[x] && errorLog[x].length > 0) {\n    aux.push(\" // error: \")\n    for (let er of errorLog[x]) {\n      if (aux.length > 1) aux.push(\"; \")\n      aux.push(dom(...er))\n    }\n  }\n  if (needSymbol(x)) {\n    let kw = dom(\"let\")\n    kw.style[\"color\"] = \"purple\"\n    emitLine1(kw,\" \",formatSym(x),\" \",\"=\",\" \",walkExpr2(c),...aux)\n  }\n  else\n    emitLine1(walkExpr2(c),...aux)\n}\nfunction traverseListCompact(nodes, res) {\n  for (let c of nodes) {\n    let [_let, sym, [op,...args]] = c\n    if (shouldInline(sym)) continue\n    prettyNodeCompact(c)\n  }\n  emitLine1(walkSym(res[0])) // 0 is value, rest is eff\n}\n//o.appendChild(formatBlock(() => {\n//traverseBlock1([res[1]])\n//}))\n;\n</code>\n<p>Main function and augmented editor config</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\no.appendChild(row) // basic editor (p)\nlet oo = e(\"div\",{})\no.appendChild(oo)\nfunction panel(str,d,open) {\n  let sum = e(\"summary\",{},str)\n  sum.style[\"outline\"] = \"none\"\n  let det = e(\"details\",{},sum,d)\n  det.open = open\n  oo.appendChild(det)\n}\nfunction print(...es) {\n  oo.appendChild(e(\"div\",{},...es))\n}\nfunction run(src,dst) {\n  p.style.width = \"100%\"\n  d.style.width = \"100%\"\n  onEdit = () => {\n    // reset state\n    reset()\n    // reset output\n    p.innerText = \"\"\n    d.innerText = \"\"\n    oo.innerText = \"\"\n    // parse\n    let cst = parse(text)\n    let ast = walk(cst)\n    p.appendChild(cst)\n    d.appendChild(ast)\n    if (asides[\"AST\"]) {\n      let as = asides[\"AST\"]\n      as.innerText = \"\"\n      as.appendChild(d)\n    } else {\n      panel(\"AST\", d)\n    }\n    res = env[\"main\"]\n    if (!res) {\n      print(\"Error: no main function found\")\n      return\n    }\n    //print(\"--- Traversal / codegen:\")\n    seq = []\n    path = new Set([])\n    inner = code\n    traverseBlock1(res)\n    //emitLine(prettyDomSym(res))\n    //, prettyAliases(alias[res]), prettyDeps(state))\n    if (asides[\"Graph IR\"]) {\n      let as = asides[\"Graph IR\"]\n      as.innerText = \"\"\n      as.appendChild(e(\"pre\",{},...seq))\n    } else {\n      panel(\"Graph IR\", e(\"pre\",{},...seq))\n    }\n    //print(\"--- Compact Traversal / codegen:\")\n    seq = []\n    path = new Set([])\n    inner = code\n    let out = formatBlockCompact(() => {\n      traverseBlockCompact1([res])\n    }, true)\n    let q = e(\"pre\",{},out)\n    q.style[\"border\"] = \"1px solid grey\"\n    q.style[\"padding\"] = \"3px\"\n    panel(\"Target Code\", q, true)\n    if (dst) {\n      // some visual feedback options: ‚úÖüö´‚ùåüü¢üî¥üü©üü•\n      if (out.textContent.trim() != dst.trim()) {\n        panel(\"üî¥ Test FAILED\",e(\"pre\", {},\n          \"// ACTUAL:\\n\", out.textContent.trim(), \"\\n\",\n          \"// EXPECTED:\\n\", dst.trim()), true)\n      } else {\n        print(\"üü¢ Test passed\")\n      }\n    }\n  }\n  text = src\n  onEdit()\n}\n</code>\n</aside>\n<p>Examples / test cases:</p>\n<ul>\n<li><aside>\n<p>Basic println</p>\n<p>Effect dependencies ensure that side-effecting statements\nare not accidentally removed from the graph or reordered, even though\ntheir result values may never be used (and hence, there is no\ndependency on their result).</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(stdout: IO @track) = {\n  println(stdout,1)\n  println(stdout,2)\n  0\n}\n`,`main2(stdout3) => {\n  print(stdout3, 1)\n  print(stdout3, 2)\n  0\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Basic dce 1</p>\n<p>Pieces of mutable state that are never <em>actually</em> used, i.e.,\nthat do not contribute to any actual value computation are\nremoved.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  let d = alloc(store) // dce\n  get(d) // dce\n  get(c)\n}\n`,`main2(store3) => {get(alloc(store3, 0))}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Basic dce 2</p>\n<p>Pieces of mutable state that are never <em>actually</em> used, i.e.,\nthat do not contribute to any actual value computation are\nremoved.</p>\n<p>This holds even for stateful variables that are modified.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  set(c, 0) // dce\n  get(c)    // dce\n  set(c, 1)\n  get(c)    // dce\n  get(c)\n}\n`,`main2(store3) => {\n  let c5 = alloc(store3, 0)\n  set(c5, 1)\n  get(c5)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Escaping ref</p>\n<p>When a function creates a mutable variable that escapes\n(directly or indirectly via another function), the identity\nof that variable is tracked, even though it does not have\nany externally visible identifier.</p>\n<p>The mechanism to achieve this is by logically subsuming\nthe escaping variable into the function via which it\nescapes, and tracking the identity of that function\nwith a self-type (just like in DOT).</p>\n<p>(See the Graph IR pane below for detailed type assignments)</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def f(a: Int) = {\n    let c = alloc(store)\n    def g(b: Int) = c\n    g\n  }\n  let h0 = f(0)\n  let h1 = f(1)\n  let c0 = h0(0)\n  let c1 = h0(1) // same as c0\n  let c3 = h1(0)\n  let c4 = h1(1) // same as c3\n  inc(c0)\n  inc(c1)\n  inc(c3)\n  inc(c4)\n  get(c0)\n  // expected result:\n  // - ops on c0 and c1 are serialized\n  // - c3 and c4 are never read and hence\n  //   dce'd along with all their ops\n}\n`,`main2(store3) => {\n  let h014 = f6(a7) => {\n    let c9 = alloc(store3, 0)\n    g12(b13) => {c9}\n  }(0)\n  let c017 = h014(0)\n  inc(c017)\n  inc(h014(1))\n  get(c017)\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Compact codegen soft deps</p>\n<p>Soft dependencies are honored when inlining an expression.\nWithout further checks, the first read <code class=\"language-text\">r</code> would be inlined as the\nblock result, incorrectly moving it after the <code class=\"language-text\">inc(c)</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  let r = get(c) // may not move after inc\n  inc(c)\n  println(store, get(c))\n  r // tempting to inline r here\n}\n`,`main2(store3) => {\n  let c5 = alloc(store3, 0)\n  let r6 = get(c5)\n  inc(c5)\n  print(store3, get(c5))\n  r6\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Kill effects 1</p>\n<p>Effects can be flow-sensitive, implementing a form of typestate tracking.\nA simple but important use case are ‚Äúconsume‚Äù or ‚Äúkill‚Äù effects that\nmake a value unusable.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  inc(c)\n  println(store, get(c))\n  free(c)\n  get(c) // error\n}\n`,`main2(store3) => {\n  let c5 = alloc(store3, 0)\n  inc(c5)\n  print(store3, get(c5))\n  free(c5)\n  let x10 = get(c5) // error: can't read dead object: c5\n  x10\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Kill effects 2</p>\n<p>Effects can be flow-sensitive, implementing a form of typestate tracking.\nA simple but important use case are ‚Äúconsume‚Äù or ‚Äúkill‚Äù effects that\nmake a value unusable.</p>\n<p>Of course this also works for user-defined functions, not just primitives.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def myfree(c: Ref(Int) @track) = {\n    free(c)\n  }\n  let c = alloc(store)\n  inc(c)\n  println(store, get(c))\n  myfree(c)\n  get(c) // error\n}\n`,`let myfree6 = myfree6(c7) => {free(c7)}\nmain2(store3) => {\n  let c10 = alloc(store3, 0)\n  inc(c10)\n  print(store3, get(c10))\n  myfree6(c10)\n  let x15 = get(c10) // error: can't read dead object: c10\n  x15\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Higher order, traversal with effect polymorphism 1</p>\n<p>We support lightweight bounded effect polymorphism\nfor higher order functions using a special <code class=\"language-text\">@call</code>\neffect that is resolved at the call site of the\nhigher order function to the latent effect of\nits argument.</p>\n<p>TODO:</p>\n<ul>\n<li><del>use latent function effect in app</del></li>\n<li><del>subtype checking for self types (via aliasing)</del></li>\n<li><del>record effects explicitly in reflect0</del></li>\n<li><del>track and resolve latent self effect</del></li>\n<li>parse <code class=\"language-text\">@call</code> qualifier</li>\n</ul>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  // rwk is an abbreviation for read, write, kill\n  // result type: Int @call(f)\n  def gen(f: (f(x:Int) => Int @rwk(f)) @track) = {\n    f(1)\n  }\n  def g(x: Int) = {\n    println(store, x)\n    x\n  }\n  let res = gen(g) // effect: @call(g), doesn't really kill g or store!\n  println(store,1)\n}\n`,`let gen8 = gen8(f9) => {f9(1)}\nmain2(store3) => {\n  gen8(g14(x15) => {\n    print(store3, x15)\n    x15\n  })\n  print(store3, 1)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Higher-order, traversal with read/write 2</p>\n<p>Does not rely on effect polymorphism</p>\n<p>TODO/FIXME:</p>\n<ul>\n<li><del>parse function type and type check</del></li>\n<li><del>parse lambda expr and type check bidirectionally with expected type</del></li>\n<li><del>parse and check effect annotations</del></li>\n<li><del>close type and do self type comparison</del></li>\n</ul>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def gen(f: (f(Int) => Int @rw(f)) @track) = {\n    f(1) + f(2)\n  }\n  def g(x: Int) = {\n     println(store, x)\n     x // could do 2*x\n  }\n  let res = gen(g)\n  println(store,res)\n}\n`,`let gen8 = gen8(f9) => {+(f9(1), f9(2))}\nmain2(store3) => {print(store3, gen8(g17(x18) => {\n    print(store3, x18)\n    x18\n  }))}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Higher-order, traversal with kill 1</p>\n<p>Motivation: delimited one-shot continuation</p>\n<p>Negative case 1</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(Int) => Int @rw(f)) @track) = {\n    f(1) + f(2)\n  }\n  def g(x: Int) = {\n     println(store, x)\n     free(c)\n     x\n  }\n  println(store,gen(g)) // error: type mismatch of g\n}\n`,`let gen10 = gen10(f11) => {+(f11(1), f11(2))}\nmain2(store3) => {\n  let c5 = alloc(store3, 0)\n  let g19 = g19(x20) => {\n    print(store3, x20)\n    free(c5)\n    x20\n  } // error: kill qualifier check failed: [5] <: none\n  print(store3, gen10(g19))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Higher-order, traversal with kill 2</p>\n<p>Motivation: delimited one-shot continuation</p>\n<p>Negative case 2</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(x:Int) => Int @rwk(f)) @track) = {\n    f(1) + f(2)  // error: f already killed\n  }\n  def g(x: Int) = {\n     println(store, x)\n     free(c)\n     x\n  }\n  println(store,gen(g))\n}\n`,`let gen10 = gen10(f11) => {\n  let x13 = f11(1)\n  let x15 = f11(2) // error: can't read dead object: f11; can't write dead object: f11\n  +(x13, x15)\n}\nmain2(store3) => {\n  let c5 = alloc(store3, 0)\n  print(store3, gen10(g19(x20) => {\n    print(store3, x20)\n    free(c5)\n    x20\n  }))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Higher-order, traversal with kill 3</p>\n<p>Motivation: delimited one-shot continuation</p>\n<p>Positive case. Relies on effect polymorphism (really?).</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(x:Int) => Int @rwk(f)) @track) = {\n    f(1)\n  }\n  def g(x: Int) = {\n    println(store, x)\n    free(c)\n    x\n  }\n  println(store,gen(g))\n}\n`,`let gen10 = gen10(f11) => {f11(1)}\nmain2(store3) => {\n  let c5 = alloc(store3, 0)\n  print(store3, gen10(g16(x17) => {\n    print(store3, x17)\n    free(c5)\n    x17\n  }))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Effect deps of escaping lambda</p>\n<p>This is a variant of the counter example that initializes\ncounters to a given value.</p>\n<p><del>There is a bug right now that drops the initial write\nwhen returning a lambda.</del></p>\n<p>Fixed now. The root cause was that effect deps weren‚Äôt\ncounted for escaping values ‚Äî only for outer values\n(function itself, argument, anything from enclosing scope).\nSee second test case.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def counter(i: Int) = {\n    let c = alloc(world)\n    set(c,i) // <--- error: shouldn't remove this\n    () => inc(c)\n  }\n  let inc1 = counter(0)\n  let inc2 = counter(10)\n  inc1()\n  inc1()\n  inc2()\n  inc2()\n  // uncomment the following lines one by one\n  // and watch the target code change:\n  inc2()\n  // inc1()\n  // inc1() + inc2()\n  // 0\n}\n`,`main2(world3) => {\n  let inc218 = counter6(i7) => {\n    let c9 = alloc(world3, 0)\n    set(c9, i7)\n    fun13(arg14) => {inc(c9)}\n  }(10)\n  inc218(())\n  inc218(())\n  inc218(())\n}\n`)\n</code>\n<p>Second, minimized, test case:</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  set(c,2) // <--- error: shouldn't remove this\n  c\n}\n`,`\nmain2(world3) => {\n  let c5 = alloc(world3, 0)\n  set(c5, 2)\n  c5\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Overlapping function args</p>\n<p>Test permitted vs illegal overlap</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c1 = alloc(world)\n  let c2 = alloc(world)\n  let c3 = alloc(world)\n  def foo(c: Ref(Int) @track(c1)) = {\n    inc(c1)\n    inc(c2)\n    inc(c)\n  }\n  foo(c1) // ok: permitted overlap\n  foo(c2) // error: illegal overlap\n  foo(c3) // ok: no overlap\n}\n`,`main2(world3) => {\n  let c15 = alloc(world3, 0)\n  let c26 = alloc(world3, 0) // error: foo10 and c26 overlap with c26\n  let foo10 = foo10(c11) => {\n    inc(c15)\n    inc(c26)\n    inc(c11)\n  }\n  foo10(c15)\n  foo10(c26)\n  foo10(alloc(world3, 0))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Nested mutable state</p>\n<p>Test nested mutable state with ‚Äúmove‚Äù and ‚Äúswap‚Äù.</p>\n<p>Explicit move operation: if the arg is tracked, kill all\ncurrent aliases, and return the arg as fresh, non-aliased,\nbut tracked value.</p>\n<p>Swap operation: swap the value of a ref cell, returning the\nold value as fresh, non-aliased, but tracked value.</p>\n<p><strong>Case 1:</strong> swap: combined get/set for nested ref cells (tracked elem type)</p>\n<p>Note: ‚Äúget‚Äù together with ‚Äúswap‚Äù is unsound! (but ‚Äúget‚Äù can still be\nused for untracked elem types). Initial arg to ‚Äúalloc‚Äù also has to be moved.</p>\n<p>Note: explicit ‚Äúmove‚Äù isn‚Äôt always enough in our graph IR, because even the result of ‚Äúmove‚Äù gets bound to a variable (so there‚Äôs no such thing as ‚Äúnot bound at all‚Äù).</p>\n<p>Therefore, ‚Äúswap‚Äù has move semantics baked in.</p>\n<p>Question: should alloc always move, too? This depends on how far we want to support standard get/set.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c1 = alloc(world)\n  let c2 = alloc(world)\n  let nc = alloc(world,move(c1)) // nested!\n  let c1a = swap(nc,c2)\n  inc(c1a)\n  let c2a = swap(nc,c1a)\n  inc(c2a)\n  let c1b = swap(nc,c2a)\n  inc(c1b)\n  let c2b = swap(nc,alloc(world)) // replace with sth else\n  inc(c2b)\n  get(c1) // error\n  get(c2) // error\n  get(c1a) // error\n  get(c2a) // error\n  let r1 = get(c1b)\n  let r2 = get(c2b)\n  println(world,r1+r2)\n}`,`main2(world3) => {\n  let nc8 = alloc(world3, move(alloc(world3, 0)))\n  let c1b13 = swap(nc8, swap(nc8, swap(nc8, alloc(world3, 0))))\n  inc(c1b13)\n  let c2b16 = swap(nc8, alloc(world3, 0))\n  inc(c2b16)\n  print(world3, +(get(c1b13), get(c2b16)))\n}\n`)\n</code>\n<p><strong>Case 2:</strong> nested refs with get/set</p>\n<p>Note: ‚Äúset‚Äù is hampered by the inability to do an explicit ‚Äúmove‚Äù. Should we bake move semantics directly into ‚Äúset‚Äù? There‚Äôs a bit of a question how: we wouldn‚Äôt want to kill a value that‚Äôs covered as part of the allowed overlap.</p>\n<p>We elide an explicit test for now.</p>\n<!--\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\n// source program\ndef main(world: IO @track) = {\n  let c1 = alloc(world)\n  let c2 = alloc(world)\n  let nc = alloc(world,c1) // nested!\n  set(nc,c1) // ok, no-op\n  set(nc,c2) // error\n  set(nc,move(c2)) // ok, explicit move\n  let r1 = get(c1)\n  //let r2 = get(c2) // error: killed by move\n  let r3 = get(get(nc))\n  println(world,r1+r3)\n}`,`TODO\n`)\n</code> -->\n</aside></li>\n<li><aside>\n<p>Data structure encoding I - boxes</p>\n<p>Test lambda encodings of data structures (the lack of generics make it a bit cumbersome ‚Ä¶)</p>\n<p><strong>Case 1:</strong> one-element box</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def box(a: Ref(Int) @track) = {\n    def visit(f: (x:Ref(Int) @track) => Ref(Int) @track(x)) = {\n       f(a)\n    }\n    visit\n  }\n  let c = alloc(world)\n  let b = box(c)\n  let d = b(a => a) // aliased with c\n  free(c)\n  1 + get(d) // error: can't read dead object c\n}`,`let box6 = box6(a7) => {visit12(f13) => {f13(a7)}}\nlet fun20 = fun20(a21) => {a21}\nmain2(world3) => {\n  let c16 = alloc(world3, 0)\n  free(c16)\n  let x25 = get(box6(c16)(fun20)) // error: can't read dead object: c16\n  +(1, x25)\n}`)\n</code>\n<p><strong>Case 2:</strong> box that escapes from a function</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def box(a: Ref(Int) @track) = {\n    def visit(f: (x:Ref(Int) @track) => Ref(Int) @track(x)) = {\n       f(a)\n    }\n    visit\n  }\n  def test() = {\n    let c = alloc(world)\n    box(c)\n  }\n  let b = test()\n  let c = b(a => a) // aliased with b\n  let d = b(a => a) // aliased with b,c\n  free(c) // not original but still useful to try\n  1 + get(d) // error: can't read dead object b\n}\n`,`\nlet box6 = box6(a7) => {visit12(f13) => {f13(a7)}}\nlet fun26 = fun26(a27) => {a27}\nlet fun31 = fun31(a32) => {a32}\nmain2(world3) => {\n  let b23 = test17(arg18) => {box6(alloc(world3, 0))}(())\n  free(b23(fun26))\n  let x36 = get(b23(fun31)) // error: can't read dead object: b23\n  +(1, x36)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Data structure encoding II - tuples</p>\n<p>Test lambda encodings of data structures (the lack of generics make it a bit cumbersome ‚Ä¶)</p>\n<p>How precise is it? Can we kill one element and still access the other? No. We take the typings as given. Function f may track {c,d}, which maps to {a,b} and hence {u,v}. (Making it more precise would require function applications in track sets).</p>\n<p><strong>Case 1:</strong> two-element pair</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let Pair = (a: Ref(Int) @track)\n          => (b: Ref(Int) @track)\n          => (f: (c: Ref(Int) @track)\n             => ((d: Ref(Int) @track)\n             => Ref(Int) @track(c,d))\n             @track(c))\n          => f(a)(b)\n  let u = alloc(world)\n  let v = alloc(world)\n  let p = Pair(u)(v)\n  let up = p(x => y => x)\n  let vp = p(x => y => y)\n  free(u)\n  1 + get(vp) // error: dead object\n}\n`,`let Pair6 = Pair6(a7) => {fun10(b11) => {fun18(f19) => {f19(a7)(b11)}}}\nlet fun42 = fun42(y43) => {y43}\nlet fun38 = fun38(x39) => {fun42}\nmain2(world3) => {\n  let u23 = alloc(world3, 0)\n  free(u23)\n  let x47 = get(Pair6(u23)(alloc(world3, 0))(fun38)) // error: can't read dead object: u23\n  +(1, x47)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>MinEligible stress test I - returning dead objects</p>\n<p>New cases from Guannan. These are related to ‚ÄúCapturing/returning dead variables‚Äù.</p>\n<p><del>The prototype seems to have a soundness issue for related examples</del> fixed by rephrasing minEligible to blacklist removed symbols, rather than whitelist via inclusion in the parent env.</p>\n<p><strong>Case 1:</strong></p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  def f() = {\n    def g() = c\n    g\n  }\n  free(c)\n  let h = f()\n  get(h()) + 1 // error: reading from c which has been free'd\n}\n`,`main2(world3) => {\n  let c5 = alloc(world3, 0)\n  let g12 = g12(arg13) => {c5}\n  free(c5)\n  let x18 = get(f8(arg9) => {g12}(())(())) // error: can't read dead object: c5\n  +(x18, 1)\n}\n`)\n</code>\n<p><strong>Case 2:</strong></p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  def f() = {\n    def g() = c\n    free(c)\n    g\n  }\n  let h = f()\n  get(h()) + 1 // error: reading from c which has been free'd\n}\n`,`main2(world3) => {\n  let c5 = alloc(world3, 0)\n  let g12 = g12(arg13) => {c5} // error: cannot return dead object: c5\n  let x18 = get(f8(arg9) => {\n    free(c5)\n    g12\n  }(())(())) // error: can't read dead object: c5\n  +(x18, 1)\n}\n`)\n</code>\n<p>Both of them should not be allowed <del>but the prototype seems to be okay with them</del>.</p>\n</aside></li>\n<li><aside>\n<p>MinEligible stress test II - pair encoding</p>\n<p><del>TODO: fix impl: need access to parent scopes in fun/minEligible.</del></p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\n    def main(world: IO @track) = {\n      let nest1 = (x: Ref(Int)@track) => () => x\n      let nest2 = (x: Ref(Int)@track) => () => () => x\n      let c = alloc(world)\n      let c1 = nest1(c)()\n      let c2 = nest2(c)()()\n      inc(c)\n      get(c2) // was losing inc statement! (c1 instead worked)\n    }\n`,`let nest214 = nest214(x15) => {\n  let fun22 = fun22(arg23) => {x15}\n  fun18(arg19) => {fun22}\n}\nmain2(world3) => {\n  let c25 = alloc(world3, 0)\n  inc(c25)\n  get(nest214(c25)(())(()))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Reachability Polymorphism</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def assertpure(a: Int) = a\n  def context(it: Int => Int @track) = { // produce tracked ints\n    def id(x: Int @track) = x  // type id16(x17:Int^*) => Int^{x17}\n    let a = id(2)      // untracked\n    let b = id(it(3))  // tracked\n    assertpure(a) + assertpure(b) // error: b is tracked\n  }\n  context(x => x)\n}\n`,`let assertpure6 = assertpure6(a7) => {a7}\nlet id16 = id16(x17) => {x17}\nlet x23 = assertpure6(id16(2))\nlet x30 = context12(it13) => {\n  let b22 = id16(it13(3)) // error: expected an untracked value as arg to assertpure6\n  +(x23, assertpure6(b22))\n}(fun28(x29) => {x29})\nmain2(world3) => {x30}\n`)\n</code>\n</ul>\n<p>Limitations / noteworthy behavior:</p>\n<ul>\n<li><aside>\n<p>DCE of free - need new ideas for deallocation?</p>\n<p>Operator free is subject to DCE like other nodes, based on\nsoft dependencies, and since there‚Äôs no good reason to\ndepend on the <em>result</em> of a free it can be expected that\n<em>most</em> frees will be DCE‚Äôd in practice.</p>\n<p>This is consistent, but may look undesirable! Is there a\nway to keep the free (or any kill op) if it‚Äôs determined\nthat the alloc needs to stay?</p>\n<p>In general this seems tough, unless we start thinking about\nmust-kill effects (we had those in early LMS versions) and demand\nthat everything that‚Äôs allocated\nis also deallocated.</p>\n<p>But more generally it seems we may want think about deallocation\ndifferently. We know when a tracked symbol goes out of scope:\nwhen it‚Äôs not aliased by the enclosing block‚Äôs return type. So\nat this point we could deallocate it automatically.</p>\n<p>Of course we might still want to deallocate it earlier using\nan explicit free. In that case we‚Äôre still out of luck without\nfurther refinements.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  let res = get(c)\n  free(c)\n  res\n}\n`,`main2(world3) => {get(alloc(world3, 0))}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>No DCE for effects in inner scopes - the case for soft effects?</p>\n<p>We‚Äôve seen above that <em>most</em> uses of free will be DCE‚Äôd,\nsince its unlikely one would depend on the result of free.</p>\n<p>However, the free (or any other effect, really)\nisn‚Äôt removed when it‚Äôs inside another function.</p>\n<p>This definitely looks like a missed optimization opportunity!</p>\n<p>We should investigate a notion of soft effects. Similar to\nsoft dependencies, these would be dropped if the affected\nobject is not required elsewhere.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  let myfree = () => { free(c); 7 } // c never used: how to dce?\n  myfree()\n}\n`,`main2(world3) => {\n  let c5 = alloc(world3, 0)\n  myfree8(arg9) => {\n    free(c5)\n    7\n  }(())\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Capturing/returning dead variables - how to preserve typestate?</p>\n<p>Let‚Äôs reflect on how we track liveness - which things have\nbeen killed and which have not.</p>\n<p>Right now, we identify a dead variable by looking at prior effectful\nstatements in the current scope and checking if any of them had a kill\neffect that touched the variable in question.</p>\n<p>In other words, we do not track the liveness state of variables in\ntheir types. We only track kill effects in the types of computations.</p>\n<p>This raises a couple of questions. Importantly, what happens with\nindirect references to killed variables when:</p>\n<ul>\n<li>returning a killed variable</li>\n<li>closing over a killed variable</li>\n<li>(passing a killed variable as argument)</li>\n</ul>\n<p>We consider a number of cases below that all work out in the right\nway (in the return case, after tightening the rules).</p>\n<p>Questions:</p>\n<ul>\n<li>Are there other situations that may cause problems?\n<ul>\n<li>Specifically, related to closing over a dead var?</li>\n</ul>\n</li>\n<li>Potential alternative: track ‚Äúis dead‚Äù (and potentially ‚Äúis killable‚Äù) as part of the type. This would track status of return values and closures explicitly.\n<ul>\n<li>What are the tradeoffs?</li>\n</ul>\n</li>\n</ul>\n<p><strong>Case 1: returning dead variable (checked now)</strong></p>\n<p>This actually lead to escaping dead values, but was easy to fix.</p>\n<p>We now prevent returning anything that aliases a dead value from functions.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def f() = {\n    let c = alloc(world)\n    free(c)\n    c\n  }\n  let dead = f()\n  get(dead) // should be an error!\n}\n`,`main2(world3) => {get(f6(arg7) => {\n    let c9 = alloc(world3, 0) // error: cannot return dead object: c9\n    free(c9)\n    c9\n  }(()))}\n`)\n</code>\n<p><strong>Case 2: passing dead variable as argument (checked)</strong></p>\n<p>Effect on arg becomes part of the function type => error when calling it.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  free(c)\n  def f(c: Ref(Int) @track) = {\n    get(c)\n  }\n  f(c)\n}\n`,`let f9 = f9(c10) => {get(c10)}\nmain2(world3) => {\n  let c5 = alloc(world3, 0)\n  free(c5)\n  let x12 = f9(c5) // error: can't read dead object: c5\n  x12\n}\n`)\n</code>\n<p><strong>Case 3: closing over dead variable (checked)</strong></p>\n<p>Effect on free var becomes part of the function type => error when calling it.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  free(c)\n  def f() = {\n    get(c)\n  }\n  f()\n}\n`,`main2(world3) => {\n  let c5 = alloc(world3, 0)\n  free(c5)\n  let x13 = f9(arg10) => {get(c5)}(()) // error: can't read dead object: c5\n  x13\n}\n`)\n</code>\n<p><strong>Case 4: return fun that closes over dead var (checked now)</strong></p>\n<p>This is similar to case 1, but with an added level of indirection\nthrough a closure.</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  def g() = {\n    let c = alloc(world)\n    free(c)\n    def f() = {\n      get(c)\n    }\n  }\n  let f = g()\n  f()\n}\n`,`main2(world3) => {g6(arg7) => {\n    let c9 = alloc(world3, 0)\n    free(c9)\n    let f13 = f13(arg14) => {get(c9)} // error: cannot return dead object: c9\n    f13\n  }(())(())}\n`)\n</code>\n</aside></li>\n</ul>\n<p>Currently failing / to be done</p>\n<ul>\n<li> None currently</li>\n<li> Look at: https://github.com/YuyanBao/DependencyTracking/issues/12 </li>\n<li> Songlin's test case (code motion with soft dependencies) </li>\n</ul>\n<p>Infrastructure tests:</p>\n<ul>\n<li><aside>\n<p>Parser/typer errors</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\n(d: Int) => 2\ndef main(world: IO @track) = { ((d: Int) => d) }\ndef main(world: IO @track) = { (d: Int) => d }\ndef main(world: IO @track) = { (x:Int => 9) }\ndef main(world: IO @track) = { x:Int => 9 }\ndef main(world: IO @track) = (x:Int => 9)\ndef main(world: IO @track) = x:Int => 9\ndef main(world: IO @track) = x => 9\ndef main(world: IO @track) = x:Int => x\ndef main(world: IO @track) = x => x\ndef main(world: IO @track) = ((d: Int) => d)\ndef main(world: IO @track) = ((d: Int) => 9)\ndef main(world: IO @track) = (d) => d\ndef main(world: IO @track) = (d) => 9\ndef main(world: IO @track) = () => 9\ndef main(world: IO @track) = (d: Int) => 2\n`,`let fun89 = fun89(d90) => {2}\nmain85(world86) => {fun89}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Parse error</p>\n<p><del>Deleting the closing brace below will cause the two comments to be duplicated at the bottom:</del> fixed</p>\n<p>Do note that the syntax highlighting of the trailing comment is off!</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\ndef main(world: IO @track) = {\n  0\n  // long and tedious comment 1\n  // long and tedious comment 2\n}\n// try deleting the closing brace above\n`,`main2(world3) => {0}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Extended parser / type checker</p>\n<p>Note how clicking symbols in the IR highlights program fragments in both the source and target code.</p>\n<p><del>We may want to resolve associativity earlier in the parser and re-nest the concrete syntax tree for better syntax highlighting (TODO?)</del> done</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Int => Int = g(x) => h(y) => x+y\n`,`main6(x7) => {h10(y11) => {+(x7, y11)}}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Expected type failure</p>\n<p>TODO:</p>\n<ul>\n<li><del>invisible output in test 2</del></li>\n<li>double error in test 1\n<ul>\n<li>checkSub: currently reporting innermost comparison on error - show outermost instead?</li>\n</ul>\n</li>\n<li>fix internal checks (base,alias,effect) (12/10 done?)</li>\n<li>fix substitution for function type  (12/10 done?)</li>\n</ul>\n<h3>Test 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Int => Unit = g(x) => h(y) => x+y\n`,`let main6 = main6(x7) => {\n  let h10 = h10(y11) => {\n    let x12 = +(x7, y11) // error: type check failed: Int <: Unit\n    x12\n  } // error: type check failed: Int <: Unit\n  h10\n} // error: type check failed: Int <: Unit\nmain6\n`)\n</code>\n<h3>Test 2</h3>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Unit => Int = g(x) => h(y) => x+y\n`,`main6(x7) => {h10(y11) => {\n    // error: type check failed: Unit <: Int\n    +(x7, y11)\n  }}\n`)\n</code>\n<h3>Test 3</h3>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Unit => Int = g(x) => h(y:Int) => x+y\n`,`let main6 = main6(x7) => {\n  let h10 = h10(y11) => {+(x7, y11)} // error: type check failed: Unit <: Int\n  h10\n} // error: type check failed: Unit <: Int\nmain6\n`)\n</code>\n</aside></li>\n</ul>\n<p>Progress tracking</p>\n<aside>\n<p>Limitations, features, todo, ‚Ä¶</p>\n<p>Tests:</p>\n<ul>\n<li><del>test compact codegen sequencing</del></li>\n<li><del>test kill effects (‚Äúfree‚Äù)</del></li>\n<li><del>test effect polymorphism</del></li>\n<li><del>pair encoding: minEligible across two levels is wrong (need access to parent scopes)</del></li>\n<li>new effect recording method: what happens if a local value aliases an outer one and is modified. Do we drop the effect when exiting the scope? (Would be wrong!)</li>\n</ul>\n<p>Fixes:</p>\n<ul>\n<li><del>make alloc a read effect on store</del></li>\n<li><del>track read effects in types</del></li>\n<li><del>impl &#x26; test proper soft deps dce</del></li>\n<li><del>don‚Äôt dce effect deps for return value and aliases</del></li>\n<li><del>more expressive app arg checking (allow declared overlap)</del></li>\n<li><del>show AST/IR view as aside instead of below</del></li>\n</ul>\n<p>Features (S):</p>\n<ul>\n<li><del>attach errors to graph nodes</del> (todo: other output)</li>\n<li><del>impl proper type comparisons</del></li>\n<li><del>proper operator associativity</del></li>\n<li><del>support undo in editor</del></li>\n<li>named results in function types (enables returning dead values)</li>\n<li>preserve type ascriptions in let/def (add cast node?)</li>\n<li>type unit should not incur dependencies</li>\n<li>support <del>zero-arg</del> and multi-arg functions</li>\n</ul>\n<p>Features (M):</p>\n<ul>\n<li><del>graph ir dom interaction</del></li>\n<li><del>parser</del></li>\n<li><del>compact codegen</del></li>\n<li>cse, rewriting, other opts (local and global)</li>\n<li>if, loops, recursion</li>\n<li>lowering passes</li>\n<li>macros / must-inline functions</li>\n</ul>\n<p>Features (L):</p>\n<ul>\n<li><del>effect polymorphism (lightweight)</del></li>\n<li>larger role for subtyping and type closing (minEligible): resolve @call(f,a)</li>\n<li>soft effects (dce effects in lambda)</li>\n<li>nested refs: flow-sensitive aliasing, nested heap model, strong updates, ‚Ä¶</li>\n</ul>\n<!-- Features (medium):\n- tensors, arrays, loops, if\n- lowering phases, loop fusion-->\n<p>Features (XL):</p>\n<ul>\n<li>polymorphism</li>\n<li>dependent types</li>\n<li>continuations</li>\n<li>implicits</li>\n<li>wasm codegen</li>\n</ul>\n<p>Proper theory:</p>\n<ul>\n<li><del>basic reachability types</del></li>\n<li><del>effects modulo reachability</del></li>\n<li><del>self types</del></li>\n<li><del>dependent reachability polymorphism (over tracked/untracked)</del> (todo: bring up to date with theory)</li>\n<li>dependent effect polymorphism (theory for ‚Äú@call(f,a)‚Äú)</li>\n<li>soft effects (dce across lambda)</li>\n<li>dce of ‚Äúfree‚Äù</li>\n<li>returning ‚Äúdead‚Äù objects: prohibit, or let callsite know (e.g. via self-type effect in result)</li>\n<li>code motion for effectful statements (incl alloc = read on world) &#x3C;‚Äî this seems unsafe??</li>\n</ul>\n</aside>\n</aside>\n<h3>Example 1: Tracking Independent Heap Objects</h3>\n<p>In this example, we create a higher-order function\n<code class=\"language-text\">counter</code> that allocates a mutable reference on the heap and\nreturns a function to the caller that manipulates this\nheap reference. Our system is precise enough to track the\nresult of multiple invocations of <code class=\"language-text\">counter</code> and the returned\n<code class=\"language-text\">inc</code> functions independently:</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nrun(`// source program\ndef main(world: IO @track) = {\n  def counter() = {\n    let c = alloc(world)\n    () => inc(c)\n  }\n  let inc1 = counter()\n  let inc2 = counter()\n  inc1()\n  inc1()\n  inc2()\n  inc2()\n  // uncomment the following lines one by one\n  // and watch the target code change:\n  inc2()\n  // inc1()\n  // inc1() + inc2()\n  // 0\n}\n`)\n</code>\n<p>If a heap object is allocated but doesn‚Äôt contribute to\nthe result value of <code class=\"language-text\">main</code>, it will be removed by dead-code\nelimination. This even works if the heap object is modified,\nincluding indirectly through higher-order functions.</p>\n<p>How does this work? Function <code class=\"language-text\">alloc</code> returns a <em>tracked</em>\nvalue, and every operation that aliases or accesses a\ntracked value is recorded in the type system. The <code class=\"language-text\">world</code>\nparameter of the <code class=\"language-text\">main</code> function is another example of a\ntracked value. Using the type annotation <code class=\"language-text\">@track(x)</code> we\ncan denote a tracked value that may be aliased with another\ntracked value <code class=\"language-text\">x</code>.</p>\n<p>To view inferred type signatures and other pieces of the\ninternal representation open the Graph IR panel.\nClick on any expression in the target code or the IR to\nhighlight it across all open panels (source, AST, IR,\ntarget).</p>\n<h3>Example 2: Linearity, Type-State, Effect Polymorphism</h3>\n<p>We monitor side effects on tracked variables and compute\ndependencies between effectful statements, distinguishing\nbetween read, write, and kill effects. Kill effects\nrender an object unusable, and can thus enforce affine/linear\nusage of values (move semantics, use-once capabilities,\ntype-state, etc.)</p>\n<p>Lightweight effect polymorphism enables tracking the\neffects of higher-order functions in relation to argument\nfunctions provided at the callsite, as the following example\nshows:</p>\n<code class=\"runScript\" filter=\"coolEditor\" asides=\"AST,Graph IR\" popout=\"true\">\nflags.targetSugar = true\nflags.softKill = false\nrun(`// a higher order function: its arg is tracked and\n// may read and write itself when called (=w> arrow)\ndef map(f: Int =w> Int) = {\n  f(1) + (f(2) + f(3))\n}\n// a HOF that tracks its arg linearly, assuming it\n// may read, write, and kill itself when called (=k>)\ndef mapOne(f: Int =k> Int) = {\n  f(1) // calling f more than once would be an error\n}\n// utility\ndef toInt(a: Unit) = 0\n// main program\ndef main(world: IO @track) = {\n  let c = alloc(world)\n  map(x =>\n    inc(c) // free(c) would be an error! (exec more than once)\n  )\n  mapOne(x =>\n    inc(c) // we're not freeing c this time!\n  )\n  let res = get(c) // effect polymorphism: c is still valid!\n  mapOne(x =>\n    toInt(free(c)) // now c is gone!\n  )\n  // get(c) // would be an error, c has been freed\n  res\n}\n`)\n</code>\n<p>A function closure conceptually subsumes all tracked values it\nreferences. Hence, if a function reads or modifies a tracked value\ndefined outside its scope the function can be thought to incur\nthat effect <em>on itself</em>. We can express this elegantly using\n<em>self types</em> (like in Scala/DOT).</p>\n<p>The following desugarings provide a concise notation for function\ntypes that incur a self-effect when called:</p>\n<ul>\n<li>Int =r> Int  --->  (f(x:Int) => Int @read(f)) @track</li>\n<li>Int =w> Int  --->  (f(x:Int) => Int @read(f) @write(f)) @track</li>\n<li>Int =k> Int  --->  (f(x:Int) => Int @read(f) @write(f) @kill(f)) @track</li>\n</ul>\n<!-- ### Appendix -->","fields":{"slug":"/Public/Generic/graph-ir/"},"frontmatter":{"date":"2020-09-25","title":"Graph IRs for Expressive Languages: Taming Higher-Order Control and State with Precise Effect Dependencies","description":"What if we had a sea-of-nodes IR with native support for higher-order functions and heap-allocated data?","keywords":"Aliasing, Separation, Types, Type and Effect System, Dependencies, Dependent Types, Ownership Types, Reachability Types, Graph IR, Graph-Based IR, Sea of Nodes","tags":null}}},{"node":{"excerpt":"Diff algorithms are the workhorse of modern version control systems, both internally and as part of the UX. Viewing changesets (commits‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Diff algorithms are the workhorse of modern version control systems, both internally and as part of the UX. Viewing changesets (commits, pull requests) as diff output is key for programmers to understand the evolution of a codebase and to work together effectively in a team.</p>\n<p>We‚Äôll implement a state-of-the-art diff algoritm from scratch and play with a few variations:</p>\n<ul><li>\n<aside>\n<h3>Intuition</h3>\n<p>The standard Myers Diff algorithm is widely used, efficient, well documented, and easy to understand and implement (see resources).</p>\n<p>However, a different class of diff algorithms has gained some popularity recently. These ‚Äúhistogram‚Äù algorithms tend to provide more ‚Äúnatural-looking‚Äù diffs. In git one can select this alternative algorithm with a flag: <code class=\"language-text\">git diff --histogram</code></p>\n<!-- A recent paper describes some of the differences in detail: \"How different are different diff algorithms in Git?\" https://link.springer.com/article/10.1007/s10664-019-09772-z, https://stackoverflow.com/questions/32365271/whats-the-difference-between-git-diff-patience-and-git-diff-histogram/32367597#32367597-->\n<h3>Delete from Both Sides</h3>\n<p>The key idea behind all diff algorithms is the following: we‚Äôre not directly looking to find which lines have to be deleted or inserted to turn one file into the other. Rather, we delete lines from each of the files, with the goal of finding the largest set of lines that occur in both (the longest common subsequence, LCS).</p>\n<p>To show the diff <em>between</em> files, we report only one set of deletions as deletions and the other one as additions. Intuitively, we have to delete certain lines from one file to reach the LCS and then, to reach the state of the other file, we have to add back what would need to be deleted from the other file to reach the LCS.</p>\n<h3>Keep What‚Äôs Common yet Distinguished</h3>\n<p>The key idea behing histogram algorithms now is to keep, at every step, the common line that occurs the fewest number of times (or one of those if there are multiple). Intuitively, lines that occur infrequently, perhaps even only once or twice, are the most distinguished ones, and hence we would not want to tell the user that they‚Äôd have to delete and then re-add it!</p>\n<p>And that is the entire algorithm. We select a line occuring in both files that we want to keep and then proceed recursively above and below that line.</p>\n</aside></li>\n<li><aside>\n<h3>Basic Histogram Diff</h3>\n<p>The core part of performing a diff is to compute the LCS (longest common subsequence). We do this as follows using the histogram idea:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// exercise: use global accumulator for optimization!\nfunction lcs(as, bs, a0, a1, b0, b1) {\n    // skip equivalent items at top and bottom\n    let hs = [], ts = []\n    while (as[a0] == bs[b0] && a0 < a1 && b0 < b1) {\n      hs.push(as[a0]); a0++; b0++\n    }\n    while (as[a1-1] == bs[b1-1] && a0 < a1 && b0 < b1) {\n      ts.push(as[a1-1]); a1--; b1--\n    }\n    ts.reverse()\n    // build histogram\n    let hist = {}\n    for (let i = a0; i < a1; i++) {\n      let rec = hist[as[i]]\n      if (rec) { rec.ac++; rec.ai = i }\n      else hist[as[i]] = { ac: 1, ai: i, bc: 0, bi: -1 }\n    }\n    for (let i = b0; i < b1; i++) {\n      let rec = hist[bs[i]]\n      if (rec) { rec.bc++; rec.bi = i }\n      else hist[bs[i]] = { ac: 0, ai: -1, bc: 1, bi: i }\n    }\n    // find lowest-occurrence item that appears in both\n    let cmp = Number.MAX_VALUE\n    let p = null\n    for (let k in hist) {\n      let rec = hist[k]\n      if (rec.ac > 0 && rec.bc > 0 && rec.ac + rec.bc < cmp) {\n        p = k; cmp = rec.ac + rec.bc\n      }\n    }\n    if (!p) return [...hs,...ts]\n    let rec = hist[p]\n    return [...hs, ...lcs(as,bs,a0,rec.ai,b0,rec.bi),\n                p, ...lcs(as,bs,rec.ai+1,a1,rec.bi+1,b1), ...ts]\n}\n</code>\n<p>Let‚Äôs run an example:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet s1=\"A,A,B,C,D,E,F,G\"\nlet s2=\"A,A,X,Y,Z,D,E,F\"\nlet as = s1.split(\",\")\nlet bs = s2.split(\",\")\nprint(\"Left: \"+as)\nprint(\"Right: \"+bs)\nlet ds = lcs(as, bs, 0, as.length, 0, bs.length)\nprint(\"Common: \"+ds)\n</code>\n<p>Once we have the LCS, we can produce marked-up diff output by checking which lines are part of the LCS and which are not.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction diff(as,bs) {\n  let ds = lcs(as, bs, 0, as.length, 0, bs.length)\n  let ai = 0\n  let bi = 0\n  for (let di = 0; di < ds.length; di++) {\n    while (ai < as.length && as[ai] != ds[di])\n      print(\"- \" + as[ai++])\n    while (bi < bs.length && bs[bi] != ds[di])\n      print(\"+ \" + bs[bi++])\n    print(\"  \" + ds[di]); ai++; bi++\n  }\n  while (ai < as.length)\n    print(\"- \" + as[ai++])\n  while (bi < bs.length)\n    print(\"+ \" + bs[bi++])\n}\n</code>\n<p>Example:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet s1 = `function foo() {\nprint(\"yo\")\n}\n`\nlet s2 = `// some comment\nprint(\"yo\")\n`\nprint(\"=== LEFT: ===\")\ns1.split(\"\\n\").forEach(x => print(x))\nprint(\"=== RIGHT: ===\")\ns2.split(\"\\n\").forEach(x => print(x))\nprint(\"=== DIFF: ===\")\ndiff(s1.split(\"\\n\"), s2.split(\"\\n\"))\n</code>\n<p><strong>Exercise:</strong> what is the asymptotic complexity of the histogram algorithm? How can it be improved? Hint: rewrite the LCS implementation to use accumulator parameters.</p>\n<p><strong>Exercise:</strong> what is the asymptotic complexity after this improvement? How does is compare to Myers‚Äô algorithm?</p>\n<p><strong>Exercise:</strong> how can potential slowdowns compared to Myers be mitigated? Hint: git and other tools employ hybrids, using histogram as first layer and falling back to Myers.</p>\n</aside></li>\n<li><aside>\n<h3>Timetravel Editing</h3>\n<p>Let‚Äôs implement an interactive editing environment and visualize diff output so that we can play with a few variations.</p>\n<p>The ‚Äútimetravel‚Äù editors below allow concurrent editing of multiple versions of a file, highlighting the diff from one version to the next.</p>\n<aside id=\"diff-timetravel-editor\">\n<h2>Timetravel Editing (Line Diff)</h2>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction findOffsetInParent(node, pos, top) {\n    if (node == top)\n        return pos;\n    while (node.previousSibling) {\n        node = node.previousSibling;\n        var len = node.nodeType == 3 ? node.length : node.innerText.length;\n        pos = len + pos;\n    }\n    return findOffsetInParent(node.parentNode, pos, top);\n}\nfunction findChildForOffset(node, pos) {\n    var len = node.nodeType == 3 ? node.length : node.innerText.length;\n    if (pos > len)\n        return findChildForOffset(node.nextSibling, pos - len);\n    if (node.firstChild)\n        return findChildForOffset(node.firstChild, pos);\n    return {node: node, pos: pos};\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet keyframes = [`function foo() {\nprint(\"yo\")\n}\n`,`function boo(arg) {\nprint(\"ho\")\n}\n`,`// some comment\nprint(\"yo\")\n`]\nlet textboxes = []\nlet selection = null\nlet container = document.createElement(\"div\")\ncontainer.style[\"width\"] = \"600px\"\no.appendChild(container)\nfunction patch(txt, start, end, data) {\n  return txt.substring(0, start) + data + txt.substring(end, txt.length)\n}\nfunction render() {\n  if (keyframes.length != textboxes.length) {\n    container.innerHTML = \"\"\n    textboxes = []\n  }\n  for (let k in keyframes) {\n    renderKeyframe(k)\n  }\n  if (selection)\n    renderSelection(selection.index, selection.start, selection.end)\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  return e\n}\nfunction renderKeyframe(kindex) {\n  let p = textboxes[kindex]\n  // ---- diff logic follows ----\nfunction diffChunk(as,bs) {\n    if (as.length == 0 && bs.length == 0) return\n    let a = as.join(\"\\n\")\n    let b = bs.join(\"\\n\")\n    if (as.length > 0) a += \"\\n\"\n    if (bs.length > 0) b += \"\\n\"\n    let span = document.createElement(\"span\")\n    span.style[\"background\"] = \"#AAFFAA\"\n    //span.style[\"padding-left\"] = \"5px\"\n    span.style[\"padding\"] = \"2px\"\n    span.setAttribute(\"title\", a)\n    span.appendChild(document.createTextNode(b))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert?\")) print(\"revert op not implemented\")\n    })\n}\nfunction sameChunk(a) {\n    let span = document.createElement(\"span\")\n    //span.style[\"background\"] = \"lightgrey\"\n    //span.style[\"padding-left\"] = \"5px\"\n    span.appendChild(document.createTextNode(a+\"\\n\"))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert?\")) print(\"revert op not implemented\")\n    })\n}\nfunction diff(as,bs) {\n  let ds = lcs(as, bs, 0, as.length, 0, bs.length)\n  let ai = 0\n  let bi = 0\n  for (let di = 0; di < ds.length; di++) {\n    let del = []\n    let ins = []\n    while (ai < as.length && as[ai] != ds[di]) {\n      del.push(as[ai++])\n    }\n    while (bi < bs.length && bs[bi] != ds[di]) {\n      ins.push(bs[bi++])\n    }\n    diffChunk(del,ins)\n    sameChunk(ds[di]); ai++; bi++\n  }\n  let del = []\n  let ins = []\n  while (ai < as.length) {\n    del.push(as[ai++])\n  }\n  while (bi < bs.length) {\n    ins.push(bs[bi++])\n  }\n  diffChunk(del,ins)\n}\n  // ---- diff logic end ----\n  if (!p) {\n    p = textboxes[kindex] = document.createElement(\"pre\")\n    let div = document.createElement(\"div\")\n    div.style[\"display\"] = \"flex\"\n    container.appendChild(div)\n    container.appendChild(button(\"Remove\", ev => {keyframes.splice(kindex,1); render()}))\n    container.appendChild(button(\"Add\", ev => {keyframes.splice(kindex,0,keyframes[kindex]); render()}))\n    div.appendChild(p)\n    p.setAttribute(\"contenteditable\", true)\n    p.setAttribute(\"spellcheck\", false)\n    //p.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\n    p.style[\"border\"] = \"1px solid grey\"\n    p.style[\"width\"] = \"300px\"\n    p.style[\"height\"] = \"200px\"\n    p.style[\"padding\"] = \"5px\"\n    p.style[\"margin\"] = \"0px\"\n    p.style[\"outline\"] = \"none\"\n    p.style[\"letter-spacing\"] = \"2px\"\n    p.addEventListener(\"beforeinput\", ev => inputEvent(ev,kindex))\n    p.addEventListener(\"focus\", ev => selection = {index:kindex, start:0, end: 0})\n  } else {\n    p.innerHTML = \"\"\n  }\nlet prev = kindex > 0 ? keyframes[kindex-1].split(\"\\n\") : []\nlet next = keyframes[kindex].split(\"\\n\")\ndiff(prev, next)\n  //p.appendChild(document.createTextNode(\"\\n\"))\n}\nfunction renderSelection(index, start, end) {\n  let p = textboxes[index]\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\nfunction inputEvent(ev, kindex) {\n  let p = textboxes[kindex]\n  ev.preventDefault()\n  let data = ev.data || (ev.dataTransfer && ev.dataTransfer.getData(\"text/plain\")) || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  recordEdit(kindex, start, end, data)\n  render()\n}\nfunction recordEdit(kindex, start, end, data) {\n  keyframes[kindex] = patch(keyframes[kindex], start, end, data)\n  selection = {index: kindex, start: start+data.length, end: start+data.length}\n}\nrender()\n</code>\n</aside>\n<p>The most basic version compares individual lines. This works fine but is relatively coarse-grained.</p>\n<aside id=\"diff-timetravel-editor1\">\n<h2>Timetravel Editing (Line then Char Diff)</h2>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet keyframes = [`function foo() {\nprint(\"yo\")\n}\n`,`function boo(arg) {\nprint(\"ho\")\n}\n`,`// some comment\nprint(\"yo\")\n`]\nlet textboxes = []\nlet selection = null\nlet container = document.createElement(\"div\")\ncontainer.style[\"width\"] = \"600px\"\no.appendChild(container)\nfunction patch(txt, start, end, data) {\n  return txt.substring(0, start) + data + txt.substring(end, txt.length)\n}\nfunction render() {\n  if (keyframes.length != textboxes.length) {\n    container.innerHTML = \"\"\n    textboxes = []\n  }\n  for (let k in keyframes) {\n    renderKeyframe(k)\n  }\n  if (selection)\n    renderSelection(selection.index, selection.start, selection.end)\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  return e\n}\nfunction renderKeyframe(kindex) {\n  let p = textboxes[kindex]\n  // ---- diff logic follows ----\n  function diffLineChunk(as,bs) {\n    if (as.length == 0 && bs.length == 0) return\n    let a = as.join(\"\\n\")\n    let b = bs.join(\"\\n\")\n    if (as.length > 0) a += \"\\n\"\n    if (bs.length > 0) b += \"\\n\"\n    diff(a.split(\"\"), b.split(\"\"), diffCharChunk, sameCharChunk)\n}\nfunction diffCharChunk(as,bs) {\n    if (as.length == 0 && bs.length == 0) return\n    let u = as.join(\"\")\n    let a = bs.join(\"\")\n    let span = document.createElement(\"span\")\n    span.style[\"background\"] = \"#AAFFAA\"\n    //span.style[\"padding-left\"] = \"5px\"\n    span.style[\"padding\"] = \"2px\"\n    span.setAttribute(\"title\", u)\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert?\")) print(\"revert op not implemented\")\n    })\n}\nfunction sameLineChunk(a) {\n    let span = document.createElement(\"span\")\n    //span.style[\"background\"] = \"lightgrey\"\n    //span.style[\"padding-left\"] = \"5px\"\n    span.appendChild(document.createTextNode(a+\"\\n\"))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert?\")) print(\"revert op not implemented\")\n    })\n}\nfunction sameCharChunk(a) {\n    let span = document.createElement(\"span\")\n    //span.style[\"background\"] = \"lightgrey\"\n    //span.style[\"padding-left\"] = \"5px\"\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert?\")) print(\"revert op not implemented\")\n    })\n}\nfunction diff(as,bs,diffChunk,sameChunk) {\n  let ds = lcs(as, bs, 0, as.length, 0, bs.length)\n  let ai = 0\n  let bi = 0\n  for (let di = 0; di < ds.length; di++) {\n    let del = []\n    let ins = []\n    while (ai < as.length && as[ai] != ds[di]) {\n      del.push(as[ai++])\n    }\n    while (bi < bs.length && bs[bi] != ds[di]) {\n      ins.push(bs[bi++])\n    }\n    diffChunk(del,ins)\n    sameChunk(ds[di]); ai++; bi++\n  }\n  let del = []\n  let ins = []\n  while (ai < as.length) {\n    del.push(as[ai++])\n  }\n  while (bi < bs.length) {\n    ins.push(bs[bi++])\n  }\n  diffChunk(del,ins)\n}\n// ---- diff logic end ----\n  if (!p) {\n    p = textboxes[kindex] = document.createElement(\"pre\")\n    let div = document.createElement(\"div\")\n    div.style[\"display\"] = \"flex\"\n    container.appendChild(div)\n    container.appendChild(button(\"Remove\", ev => {keyframes.splice(kindex,1); render()}))\n    container.appendChild(button(\"Add\", ev => {keyframes.splice(kindex,0,keyframes[kindex]); render()}))\n    div.appendChild(p)\n    p.setAttribute(\"contenteditable\", true)\n    p.setAttribute(\"spellcheck\", false)\n    //p.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\n    p.style[\"border\"] = \"1px solid grey\"\n    p.style[\"width\"] = \"300px\"\n    p.style[\"height\"] = \"200px\"\n    p.style[\"padding\"] = \"5px\"\n    p.style[\"margin\"] = \"0px\"\n    p.style[\"outline\"] = \"none\"\n    p.style[\"letter-spacing\"] = \"2px\"\n    p.addEventListener(\"beforeinput\", ev => inputEvent(ev,kindex))\n    p.addEventListener(\"focus\", ev => selection = {index:kindex, start:0, end: 0})\n  } else {\n    p.innerHTML = \"\"\n  }\nlet prev = kindex > 0 ? keyframes[kindex-1].split(\"\\n\") : []\nlet next = keyframes[kindex].split(\"\\n\")\ndiff(prev, next, diffLineChunk, sameLineChunk)\n  //p.appendChild(document.createTextNode(\"\\n\"))\n}\nfunction renderSelection(index, start, end) {\n  let p = textboxes[index]\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\nfunction inputEvent(ev, kindex) {\n  let p = textboxes[kindex]\n  ev.preventDefault()\n  let data = ev.data || (ev.dataTransfer && ev.dataTransfer.getData(\"text/plain\")) || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  recordEdit(kindex, start, end, data)\n  render()\n}\nfunction recordEdit(kindex, start, end, data) {\n  keyframes[kindex] = patch(keyframes[kindex], start, end, data)\n  selection = {index: kindex, start: start+data.length, end: start+data.length}\n}\nrender()\n</code>\n</aside>\n<p>An appealing aspect of diff algorithms is that we can apply them hierarchically on hierarchical data: whenever we detect a difference at the top level, we can run the algorithm at a finer resolution to drill down into those differences.</p>\n<p>Here, we refine the initial approach by first comparing lines, and then for each multi-line chunk that differs, comparing that chunk character-by-character.</p>\n<aside id=\"diff-timetravel-editor2\">\n<h2>Timetravel Editing (Token with Gap Diff)</h2>\n<p>Define lexer:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction tokenize(input) {\n  let pos = 0\n  let out = []\n  let isAlpha = c => (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n  let isNum = c => (c >= '0' && c <= '9')\n  let isEOF = c => !c\n  let isGap = c => (!isAlpha(c) && !isNum(c) && !isEOF(c) &&\n(c != '\\n') && (c != '}' && (c != \"{\") && (c != ')' && (c != \"(\")))\n)\n  while(input[pos]) {\n    let gap = \"\"\n    let val = \"\"\n    if (isGap(input[pos])) {\n      while (isGap(input[pos])) gap += input[pos++]\n    }\n    if (isAlpha(input[pos])) {\n      while (isAlpha(input[pos])) val += input[pos++]\n    } else if (isNum(input[pos])) {\n      while (isNum(input[pos])) val += input[pos++]\n    } else if (input[pos]) val += input[pos++]\n    out.push({gap,val})\n  }\n  return out\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet keyframes = [`function foo() {\nprint(\"yo\")\n}\n`,`function boo(arg) {\nprint(\"ho\")\n}\n`,`// some comment\nprint(\"yo\")\n`]\nlet textboxes = []\nlet selection = null\nlet container = document.createElement(\"div\")\ncontainer.style[\"width\"] = \"600px\"\no.appendChild(container)\nfunction patch(txt, start, end, data) {\n  return txt.substring(0, start) + data + txt.substring(end, txt.length)\n}\nfunction render() {\n  if (keyframes.length != textboxes.length) {\n    container.innerHTML = \"\"\n    textboxes = []\n  }\n  for (let k in keyframes) {\n    renderKeyframe(k)\n  }\n  if (selection)\n    renderSelection(selection.index, selection.start, selection.end)\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  return e\n}\nfunction renderKeyframe(kindex) {\n  let p = textboxes[kindex]\n  // ---- diff logic follows ----\n  function diffChunk(as,bs) {\n    if (as.length == 0 && bs.length == 0) return\n    let u = as.map(o => o.gap+o.val).join(\"\") // TODO: gap!\n    let a = bs.map(o => o.gap+o.val).join(\"\") // TODO: gap!\n    let span = document.createElement(\"span\")\n    span.style[\"background\"] = \"#AAFFAA\"\n    span.style[\"padding\"] = \"2px\"\n    span.setAttribute(\"title\", u)\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert '\"+a+\"' to '\"+u+\"'?\")) {\n        // TODO: do this properly, call recordEdit with the right indices\n        span.style[\"background\"] = \"none\"\n        span.style[\"padding\"] = \"0px\"\n        span.innerText = u\n      }\n    })\n  }\n  function sameChunk(a) {\n    let span = document.createElement(\"span\")\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n  }\n  function diff(as,bs) {\n    //print(\"A:\"+as.map(o => o.gap+\"/\"+o.val))\n    //print(\"B:\"+bs.map(o => o.gap+\"/\"+o.val))\n    let ds = lcs(as.map(a => a.val), bs.map(a => a.val), 0, as.length, 0, bs.length)\n    let ai = 0\n    let bi = 0\n    for (let di = 0; di < ds.length; di++) {\n      let del = []\n      let ins = []\n      // need to check if beginning gap is same\n      // (default: treat as different) -- could also do this partially\n      if (ai < as.length && bi < bs. length && as[ai].gap == bs[bi].gap) {\n        sameChunk(as[ai].gap); as[ai].gap = \"\"; bs[bi].gap = \"\"\n      }\n      while (ai < as.length && as[ai].val != ds[di]) {\n        del.push(as[ai++])\n      }\n      while (bi < bs.length && bs[bi].val != ds[di]) {\n        ins.push(bs[bi++])\n      }\n      // need to check if beginning gap is different!\n      // (default: treat as same)\n      let gap = \"\"\n      if (ai < as.length && bi < bs.length && as[ai].gap == bs[bi].gap) {\n        gap = bs[bi].gap\n      } else {\n        del.push({gap: as[ai].gap, val: \"\"})\n        ins.push({gap: bs[bi].gap, val: \"\"})\n      }\n      diffChunk(del,ins)\n      sameChunk(gap+ds[di]); ai++; bi++\n    }\n    let del = []\n    let ins = []\n    // check if beginning gap is same\n    if (ai < as.length && bi < bs. length && as[ai].gap == bs[bi].gap) {\n      sameChunk(as[ai].gap); as[ai].gap = \"\"; bs[bi].gap = \"\"\n    }\n    while (ai < as.length) {\n      del.push(as[ai++])\n    }\n    while (bi < bs.length) {\n      ins.push(bs[bi++])\n    }\n    diffChunk(del,ins)\n  }\n  // ---- diff logic end ----\n  if (!p) {\n    p = textboxes[kindex] = document.createElement(\"pre\")\n    let div = document.createElement(\"div\")\n    div.style[\"display\"] = \"flex\"\n    container.appendChild(div)\n    container.appendChild(button(\"Remove\", ev => {keyframes.splice(kindex,1); render()}))\n    container.appendChild(button(\"Add\", ev => {keyframes.splice(kindex,0,keyframes[kindex]); render()}))\n    div.appendChild(p)\n    p.setAttribute(\"contenteditable\", true)\n    p.setAttribute(\"spellcheck\", false)\n    //p.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\n    p.style[\"border\"] = \"1px solid grey\"\n    p.style[\"width\"] = \"300px\"\n    p.style[\"height\"] = \"200px\"\n    p.style[\"padding\"] = \"5px\"\n    p.style[\"margin\"] = \"0px\"\n    p.style[\"outline\"] = \"none\"\n    p.style[\"letter-spacing\"] = \"2px\"\n    p.addEventListener(\"beforeinput\", ev => inputEvent(ev,kindex))\n    p.addEventListener(\"focus\", ev => selection = {index:kindex, start:0, end: 0})\n  } else {\n    p.innerHTML = \"\"\n  }\n  let prev = kindex > 0 ? tokenize(keyframes[kindex-1]) : []\n  let next = tokenize(keyframes[kindex])\n  diff(prev, next)\n  p.appendChild(document.createTextNode(\"\\n\"))\n}\nfunction renderSelection(index, start, end) {\n  let p = textboxes[index]\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\nfunction inputEvent(ev, kindex) {\n  let p = textboxes[kindex]\n  ev.preventDefault()\n  let data = ev.data || (ev.dataTransfer && ev.dataTransfer.getData(\"text/plain\")) || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  recordEdit(kindex, start, end, data)\n  render()\n}\nfunction recordEdit(kindex, start, end, data) {\n  keyframes[kindex] = patch(keyframes[kindex], start, end, data)\n  selection = {index: kindex, start: start+data.length, end: start+data.length}\n}\nrender()\n</code>\n</aside>\n<p>Another option that works especially well for program source code is to first tokenize the input into a sequence of meaningful lexical tokens (words, numbers, operators, etc.) and to compute the diff based on those token sequences. Changes in whitespace are deprioritized and never counted as significant.</p>\n<p><strong>Exercise:</strong> implement a version that first parses the input into a syntax <em>tree</em> and then computes diffs hierarchically for the children of each tree node. Hint: <a href=\"/Public/Generic/just-write-the-parser\">how to write a parser</a>.</p>\n</aside></li>\n</ul>\n<h3>The Result</h3>\n<p>Below is a ‚Äútimetravel‚Äù editor that allows concurrent editing of multiple versions of a file, highlighting the diff from one version to the next.</p>\n<p>Diffs are computed on a token stream, which produces slightly more natural results for source code than comparing lines and/or characters (which, of course, is still an entirely viable alternative).</p>\n<p>Edit any of the text boxes to see the diffs change. Hover over any change (marked in green) to see the previous version of that chunk. Deletions are hidden by default, but deleted text will show up in tooltips on mouseover. Use the appropriate buttons to add or remove versions/commits anywhere in the list.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet keyframes = [`function foo() {\nprint(\"yo\")\n}\n`,`function boo(arg) {\nprint(\"ho\")\n}\n`,`// some comment\nprint(\"yo\")\n`]\nlet textboxes = []\nlet selection = null\nlet container = document.createElement(\"div\")\ncontainer.style[\"width\"] = \"600px\"\no.appendChild(container)\nfunction patch(txt, start, end, data) {\n  return txt.substring(0, start) + data + txt.substring(end, txt.length)\n}\nfunction render() {\n  if (keyframes.length != textboxes.length) {\n    container.innerHTML = \"\"\n    textboxes = []\n  }\n  for (let k in keyframes) {\n    renderKeyframe(k)\n  }\n  if (selection)\n    renderSelection(selection.index, selection.start, selection.end)\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  return e\n}\nfunction renderKeyframe(kindex) {\n  let p = textboxes[kindex]\n  // ---- diff logic follows ----\n  function diffChunk(as,bs) {\n    if (as.length == 0 && bs.length == 0) return\n    let u = as.map(o => o.gap+o.val).join(\"\") // TODO: gap!\n    let a = bs.map(o => o.gap+o.val).join(\"\") // TODO: gap!\n    let span = document.createElement(\"span\")\n    span.style[\"background\"] = \"#AAFFAA\"\n    span.style[\"padding\"] = \"2px\"\n    span.setAttribute(\"title\", u)\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n    span.addEventListener(\"click\", ev => {\n      if (ev.shiftKey && window.confirm(\"revert '\"+a+\"' to '\"+u+\"'?\")) {\n        // TODO: do this properly, call recordEdit with the right indices\n        span.style[\"background\"] = \"none\"\n        span.style[\"padding\"] = \"0px\"\n        span.innerText = u\n      }\n    })\n  }\n  function sameChunk(a) {\n    let span = document.createElement(\"span\")\n    span.appendChild(document.createTextNode(a))\n    p.appendChild(span)\n  }\n  function diff(as,bs) {\n    //print(\"A:\"+as.map(o => o.gap+\"/\"+o.val))\n    //print(\"B:\"+bs.map(o => o.gap+\"/\"+o.val))\n    let ds = lcs(as.map(a => a.val), bs.map(a => a.val), 0, as.length, 0, bs.length)\n    let ai = 0\n    let bi = 0\n    for (let di = 0; di < ds.length; di++) {\n      let del = []\n      let ins = []\n      // need to check if beginning gap is same\n      // (default: treat as different) -- could also do this partially\n      if (ai < as.length && bi < bs. length && as[ai].gap == bs[bi].gap) {\n        sameChunk(as[ai].gap); as[ai].gap = \"\"; bs[bi].gap = \"\"\n      }\n      while (ai < as.length && as[ai].val != ds[di]) {\n        del.push(as[ai++])\n      }\n      while (bi < bs.length && bs[bi].val != ds[di]) {\n        ins.push(bs[bi++])\n      }\n      // need to check if beginning gap is different!\n      // (default: treat as same)\n      let gap = \"\"\n      if (ai < as.length && bi < bs.length && as[ai].gap == bs[bi].gap) {\n        gap = bs[bi].gap\n      } else {\n        del.push({gap: as[ai].gap, val: \"\"})\n        ins.push({gap: bs[bi].gap, val: \"\"})\n      }\n      diffChunk(del,ins)\n      sameChunk(gap+ds[di]); ai++; bi++\n    }\n    let del = []\n    let ins = []\n    // check if beginning gap is same\n    if (ai < as.length && bi < bs. length && as[ai].gap == bs[bi].gap) {\n      sameChunk(as[ai].gap); as[ai].gap = \"\"; bs[bi].gap = \"\"\n    }\n    while (ai < as.length) {\n      del.push(as[ai++])\n    }\n    while (bi < bs.length) {\n      ins.push(bs[bi++])\n    }\n    diffChunk(del,ins)\n  }\n  // ---- diff logic end ----\n  if (!p) {\n    p = textboxes[kindex] = document.createElement(\"pre\")\n    let div = document.createElement(\"div\")\n    div.style[\"display\"] = \"flex\"\n    container.appendChild(div)\n    container.appendChild(button(\"Remove\", ev => {keyframes.splice(kindex,1); render()}))\n    container.appendChild(button(\"Add\", ev => {keyframes.splice(kindex,0,keyframes[kindex]); render()}))\n    div.appendChild(p)\n    p.setAttribute(\"contenteditable\", true)\n    p.setAttribute(\"spellcheck\", false)\n    //p.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\n    p.style[\"border\"] = \"1px solid grey\"\n    p.style[\"width\"] = \"300px\"\n    p.style[\"height\"] = \"200px\"\n    p.style[\"padding\"] = \"5px\"\n    p.style[\"margin\"] = \"0px\"\n    p.style[\"outline\"] = \"none\"\n    p.style[\"letter-spacing\"] = \"2px\"\n    p.addEventListener(\"beforeinput\", ev => inputEvent(ev,kindex))\n    p.addEventListener(\"focus\", ev => selection = {index:kindex, start:0, end: 0})\n  } else {\n    p.innerHTML = \"\"\n  }\n  let prev = kindex > 0 ? tokenize(keyframes[kindex-1]) : []\n  let next = tokenize(keyframes[kindex])\n  diff(prev, next)\n  p.appendChild(document.createTextNode(\"\\n\"))\n}\nfunction renderSelection(index, start, end) {\n  let p = textboxes[index]\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\nfunction inputEvent(ev, kindex) {\n  let p = textboxes[kindex]\n  ev.preventDefault()\n  let data = ev.data || (ev.dataTransfer && ev.dataTransfer.getData(\"text/plain\")) || \"\"\n  if (ev.inputType == \"insertLineBreak\" || ev.inputType == \"insertParagraph\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  recordEdit(kindex, start, end, data)\n  render()\n}\nfunction recordEdit(kindex, start, end, data) {\n  keyframes[kindex] = patch(keyframes[kindex], start, end, data)\n  selection = {index: kindex, start: start+data.length, end: start+data.length}\n}\nrender()\n</code>\n<h3>Appendix</h3>\n<aside>\n<h2>Resources</h2>\n<p>Standard Myers Diff algorithm:</p>\n<ul>\n<li><a href=\"https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/\">https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/</a></li>\n<li><a href=\"https://blog.robertelder.org/diff-algorithm/\">https://blog.robertelder.org/diff-algorithm/</a></li>\n<li><a href=\"http://www.xmailserver.org/diff2.pdf\">http://www.xmailserver.org/diff2.pdf</a> (original paper)</li>\n</ul>\n<p>Histogram Diff algorithm:</p>\n<ul>\n<li><a href=\"https://link.springer.com/article/10.1007/s10664-019-09772-z\">https://link.springer.com/article/10.1007/s10664-019-09772-z</a></li>\n<li><a href=\"https://stackoverflow.com/questions/32365271/whats-the-difference-between-git-diff-patience-and-git-diff-histogram/32367597#32367597\">https://stackoverflow.com/questions/32365271/whats-the-difference-between-git-diff-patience-and-git-diff-histogram/32367597#32367597</a></li>\n</ul>\n<p>See also:</p>\n<ul>\n<li>Difftastic: language-aware diffing on syntax trees <a href=\"https://github.com/wilfred/difftastic\">https://github.com/wilfred/difftastic</a></li>\n</ul>\n</aside>","fields":{"slug":"/Public/Generic/diff-algorithm/"},"frontmatter":{"date":"2020-07-25","title":"The Histogram Diff Algorithm","description":"How does diff work? Let's find out! We'll implement a modern diff algorithm from scratch.","keywords":"Diff, Git, Commit, Histogram Diff, Myers Diff, Timetravel Editing, Tokenization","tags":null}}},{"node":{"excerpt":"Delimited continuations are a powerful and generic control abstraction. Fully-general implementations tend to be heavyweight (full CPS‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Delimited continuations are a powerful and generic control abstraction. Fully-general implementations tend to be heavyweight (full CPS: runtime overhead; selective CPS: type/syntax overhead; stack copying: different kind of runtime overhead). But often, restricted models are sufficient, and can be implemented more efficiently.</p>\n<p>Here we consider delimited continuations restricted to affine and non-escaping use: we assume a control operator <code class=\"language-text\">shift(k => ...)</code> that permits invocation of k once or not at all, and only within the operator‚Äôs dynamic extent.</p>\n<p>We will show that we can implement this operator efficiently, using a single auxiliary stack in addition to the standard call stack.</p>\n<p>Our implementation is in JavaScript, so the restrictions aren‚Äôt enforced, but type systems exist that could provide corresponding static guarantees.</p>\n<p>Use cases:</p>\n<ul>\n<li><a href=\"/Public/Generic/differentiable-programming-in-js\">AutoDiff</a> (backward pass to propagate gradient updates)</li>\n<li>Automatic resource management (clean up resource after use)</li>\n<li>Algebraic effects (certain classes)</li>\n</ul>\n<p>Restriction:</p>\n<pre>\nshift(k => k() * 2)         // ok: linear (1 use)\nshift(k => 2)               // ok: not linear but still affine (0 uses)\n// shift(k => k() + k())    // not affine (2 uses)\n// shift(k => outer = k)    // not affine (k escapes)\n</pre>\n<p>Running Example:</p>\n<pre>\nreset(() => {\n    4 + shift(k => k(3) * 2)\n})\n// result: (4 + 3) * 2 = 14\n</pre>\n<h2>Key Idea</h2>\n<aside>\n<h2>Recall the general implementation using CPS</h2>\n<p>The original semantics for shift/reset is expressed in terms of whole-program CPS transformation. In that case, there is an implicit reset around the shift body. This is useful for uniformity, but not strictly necessary.</p>\n<p>It is often useful to implement a selective CPS transform. In this case we have distinct CPS and non-CPS code paths in the same program. We can keep the two worlds apart using a type system (as in Scala) or using syntax annotations (monadic do, async/await). In either case, we can leave the shift body in direct style.</p>\n<p>Example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// result: (4 + 3) * 2 = 14\nlet res = (k1 => {\n    let k = (r => k1(4 + r));\n    return (k => k(3) * 2)(k)\n})(r1 => r1)\nprint(res)\n</code>\n<p>Transformation rules (selective cps, excerpt):</p>\n<pre>\n[[ reset(f) ]]    = [[ f ]](r => r)\n[[ shift(f) ]](k) = f(k)\n</pre>\n</aside>\n<p>Here‚Äôs what‚Äôs different:</p>\n<ul>\n<li>Standard shift/reset\n<ul>\n<li>Materialize the continuation (the return path) of shift</li>\n<li>Selectively CPS-transform the code outside of shift (up to enclosing reset)</li>\n<li>Code inside shift is in direct style</li>\n<li>Shift body invokes k as desired, metacontinuation (what happens after calling k) is implicit</li>\n<li>Reset applies identity continuation to extract result</li>\n</ul>\n</li>\n<li>Affine, non-escaping shift/reset\n<ul>\n<li>Materialize the metacontinuation (the ‚Äúcleanup‚Äù code, what to do after returning)</li>\n<li>Selectively CPS-transform the code inside of shift</li>\n<li>Code outside shift is in direct style</li>\n<li>Shift returns normally, but pushes explicit metacontinuation (continuation of calling k) on a stack</li>\n<li>Reset empties the stack to execute metacontinuation and extract result</li>\n</ul>\n</li>\n</ul>\n<h2>Technical Details</h2>\n<p>Recall running Example:</p>\n<pre>\nreset(() => {\n    4 + shift(k => k(3) * 2)\n})\n// result: (4 + 3) * 2 = 14\n</pre>\n<p>Proposed implementation (example):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet stack = []\nstack.push(r => r * 2)\nlet r = 4 + 3\nstack.pop()(r)\n</code>\n<p>Proposed implementation (generic, linear case):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet stack = []\nfunction shift(f) {\n  let rval\n  f((z,k2) => { rval = z; stack.push(k2) })\n  return rval\n}\nfunction reset(f) {\n  let save = stack.length\n  let r = f()\n  // exception handling elided\n  while (stack.length > save)\n    r = stack.pop()(r)\n  return r\n}\n</code>\n<p>Let‚Äôs try it on our example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(reset(() => 4 + shift(k => k(3, r => r*2))))\n</code>\n<p>Another example (multiple shifts):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction foo() {\n    let x1 = shift(k => k(\"1\", r => r + \"A\"))\n    let x2 = shift(k => k(\"2\", r => r + \"B\"))\n    let x3 = shift(k => k(\"3\", r => r + \"C\"))\n    return (x1+x2+x3)\n}\nprint(reset(foo))\n</code>\n<h3>Linear to Affine</h3>\n<p>The code shown above only implements the linear case (exactly 1 use of k). To deal with the affine case (k not used at all), we can throw an exception when we detect that the function passed to shift returns without having invoked k. This exception can communicate the result value outward until caught by reset.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h3>Sync to Async, Non-Escaping to Escaping</h3>\n<p>Since our implementation returns normally (using the regular call stack) we cannot use our version of shift to actually interrupt the program, and, say, continue later by calling k from an event handler.</p>\n<p>Many languages these days implement async/await or generators with <code class=\"language-text\">yield</code>. Essentially, these are one-shot <em>undelimited</em> continuations. This differs from our non-escaping model in that asynchronous interruption is supported, using some variant of CPS underneath the covers (typically chaining futures and promises).</p>\n<p>Using the auxiliary stack technique shown above, we can extend these existing facilities to (potentially escaping) one-shot <em>delimited</em> continuations.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h3>The CPS Hierarchy</h3>\n<p>How to support nested continuations (e.g. for higher-order derivatives in AD)? Maintain a separate stack for each level of nesting, so that shift-n can push to the level-n stack anywhere.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h2>Discussion</h2>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://dev.to/yelouafi/algebraic-effects-in-javascript-part-3---delimited-continuations-42hj\">https://dev.to/yelouafi/algebraic-effects-in-javascript-part-3---delimited-continuations-42hj</a></li>\n<li><a href=\"https://gist.github.com/yelouafi/44f5ed9bcdd1100b1902bcdb80aa32da\">https://gist.github.com/yelouafi/44f5ed9bcdd1100b1902bcdb80aa32da</a></li>\n</ul>","fields":{"slug":"/Public/Generic/affine-continuations/"},"frontmatter":{"date":"2020-07-14","title":"Implementing Affine Non-Escaping Delimited Continuations with a Single Auxiliary Stack","description":"Instead of materializing the continuation (the return path) of 'shift', we materialize the metacontinuation (the 'cleanup' code) on a stack that is drained by 'reset'.","keywords":"Delimited Continuations, Shift/Reset, Async","tags":null}}},{"node":{"excerpt":"Differentiable programming enables a form of backwards execution of programs: specify a computation based on tunable parameters, provide a‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Differentiable programming enables a form of backwards execution of programs: specify a computation based on tunable parameters, provide a desired result, and then use gradient descent to derive the correct parameter values that match the computation to the desired output.</p>\n<p>Let‚Äôs explore this idea in the context of interative graphics. We‚Äôll implement just the drawing logic, and obtain an interactive environment that enables interaction with the drawn shapes, subject to constraints inherent in the program structure.</p>\n<p>The code is based on the <a href=\"/Public/Generic/differentiable-programming-in-js\">minimal AD toolkit presented in a companion note</a>.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// stack to remember backward operations\nlet tape = []\n// dual number api\nfunction num(x) {\n    return { val: x, grad: 0 }\n}\nfunction plus(x,y) {\n    let z = num(x.val + y.val)\n    tape.push(() => { x.grad += z.grad; y.grad += z.grad })\n    return z\n}\nfunction minus(x,y) {\n    let z = num(x.val - y.val)\n    tape.push(() => { x.grad += z.grad; y.grad -= z.grad })\n    return z\n}\nfunction times(x,y) {\n    let z = num(x.val * y.val)\n    tape.push(() => { x.grad += y.val * z.grad; y.grad += x.val * z.grad })\n    return z\n}\nfunction sin(x) {\n    let z = num(Math.sin(x.val))\n    tape.push(() => { x.grad += z.grad * Math.cos(x.val) })\n    return z\n}\nfunction cos(x) {\n    let z = num(Math.cos(x.val))\n    tape.push(() => { x.grad += -z.grad * Math.sin(x.val) })\n    return z\n}\n// derivative api\nfunction deriv(f) {\n    function d(x) {\n        // forward pass\n        let dx = num(x)\n        let dz = f(dx)\n        dz.grad = 1\n        // backward pass\n        for (b of tape.reverse()) b()\n        tape = []\n        return dx.grad\n    }\n    return d\n}\n// optimizable parameters\nlet params = []\nfunction param(x) {\n    const dx = num(x)\n    params.push(dx)\n    return dx\n}\n// compute primal and gradient\nfunction compute(loss) {\n    tape = []\n    // forward\n    const d = loss()\n    // backprop\n    d.grad = 1\n    for (const b of tape.reverse()) b()\n    return d\n}\n// one optimization step\nlet lr = 0.0001 // learning rate\nfunction optimize(loss) {\n    const d = compute(loss)\n    // gradient descent\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        p.val -= lr * p.grad\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// basic drawing code\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 300\ncvs.height = 150\nlet ctx = cvs.getContext(\"2d\")\no.appendChild(cvs)\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n}\n</code>\n<p>Let‚Äôs define a parameterized drawing. We pick an example from the <a href=\"https://ravichugh.github.io/sketch-n-sketch/\">Sketch-n-Sketch</a> bidirectional programming environment):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet y = param(10)\nlet w = param(20)\nlet h = param(100)\nlet d = param(40)\nfunction draw() {\n    drawRect(times(num(1), d), y, w, h)\n    drawRect(times(num(2), d), y, w, h)\n    drawRect(times(num(3), d), y, w, h)\n    drawRect(times(num(4), d), y, w, h)\n}\n</code>\n<p>Regular forward computation will plot it to the screen:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndraw()\n</code>\n<h2>Interactivity</h2>\n<p>Now let‚Äôs make it interactive. We do this by introducing a set of ‚Äúactive‚Äù (draggable) points, that are coupled to differentiable coordinates.</p>\n<p>Whenever we move such a point, we set its gradient to the delta between the last drawn position and the current mouse position, and then run gradient descent to adjust the parameters of the drawing.</p>\n<p>This will tweak as many parametric aspects of the drawing as necessary to move the desired point to its new position.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet active = []\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n  active.push({x,y})\n  active.push({x: plus(x,w), y: plus(y,h)})\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawActive() {\n  ctx.strokeStyle = \"#aaaaaa\"\n  ctx.lineWidth = 2\n  for (let {x,y} of active) {\n    ctx.beginPath()\n    ctx.arc(x.val, y.val, 5, 0, 2*Math.PI)\n    ctx.stroke()\n  }\n  ctx.strokeStyle = \"black\"\n}\nfunction drawAll() {\n  tape = []\n  active = []\n  ctx.clearRect(0,0,300,150)\n  draw()\n  drawActive()\n}\nfunction findActivePoint(offsetX,offsetY) {\n  for (let i in active) {\n    let {x,y} = active[i]\n    const dx = x.val - offsetX\n    const dy = y.val - offsetY\n    if (Math.sqrt(dx*dx + dy*dy) < 5)\n      return i\n  }\n  return -1\n}\nfunction dragActivePoint(dragging,offsetX,offsetY) {\n  for (let i = 0; i<200; i++){\n    let {x,y} = active[dragging]\n    x.grad += offsetX - x.val\n    y.grad += offsetY - y.val\n    optimize()\n    drawAll()\n  }\n}\nlr = 0.01\nfunction optimize() {\n  // backprop\n  for (b of tape.reverse()) b()\n  tape = []\n  // gradient descent\n  let totaldiff = 0\n  for (let p of params) {\n    totaldiff += p.grad*p.grad\n    p.val += lr * p.grad\n    p.grad = 0\n  }\n}\ncvs.addEventListener(\"mousedown\", ev => {\n  let dragging = findActivePoint(ev.offsetX, ev.offsetY)\n  if (dragging >= 0) {\n    let drag = ev => dragActivePoint(dragging,ev.offsetX,ev.offsetY)\n    document.addEventListener(\"mousemove\", drag)\n    document.addEventListener(\"mouseup\", ev => {\n      document.removeEventListener(\"mousemove\", drag)\n    })\n  }\n})\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawAll()\n</code>\n<p>Note how dragging the top left corners only moves the rectangles, while dragging the bottom right corners also resizes them. This is because the bottom right corners create gradient updates for <code class=\"language-text\">x</code>,<code class=\"language-text\">y</code> and <code class=\"language-text\">w</code>,<code class=\"language-text\">h</code> to equals parts, instead of just <code class=\"language-text\">x</code>,<code class=\"language-text\">y</code>.</p>\n<h2>More Constraints</h2>\n<p>What if we want to have more control, such as a control handle that <em>only</em> resizes, without moving?</p>\n<p>Fortunately, we can achieve this with a relatively small change. We allow each active point to specify others that should <em>not</em> move, e.g., opposite corners of a rectangle.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n  // center\n  active.push({x: plus(x, times(w, num(0.5))),\n               y: plus(y, times(h, num(0.5))),\n               constraint: [w,h]})\n  // top left\n  active.push({x: x, y: y, constraint: [plus(x,w),plus(y,h)]})\n  // top right\n  active.push({x: plus(x,w), y: y, constraint: [x,plus(y,h)]})\n  // bottom left\n  active.push({x: x, y: plus(y,h), constraint: [plus(x,w),y]})\n  // bottom right\n  active.push({x: plus(x,w), y: plus(y,h), constraint: [x,y]})\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet constraint = []\nfunction findActivePoint(offsetX,offsetY) {\n  for (let i in active) {\n    let p = active[i]\n    const dx = p.x.val - offsetX\n    const dy = p.y.val - offsetY\n    if (Math.sqrt(dx*dx + dy*dy) < 5) {\n      constraint = (p.constraint || []).map(x => x.val)\n      return i\n    }\n  }\n  return -1\n}\nfunction dragActivePoint(dragging,offsetX,offsetY) {\n  for (let i = 0; i<200; i++){\n    let p = active[dragging]\n    p.x.grad += offsetX - p.x.val\n    p.y.grad += offsetY - p.y.val\n    for (let i in p.constraint) {\n      p.constraint[i].grad += constraint[i] - p.constraint[i].val\n    }\n    optimize()\n    drawAll()\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawAll()\n</code>\n<p>This is just another form of constraints. Active points are constrained to follow the mouse pointer when dragged (by setting their gradient to the delta between current and desired position), and stationary points are constrained to stay fixed by adjusting their gradient to the delta between their current position (which may have shifted) and the position at the start of the drag, effectively keeping them in place.</p>\n<p>Other forms of constraints are of course possible as well, e.g., to keep shapes non-overlapping, or a certain distance apart.</p>\n<h2>More Examples</h2>\n<h3>Sine Wave</h3>\n<p>Here is another example from Sketch-n-Sketch. We fix the starting x,y coordinate so dragging will be directed to only change the amplitude, not the overall position of the curve:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet [x0,y0] = [10,50]\nlet [pw,ph,psep,pamp] = [15,50,20,40].map(param)\nlet n = 14\nfunction draw() {\n  function box(i) {\n   let x = plus(num(x0), times(num(i), psep))\n   let y = minus(num(y0), times(pamp, sin(num(i*2*Math.PI/n))))\n   drawRect(x,y,pw,ph)\n  }\n  for (let i = 0; i < n; i++) box(i)\n}\ndrawAll()\n</code>\n<h3>Sliders</h3>\n<p>We can create UI elements such as interconnected sliders:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet p1 = param(20)\nlet p2 = param(20)\nfunction draw() {\n  let [x0,y0,] = [10,20]\n  function slider(p,min,max,label) {\n    ctx.fillText(label,x0+110,y0+3)\n    ctx.fillRect(x0,y0-2,100,4)\n    if (p.val < min) p.val = min\n    if (p.val > max) p.val = max\n    active.push({x:plus(num(x0),times(p,num(100/(max-min)))),y:num(y0)})\n    y0 += 20\n  }\n  slider(p1,0,100,\"p1\")\n  slider(p2,0,100,\"p2\")\n  slider(plus(p1,p2),0,200,\"p1+p2\")\n  slider(times(p1,p2),0,10000,\"p1*p2\")\n  slider(minus(num(200),plus(p1,p2)),0,200,\"200-p1-p2\")\n  slider(minus(num(100),p1),0,100,\"100-p1\")\n  slider(minus(num(100),p2),0,100,\"100-p2\")\n}\ndrawAll()\n</code>\n<p>Note how dragging the <code class=\"language-text\">p1+p2</code> or <code class=\"language-text\">p1*p2</code> will update <code class=\"language-text\">p1</code> and <code class=\"language-text\">p2</code> without any explicit backward calculation. Note also the clamping to <code class=\"language-text\">min</code> and <code class=\"language-text\">max</code> using regular control flow (an alternative would be soft clamping via gradients, or we could do both).</p>\n<h3>Connected Points and Circles</h3>\n<p>Some more examples, this time from <a href=\"http://omrelli.ug/g9/gallery/\">g9.js</a>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet px = param(80)\nlet py = param(70)\nfunction draw() {\n  active.push({x:px,y:py})\n  active.push({x:py,y:px})\n}\ndrawAll()\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet pradius = param(50)\nlet pangle = param(0)\nfunction draw() {\nlr = 0.0001\n    let [mx,my] = [num(75),num(75)]\n    let sides = 10\n    for (var i=0; i < sides; i++) {\n        let a = plus(pangle, num(i/sides * Math.PI * 2))\n        let a1 = times(num(-1),a)\n        let r1 = pradius\n        let r2 = times(r1, num(0.5))\n        active.push({x: plus(mx, times(r1, cos( a))), y: plus(my, times(r1, sin( a))) })\n        active.push({x: plus(mx, times(r2, cos(a1))), y: plus(my, times(r2, sin(a1))) })\n    }\n}\ndrawAll()\n</code>\n<p>The last example is interesting as it computes derivates for <code class=\"language-text\">sin</code> and <code class=\"language-text\">cos</code>. This requires a smaller learning rate. <a href=\"/gradient-descent-with-adam\">Adaptive optimizers such as Adam</a> might perform better on this example than the plain vanilla gradient descent we‚Äôre currently using.</p>\n<h3>Turtle Graphics</h3>\n<p>A classic example of LOGO-style turtle graphics: here is a simple spiral drawn using forward, turn, etc. commands. Varying the radius, angle, and scale leads to many different shapes. Drag the control points to explore!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet pradius = param(10)\nlet pangle = param(60)\nlet pscale = num(1.2)\nfunction draw() {\n  // turtle API\n  let [mx,my,ma] = [num(75),num(75),num(-Math.PI)]\n  active.push({x: mx, y: my })\n  ctx.beginPath()\n  ctx.moveTo(mx.val, my.val)\n  function forward(n) {\n    mx = plus(mx,times(sin(ma), n))\n    my = plus(my,times(cos(ma), n))\n    active.push({x: mx, y: my })\n    ctx.lineTo(mx.val, my.val)\n  }\n  function turn(n) {\n    ma = minus(ma, times(n, num(Math.PI/180)))\n  }\n  // turtle program: draw spiral\n  let [r,a,s] = [pradius, pangle, pscale]\n  for (let i = 0; i < 10; i++) {\n    forward(r)\n    turn(a)\n    r = times(r, s)\n  }\n  // finish up\n  ctx.stroke()\n}\ndrawAll()\n</code>\n<h2>Discussion</h2>\n<p>Related:</p>\n<ul>\n<li>G9 <a href=\"http://omrelli.ug/g9/\">http://omrelli.ug/g9/</a></li>\n<li>Basalt <a href=\"https://www.anishathalye.com/2019/12/12/constraint-based-graphic-design/\">https://www.anishathalye.com/2019/12/12/constraint-based-graphic-design/</a></li>\n<li>HN discussion of Basalt, mentions other pieces of related work <a href=\"https://news.ycombinator.com/item?id=21774018\">https://news.ycombinator.com/item?id=21774018</a></li>\n<li>Sketch-n-Sketch <a href=\"https://ravichugh.github.io/sketch-n-sketch/\">https://ravichugh.github.io/sketch-n-sketch/</a></li>\n<li>Apparatus <a href=\"http://aprt.us\">http://aprt.us</a></li>\n</ul>","fields":{"slug":"/Public/Generic/differentiable-graphics/"},"frontmatter":{"date":"2020-07-12","title":"Differentiable Programming for Interactive Graphics","description":"From parameterized drawings to interactive diagrams with differentiable programming and gradient descent.","keywords":"Gradient Descent, Interactive Graphics, AutoDiff","tags":null}}},{"node":{"excerpt":"React is a JavaScript library for building interactive user interfaces. Contrary to traditional, imperative, approaches to UI programming‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>React is a JavaScript library for building interactive user interfaces. Contrary to traditional, imperative, approaches to UI programming, React embraces ideas from functional programming.</p>\n<aside>\n<h2>Creating Web UIs Programmatically</h2>\n<p>Traditionally, web pages were largely based on static HTML, perhaps generated by server-side application logic, and maybe with a bit of JavaScript sprinkled in for interactivity.</p>\n<p>React and similar frameworks turn this model upside-down, and generate the entire DOM presentation programmatically from JS.\nClearly, a good API for this is key. The traditional, imperative, DOM API is verbose and cumbersome. Hence, React code is typically written using JSX ‚Äî JavaScript enriched with quasiquotations to embed HTML syntax ‚Äî but this layer of syntactic sugar is entirely optional.</p>\n<h3>DOM Trees: Think S-Expressions</h3>\n<p>We‚Äôll use a more direct API as our starting point. Our first version (which we will gradually refine) recomputes the full DOM for every change, which is limiting in several ways. First, it is inefficient. Second, while it supports persistent/global state, it does not support ephemeral/local state.</p>\n<p>The essence of this API is a single function <code class=\"language-text\">createElement</code> (which we‚Äôll alias to <code class=\"language-text\">e</code>) to create DOM nodes with a given set of properties and children.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  // Set properties\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  // Add children\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\n</code>\n<p>Here is a basic example. Note how we‚Äôre essentially using s-expression syntax to build DOM trees:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction greet(name) {\n  return e(\"div\",{},\"Hello, \",e(\"i\",{},name),\"!\")\n}\nrender(greet(\"World\"))\n</code>\n<h3>Functions I: Event Listeners for Interactivity</h3>\n<p>Properties may include event listeners, so we can support basic interactivity. True to our goal, we recompute the whole UI on every change:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nconst state = [{label: \"A\", count: 1}, {label: \"B\", count: 1}]\nfunction App() {\n  return e(\"div\", {}, ...state.map(Counter))\n}\nfunction Counter(state) {\n  return e(\"div\",\n    { onClick: () => update(state.count += 1) },\n    state.label, \": \", state.count)\n}\nfunction update() {\n  render(App())\n}\nrender(App())\n</code>\n<h3>Functions II: Abstracting Component Composition</h3>\n<p>Note how we can freely use functional abstraction to build components. In the current implementation, these functions are immediately evaluated to compute UI components, but they do not become part of the computed UI. Thinking about this more formally, the language of UI components does not include a case for function application. Instead, all function applications are fully normalized (beta-reduced) while computing the UI.</p>\n<p>This works OK here because the <em>entire</em> UI state is determined by the global model.</p>\n<h3>Limitation: Recomputation Discards Local State</h3>\n<p>But this is not always the case. Here is an example that doesn‚Äôt work so well. Let‚Äôs build a temperature converter:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nconst state = { val: 30 }\nfunction App() {\n  return e(\"div\", {},\n    Field(state, \"¬∞F: \", 9/5, 32),\n    Field(state, \"¬∞C: \", 1, 0))\n}\nfunction Field(state, label, factor, offset) {\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state.val*factor+offset),\n      onInput: (e) => update(state.val = (event.target.value-offset)/factor) }))\n}\nfunction update() {\n  render(App())\n}\nrender(App())\n</code>\n<p>Using this interface is quite a pain. Every time we change one of the fields, an input event is triggered that deletes the existing text fields and replaces them with identical ones. And in doing so, we throw away the ephemeral state of the input fields: keyboard focus, cursor position, etc.</p>\n</aside>\n<p>Notably, React is based on a programming model that treats the UI as immutable, which means that (conceptually) the entire UI is regenerated from a data model after every change.</p>\n<aside>\n<h2>Virtual DOM and Diff Algorithm</h2>\n<p>The key idea behind React is to prevent the situation in the previous section by decoupling ephemeral presentation state from persistent application state and to preserve the presentation state for pieces of application state that didn‚Äôt change.</p>\n<h3>Virtual DOM</h3>\n<p>React introduces a ‚Äúvirtual DOM‚Äù layer, i.e., a shallow representation of UI elements as plain JavaScript objects. How to detect change? Keep the previous version and do a diff! This process is called ‚Äúreconciliation‚Äù in React.</p>\n<p>Here is our revised implementation (much of it inspired by <a href=\"https://pomb.us/build-your-own-react/\">Rodrigo Pombo‚Äôs ‚ÄúBuild your own React‚Äù</a>). Function <code class=\"language-text\">createElement</code> just wraps its parameters in an object for later use:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: props,\n    children: children.map(child =>\n      typeof child === \"object\"\n        ? child\n        : createTextElement(child)\n      )\n  }\n}\n// Special case for plain strings: distinction\n// is not really necessary here, but it allows\n// updating \"nodeValue\" as property without\n// dispatch later\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: String(text),\n    },\n    children: []\n  }\n}\n// Create an actual DOM node\nfunction createDom(type) {\n  const dom = type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(type)\n  return dom\n}\n</code>\n<h3>Diffing Properties and Tree Structure</h3>\n<p>Given a real DOM node and old and new virtual DOM nodes, we can diff and patch object properties including event listeners:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction updateProperties(dom, prevProps, nextProps) {\n  const isNew  = key => prevProps[key] !== nextProps[key]\n  const isGone = key => !(key in nextProps)\n  // Remove old properties and event listeners\n  for (let k in prevProps) {\n    if (isEvent(k)) {\n      if (isGone(k) || isNew(k))\n        dom.removeEventListener(eventName(k), prevProps[k])\n    } else {\n      if (isGone(k))\n        dom[k] = \"\"\n    }\n  }\n  // Remove new/updated properties and event listeners\n  for (let k in nextProps) {\n    if (isEvent(k)) {\n      if (isNew(k))\n        dom.addEventListener(eventName(k), nextProps[k])\n    } else {\n      if (isNew(k) && dom[k] != nextProps[k])\n        dom[k] = nextProps[k]\n    }\n  }\n}\n</code>\n<p>And we proceed recursively to diff and patch DOM children, dealing with newly inserted and removed nodes appropriately:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      newChild.dom = oldChild.dom\n      updateProperties(newChild.dom, oldChild.props, newChild.props)\n      updateChildren(newChild.dom, oldChild.children, newChild.children)\n    } else {\n    if (oldChild) {\n      domParent.removeChild(oldChild.dom)\n    }\n    if (newChild) {\n      newChild.dom = createDom(newChild.type),\n      updateProperties(newChild.dom, {}, newChild.props)\n      updateChildren(newChild.dom, [], newChild.children)\n      domParent.appendChild(newChild.dom)\n    }\n    }\n  }\n}\n</code>\n<h3>Top Level &#x26; Improved Example</h3>\n<p>Finally, the <code class=\"language-text\">render</code> method remembers the previous version\nand triggers reconciliation:\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nlet currentRoot = []\nfunction render(element, container=o) {\nupdateChildren(container, currentRoot, [element])\ncurrentRoot = [element]\n}\n// internal: cleanup on recompile\nonclear(() => updateChildren(o,currentRoot,[]))\n</code></p>\n<p>Here is the temperature converter example again (code is unchanged):</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nconst state = { val: 30 }\nfunction App() {\n  return e(\"div\", {},\n    Field(state, \"¬∞F: \", 9/5, 32),\n    Field(state, \"¬∞C: \", 1, 0))\n}\nfunction Field(state, label, factor, offset) {\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state.val*factor+offset),\n      onInput: (e) => update(state.val = (event.target.value-offset)/factor) }))\n}\nfunction update() {\n  render(App(),o)\n}\nrender(App(),o)\n</code>\n<p>This is much better than before! Since physical DOM nodes are preserved, we no longer lose any ephemeral state.</p>\n<h3>Diff Algorithm Considerations I: How to Compare</h3>\n<p>The diff algorithm used here (also in the real React) is quite simplistic. This is a conscious choice. First, diffs are computed on trees so the natural hierarchy already provides significant structure. Doing a ‚Äúproper‚Äù diff on the sequence of child nodes would be too expensive for many uses, with unclear practical benefits.</p>\n<p>Clearly there are cases where this is too simple, in particular when elements are reordered. For such situations, React provides a facility to diff child nodes by a computed key instead of by numeric index within the parent.</p>\n<p><strong>Exercise:</strong> implement reconciliation by key.</p>\n<p>See also: <a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation</a> chapter of the React.js docs.</p>\n<h3>Diff Algorithm Considerations II: What to Compare</h3>\n<p>Another question is what to diff against, and again there are some choices: in the code above, we diff the freshly computed virtual DOM with the previous virtual DOM. An alternative would be to diff the new virtual DOM against the real mutable DOM (in fact, we‚Äôre also looking at the real DOM for property updates, since the real DOM can be changed through user actions). Keeping the previous virtual DOM around becomes necessary once we add additional structure that is not present in the real DOM (virtual components, in the next section).</p>\n<p>Virtual DOM trees are treated by design as immutable. However, we‚Äôre taking a little shortcut by mutably adding a reference to the physical DOM node.</p>\n<p>This works fine for most cases, but what if we want to use a single child node in multiple places? Then we have a problem: we‚Äôd try add <em>two</em> physical DOM references to the same virtual DOM node. We should be allowed to freely share virtual DOM nodes, but in our implementation this won‚Äôt work (not without an explicit copy operation).</p>\n<p>The solution is to create a mutable ‚Äúaugmented DOM‚Äù that represents the currently installed state. This is what React does, as part of its Fiber data structure.</p>\n<p><strong>Exercise:</strong> implement mutable augmented DOM.</p>\n</aside>\n<p>A key obstacle to making this approach work in practice is that UIs contain a lot of ephemeral state that is not determined by the data model (selections, cursor and scroll positions, etc). To deal with this, React diffs the new UI from the previous version, and carefully patches underlying mutable UI widgets to preserve local emphemeral state across updates.</p>\n<aside>\n<h2>Components, Life Cycle, State</h2>\n<p>Of course we want to be able to define our own local state in higher-level UI components, in addition to state embedded in DOM nodes. For example, which tab is shown, which items are selected, etc.</p>\n<p>The key idea is to replicate what we did for the physical DOM in the virtual DOM: maintain a mutable component instance that, once created, is shared by all ‚Äúversions‚Äù of the component.</p>\n<p>In addition, we want to support local updates to the tree. Whenever a component changes, only the components below should be recomputed, not the whole tree.</p>\n<p>Finally, we want to suppport lifecycle callbacks. In many cases, a component needs to perform some cleanup once it‚Äôs removed from the tree (e.g., close a network connection or deinstall a timer).</p>\n<p>The basics of the implementation remain the same. Only the diff and update code gets some extra cases:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction renderSubTree(newChildInst) {\n  let newSub = [newChildInst.type(newChildInst)]\n  updateChildren(newChildInst.domParent, newChildInst.sub, newSub)\n  newChildInst.sub = newSub\n}\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      if (newChild.type instanceof Function) {\n        let oldSub = oldChild.instance.sub\n        newChild.instance = oldChild.instance\n        newChild.instance.type = newChild.type\n        newChild.instance.props = newChild.props\n        newChild.instance.children = newChild.children\n        newChild.instance.domParent = domParent\n        newChild.instance.sub = [newChild.type(newChild.instance)]\n        updateChildren(domParent, oldSub, newChild.instance.sub)\n      } else {\n        newChild.dom = oldChild.dom\n        updateProperties(newChild.dom, oldChild.props, newChild.props)\n        updateChildren(newChild.dom, oldChild.children, newChild.children)\n      }\n    } else {\n      if (oldChild) {\n        if (oldChild.type instanceof Function) {\n          if (oldChild.instance.componentWillUnmount)\n            oldChild.instance.componentWillUnmount()\n          updateChildren(domParent, oldChild.instance.sub, [])\n        } else {\n          domParent.removeChild(oldChild.dom)\n          // make sure all cleanup handlers are called\n          updateChildren(oldChild.dom, oldChild.children, [])\n        }\n      }\n      if (newChild) {\n        if (newChild.type instanceof Function) {\n          // instance is uninitialized\n          newChild.instance = {}\n          newChild.instance.type = newChild.type\n          newChild.instance.props = newChild.props\n          newChild.instance.children = newChild.children\n          newChild.instance.domParent = domParent\n          newChild.instance.sub = [newChild.type(newChild.instance)]\n          updateChildren(domParent, [], newChild.instance.sub)\n        } else {\n          newChild.dom = createDom(newChild.type),\n          updateProperties(newChild.dom, {}, newChild.props)\n          updateChildren(newChild.dom, [], newChild.children)\n          domParent.appendChild(newChild.dom)\n        }\n      }\n    }\n  }\n}\n</code>\n<h3>Local State</h3>\n<p>Here is the temperature converter again, now using local component state:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example\nfunction App(self) {\n  if (self.state == undefined)\n    self.state = 30\n  const setState = (x => self.state = x)\n  return e(\"div\", {}, \"Foo\",\n    e(Field, { state: self.state, setState: setState, label: \"¬∞F: \", factor: 9/5, offset: 32}),\n    e(Field, { state: self.state, setState: setState, label: \"¬∞C: \", factor: 1, offset: 0}))\n}\nfunction Field(self) {\n  const { state, setState, label, factor, offset } = self.props\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state*factor+offset),\n      onInput: (e) => setState((event.target.value-offset)/factor) }))\n}\nrender(e(App,{}),o)\n</code>\n<h3>Nested Local State</h3>\n<p>Nested state work as expected, too:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer(self) {\n  if (self.v == undefined)\n    self.v = 0\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(self) {\n  const [oSt,oSetSt] = self.props.outerState\n  if (self.v == undefined)\n    self.v = oSt\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nrender(e(Outer),o)\n</code>\n<p>Clicking on ‚ÄúOuter‚Äù or ‚ÄúInner‚Äù will increment the respective counter.</p>\n<h3>Asynchronicity and Life Cycle Management</h3>\n<p>We can support asynchronous interaction, e.g. using a timer:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer(self) {\n  if (self.v == undefined)\n    self.v = 0\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  return e(Inner,{outerState: [self.v, setState]})\n}\nfunction Inner(self) {\n  const [oSt,oSetSt] = self.props.outerState\n  if (self.v == undefined)\n    self.v = oSt\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  if (self.timer == undefined) {\n    self.timer = setInterval(() => iSetSt(s=>s-1), 1000)\n    console.log(\"start \",self.timer)\n  }\n  self.componentWillUnmount = () => {\n    console.log(\"stop \",self.timer)\n    clearInterval(self.timer)\n  }\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n<p>Once started, the timer will run forever if we don‚Äôt shut it down. We can invoke such cleanup logic using <code class=\"language-text\">componentWillUnmount</code>.</p>\n</aside>\n<p>React implements a tree of components, with data flowing unidirectionally from parents to children. The conceptual model of a component is a function from data to UI, with lifecycle callbacks (invoked when added/removed from tree), and optional local state. Whenever a child component wants to update state higher up in the tree, the corresponding subtree will be regenerated based on the new state of the ancestor.</p>\n<aside>\n<h2>State and Effect Hooks API</h2>\n<p>It is useful to encapsulate state and lifecycle management further, using functional abstractions. React provides a ‚Äúhooks‚Äù API, which developers can use to parameterize, compose, and abstracted over component behavior using functional techniques.</p>\n<h3>The useState and useEffect Hooks</h3>\n<p>The use of hooks allows us to hide the mutable component instance from the user-facing API entirely, accessing it only internally in a sort of dynamically scoped way during component evaluation.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet currentInstance = null\nfunction useState(init) {\n  let inst = currentInstance.self\n  let i = currentInstance.hookIndex++\n  if (i < inst.hooks.length)\n    return inst.hooks[i]\n  let update = (f => renderSubTree(inst, inst.hooks[i][0] = f(inst.hooks[i][0])))\n  return inst.hooks[i] = [init, update]\n}\nfunction useEffect(f,watch) {\n  let inst = currentInstance.self\n  let i = currentInstance.effectIndex++\n  if (i < inst.effects.length) {\n    let [g1,w1] = inst.effects[i]\n    if (watch != undefined && arraysMatch(w1,watch))\n      return\n    if (g1) g1()\n  }\n  inst.effects[i] = [f(),watch]\n}\nfunction arraysMatch(arr1, arr2) {\n  if (arr1.length !== arr2.length) return false;\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) return false;\n  }\n  return true;\n}\nfunction renderInstance(instance) {\n  let save = currentInstance\n  currentInstance = { self: instance, hookIndex: 0, effectIndex: 0 }\n  let res = instance.type(instance.props, instance.children)\n  currentInstance = save\n  return res\n}\n</code>\n<p>We refactor <code class=\"language-text\">updateChildren</code> slightly to reduce code duplication between the insert and update cases.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction renderSubTree(instance) {\n  let oldSub = instance.sub\n  instance.sub = [renderInstance(instance)]\n  updateChildren(instance.domParent, oldSub, instance.sub)\n}\nfunction updateInstance(domParent, instance, newChild) {\n  let oldSub = instance.sub\n  newChild.instance = instance\n  instance.type = newChild.type\n  instance.props = newChild.props\n  instance.children = newChild.children\n  instance.domParent = domParent\n  instance.sub = [renderInstance(instance)]\n  updateChildren(domParent, oldSub, instance.sub)\n}\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      if (newChild.type instanceof Function) {\n        updateInstance(domParent, oldChild.instance, newChild)\n      } else {\n        newChild.dom = oldChild.dom\n        updateProperties(newChild.dom, oldChild.props, newChild.props)\n        updateChildren(newChild.dom, oldChild.children, newChild.children)\n      }\n    } else {\n      if (oldChild) {\n        if (oldChild.type instanceof Function) {\n          for (let [g,w] of oldChild.instance.effects) if (g) g()\n          updateChildren(domParent, oldChild.instance.sub, [])\n        } else {\n          domParent.removeChild(oldChild.dom)\n          // make sure all cleanup handlers are called\n          updateChildren(oldChild.dom, oldChild.children, [])\n        }\n      }\n      if (newChild) {\n        if (newChild.type instanceof Function) {\n          // instance is uninitialized\n          updateInstance(domParent, {sub: [], hooks: [], effects: []}, newChild)\n        } else {\n          newChild.dom = createDom(newChild.type),\n          updateProperties(newChild.dom, {}, newChild.props)\n          updateChildren(newChild.dom, [], newChild.children)\n          domParent.appendChild(newChild.dom)\n        }\n      }\n    }\n  }\n}\n</code>\n<p>Here is the timer example again, using hooks <code class=\"language-text\">useState</code> and <code class=\"language-text\">useEffect</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer() {\n  const [iSt,iSetSt] = useState(0)\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(props) {\n  const [oSt,oSetSt] = props.outerState\n  const [iSt,iSetSt] = useState(oSt)\n  useEffect(() => {\n    let timer = setInterval(() => iSetSt(s=>s-1), 1000)\n    return () => clearInterval(timer)\n  }, [])\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n<h3>Custom Hooks: Reusable Interaction Patterns</h3>\n<p>The <code class=\"language-text\">useEffect</code> hook executes the provided function on\ncomponent insertion, and on updates whenever the second\nargument changes (<code class=\"language-text\">[]</code> in this case, so never).\nThe function returned from the provided one is installed\nas a cleanup callback.</p>\n<p>Based on this definition, we can extract the timer handling\ninto a new custom hook, <code class=\"language-text\">useTimer</code>, which can be reused by\nother components:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet useTimer = (f, n) => useEffect(() => {\n  let timer = setInterval(f, n)\n  return () => clearInterval(timer)\n}, [])\nfunction Outer() {\n  const [iSt,iSetSt] = useState(0)\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(props) {\n  const [oSt,oSetSt] = props.outerState\n  const [iSt,iSetSt] = useState(oSt)\n  useTimer(() => iSetSt(s=>s-1), 1000)\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n</aside>\n<p>State management and other side effects are defined as ‚Äúhooks‚Äù in React, using a higher-order functional API. This means that component behavior can be parameterized, composed, and abstracted over using functional\ntechniques.</p>\n<aside>\n<h2>Asynchronous Updates</h2>\n<p>Right now we update (re-render) only the relevant subtrees, which is good. But we‚Äôre updating them synchronously. If there are two subsequent modifications of the same component, we‚Äôll update it twice. If we modify a child, then the parent, the child gets updated twice.</p>\n<h3>Async Updates</h3>\n<p>Better idea: schedule updates in a work queue, and batch-process them later. When processing, order by distance from the root. This way, parents are processed before children. Maintain a dirty flag on components, so that redundant children can be skipped.</p>\n<h3>Async State Management</h3>\n<p>Directly modifying component state but processing DOM updates asynchronously may lead to some inconsistencies (state is state, so inconsistencies may have other causes as well).</p>\n<p>To reduce inconsistencies, do not modify component state directly, but schedule state updates <code class=\"language-text\">s => f(s)</code> for batch processing, too (can be done during reconciliation).</p>\n<p>The dirty flag on components becomes a queue of state transitions to apply. If empty, the component is up to date and doesn‚Äôt need re-rendering (unless props have changed).</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://github.com/facebook/react/issues/11527\">https://github.com/facebook/react/issues/11527</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/11527#issuecomment-360199710\">https://github.com/facebook/react/issues/11527#issuecomment-360199710</a></li>\n</ul>\n<h3>Incremental Reconciliation</h3>\n<p>Reconciliation may take time, so there are benefits in making it interruptible. This is easy to do at the granularity of a worklist (non-overlapping subtrees), but for large trees it is worth to chunk up traversal of children. Standard methods exist to make a recursive traversal interruptible. React uses a Zipper-like data structure they call a fiber (a tree node with parent and sibling pointers). A simpler option in JS is async/await.</p>\n<p>It is still important that DOM modifications are applied atomically. After all, we don‚Äôt want to see a partially updated UI. Hence, React splits processing into a ‚Äúrender‚Äù and a ‚Äúcommit‚Äù phase. The (interruptible) render phase does all the diffing and determines necessary DOM changes, and the commit phase applies the final changes in a single atomic step.</p>\n<p>There is some overhead associated with maintaining data structures for this phase separation. Presumably these are outweighed by the benefits of incrementality in some cases but not all.</p>\n<h3>Concurrency</h3>\n<p>It is sometimes desirable to not process updates strictly in order, but according to priorities. This way, a response to clicks or key presses may be processed immediately, while, for example, updates due to incoming network data may be batched a little bit to enable processing in larger chunks (to keep the UI responsive to user actions).</p>\n</aside>\n<p>React always keeps the component tree in a consistent state, which provides considerable freedom for asynchronous processing, such as batching or prioritizing updates.</p>\n<aside>\n<h2>Discussion</h2>\n<p>At its core, React is a system for computing incremental updates on conceptually immutable trees. Children are computed from parents, and may contain independent local state. Information flows downward in the tree, from parents to children. Children may request a change further up the tree, which will trigger recomputation of the affected part of the tree.</p>\n<p>The basic design permits several degrees of freedom, including:</p>\n<ul>\n<li>What and how to diff (reconciliation by key, etc.)</li>\n<li>Synchronous and asynchronous processing (decoupling effect logic)</li>\n<li>User-defined functional abstractions (components, hooks, etc.)</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://pomb.us/build-your-own-react/\">Build your own React</a> by Rodrigo Pompbo</li>\n<li><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a></li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation</a> from the React.js docs</li>\n<li>State handling <a href=\"https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key\">broken</a> and <a href=\"https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key\">fixed</a> using keys</li>\n<li><a href=\"http://todomvc.com/examples/react/#/\">TodoMvc</a> example in React</li>\n<li>Dealing with input React Mental Models: Working With <code class=\"language-text\">&lt;input></code> | Learn React.Design Backstories <a href=\"https://learnreact.design/2020/03/31/react-mental-models-working-with-input\">https://learnreact.design/2020/03/31/react-mental-models-working-with-input</a> HN: React Mental Models: Working with Input | Hacker News <a href=\"https://news.ycombinator.com/item?id=22761622\">https://news.ycombinator.com/item?id=22761622</a></li>\n<li>A visual guide to React Mental models, part 2: useState, useEffect and lifecycles | Obed Parlapiano - JavaScript Engineer &#x26; Writer <a href=\"https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/\">https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/</a></li>\n</ul>\n</aside>","fields":{"slug":"/Public/Generic/deconstructing-react/"},"frontmatter":{"date":"2020-07-07","title":"Deconstructing React","description":"How does React work? Let's build a React clone from scratch to understand.","keywords":"JavaScript, React, State, Hook, Virtual DOM, Diff, Reconciliation, Async","tags":null}}},{"node":{"excerpt":"Device APIs allow web pages to interface with the physical world, blending the boundary between web and native apps.\nPhones and tablets come‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Device APIs allow web pages to interface with the physical world, blending the boundary between web and native apps.\nPhones and tablets come with a variety of sensors, and web APIs exist for many of them. Below are examples for the most interesting ones.</p>\n<p>References:</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals\">Google developer pages</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API\">Mozilla developer‚Äôs network (MDN)</a></li>\n</ul>\n<h2>Touch</h2>\n<p>Finger and stylus, sensitive to touch size, pressure, tilt.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!window.PointerEvent)\n  return print(\"PointerEvent not supported\")\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 600\ncvs.height = 300\nlet ctx = cvs.getContext(\"2d\")\nctx.strokeRect(0,0,cvs.width,cvs.height)\no.appendChild(cvs)\nlet msg = document.createElement(\"small\")\no.appendChild(msg)\nfunction show(e) {\n  msg.innerText = e+\"\\n\"\n}\nshow(\"navigator.maxTouchPoints: \"+ navigator.maxTouchPoints)\ncvs.style.touchAction=\"none\" // prevent scrolling\ncvs.addEventListener(\"pointerdown\", ev => {\n  cvs.setPointerCapture(ev.pointerId)\n  ev.preventDefault()\n  ev.stopPropagation()\n  // ev.stopImmediatePropagation() // necessary?\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointermove\", ev => {\n  ev.preventDefault()\n  ev.stopPropagation()\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointerup\", ev => {\n  ev.preventDefault()\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointercancel\", ev => {\n  ev.preventDefault()\n  drawTouch(ev)\n})\nfunction drawTouch(ev) {\n  show(ev.type + \"/\" + ev.pointerType + \"\\n\"+\n   \"width: \"+ev.width +\", \" +\n   \"height: \"+ev.height +\"\\n\" +\n   \"button: \"+ev.button +\", \" +\n   \"buttons: \"+ev.buttons +\"\\n\" +\n   \"pressure: \"+ev.pressure +\", \" +\n   \"tangentialPressure: \"+ev.tangentialPressure +\", \" +\n   \"webkitForce: \"+ev.webkitForce +\"\\n\" +\n   \"tiltX: \"+ev.tiltX +\", \" +\n   \"tiltY: \"+ev.tiltY\n  )\n  // debug: print all fields\n  // for (k in ev) msg.innerText += (k+\"\\n\")\n  let rect = cvs.getBoundingClientRect()\n  let x = ev.clientX-rect.left\n  let y = ev.clientY-rect.top\n  if (ev.pointerType == \"touch\") {\n    let rx = ev.width\n    let ry = ev.height\n    ctx.fillStyle = \"white\"\n    ctx.fillRect(x-rx/2,y-ry/2,rx,ry)\n    ctx.strokeRect(x-rx/2,y-ry/2,rx,ry)\n  } else if (ev.pointerType == \"pen\") {\n    let r = ev.pressure * 100\n    let tanX = Math.tan(ev.tiltX/180*Math.PI)\n    let tanY = Math.tan(ev.tiltY/180*Math.PI)\n    let azimuth = Math.atan2(tanY,tanX)\n    let altitude =Math.atan2(1, Math.sqrt(tanX*tanX+tanY*tanY))\n    let rx = r+Math.cos(altitude) * r\n    let ry = r\n    ctx.beginPath()\n    ctx.ellipse(x,y,rx,ry,azimuth,0,2*Math.PI)\n    ctx.fillStyle = \"white\"\n    ctx.closePath()\n    ctx.fill()\n    ctx.stroke()\n  } else {\n    let rx = ev.width\n    let ry = ev.height\n    ctx.fillStyle = \"white\"\n    ctx.fillRect(x-rx/2,y-ry/2,rx,ry)\n    ctx.strokeRect(x-rx/2,y-ry/2,rx,ry)\n  }\n}\n</code>\n<p>This example uses ‚Äòpointer events‚Äô, which are the new emerging standard for unifying touch and mouse events. Tested on a 2018 iPad Pro with Apple Pencil, running Safari 13.</p>\n<p>Some notes: <code class=\"language-text\">setPointerCapture</code> is necessary to continue receiving <code class=\"language-text\">pointermove</code> events after leaving the canvas, <code class=\"language-text\">touch-action=none</code> is necessary to prevent scrolling. On iPad, finger touches have size but no pressure. The first touch with a pencil appears to register with higher pressure than subsequent ones. Finger and stylus touches are mutually exclusive, presumably to enable hand-resting on the surface while drawing or writing.</p>\n<p>Desktop Safari (13.1) currently doesn‚Äôt report trackpad pressure for pointer events. There is a separate and non-standard set of events for this (<code class=\"language-text\">webkitmouseforcewillbegin</code>, <code class=\"language-text\">webkitmouseforcedown</code>,<code class=\"language-text\"> webkitmouseforcechanged</code>, <code class=\"language-text\">webkitmouseforceup</code>).</p>\n<p>See also: <a href=\"https://patrickhlauke.github.io/getting-touchy-presentation/\">https://patrickhlauke.github.io/getting-touchy-presentation/</a></p>\n<h2>Motion &#x26; Orientation</h2>\n<p>Accelerometer, Gyroscope, Compass.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!window.DeviceMotionEvent)\n  return print(\"DeviceMotionEvent not supported\")\nsizeX = 300\nsizeY = 150\nlet cvs = document.createElement(\"canvas\")\ncvs.width = sizeX\ncvs.height = sizeY\nlet ctx = cvs.getContext(\"2d\")\no.appendChild(cvs)\nlet msg = document.createElement(\"small\")\no.appendChild(msg)\nfunction show(e) {\n  msg.innerText = e+\"\\n\"\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => { DeviceMotionEvent.requestPermission().then(res => {\n  if (res != 'granted')\n    return print(\"Error: \"+res)\n  window.addEventListener(\"devicemotion\", motion)\n  window.addEventListener(\"deviceorientation\", orientation)\n  let a = document.createElement(\"div\")\n  let b = document.createElement(\"div\")\n  let g = document.createElement(\"div\")\n  let c = document.createElement(\"div\")\n  let x = document.createElement(\"div\")\n  let y = document.createElement(\"div\")\n  let z = document.createElement(\"div\")\n  o.appendChild(x)\n  o.appendChild(y)\n  o.appendChild(z)\n  o.appendChild(a)\n  o.appendChild(b)\n  o.appendChild(g)\n  o.appendChild(c)\n  function motion(ev) {\n    ctx.clearRect(0,0,100,sizeY)\n    ctx.fillRect(10,sizeY/2,20,-10*ev.acceleration.x)\n    ctx.fillRect(40,sizeY/2,20,-10*ev.acceleration.y)\n    ctx.fillRect(70,sizeY/2,20,-10*ev.acceleration.z)\n    x.innerText = \"\"+ev.acceleration.x\n    y.innerText = \"\"+ ev.acceleration.y\n    z.innerText = \"\"+ ev.acceleration.z\n  }\n  function orientation(ev) {\n    ctx.clearRect(100,0,sizeX,sizeY)\n    let r = 15\n    function drawDial(x,angle) {\n      let dx = r * Math.cos(angle/180*Math.PI)\n      let dy = r * Math.sin(angle/180*Math.PI)\n      ctx.beginPath()\n      ctx.moveTo(x,sizeY/2)\n      ctx.lineTo(x+dx,sizeY/2+dy)\n      ctx.stroke()\n      ctx.beginPath()\n      ctx.arc(x,sizeY/2,r,0,2*Math.PI)\n      ctx.stroke()\n    }\n    drawDial(110,ev.alpha)\n    drawDial(140,ev.beta)\n    drawDial(170,ev.gamma)\n    drawDial(210,ev.webkitCompassHeading)\n    a.innerText = \"\"+ev.alpha\n    b.innerText = \"\"+ ev.beta\n    g.innerText = \"\"+ ev.gamma\n    c.innerText = \"\"+ ev.webkitCompassHeading\n  }\n  button(\"stop\", () => {\n    window.removeEventListener(\"devicemotion\", motion)\n    window.removeEventListener(\"deviceorientation\", orientation)\n  })\n})})\n</code>\n<h2>Location</h2>\n<p>Via GPS or Wifi.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!navigator.geolocation)\n  return print(\"geolocation not supported\")\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nbutton(\"start\", ev => {\n  function success(pos) {\n    print(\"Latitude: \" + pos.coords.latitude)\n    print(\"Longitude: \" + pos.coords.longitude)\n  }\n  function error(err) {\n    print(\"Error: \"+err.message)\n  }\n  navigator.geolocation.getCurrentPosition(success, error)\n})\n</code>\n<p>In addition to <code class=\"language-text\">getCurrentPosition</code>, there is also <code class=\"language-text\">watchCurrentPosition</code>, which provides continuous updates (returns a watch id, clean up with <code class=\"language-text\">clearWatch</code>). Both calls support some options (passed as third argument): <code class=\"language-text\">enableHighAccuracy</code>, <code class=\"language-text\">maximumAge</code>, <code class=\"language-text\">timeout</code>.</p>\n<h2>Microphone</h2>\n<p>Capture audio input, do an FFT on the fly, and draw a frequency spectrum.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => {\n  navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(handleSuccess)})\nfunction handleSuccess(stream) {\n    // console.log(stream)\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      // console.log(devices)\n      for (d of devices) print(d.kind,d.label)\n    })\n    // set up canvas\n    let WIDTH = 600\n    let HEIGHT = 100\n    let cvs = document.createElement(\"canvas\")\n    cvs.width = WIDTH\n    cvs.height = HEIGHT\n    let ctx = cvs.getContext(\"2d\")\n    o.appendChild(cvs)\n    print(\"\")\n    let msg = document.createElement(\"small\")\n    o.appendChild(msg)\n    print(\"\")\n    // set up audio\n    if (!window.audioContext)\n      window.audioContext = new (window.webkitAudioContext||AudioContext)();\n    const context = window.audioContext\n    const source = context.createMediaStreamSource(stream);\n    const analyser = context.createAnalyser()\n    analyser.minDecibels = -50;\n    analyser.maxDecibels = -5;\n    analyser.smoothingTimeConstant = 0.85;\n    source.connect(analyser);\n    // analyser.connect(context.destination); // if we want sound output\n    analyser.fftSize = 4096;\n    var bufferLength = analyser.frequencyBinCount;\n    var dataArray = new Float32Array(bufferLength);\n    // stop button\n    button(\"stop\", ev => {\n      stream.getTracks().forEach(track=>track.stop())\n      source.disconnect()\n      analyser.disconnect()\n      cancelAnimationFrame(drawId)\n    })\n    // drawing loop\n    let drawId = requestAnimationFrame(draw)\n    function draw() {\n      analyser.getFloatFrequencyData(dataArray);\n      // compute peak frequency\n      let max = 0\n      let maxi = 0\n      for(let i = 20; i < bufferLength; i++) {\n        if (dataArray[i]+200 > max) {\n          max = dataArray[i]+200\n          maxi = i\n        }\n      }\n/*\nWhat is the frequency at i?\nLinear scale from 0 to window.audioContext.sampleRate/2 (typically 44100/2 = 22050, so each step is 22050/fftSize)\n*/\n// Some note indexes, calibrated by xylophone\n// (these are C6, C7, ...):\n// C  97 194\n// D 109 218\n// E 122 245\n// F 130 259\n// G 146\n// A 163\n// H 183\n      let freq = window.audioContext.sampleRate/2/(bufferLength-1)*maxi\n      msg.innerText = \"peak: \" + Math.round(freq) + \" Hz (index \" + maxi + \")\"\n      // draw spectrum\n      ctx.clearRect(0, 0, WIDTH, HEIGHT)\n      let barCount = bufferLength/2\n      let barWidth = (WIDTH / barCount) * 2.5\n      let barHeight\n      let x = 0\n      for(let i = 0; i < barCount; i++) {\n        barHeight = (dataArray[i] + 100)*2\n        //ctx.fillStyle = 'rgb(' + Math.floor(barHeight+100) + ',50,50)'\n        ctx.fillRect(x,HEIGHT-barHeight/2,barWidth,barHeight/2)\n        x += barWidth + 1\n      }\n      drawId = requestAnimationFrame(draw)\n    }\n}\n/*\n    Alternative to manually process raw audio:\n    const processor = context.createScriptProcessor(1024, 1, 1)\n    source.connect(processor)\n    processor.connect(context.destination)\n    processor.onaudioprocess = function(e) {\n      // Process the data ...\n      //console.log(e.inputBuffer)\n    }\n*/\n</code>\n<p>Given the frequency spectrum data we can detect peaks using a simple threshold scheme. This is almost useable as a guitar tuner, but not quite (resolution of FFT at low frequencies is not high enough, so typical tuner apps use other algorithms, typically based on autocorrelation in the time domain).</p>\n<p>See also: <a href=\"https://mdn.github.io/voice-change-o-matic/\">https://mdn.github.io/voice-change-o-matic/</a></p>\n<h2>Camera</h2>\n<p>Show camera input, and grab frames by drawing to a canvas.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => {\n  navigator.mediaDevices.getUserMedia({ audio: true, video: true }).then(handleSuccess)})\nfunction handleSuccess(stream) {\n    // console.log(stream)\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      // console.log(devices)\n      for (d of devices) print(d.kind,d.label)\n    })\n    // set up canvas\n    let WIDTH = 600\n    let HEIGHT = WIDTH/4*3\n    // msg not used ...\n    // let msg = document.createElement(\"small\")\n    // o.appendChild(msg)\n    print(\"\")\n    // video elem\n    let vid = document.createElement(\"video\")\n    vid.autoplay = true\n    vid.width = WIDTH\n    vid.height = HEIGHT\n    vid.srcObject = stream\n    o.appendChild(vid)\n    print(\"\")\n    // snapshot button\n    button(\"snapshot\", ev => {\n      let cvs = document.createElement(\"canvas\")\n      cvs.width = WIDTH/3\n      cvs.height = HEIGHT/3\n      o.appendChild(cvs)\n      let ctx = cvs.getContext(\"2d\")\n      ctx.drawImage(vid,0,0,cvs.width,cvs.height)\n    })\n    // stop button\n    button(\"stop\", ev => {\n      stream.getTracks().forEach(track=>track.stop())\n      cancelAnimationFrame(drawId)\n    })\n    // drawing loop\n    //let drawId = requestAnimationFrame(draw)\n    //function draw() {\n    //  drawId = requestAnimationFrame(draw)\n    //}\n}\n</code>\n<p>Video DOM elements can be styled using CSS, so it‚Äôs possible to add filters or other transformations in that way. Video frames can be drawn to a canvas (like above) or also serve as texture in a WebGL context.</p>\n<p>See also: <a href=\"https://www.html5rocks.com/en/tutorials/getusermedia/intro/\">https://www.html5rocks.com/en/tutorials/getusermedia/intro/</a></p>\n<p>To get access to raw pixel data, first draw a video frame to a canvas, and then read back pixel data from the canvas using <code class=\"language-text\">ctx.getImageData</code>. This enables CPU processing using JS or, potentially, WASM. For GPU processing, once loaded as a WebGL texture, a video frame can be processed using vertex and fragment shaders.</p>\n<p>See also: <a href=\"https://developers.google.com/web/fundamentals/media/manipulating/live-effects\">https://developers.google.com/web/fundamentals/media/manipulating/live-effects</a></p>","fields":{"slug":"/Public/Generic/touch-camera-device-apis/"},"frontmatter":{"date":"2020-07-04","title":"Touch, Camera, and Other Device APIs","description":"How to enable touch and stylus input, and access the accelerometer, compass, GPS, microphone, and camera in your device from JS.","keywords":"Device API, Touch Events, Pointer Events, Stylus, DeviceMotion Event, Accelerometer, Geolocation, Microphone, Camera, Web, JavaScript","tags":null}}},{"node":{"excerpt":"Graphs are everywhere, and it‚Äôs often useful to visualize them. We can use tools like GraphViz to do so, or TikZ, Mathematica, or D3. But‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Graphs are everywhere, and it‚Äôs often useful to visualize them. We can use tools like GraphViz to do so, or TikZ, Mathematica, or D3. But how does GraphViz work? And what if we wanted to draw nice-looking graphs ourselves from scratch?</p>\n<p>We can think about drawing graphs as two separate problems. One is determining where to place each node and edge (‚ÄúFrontend‚Äù). The other is to actually draw them once positions are determined (‚ÄúBackend‚Äù). We‚Äôll go bottom-up and start with the backend.</p>\n<aside>\n<h2>Backend</h2>\n<p>In this section we‚Äôll assume we already know where to place graph nodes. We‚Äôll treat ways to automate this below under <a href=\"/graphs-frontend\">Frontend</a>.</p>\n<p>Let‚Äôs create a place to draw.</p>\n<code class=\"runScript\" filter=\"setPreamble\" popout=\"true\">\nlet cvs = null\nlet ctx = null\nlet sizeX = 300\nlet sizeY = 100\nfunction createCanvas() {\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.width = sizeX\n  cvs.height = sizeY\n  ctx = cvs.getContext(\"2d\")\n  ctx.lineWidth = 1\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n}\n</code>\n<h3>Boxes</h3>\n<p>Here‚Äôs our first graph. Just a single node, i.e., a box and a label:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\nctx.strokeRect(10, 10, 80, 80)\nctx.fillText(\"A\", 50, 50)\n</code>\n<p>We‚Äôre going to draw more boxes, so let‚Äôs define\na few auxiliaries.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// Fix some parameters\nlet boxX = 20\nlet boxY = 20\n</code>\n<p>Wrap it up in a function that draws labeled boxes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// Draw a box with label n centered around point x,y\nfunction drawBox(n, x, y) {\n  ctx.strokeRect(x-boxX/2, y-boxY/2, boxX, boxY)\n  ctx.fillText(n, x, y, boxX)\n}\n</code>\n<p>Cool. Now this works:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\n</code>\n<h3>Lines</h3>\n<p>Now let‚Äôs draw some lines:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction drawLine(x1, y1, x2, y2) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawLine(20, 20, 80, 20)\ndrawLine(20, 20, 80, 80)\n</code>\n<p>That‚Äôs not ideal. We want lines to stop at the edges of boxes. An easy way is to adjust by <code class=\"language-text\">boxX/2</code> or <code class=\"language-text\">boxY/2</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawLine(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const skipX = dx < dy  ? 0 : x2 > x1 ? boxX/2 : -boxX/2\n  const skipY = dx >= dy ? 0 : y2 > y1 ? boxY/2 : -boxY/2\n  ctx.beginPath()\n  ctx.moveTo(x1+skipX, y1+skipY)\n  ctx.lineTo(x2-skipX, y2-skipY)\n  ctx.stroke()\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawBox(\"D\", 20, 80)\ndrawLine(20, 20, 80, 20)\ndrawLine(20, 20, 80, 80)\ndrawLine(20, 20, 20, 80)\n</code>\n<p>The result always connects the centerpoints of the opposing faces. Good enough for now, but we‚Äôll consider alternatives below.</p>\n<h3>Arrows</h3>\n<p>Here‚Äôs how to draw basic arrow heads:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawArrowHead(x, y, angle) {\n  ctx.save()\n  ctx.translate(x,y)\n  ctx.rotate(angle)\n  ctx.beginPath()\n  ctx.moveTo(0,0)\n  ctx.lineTo(-6,-3)\n  ctx.lineTo(-5,0)\n  ctx.lineTo(-6,3)\n  ctx.lineTo(0,0)\n  ctx.fill()\n  ctx.restore()\n}\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = x2 - x1\n  const dy = y2 - y1\n  const angle = Math.atan2(dy, dx)\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n  drawArrowHead(x2, y2, angle)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawArrow(10,50,40,50)\ndrawArrow(50,40,70,60)\ndrawArrow(90,35,90,65)\ndrawArrow(110,60,140,40)\n</code>\n<p>Now we put it back together with the rest of the line drawing code:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const skipX = dx < dy  ? 0 : x2 > x1 ? boxX/2 : -boxX/2\n  const skipY = dx >= dy ? 0 : y2 > y1 ? boxY/2 : -boxY/2\n  const angle = Math.atan2(dy, dx)\n  ctx.beginPath()\n  ctx.moveTo(x1+skipX, y1+skipY)\n  ctx.lineTo(x2-skipX, y2-skipY)\n  ctx.stroke()\n  drawArrowHead(x2-skipX, y2-skipY, angle)\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawBox(\"D\", 20, 80)\ndrawArrow(20, 20, 80, 20)\ndrawArrow(20, 20, 80, 80)\ndrawArrow(20, 20, 20, 80)\n</code>\n<p>Pretty neat, huh?</p>\n<h3>Lines: targeting the center</h3>\n<p>This style gets a bit crowded if many arrows point to the same node. All the arrow heads will point to the same exact location and partly overlap there (which doesn‚Äôt look nice).</p>\n<p><strong>Exercise:</strong> Try it!</p>\n<p>An alternative is to plan drawing the lines into the center of the box and then cut them short where they cross the box outline:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = x2 - x1\n  const dy = y2 - y1\n  if (Math.abs(dx) > Math.abs(dy)) {\n    const slope = dy / dx\n    const angle = Math.atan2(dy, dx)\n    const skip = dx >= 0 ? boxX/2 : -boxX/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skip, y1+skip*slope)\n    ctx.lineTo(x2-skip, y1+(dx-skip)*slope)\n    ctx.stroke()\n    drawArrowHead(x2-skip, y1+(dx-skip)*slope, angle)\n  } else {\n    const slope = dx / dy\n    const angle = Math.atan2(dy, dx)\n    const skip = dy >= 0 ? boxY/2 : -boxY/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skip*slope, y1+skip)\n    ctx.lineTo(x1+(dy-skip)*slope, y2-skip)\n    ctx.stroke()\n    drawArrowHead(x1+(dy-skip)*slope, y2-skip, angle)\n  }\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 140, 20)\ndrawBox(\"D\", 20, 80)\ndrawBox(\"E\", 80, 80)\ndrawBox(\"F\", 140, 80)\ndrawArrow(20, 20, 80, 80) // A->E right down\ndrawArrow(20, 80, 80, 20) // D->B right up\ndrawArrow(140, 80, 80, 20) // C -> E left down\ndrawArrow(140, 20, 80, 80) // F -> B left up\ndrawArrow(20, 20, 20, 80) // A->D down\ndrawArrow(140, 80, 140, 20) // F->C up\n\"done\"\n</code>\n<p>This approach generalizes pretty well to other node shapes (circles, etc.).</p>\n<p><strong>Exercise</strong>: Try it!</p>\n<h3>Lines: straight segments</h3>\n<p>Sometimes we don‚Äôt want to draw lines at arbitrary angles but have something more orthogonal.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawStraightArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  if (dx > dy) {\n    const skipX = x2 > x1 ? boxX/2 : -boxX/2\n    const midX = (x1+skipX+x2-skipX)/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skipX, y1)\n    ctx.lineTo(midX, y1)\n    ctx.lineTo(midX, y2)\n    ctx.lineTo(x2-skipX, y2)\n    ctx.stroke()\n    drawArrowHead(x2-skipX, y2, x2 > x1 ? 0 : Math.PI)\n  } else {\n    const skipY = y2 > y1 ? boxY/2 : -boxY/2\n    const midY = (y1+skipY+y2-skipY)/2\n    ctx.beginPath()\n    ctx.moveTo(x1, y1+skipY)\n    ctx.lineTo(x1, midY)\n    ctx.lineTo(x2, midY)\n    ctx.lineTo(x2, y2-skipY)\n    ctx.stroke()\n    drawArrowHead(x2, y2-skipY, y2 > y1 ? Math.PI/2 : 3*Math.PI/2)\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 120, 20)\ndrawBox(\"C\", 120, 80)\ndrawBox(\"D\", 40, 80)\ndrawStraightArrow(20, 20, 120, 20)\ndrawStraightArrow(20, 20, 120, 80)\ndrawStraightArrow(20, 20, 40, 80)\n</code>\n<h3>Lines: curved segments</h3>\n<p>If these right angles look too rigid, we can also use Bezier curves.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawCurvedArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const bend = 0.75 // play with this factor!\n  if (dx > dy) {\n    const skipX = x2 > x1 ? boxX/2 : -boxX/2\n    const ctrlX = bend*(x2-x1-2*skipX)\n    ctx.beginPath()\n    ctx.moveTo(x1+skipX, y1)\n    ctx.bezierCurveTo(\n      x1+skipX + ctrlX, y1,\n      x2-skipX - ctrlX, y2,\n      x2-skipX, y2)\n    ctx.stroke()\n    drawArrowHead(x2-skipX, y2, x2 > x1 ? 0 : Math.PI)\n  } else {\n    const skipY = y2 > y1 ? boxY/2 : -boxY/2\n    const ctrlY = bend*(y2-y1-2*skipY)\n    ctx.beginPath()\n    ctx.moveTo(x1, y1+skipY)\n    ctx.bezierCurveTo(\n      x1, y1+skipY+ctrlY,\n      x2, y2-skipY-ctrlY,\n      x2, y2-skipY)\n    ctx.stroke()\n    drawArrowHead(x2, y2-skipY, y2 > y1 ? Math.PI/2 : 3*Math.PI/2)\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 120, 20)\ndrawBox(\"C\", 120, 80)\ndrawBox(\"D\", 40, 80)\ndrawCurvedArrow(20, 20, 120, 20)\ndrawCurvedArrow(20, 20, 120, 80)\ndrawCurvedArrow(20, 20, 40, 80)\n</code>\n<p>It‚Äôs also possible to draw curves using circle segments or quadratic curves instead of cubic bezier curves.</p>\n<p><strong>Exercise:</strong> Try it!</p>\n<!--\n// Understanding arcto\n\net r = 20\n\nfunction arc(x2,y2,d) {\nlet [x1,y1] = [x2-100,y2-d]\nlet [x3,y3] = [x2-100,y2+d]\nctx.beginPath()\nctx.moveTo(x1,y1)\nctx.arcTo(x2,y2,x3,y3,r)\nctx.lineTo(x3,y3)\nctx.stroke()\n\nctx.beginPath()\nctx.arc(x2,y2,3,0,2*Math.PI)\nctx.fill()\nctx.beginPath()\nctx.arc(x2,y2,r,0,2*Math.PI)\nctx.stroke()\n}\n\n\narc(220,150, 100)\narc(220,150, 90)\narc(220,150, 80)\narc(220,150, 70)\narc(220,150, 60)\narc(220,150, 50)\narc(220,150, 40)\narc(220,150, 30)\narc(220,150, 21)\narc(220,150, 20)\narc(220,150, 19)\narc(220,150, 18)\narc(220,150, 17)\narc(220,150, 16)\narc(220,150, 15)\narc(220,150, 14)\narc(220,150, 13)\narc(220,150, 12)\narc(220,150, 11)\narc(220,150, 10)\n\n\narc(460,150, 60)\narc(460,150, 60)\narc(460,150, 40)\narc(460,150, 20)\narc(460,150, 10)\n\n  -->\n<h3>Lines: specifying connectors and waypoints</h3>\n<p><strong>Exercise:</strong> Let the user specify which side of a box a line should be attached to.</p>\n<p>This may require drawing multiple line segments, for example when node A is above B and we want to connect the top of node A with the bottom of node B.</p>\n<p>As a generalization we provide a function that draws a line through an arbitrary number of waypoints. It‚Äôs also useful to introduce a special case for cycles.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet edgeBend = 20\nfunction drawCircle(n, x, y) {\n  ctx.beginPath();\n  ctx.arc(x, y, boxX/2, 0, 2 * Math.PI);\n  ctx.stroke();\n  ctx.fillText(n, x, y, boxX)\n}\nfunction drawArrowHead(x, y, angle) {\n  ctx.save()\n  ctx.translate(x,y)\n  ctx.rotate(angle)\n  ctx.beginPath()\n  ctx.moveTo(0,0)\n  ctx.lineTo(-6,-3)\n  ctx.lineTo(-5,0)\n  ctx.lineTo(-6,3)\n  ctx.lineTo(0,0)\n  ctx.fill()\n  ctx.restore()\n}\nfunction drawArrow(u1, v1, u2, v2) {\n  drawArrowN([u1, v1, u2, v2])\n}\nfunction drawArrowN(points) {\n  let [x1,y1,x2,y2] = points\n  let dx = x2 - x1\n  let dy = y2 - y1\n  let angle = Math.atan2(dy, dx)\n  x1 += Math.cos(angle) * boxX/2\n  y1 += Math.sin(angle) * boxX/2\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  for (let j = 4; j < points.length; j+=2) {\n    let [x3,y3] = [points[j],points[j+1]]\n    ctx.arcTo(x2, y2, x3, y3, edgeBend);\n    x1 = x2; y1 = y2\n    x2 = x3; y2 = y3\n  }\n  dx = x2 - x1\n  dy = y2 - y1\n  angle = Math.atan2(dy, dx)\n  x2 -= Math.cos(angle) * boxX/2\n  y2 -= Math.sin(angle) * boxX/2\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n  drawArrowHead(x2, y2, angle)\n}\nfunction drawCycle(x,y) {\n  ctx.beginPath()\n  let r1 = boxX/2\n  let r2 = 15\n  let a = 2*Math.asin(0.5*r1/r2)\n  ctx.arc(x+r2,y,r2,Math.PI+a,3*Math.PI-a)\n  ctx.stroke()\n  drawArrowHead(x+r2+r2*Math.cos(Math.PI+a),y+r2*Math.sin(Math.PI+a),Math.PI-a)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawCircle(\"A\",20,20)\ndrawCircle(\"B\",180,20)\ndrawArrowN([20,20,60,60,140,60,180,20])\ndrawCycle(180,20)\n</code>\n<h3>Lines: avoiding overlap</h3>\n<p><strong>Exercise:</strong> Keep track of where line segments are, and move new ones slightly off to the side. Hint: see <a href=\"/graphs-frontend\">Frontend</a> section below for a variant that does this for back-edges</p>\n<h3>Deferred mode</h3>\n<p>So far, we have drawing functions that produce immediate graphical output at the given coordinates.</p>\n<p>Remembering all these coordinate values is a bit cumbersome, so let‚Äôs introduce a layer that allows us to assign node coordinates first, and then draw nodes and edges based on the assigned positions in a second step.</p>\n<p>This model has a number of other advantages. We become independent of a specific drawing backend (e.g., we could use positioned HTML or SVG nodes instead of canvas), and of course we have a better foundation for computing positions programmatically later on.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet gridX = 50\nlet gridY = 50\nlet originX = 20\nlet originY = 20\nlet pos = {}\nfunction placeNode(n, u, v) {\n  pos[n] = [u*gridX, v*gridY]\n}\nfunction drawNode(n1) {\n  let [x,y] = pos[n1]\n  drawCircle(n1, originX + x, originY + y)\n}\nfunction drawEdge(n1,n2) { // TODO: N\n  let [x1,y1] = pos[n1]\n  let [x2,y2] = pos[n2]\n  drawArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n}\nfunction createCanvas() {\n  let minX = Number.MAX_VALUE\n  let maxX = Number.MIN_VALUE\n  let minY = Number.MAX_VALUE\n  let maxY = Number.MIN_VALUE\n  for (let n in pos) {\n    let [x,y] = pos[n]\n    minX = Math.min(minX, x-boxX/2)\n    maxX = Math.max(maxX, x+boxX/2)\n    minY = Math.min(minY, y-boxY/2)\n    maxY = Math.max(maxY, y+boxY/2)\n  }\n  minX -= 20\n  maxX += 20\n  minY -= 20\n  maxY += 20\n  originX = -minX\n  originY = -minY\n  sizeX = maxX - minX\n  sizeY = maxY - minY\n  // super.createCanvas\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.height = sizeY\n  cvs.width = sizeX\n  ctx = cvs.getContext(\"2d\")\n  ctx.lineWidth = 1\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 1, 0)\nplaceNode(\"C\", 1, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\n</code>\n</aside>\n<p>Now we have tools to draw various forms of lines and boxes:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 1, 0)\nplaceNode(\"C\", 1, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawArrow = drawStraightArrow\ndrawCircle = drawBox\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 2, 0)\nplaceNode(\"C\", 2, 1)\nplaceNode(\"D\", 0.5, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawNode(\"D\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\ndrawEdge(\"A\",\"D\")\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawArrow = drawCurvedArrow\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 2, 0)\nplaceNode(\"C\", 2, 1)\nplaceNode(\"D\", 0.5, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawNode(\"D\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\ndrawEdge(\"A\",\"D\")\n</code>\n<p>Deciding how exactly to draw connecting edges (between which faces, when to draw an ‚ÄúS‚Äù vs ‚ÄúL‚Äù shape, etc.) already requires some nontrivial geometry.</p>\n<aside>\n<h2>Frontend - Drawing Trees</h2>\n<p>Before we tackle general graphs, let‚Äôs take a look at trees. Trees are of course a very important subclass of graphs, but they are actually quite interesting in their own right.</p>\n<h3>Algorithm 1</h3>\n<p>Preliminaries:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//let g = {5: {11: {0:{},2:{},4:{}}, 1.3: { 7.9: {6:{}, 8:{}, 10:{} }}}}\nlet g = { 1: { 2: { 3: { 4: {5: {}}, 6: {7:{}, 8:{}, 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\nfunction succ(n) {\n  return Object.entries(n)\n}\nfunction drawForest(g,p) {\n  for (let [k,v] of succ(g)) {\n    drawForest(v, k)\n    drawNode(k)\n    if (p != null) drawEdge(p,k)\n  }\n}\n</code>\n<p>How to place the nodes? Let‚Äôs start on one end of\nthe canvas and keep track of how many we‚Äôve drawn at each level:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    placeForest(v, d+1)\n    placeNode(k, d, fringe[d])\n    fringe[d] += 1\n  }\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>Looks like a good start, but obviously not great.</p>\n<h3>Algorithm 2</h3>\n<p>An easy idea to improve the layout is to center nodes at each level. We can do this in two passes:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet extent = []\nfunction layoutForest(g,d) {\n  extent[d] = extent[d] || 0\n  for (let [k,v] of succ(g)) {\n    layoutForest(v, d+1, extent[d])\n    extent[d] += 1\n  }\n}\nlet max = 4\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    const pos = (max-extent[d])/2 + fringe[d]\n    placeForest(v, d+1)\n    placeNode(k, d, pos)\n    fringe[d] += 1\n  }\n}\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This is better, but still not optimal. The placement of parents with respect to children is awkward.</p>\n<h3>Algorithm 3</h3>\n<p>We‚Äôd like to place parents in the middle above of their children. We‚Äôll implement a version of an algorithm attributed to Reingold and Tilford.</p>\n<p>First cut:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) { return Object.entries(g).reverse() }\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let childpos = []\n  for (let [k,v] of succ(g)) {\n    const cp = placeForest(v, d+1)\n    let pos = fringe[d]\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid > pos) pos = mid\n    }\n    placeNode(k, d, pos)\n    fringe[d] = pos+1\n    childpos.push(pos)\n  }\n  return childpos\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This is better, but misses the case where a subtree would need to be moved after it has been drawn.</p>\n<p>We switch back to a two-pass process and add a function to move already-positioned subtrees:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n// annoying: converting between screen and grid pos\nfunction succ(g) { return Object.entries(g).reverse() }\nlet fringe = []\nfunction moveForest(g,d,off) {\n  for (let [k,v] of succ(g)) {\n    moveForest(v,d+1,off)\n    pos[k][1] += off*gridY\n    let scaled = pos[k][1]/gridY\n    if (scaled + 1 > fringe[d])\n      fringe[d] = scaled + 1\n  }\n}\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    let p = fringe[d]\n    placeForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => pos[k1][1]/gridY)\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid >= p) {\n        p = mid\n      } else {\n        // move children and adjust fringe below!\n        moveForest(v, d+1, p-mid)\n      }\n    }\n    fringe[d] = p+1\n    placeNode(k,d,p)\n  }\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This works great! But it‚Äôs horribly inefficient. The recursive invocation of <code class=\"language-text\">moveForest</code> makes the implementation exponential (compare recursion pattern to naive Fibonacci).</p>\n<p>We‚Äôll be back to linear performance if we manage to remove recursion from <code class=\"language-text\">moveForest</code>. But how can we do that?</p>\n<p>Function <code class=\"language-text\">moveForest</code> does two things: it updates the position of each node (shifting by <code class=\"language-text\">off</code>), and it updates the fringe accordingly.</p>\n<p>Updating node positions can be done in constant time if we just record the offset, and add it in later while drawing.</p>\n<p>This means that we no longer need to traverse the full subtree to move, but we still need to traverse the fringe (up to the depth of the subtree) to adjust the offset.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    let off = 0\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1.pos)\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid >= pos) {\n        pos = mid\n      } else {\n        off = pos-mid\n        // children move lazily, but still need\n        // to update fringe (up to depth of child tree)\n        for (let d1 = 0; d1 < cd; d1++)\n          fringe[d+1+d1] += off\n      }\n    }\n    fringe[d] = pos+1\n    v.pos = pos\n    v.off = off\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,off) {\n  for (let [k,v] of succ(g)) {\n    const pos = v.pos\n    placeForest(v, d+1, off+v.off, pos+off)\n    placeNode(k, d, pos+off)\n  }\n}\nlayoutForest(g,0)\nplaceForest(g,0,0)\ncreateCanvas()\ndrawForest(g)</code>\n<p>This is much better, but still not ideal in terms of performance.</p>\n<p><strong>Exercise:</strong> what is the worst case complexity? Prove it.</p>\n<p>What can we do to make it linear?</p>\n<p>The key idea is to make fringe entries relative to the parent. Then we only need to adjust the value at <code class=\"language-text\">d+1</code> and set it back at <code class=\"language-text\">d+cd+1</code> (where <code class=\"language-text\">cd</code> is the depth of the child tree)!</p>\n<p>This works best when tree positions are also relative to the parent. So we get rid of the relative <code class=\"language-text\">off</code> field and just use the normal <code class=\"language-text\">pos</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1)\n    if (cp.length > 0) {\n      const mid = (cp[0].pos + cp[cp.length-1].pos)/2\n      cp.forEach(v1 => v1.pos -= mid)\n      if (mid >= 0) {\n        pos += mid\n      } else {\n        // children are relative, fringe also relative\n        fringe[d+1] -= mid\n        fringe[d+1+cd] += mid\n      }\n    }\n    fringe[d+1] += fringe[d] - (pos+1)\n    fringe[d] = pos+1\n    v.pos = pos\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,p) {\n  for (let [k,v] of succ(g)) {\n    const pos = (p||0) + v.pos\n    placeForest(v, d+1, pos)\n    placeNode(k, d, pos)\n  }\n}\ng = { 1: {\n2: { 3: { 4: {5: {50:{501:{},502:{}}}}, 6: {7:{71:{},72:{},73:{}}, /*8:{80:{} },*/ 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>Now we‚Äôre done, and we have a nice and efficient method for drawing trees.</p>\n<p><strong>Exercise:</strong> why do we need the line <code class=\"language-text\">fringe[d+1+cd] += mid</code>? Find a test case.</p>\n<h3>Discussion</h3>\n<p>References:</p>\n<ul>\n<li>\n<p>Reingold and Tilford <a href=\"https://reingold.co/tidier-drawings.pdf\">https://reingold.co/tidier-drawings.pdf</a></p>\n</li>\n<li>\n<p>Br√ºggemann-Klein and Wood <a href=\"http://cajun.cs.nott.ac.uk/compsci/epo/papers/volume2/issue2/epabk022.pdf\">http://cajun.cs.nott.ac.uk/compsci/epo/papers/volume2/issue2/epabk022.pdf</a></p>\n</li>\n<li>\n<p>TikZ manual <a href=\"https://pgf-tikz.github.io/pgf/pgfmanual.pdf\">https://pgf-tikz.github.io/pgf/pgfmanual.pdf</a></p>\n</li>\n</ul>\n</aside>\n<p>Trees are an important subclass of graphs that deserves special attention. While simpler than the case of general graphs, drawing trees with automatic layout already requires careful planning where to place children and parents with respect to each other, to make efficient use of space available at each layer:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1)\n    if (cp.length > 0) {\n      const mid = (cp[0].pos + cp[cp.length-1].pos)/2\n      cp.forEach(v1 => v1.pos -= mid)\n      if (mid >= 0) {\n        pos += mid\n      } else {\n        // children are relative, fringe also relative\n        fringe[d+1] -= mid\n        fringe[d+1+cd] += mid\n      }\n    }\n    fringe[d+1] += fringe[d] - (pos+1)\n    fringe[d] = pos+1\n    v.pos = pos\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,p) {\n  for (let [k,v] of succ(g)) {\n    const pos = (p||0) + v.pos\n    placeForest(v, d+1, pos)\n    placeNode(k, d, pos)\n  }\n}\ng = { 1: {\n2: { 3: { 4: {5: {}}, 6: {7:{}, 8:{}, 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\ngridY = 30\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<aside id=\"graphs-frontend\">\n<h2>Frontend - Drawing Graphs</h2>\n<h3>Algorithm 1: Spanning Trees</h3>\n<p>Find a spanning tree of the graph, draw it as a tree, then draw the remaining edges.</p>\n<p><strong>Exercise:</strong> implement it!</p>\n<h3>Algorithm 2: Layered Graph Drawing</h3>\n<p>Steps:</p>\n<ul>\n<li>Compute node ranks</li>\n<li>Route edges by creating dummy nodes</li>\n<li>Shuffle to minimize crossings</li>\n<li>Draw</li>\n</ul>\n<p>In rough pseudo-code:</p>\n<pre>\ncomputeRank()\ncomputePositions()\ncreateCanvas()\ndrawGraph()\n</pre>\n<p>Let‚Äôs fill it with life. As a first cut we assign positions by distributing the vertical space within each rank:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// Compute succ/pred relations from edge list\nfunction computeGraph(edges) {\n  let nodes = new Set(edges.flat())\n  let pred = {}\n  let succ = {}\n  for (let [n1,n2] of edges) {\n    if (pred[n2]) pred[n2].push(n1)\n    else pred[n2] = [n1]\n    if (succ[n1]) succ[n1].push(n2)\n    else succ[n1] = [n2]\n  }\n  return {\n     start: Array.from(nodes),//.filter(n => !pred[n]),\n    succ: succ, pred: pred\n  }\n}\n// Compute the rank of each node\nfunction computeRank(start, succ) {\n  const rank = {}\n  const mark = {} // is node on current path\n  const path = []\n  function visit(node) {\n    if (mark[node]) return // cycle\n    if (path.length < rank[node]) return // want to compute the max rank ...\n    rank[node] = path.length\n    mark[node] = true\n    path.push(node)\n    for (let n of succ[node]||[])\n      visit(n)\n    path.pop()\n    mark[node] = undefined\n  }\n  for (let n of start)\n    visit(n)\n  return rank\n}\n// Compute a list of nodes ordered by rank\nfunction computeLayout(rank) {\n  // Now compute ranked list of nodes\n  const layout = []\n  for (let n in rank) {\n    let ns = layout[rank[n]] || (layout[rank[n]] = [] )\n    ns.push(n)\n  }\n  return layout\n}\n// Compute positions based on layout\nfunction computePositions(layout) {\n  const pos = {}\n  const countX = layout.length\n  let countY = 0\n  for (let x = 0; x < countX; x++) {\n    countY = Math.max(countY, layout[x].length)\n  }\n  for (let x = 0; x < countX; x++) {\n    const ns = layout[x]\n    const freeY = (countY - ns.length)/2\n    for (let y = 0; y < ns.length; y++) {\n      pos[ns[y]] = { x: x, y: y + freeY}\n    }\n  }\n  //return { pos1: pos, width: countX, height: countY }\n  return pos\n}\nfunction placeGraph(pos1) {\n  for (let n in pos1) {\n    placeNode(n, pos1[n].x, pos1[n].y)\n  }\n}\nfunction drawGraph(succ) {\n  for (let n in pos) {\n    drawNode(n)\n    for (let n2 of g.succ[n]||[])\n      drawEdge(n,n2)\n  }\n}\n</code>\n<p>Let‚Äôs try it on an example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,1]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\ngridX = 100\ngridY = 100 // more space\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>Pretty cool!</p>\n<p>But we don‚Äôt pay any special attention to edges yet. So edges may overlap, cross, etc. Especially back-edges are annoying:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"C\"],[\"D\",\"A\"]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\ngridX = 100\ngridY = 100 // more space\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>The first idea is to do something relatively simple. Let‚Äôs move those back edges out of the way.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet lastBackEdge = {}\nlet countBackEdge = {}\nfunction drawRaisedBackArrow(x1,y1,x2,y2) {\n  let dx = x2-x1\n  let dy = y2-y1\n  let h = -Math.min(0,dy) + 10\n  let u = y1-boxY/2-h\n  while (lastBackEdge[u] && x2 < lastBackEdge[u]) u -= 3\n  let v = (countBackEdge[x1]||0) * 3\n  let w = (countBackEdge[x2]||0) * 3\n  ctx.beginPath()\n  ctx.moveTo(x1+v, y1-boxY/2)\n  ctx.lineTo(x1+v, u)\n  ctx.lineTo(x2+w, u)\n  ctx.lineTo(x2+w, y2-boxY/2)\n  ctx.stroke()\n  drawArrowHead(x2+w,  y2-boxY/2, Math.PI/2)\n  lastBackEdge[u] = x1\n  countBackEdge[x1] = (countBackEdge[x1]||0) + 1\n  countBackEdge[x2] = (countBackEdge[x2]||0) + 1\n}\nfunction drawEdge(n1,n2) {\n  let [x1,y1] = pos[n1]\n  let [x2,y2] = pos[n2]\n  if (x1 < x2) {\n    drawArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n  } else {\n    drawRaisedBackArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n  }\n}\n//\nfunction plotGraph(edges) {\n  pos = []\n  lastBackEdge = {}\n  countBackEdge = {}\n  g = computeGraph(edges)\n  g.rank = computeRank(g.start, g.succ)\n  const layout = computeLayout(g.rank)\n  const pos1 = computePositions(layout)\n  gridX = 100\n  gridY = 100 // more space\n  placeGraph(pos1)\n  createCanvas()\n  drawGraph(g.succ)\n  print(\"\")\n}\nplotGraph([[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,1]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"B\"]])\nplotGraph([[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"A\"],[\"C\",\"A\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"B\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"B\"],[\"D\",\"A\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"C\"],[\"D\",\"A\"]])\n</code>\n<p>This produces already some pretty neat results.</p>\n<h3>Algorithm 3: Layered with Edge Routing</h3>\n<p>A more principled idea is to insert dummy nodes along edges that traverse a layer, and then position nodes to minimize edge crossings.</p>\n<h4>Edge Routing</h4>\n<p>Let‚Äôs look at dummy nodes first. We need to create them:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction computeDummyEdges(edges,rank) {\n  // currently modifying rank table in place,\n  // could also return a new one\n  let edges1 = []\n  for (let [n1,n2] of edges) {\n    let links = []\n    const d = rank[n2] - rank[n1]\n    if (Math.abs(d) > 1) {\n      let m1 = n1\n      for (let j = 1; j < d; j++) {\n        let m2 = n1+\"-#\"+j+\"-\"+n2\n        links.push([m1,m2])\n        rank[m2] = rank[m1] + 1\n        m1 = m2\n      }\n      links.push([m1, n2])\n    } else {\n      links.push([n1,n2])\n    }\n    edges1.push(...links)\n  }\n  return edges1\n}\n</code>\n<p>And be able to draw them:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawPath(n,n2) {\n  let [[x1,y1],[x2,y2]] = [pos[n],pos[n2]]\n  if (n2 == n) {\n    drawCycle(originX + x1, originY + y1)\n  } else {\n    let points = [originX + x1, originY + y1, originX + x2, originY + y2]\n    // follow path to the next regular node\n    while (n2.toString().indexOf(\"#\") >= 0) {\n      n2 = g.succ[n2][0] // we know we have only a single successor\n      points.push(originX + pos[n2][0], originY + pos[n2][1])\n    }\n    drawArrowN(points)\n  }\n}\nfunction drawGraph(succ) {\n  for (let n in pos) {\n    if (n.indexOf(\"#\") < 0) {\n      drawNode(n)\n      for (let n2 of succ[n]||[])\n        drawPath(n,n2)\n    }\n  }\n}\n</code>\n<p>Here‚Äôs an example:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,2]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>As we can see, we have some proper routed edges now, but the overall layout isn‚Äôt great.</p>\n<p>So let‚Äôs go ahead and minimize crossings.</p>\n<h4>Minimizing Edge Crossings</h4>\n<p>We‚Äôll use a heuristic that proceeds layer by layer, and assigns each node the average (‚Äúbarycentric‚Äù, alternative: median) position of its parents.</p>\n<p>The process works best when iterated, alternating forward and backward passes. There‚Äôs some theory that says it actually minimizes crossings.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// Assign each node the average pos of its parents\nfunction recomputeLayerPositions(g, layout, pos, l, dir) {\n  for (let n2 of layout[l]) {\n    let nsy = dir > 0 ? (g.pred[n2]||[]) : (g.succ[n2]||[])\n    nsy = nsy.filter(n => g.rank[n] == l-dir).map(n => pos[n].y)\n    // TODO: include succ[n2] where rank = l-1 (outgoing back-edges)?\n    if (nsy.length > 0)\n      pos[n2].y = (Math.min(...nsy) + Math.max(...nsy))/2\n    // NOTES:\n    // GraphViz: also greedily swap adjacent nodes if that removes a crossing\n    // Note: we're computing screen positions, this may lead to overlap!\n    // Example: two nodes have same parents --> assign same position\n    // Solution step 1: sort by position (layout[l] = sortBy(pos))\n    // Solution step 2: move apart verlet-style (possible in 2 passes, but need more for best result)\n    // Alternative idea: GraphViz, run ranking in other dimension (extended constraint graph)\n  }\n}\nfunction recomputeLayerLayout(g, layout, pos, l) {\n  layout[l].sort((n1,n2) => pos[n1].y - pos[n2].y)\n}\n// Move apart overlapping nodes within a layer\nlet edgeSep = 0.15\nlet nodeSep = 0.25\nlet removeOverlapIterCount = 5\nfunction recomputeLayerOverlap(g, layout, pos, l) {\n  let rn = nodeSep // relative to grid\n  let re = edgeSep\n  for (let k = 0; k < removeOverlapIterCount; k++) {\n    for (let j = 1; j < layout[l].length; j++) {\n      let n1 = layout[l][j-1]\n      let n2 = layout[l][j]\n      let d = pos[n2].y - pos[n1].y\n      let dd1 = ((n1.indexOf(\"#\") < 0) ? rn : re)\n      let dd2 = ((n2.indexOf(\"#\") < 0) ? rn : re)\n      let dd = dd1 + dd2\n      if (d < dd) {\n        pos[n1].y -= (dd-d)*0.5//(dd2/dd)\n        pos[n2].y += (dd-d)*0.5//(dd1/dd)\n      }\n    }\n    for (let j = layout[l].length-1; j > 0; j--) {\n      let n1 = layout[l][j-1]\n      let n2 = layout[l][j]\n      let d = pos[n2].y - pos[n1].y\n      let dd1 = ((n1.indexOf(\"#\") < 0) ? rn : re)\n      let dd2 = ((n2.indexOf(\"#\") < 0) ? rn : re)\n      let dd = dd1 + dd2\n      if (d < dd) {\n        pos[n1].y -= (dd-d)*0.5//(dd2/dd)\n        pos[n2].y += (dd-d)*0.5//(dd1/dd)\n      }\n    }\n  }\n}\n// Client should iterate fwd/bwd a few times\nfunction improvePositions(g, layout, pos) {\n  for (let l = 1; l < layout.length; l++) {\n    recomputeLayerPositions(g, layout, pos, l, 1)\n    recomputeLayerLayout(g, layout, pos, l)\n    recomputeLayerOverlap(g, layout, pos, l)\n  }\n}\nfunction improvePositionsReverse(g, layout, pos) {\n  for (let l = layout.length-2; l >= 0; l--) {\n    recomputeLayerPositions(g, layout, pos, l, -1)\n    recomputeLayerLayout(g, layout, pos, l)\n    recomputeLayerOverlap(g, layout, pos, l)\n  }\n}\n</code>\n<p>Let‚Äôs try it!</p>\n<h3>Examples</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,2]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\nimprovePositions(g,layout,pos1)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>About as good as it gets for this graph, right? And already in a single pass of improving positions.</p>\n<p>Let‚Äôs try another one. This one stresses the elimination of overlap within a layer.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 11], [1, 12], [1, 13], [1, 14], [2, 21], [2, 22], [2, 23], [2, 24]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\nimprovePositions(g,layout,pos1)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>Here‚Äôs a larger example from the TikZ manual:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [\n  [\"Thompson\",\"Mashey\"],\n  [\"Thompson\",\"Bourne\"],\n  [\"Thompson\",\"csh\"],\n  [\"csh\",\"tcsh\"],\n  [\"Bourne\",\"ksh\"],\n  [\"Bourne\",\"esh\"],\n  [\"Bourne\",\"vsh\"],\n  [\"Bourne\",\"System-V\"],\n  [\"Bourne\",\"v9sh\"],\n  [\"v9sh\",\"rc\"],\n  [\"Bourne\",\"Bash\"],\n  [\"ksh-i\",\"Bash\"],\n  [\"KornShell\",\"Bash\"],\n  [\"esh\",\"ksh\"],\n  [\"vsh\",\"ksh\"],\n  [\"Formshell\",\"ksh\"],\n  [\"csh\",\"ksh\"],\n  [\"KornShell\",\"POSIX\"],\n  [\"System-V\",\"POSIX\"],\n  [\"ksh\",\"ksh-i\"],\n  [\"ksh-i\",\"KornShell\"],\n  [\"KornShell\",\"ksh-POSIX\"],\n  [\"Bourne\",\"Formshell\"],\n  [1972,1976],\n  [1976,1978],\n  [1978,1980],\n  [1980,1982],\n  [1982,1984],\n  [1984,1986],\n  [1986,1988],\n  [1988,1990],\n  [1990,\"future\"],\n]\nlet rank = {\n  \"1972\": 0,\n  \"Thompson\": 0,\n  \"1976\": 1,\n  \"Mashey\": 1,\n  \"Bourne\": 1,\n  \"1978\": 2,\n  \"Formshell\": 2,\n  \"csh\": 2,\n  \"1980\": 3,\n  \"esh\": 3,\n  \"vsh\": 3,\n  \"1982\": 4,\n  \"ksh\": 4,\n  \"System-V\": 4,\n  \"1984\": 5,\n  \"v9sh\": 5,\n  \"tcsh\": 5,\n  \"1986\": 6,\n  \"ksh-i\": 6,\n  \"1988\": 7,\n  \"KornShell\": 7,\n  //\"Perl\": 7,\n  \"rc\": 7,\n  \"1990\": 8,\n  //\"tcl\": 8,\n  \"Bash\": 8,\n  \"future\": 9,\n  \"POSIX\": 9,\n  \"ksh-POSIX\": 9,\n}\ng = computeGraph(edges)\ng.rank = rank // manually ranked, according to years\n//g.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nlet pos1 = computePositions(layout)\nedgeSep = 0.15\nnodeSep = 0.25\nimprovePositions(g,layout,pos1)\nimprovePositionsReverse(g,layout,pos1)\nimprovePositions(g,layout,pos1)\n//improvePositionsReverse(g,layout,pos1)\n//pos1 = computePositions(layout) // try this as well!\n// draw\nedgeBend = 30\ngridY = 80\ngridX = 50\nboxX = 30\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p><strong>Exercise:</strong> try more examples, e.g., from Pohlmann‚Äôs thesis, TikZ manual, Tamassia‚Äôs handbook.</p>\n<h3>Algorithm 4: Layered with clusters</h3>\n<ul>\n<li>See, e.g., layout of compound directed graphs <a href=\"https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/25862\">https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/25862</a></li>\n</ul>\n<h3>Algorithm 5: Force-Based</h3>\n<ul>\n<li>See, e.g., Pohlmann‚Äôs thesis.</li>\n</ul>\n<h3>Discussion</h3>\n<p>References:</p>\n<ul>\n<li>Methods for visual understanding of hierarchical system structures. K. Sugiyama, S. Tagawa, and M. Toda, 1981 <a href=\"https://ieeexplore.ieee.org/abstract/document/4308636\">https://ieeexplore.ieee.org/abstract/document/4308636</a></li>\n<li>A Technique for Drawing Directed Graphs. Emden R. Gansner, Eleftherios Koutsofios, Stephen C. North, Kiem-Phong Vo, 1993 <a href=\"https://www.graphviz.org/Documentation/TSE93.pdf\">https://www.graphviz.org/Documentation/TSE93.pdf</a> (GraphViz)</li>\n<li>Configurable Graph Drawing Algorithms for the TikZ Graphics Description Language. Jannis Pohlmann, MS Thesis, 2011</li>\n</ul>\n<p><a href=\"http://www.tcs.uni-luebeck.de/downloads/papers/2011/2011-configurable-graph-drawing-algorithms-jannis-pohlmann.pdf\">http://www.tcs.uni-luebeck.de/downloads/papers/2011/2011-configurable-graph-drawing-algorithms-jannis-pohlmann.pdf</a> (TikZ)</p>\n<ul>\n<li>Handbook of Graph Drawing and Visualization. Roberto Tamassia, Editor, 2013, <a href=\"http://cs.brown.edu/people/rtamassi/gdhandbook/\">http://cs.brown.edu/people/rtamassi/gdhandbook/</a> (Chapter 13: Hierarchical drawing algorithms by Healy &#x26; Nikolov <a href=\"http://cs.brown.edu/people/rtamassi/gdhandbook/chapters/hierarchical.pdf\">http://cs.brown.edu/people/rtamassi/gdhandbook/chapters/hierarchical.pdf</a>)</li>\n</ul>\n</aside>\n<p>GraphViz and similar tools are based on an approach known as the Sugiyama framework. This approach first partitions the graph into layers by assigning each node a rank, then routes edges by inserting dummy nodes whenever an edge traverses a layer, and finally minimizes edge crossings by shuffling nodes within each layer:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [\n  [\"Th\",\"Ma\"],\n  [\"Th\",\"Bo\"],\n  [\"Th\",\"cs\"],\n  [\"cs\",\"tc\"],\n  [\"Bo\",\"ks\"],\n  [\"Bo\",\"es\"],\n  [\"Bo\",\"vs\"],\n  [\"Bo\",\"Sy\"],\n  [\"Bo\",\"v9\"],\n  [\"v9\",\"rc\"],\n  [\"Bo\",\"Ba\"],\n  [\"ks\",\"Ba\"],\n  [\"Ko\",\"Ba\"],\n  [\"es\",\"ks\"],\n  [\"vs\",\"ks\"],\n  [\"Fo\",\"ks\"],\n  [\"cs\",\"ks\"],\n  [\"Ko\",\"PO\"],\n  [\"Sy\",\"PO\"],\n  [\"ks\",\"ki\"],\n  [\"ki\",\"Ko\"],\n  [\"Ko\",\"kP\"],\n  [\"Bo\",\"Fo\"],\n  [\"kP\",\"kP\"],\n]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nlet pos1 = computePositions(layout)\nedgeSep = 0.15\nnodeSep = 0.25\nimprovePositions(g,layout,pos1)\nimprovePositionsReverse(g,layout,pos1)\nimprovePositions(g,layout,pos1)\n//improvePositionsReverse(g,layout,pos1)\n//pos1 = computePositions(layout) // try this as well!\n// draw\nedgeBend = 20\ngridY = 80\ngridX = 60\nboxX = 20\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<aside>\n<h2>Discussion</h2>\n<p>The algorithms discussed here achieve visually pleasing results with a relatively simple and modular implementation, which can be tweaked in many different ways to achieve particular visualization styles.</p>\n<p>The tree layout algorithm is commonly attributed to Reingold and Tilford, the graph layout framework to Sugiyama. Many variations and extensions exist, including for clustered graphs that include a form of hierarchy, i.e., super nodes that visually contain other nodes.</p>\n<p>Force-based layout is an alternative to the rank-based graph layout approach discussed here, based on the simulation of physical attraction and repulsion forces between nodes. This approach is implemented in D3.js and various other tools.</p>\n</aside>\n<p>These algorithms achieve good results and provide many tuning knobs. An alternative graph layout model, used for example by D3.js, is based on simulating physical forces between nodes.</p>","fields":{"slug":"/Public/Generic/drawing-graphs/"},"frontmatter":{"date":"2020-06-28","title":"Drawing Graphs like GraphViz","description":"Automatic graph and tree layout. The core of GraphViz, implemented from scratch in JavaScript.","keywords":"Graphs, Graph Drawing, GraphViz, Sugiyama Framework, JavaScript","tags":null}}},{"node":{"excerpt":"I wanted to implement a piano practice app for my little son. Here‚Äôs what I came up with. Virtual Piano Implementation Preliminaries: we‚Äôll‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>I wanted to implement a piano practice app for my little son. Here‚Äôs what I came up with.</p>\n<aside>\n<h2>Virtual Piano Implementation</h2>\n<aside>\n<p>Preliminaries: we‚Äôll need buttons and a facility to pause.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nbutton(\"click\", () => print(\"click\"))\n</code>\n</aside>\n<p>Let‚Äôs see how we can get our web browser to play sound.</p>\n<aside>\n<h2>Playing a sound</h2>\n<p>Let‚Äôs get started. Here‚Äôs how to play sounds in a web browser, using the WebAudio API:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet fadeOut = 0.5\nfunction play(freq) {\n  // recycle AudioContext instances, Browser won't\n  // let us create a lot of them\n  if (!window.audio)\n      window.audio = new (window.AudioContext || window.webkitAudioContext)()\n  let osc = audio.createOscillator()\n  let gain = audio.createGain()\n  osc.type = \"sine\"\n  osc.frequency.value = freq\n  gain.gain.value = 0.3 // without this, weird interference\n  osc.connect(gain)\n  gain.connect(audio.destination)\n  let startPlay = audio.currentTime\n  osc.start(audio.currentTime)\n  function stop() {\n    let startFade = audio.currentTime\n    let stopFade = startFade + fadeOut\n    // avoid weird click sound when turning off\n    // in the middle of a sine wave (exp decay)\n    gain.gain.setValueAtTime(gain.gain.value, startFade);\n    gain.gain.linearRampToValueAtTime(0.0001, stopFade);\n    osc.stop(stopFade)\n    return startFade - startPlay\n  }\n  return stop\n}\n</code>\n<p>Try it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nawait buttonClick(\"play\")\nlet stop = play(440)\nawait buttonClick(\"stop\")\nstop()\n</code>\n<p>There are a couple issues worth pointing at and how they are solved:</p>\n<ul>\n<li>Auto-play prevention (solution: lazy init, start in response to user action)</li>\n<li>Browser limits (solution: share audio context)</li>\n<li>Weird click sound at end (solution: fade out)</li>\n<li>Weird interference when playing multiple sounds (solution: reduce gain)</li>\n</ul>\n<p>The bottom line is that sound is disturbance of air pressure. A tone is rhythmic disturbance (sine wave, or other waveform) with a certain frequency.</p>\n</aside>\n<p>Now we can do this:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nawait buttonClick(\"play\")\nlet stop = play(440)\nawait buttonClick(\"stop\")\nstop()\n</code>\n<p>But what are the sounds that make up music? We have to work out which frequencies notes like C, D, E, etc. correspond to.</p>\n<aside>\n<h2>Playing a note</h2>\n<p>Raw frequencies are kinda boring. So let‚Äôs play some actual notes. For that we need to understand a bit about music.</p>\n<p>We know that notes C, D, E, F, G, A, B form an octave. We can go an octave lower or higher and have the same notes.</p>\n<p>The frequency we played, 440 Hz, is the middle A note, A4.</p>\n<p>Human perception of sound is logarithmic. What we perceive as one step higher or lower is actually a multiplication in frequency. We perceive sounds as similar if we double or halve the frequency (low C vs high C). And we find certain ratios <em>harmonic</em> but others not.</p>\n<p>An octave corresponds to a doubling or halving in frequency. So in addition to the A4 note at 440 Hz, there are A sounds at 55 Hz, 110 Hz, 220 Hz, 440 Hz, 880 Hz, and so on.</p>\n<p>An octave is typically split into 12 <em>half tones</em>, called\nC, C#, D, D#, E, F, F#, G, G#, A, A#, B. Note that there is no E# and no B#, so E, F and B,C are just half tones apart, unlike for example C,D or F,G.</p>\n<p>(This division by 12 is called the chromatic scale. There are other ways to divide an octave, e.g., pentatonic music has 5 notes per octave, some Jazz has 8.)</p>\n<p>Given that we know where the A‚Äôs are, how can we calculate the frequencies for other notes? The next A from, say, 220 Hz is a multiplication by 2 away, so we want to do 1/12 of that step to reach the next half tone. This means that the factor we are looking for is the 12th root of 2, or 2 to the power of 1/12 (since (2^(1/12))^12 = 2).</p>\n<p>The steps are easy to compute programmatically:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"A\",\"A#\",\"B\",\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\n\"G\",\"G#\"]\nawait buttonClick(\"play\")\nfor (let i = 0; i < 13; i++) {\n  print(notes[i%notes.length], 220*Math.pow(2,i/12))\n  let stop = play(220*Math.pow(2,i/12))\n  await sleep(300)\n  stop()\n}\n</code>\n<p>So let‚Äôs collect those in a table (for two octaves) and define a helper function to play notes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet noteName = [\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\",\"C+\",\"C#+\",\"D+\",\"D#+\",\"E+\",\"F+\",\"F#+\",\"G+\",\"G#+\",\"A+\",\"A#+\",\"B+\"]\nlet noteIndx = {}\nlet noteFreq = {}\nfor (let i = 0; i < noteName.length; i++) {\n  let k = i + 3 // \"A\",\"A#\",\"B\",\"C\"\n  noteIndx[noteName[i]] = i\n  noteFreq[noteName[i]] = 220*Math.pow(2,k/12)\n}\nfunction playNote(k) {\n  return play(noteFreq[k])\n}\n</code>\n<p>Knowing how notes correspond to frequencies,\nwe can play a simple scale (this is the\nstandard ‚ÄúC Major‚Äù scale):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\nawait buttonClick(\"play\")\nfor (let i = 0; i < notes.length; i++) {\n  let stop = playNote(notes[i])\n  await sleep(300)\n  stop()\n}\n</code>\n</aside>\n<p>Knowing how notes correspond to frequencies, we can start playing interactively.</p>\n<aside>\n<h2>Drawing a piano keyboard</h2>\n<p>We can already support basic interactivity:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\nfor (let i = 0; i < notes.length; i++) {\n  button(notes[i], () => {\n    let stop = playNote(notes[i])\n    sleep(300).then(stop)\n  })\n}\n</code>\n<p>But we‚Äôd really like to have a better UI.</p>\n<p>So here we go for our first cut:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction piano(keys) {\n  let keyInputMap = [\"a\",\"s\",\"d\",\"f\",\"g\",\"h\",\"j\"] // kl;'\n  let width = 300\n  let height = 150\n  let cvs = document.createElement(\"canvas\")\n  cvs.width = width\n  cvs.height = height\n  o.appendChild(cvs)\n  // drawing\n  let ctx = cvs.getContext(\"2d\")\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n  let d = width/keys.length\n  function drawKey(k, pressed) {\n    ctx.save()\n    let bg = \"white\"\n    let fg = \"black\"\n    if (pressed) {\n      bg = \"black\"\n      fg = \"white\"\n    }\n    ctx.fillStyle = bg\n    ctx.fillRect(k*d, 0, d, height)\n    ctx.strokeStyle = fg\n    ctx.strokeRect(k*d, 0, d, height)\n    ctx.fillStyle = fg\n    if (keyInputMap[k])\n      ctx.fillText(keyInputMap[k],k*d+d/2, height-20)\n    ctx.fillText(keys[k],k*d+d/2, height-10)\n    ctx.restore()\n  }\n  for (let i = 0; i < keys.length; i++) {\n    drawKey(i,false)\n  }\n  // interactivity\n  let playing = []\n  let pressed = null\n  let touchDevice = false\n  function play(k) {\n      if (!playing[k]) {\n          drawKey(k,true)\n          playing[k] = playNote(keys[k])\n      }\n  }\n  function playStop(k) {\n      drawKey(k,false)\n      if (playing[k]) {\n          let stop = playing[k]\n          playing[k] = null\n          stop()\n      }\n  }\n  cvs.addEventListener(\"keydown\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          play(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"keyup\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          playStop(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"mouseenter\", (e) => {\n      // enable key input focus if not using touch\n      if (!touchDevice) {\n        cvs.setAttribute(\"contentEditable\", \"true\")\n        cvs.focus()\n      }\n  })\n  cvs.addEventListener(\"mousedown\", (e) => {\n      let x = e.offsetX\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n      }\n  })\n  cvs.addEventListener(\"mouseup\", (e) => {\n      playStop(pressed)\n  })\n  // could register this dynamically on mouse\n  // down with document and remove on mouse up\n  cvs.addEventListener(\"mousemove\", (e) => {\n      if (!e.buttons) return\n      let x = e.offsetX\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchstart\", (e) => {\n      touchDevice = true\n      let bounds = cvs.getBoundingClientRect()\n      let x = e.changedTouches[0].clientX-bounds.left\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n        e.preventDefault()\n        e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"touchmove\", (e) => {\n      let bounds = cvs.getBoundingClientRect()\n      let x = e.changedTouches[0].clientX-bounds.left\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchend\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchcancel\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n}\n</code>\n<p>Here‚Äôs how we use it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\npiano(notes)\n</code>\n<p>This is good and we could extend it to include half tones\nor multiple octaves by just adding more keys.</p>\n<p>However we prefer a layout that corresponds to a physical\npiano.</p>\n<p>Here is the more advanced version:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction piano2(callback) {\n  let keys = [\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\",\n  \"C+\",\"C#+\",\"D+\",\"D#+\",\"E+\",\"F+\",\"F#+\",\"G+\",\"G#+\",\"A+\",\"A#+\",\"B+\"]\n  let keyNames = keys\n  let keyInputMap = [\"a\",\"w\",\"s\",\"e\",\"d\",\"f\",\"t\",\n  \"g\",\"y\",\"h\",\"u\",\"j\",\"k\",\"o\",\"l\",\"p\",\";\",\"'\",\"0\",\"[\",\"-\",\"]\",\"=\",\"\\\\\"]\n  let width = 600\n  let height = 200\n  let upperHeight = height-40\n  let cvs = document.createElement(\"canvas\")\n  cvs.width = width\n  cvs.height = height\n  // enable key input focus\n  cvs.setAttribute(\"contentEditable\", \"true\")\n  o.appendChild(cvs)\n  // drawing\n  let ctx = cvs.getContext(\"2d\")\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n  let upperKeys = [1,3,null,6,8,10,null,13,15,null,18,20,22]\n  let lowerKeys = [0,2,4,5,7,9,11,12,14,16,17,19,21,23]\n  let d = width/lowerKeys.length\n  let upperD = d-10//d/2\n  let playing = []\n  let highlight = []\n  function drawKey1(k0, bgnd, upper) {\n    let k = upper ? upperKeys[k0] : lowerKeys[k0]\n    if (k == null) return\n    let xoffset = 0\n    let xgap = 0\n    let h = height\n    let pressed = playing[k]\n    if (upper) {\n      h = upperHeight\n      xgap = d - upperD\n      xoffset = d/2\n    }\n    let x = k0*d+xoffset\n    ctx.save()\n    let bg = upper ? \"black\" : \"white\"\n    let fg = upper ? \"white\" : \"black\"\n    if (pressed) {\n      bg = \"yellow\"\n      fg = \"black\"\n    }\n    if (bgnd) {\n      ctx.fillStyle = bg\n      ctx.fillRect(x+xgap/2, 0, d-xgap, h)\n    } else {\n      ctx.strokeStyle = \"black\"\n      ctx.strokeRect(x+xgap/2, 0, d-xgap, h)\n      ctx.fillStyle = fg\n      ctx.fillText(keyInputMap[k],x+d/2, h-20)\n      ctx.fillText(keys[k],x+d/2, h-10)\n    }\n    ctx.restore()\n  }\n  function drawHighlight(k,dur,start,i) {\n    let k0 = upperKeys.indexOf(k)\n    let upper = k0 >= 0\n    if (!upper) k0 = lowerKeys.indexOf(k)\n    let xoffset = 0\n    let xgap = 0\n    let h = upperKeys.indexOf(highlight[0])>=0 ? upperHeight : height\n    if (upper) {\n      xgap = d-upperD\n      xoffset = d/2\n    }\n    let x = k0*d+xoffset\n    const fill = [\"#FF0000\",\"#ff9999\",\"#ffe6e6\"]\n    ctx.save()\n    ctx.fillStyle = fill[Math.min(i,fill.length-1)]\n    let y = h-start*h\n    ctx.fillRect(x+xgap/2, y, d-xgap, -h*dur)\n    ctx.restore()\n  }\n  function redraw() {\n  // lower keys\n  for (let i = 0; i < lowerKeys.length; i++) {\n    drawKey1(i,true,false)\n  }\n  let start = 0\n  if (highlight)\n  for (let i = 0; i < highlight.length; i+=2) {\n    if (upperKeys.indexOf(highlight[i])<0)\n    drawHighlight(highlight[i],highlight[i+1],start,i/2)\n      start = start + highlight[i+1]\n  }\n  for (let i = 0; i < lowerKeys.length; i++) {\n    drawKey1(i,false,false)\n  }\n  for (let i = 0; i < upperKeys.length; i++) {\n    drawKey1(i,true,true)\n  }\n  // upper keys\n  start = 0\n  if (highlight)\n  for (let i = 0; i < highlight.length; i+=2) {\n    if (upperKeys.indexOf(highlight[i])>=0)\n    drawHighlight(highlight[i],highlight[i+1],start,i/2)\n      start = start + highlight[i+1]\n  }\n  for (let i = 0; i < upperKeys.length; i++) {\n    drawKey1(i,false,true)\n  }\n  }\n  function drawKey(i,pressed) {\n    redraw()\n  }\n  redraw()\n  // interactivity\n  let pressed = null\n  let touchDevice = false\n  function hit(x,y) {\n    if (y < upperHeight && x > d/2) { // try upper first\n      let u = upperKeys[Math.floor((x-d/2)/d)]\n      if (u) return u\n    }\n    return lowerKeys[Math.floor(x/d)]\n  }\n  function play(k) {\n      if (!playing[k]) {\n          playing[k] = playNote(keys[k])\n          drawKey(k,true)\n      }\n  }\n  function playStop(k) {\n      if (playing[k]) {\n          let stop = playing[k]\n          playing[k] = null\n          drawKey(k,false)\n          const d = stop()\n          if (callback) callback(keys[k],d)\n      }\n  }\n  cvs.addEventListener(\"keydown\", (e) => {\n      window.lastEvent = e\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          play(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"keyup\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          playStop(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"mouseenter\", (e) => {\n      // enable key input focus if not using touch\n      if (!touchDevice) {\n        cvs.setAttribute(\"contentEditable\", \"true\")\n        cvs.focus()\n      }\n  })\n  cvs.addEventListener(\"mousedown\", (e) => {\n      let k = hit(e.offsetX,e.offsetY)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n      }\n  })\n  cvs.addEventListener(\"mouseup\", (e) => {\n      playStop(pressed)\n  })\n  cvs.addEventListener(\"mousemove\", (e) => {\n      if (!e.buttons) return\n      let k = hit(e.offsetX,e.offsetY)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchstart\", (e) => {\n      touchDevice = true\n      let bounds = cvs.getBoundingClientRect()\n      let k = hit(e.changedTouches[0].clientX-bounds.left,e.changedTouches[0].clientY-bounds.top)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n        e.preventDefault()\n        e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"touchmove\", (e) => {\n      let bounds = cvs.getBoundingClientRect()\n      let k = hit(e.changedTouches[0].clientX-bounds.left,e.changedTouches[0].clientY-bounds.top)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchend\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchcancel\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  return { draw: (hl) => {\n    highlight = []\n    if (hl) for (let i = 0; i < hl.length; i+=2) {\n      let k = keys.indexOf(hl[i])\n      if (k >= 0) highlight.push(k, hl[i+1])\n    }\n    return redraw()\n  }}\n}\n</code>\n<p>Try it!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2()\n</code>\n<p>The code includes a facility to highlight some keys. This is extremely\nuseful when learning to play (hightlight the next ones to play).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2().draw([\"C\",1/4,\"F#\",1/2,\"F\",1/4])\n</code>\n</aside>\n<p>Try this on a phone or tablet!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2()\n</code>\n<p>Cool, we can make some music now. But how do we play a song? We have to hit the right note at the right time, for the right duration.</p>\n<aside>\n<h2>Note durations</h2>\n<p>Notes are typically played for a power-of-two ratio of the duration of a full note, i.e., as one-eighth, quarter, or half notes. The duration of a full note is anchored to the tempo.</p>\n<p>Putting things together we can define helper functions to play notes for a given duration, and to play songs, which are lists of notes with their respective duration:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet tempo = 2000\nasync function playNote(k,d) {\n  let stop = play(noteFreq[k], d * tempo)\n  await sleep(d*tempo)\n  stop()\n}\nasync function playSong(song) {\n  for (let i = 0; i < song.length; i+=2)\n    await playNote(song[i], song[i+1])\n}\n// Now play a scale\nawait buttonClick(\"play\")\nawait playSong([\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\"G\",1/4,\"A\",1/4,\"B\",1/4,\"C+\",1/4])\n</code>\n<p>The ‚Äúsong‚Äù we play ist just a simple scale. We use quarter notes and a base tempo of 2 seconds for a full note. This means 2 quarter notes per second, or 120 per minute. We often find tempo specified in this way as beats per minute (BPM).</p>\n<p>Sometimes we want to play multiple notes together (chords). It is straightforward to extend the definitions above to do that. Exercise!</p>\n</aside>\n<p>Let‚Äôs define a song (this is a popular german children‚Äôs rhyme about some little ducklings).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet song = [\n\"C\",1/8,\"D\",1/8,\"E\",1/8,\"F\",1/8,\n\"G\",1/4,\"G\",1/4,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"F\",1/8,\"F\",1/8,\"F\",1/8,\"F\",1/8,\n\"E\",1/4,\"E\",1/4,\n\"D\",1/8,\"D\",1/8,\"D\",1/8,\"D\",1/8,\n\"C\",1/2\n]\n</code>\n<p>The 1/8, 1/4, etc. are the duration of each note, as fraction of a full base note. This is how we play it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet tempo = 2000\nawait buttonClick(\"play\")\nfor (let i = 0; i < song.length; i+=2) {\n  let stop = playNote(song[i])\n  await sleep(song[i+1]*tempo)\n  stop()\n}\n</code>\n<p>If you want to play it on a piano, just run the code above in your head and implement <code class=\"language-text\">playNote</code> using your fingers. It‚Äôs easy once you got the song memorized. But until then, reading a sequence like <code class=\"language-text\">\"C\",1/8,\"D\",1/8,...</code> isn‚Äôt very natural for humans.</p>\n<p>No wonder that people came up with different notations. Let‚Äôs learn about sheet music notation.</p>\n<aside>\n<h2>Sheet music notation</h2>\n<p>A good reference is here: <a href=\"https://www.musicnotes.com/now/tips/how-to-read-sheet-music/\">How To Read Sheet Music: Step-by-Step Instructions</a></p>\n<p>The implementation is below. It might be useful to break it down into smaller increments, but for now this is what we have.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction sheet(song) {\n  let width = 600\n  let height = 100\n  let rows = 3\n  let keyIndex = {C:0, \"C#\":0, D:1, \"D#\":1, E:2, F:3, \"F#\":3, G:4, \"G#\":4, A:5, \"A#\":5, B:6,\n  \"C+\":7,\"C#+\":7,\"D+\":8,\"D#+\":8,\"E+\":9,\"F+\":10,\"F#+\":10,\"G+\":11,\"G#+\":11,\"A+\":12,\"A#+\":12,\"B+\":13}\n  let cvs2 = document.createElement(\"canvas\")\n  cvs2.width = width\n  cvs2.height = rows*height\n  o.appendChild(cvs2)\n  // drawing\n  let ctx2 = cvs2.getContext(\"2d\")\n  ctx2.strokeStyle = \"black\"\n  ctx2.lineWidth = 1\n  ctx2.textAlign = \"center\"\n  ctx2.textBaseline = \"middle\"\n  function hline(row,k) {\n    ctx2.beginPath()\n    ctx2.moveTo(0,row*100+20+k*10)\n    ctx2.lineTo(width-0,row*100+20+k*10)\n    ctx2.stroke()\n  }\n  function vline(row,k) {\n    let w = 30\n    ctx2.beginPath()\n    ctx2.moveTo(k*w,row*100+20)\n    ctx2.lineTo(k*w,row*100+60)\n    ctx2.stroke()\n  }\n  function drawSheet(rows, cols) {\n    for (let row = 0; row < rows; row++){\n      for (let j = 0; j < 5; j++) {\n        hline(row,j)\n      }\n      for (let j = 4; j <= 20; j+=4) {\n        vline(row,j)\n      }\n    }\n  }\n  function note(row,x,key,d,mark) {\n    let k = keyIndex[key]\n    let r = 5\n    let w = 15\n    let ox = w/2\n    let y = row*100+20+(5-k/2)*10\n    let o = 0\n    if (k < 0) return\n    //if (d == 4) o+=20 // if we'd want to center align notes\n    if (mark) {\n      ctx2.save()\n      ctx2.fillStyle = \"#00FFFF99\"\n      ctx2.beginPath()\n      //ctx2.arc(ox+x*w+o,y,r+r,0,2*Math.PI)\n      ctx2.rect(x*w+o,row*100+10,w,60)\n      ctx2.fill()\n      ctx2.restore()\n    }\n    ctx2.beginPath()\n    ctx2.arc(ox+x*w+o,y,r,0,2*Math.PI)\n    if (d >= 4) ctx2.fill()\n    else ctx2.stroke()\n    if (d >= 2) {\n      ctx2.beginPath()\n      ctx2.moveTo(ox+x*w+r-1+o,y)\n      ctx2.lineTo(ox+x*w+r+o,y-35)\n      ctx2.stroke()\n    }\n    if (d >= 8) { // draw 2 for 1/16, 3 for 1/32 etc\n      ctx2.beginPath()\n      ctx2.moveTo(ox+x*w+r+o,y-35)\n      ctx2.lineTo(ox+x*w+10+o,y-20)\n      ctx2.stroke()\n    }\n    //ctx2.fillText(keyInputMap[k],10+x*w+o,row*100+75)\n    ctx2.fillText(key,10+x*w+o,row*100+75)\n    ctx2.fillText(Math.ceil(d),10+x*w+o,row*100+90)\n  }\n  function drawSong(song,mark) {\n    let x = 0\n    let r = 0\n    for (let j = 0; j < song.length; j+=2) {\n      note(r,x,song[j],1/song[j+1],j==mark)\n      x+=8*song[j+1]\n      if (x >= 40) {\n        r += 1\n        x -= 40\n      }\n    }\n  }\n  drawSheet(rows)\n  drawSong(song,-1)\n  return { draw: function(song,mark) {\n    ctx2.clearRect(0,0,cvs2.width,cvs2.height)\n    drawSheet(rows)\n    drawSong(song,mark)\n  }}\n}\n</code>\n<p>Let‚Äôs use it to visualize (and play) a simple scale. We use quarter notes and a base of 2 seconds for a full note, which means 2 quarter notes per second, or 120 beats per minute (BPM).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nsong = [\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\"G\",1/4,\"A\",1/4,\"B\",1/4,\"C+\",1/4]\nlet sh = sheet(song)\nlet tempo = 2000\nawait buttonClick(\"play\")\nfor (let i = 0; i < song.length; i+=2) {\n  sh.draw(song, i)\n  let stop = playNote(song[i])\n  await sleep(song[i+1]*tempo)\n  stop()\n}\nsh.draw(song)\n</code>\n</aside>\n<p>We also define some more songs.</p>\n<aside>\n<h2>More Songs</h2>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction convertSong(song) {\nlet out = []\nfor (let j = 0; j < song.length; j+=2) {\nout[j] = keyNames[song[j]]\nout[j+1] = 1/song[j+1]\n}\nreturn out\n}\n// Oh Suzanna\nlet osz0 = [\n1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,1,4,\n2,2,/**/1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,2,4,\n1,2,/**/]\nlet osz1 = [\n4,2,4,2,\n6,4,6,2,6,4,\n5,4,5,4,3,4,1,4,\n2,2,/**/1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,2,4,\n1,2,\n]\nlet alleMeineEntchen = [\n\"C\",1/8,\"D\",1/8,\"E\",1/8,\"F\",1/8,\n\"G\",1/4,\"G\",1/4,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"F\",1/8,\"F\",1/8,\"F\",1/8,\"F\",1/8,\n\"E\",1/4,\"E\",1/4,\n\"D\",1/8,\"D\",1/8,\"D\",1/8,\"D\",1/8,\n\"C\",1/2\n]\nlet ohSuzannaChorus = [\n\"G\",0.5,\"G\",0.5,\n\"B\",0.25,\"B\",0.5,\"B\",0.25,\n\"A\",0.25,\"A\",0.25,\"F#\",0.25,\"D\",0.25,\n\"E\",0.5+0.25,\"D\",0.125,\"E\",0.125,\n\"F#\",0.25,\"A\",0.25,\"A\",0.25+0.125,\"B\",0.125,\n\"A\",0.25,\"F#\",0.25,\"D\",0.25+0.125,\"E\",0.125,\n\"F#\",0.25,\"F#\",0.25,\"E\",0.25,\"E\",0.25,\n\"D\",0.5\n]\nlet fuchsDuHastDieGansGestohlen = [\n\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\n\"G\",1/4,\"G\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"F\",1/4,\"C+\",1/4,\"A\",1/4,\n\"G\",1,\n\"A\",1/4,\"F\",1/4,\"C+\",1/4,\"A\",1/4,\n\"G\",1,\n\"G\",1/4,\"F\",1/4,\"F\",1/4,\"F\",1/4,\n\"F\",1/4,\"E\",1/4,\"E\",1/4,\"E\",1/4,\n\"E\",1/4,\"D\",1/4,\"E\",1/4,\"D\",1/4,\n\"C\",1/4,\"E\",1/4,\"G\",1/2,\n\"G\",1/4,\"F\",1/4,\"F\",1/4,\"F\",1/4,\n\"F\",1/4,\"E\",1/4,\"E\",1/4,\"E\",1/4,\n\"E\",1/4,\"D\",1/4,\"E\",1/4,\"D\",1/4,\n\"C\",1\n]\nlet katyusha = [\n\"A\",1/4+1/8,\"B\",1/8,\n\"C+\",1/4+1/8,\"A\",1/8,\n\"C+\",1/8,\"C+\",1/8,\"B\",1/8,\"A\",1/8,\n\"B\",1/4,\"E\",1/4,\n\"B\",1/4+1/8,\"C+\",1/8,\n\"D+\",1/4+1/8,\"B\",1/8,\n\"D+\",1/8,\"D+\",1/8,\"C+\",1/8,\"B\",1/8,\n\"A\",1/2,\n//\n\"E+\",1/4,\"A+\",1/4,\n\"G+\",1/4,\"A+\",1/8,\"G+\",1/8,\n\"F+\",1/8,\"F+\",1/8,\"E+\",1/8,\"D+\",1/8,\n\"E+\",1/4,\"A\",1/4,\n\"F+\",1/4+1/8,\"D+\",1/8,\n\"E+\",1/4+1/8,\"C+\",1/8,\n\"B\",1/8,\"E\",1/8,\"C+\",1/8,\"B\",1/8,\n\"A\",1/2,\n]\nlet wheelsOnTheBus = [\n\"D\",1/4,\n\"G\",1/4,\"G\",1/8,\"G\",1/8,\"G\",1/4,\"B\",1/4,\n\"D+\",1/4,\"B\",1/4,\"G\",1/2,\n\"A\",1/4,\"F#\",1/4,\"D\",1/2,\n\"D+\",1/4,\"B\",1/4,\"G\",1/4,\"D\",1/4,\n\"G\",1/4,\"G\",1/8,\"G\",1/8,\"G\",1/4,\"B\",1/4,\n\"D+\",1/4,\"B\",1/4,\"G\",1/2,\n\"A\",1/2,\"D\",1/4,\"D\",1/4,\"G\",1/2\n]\nlet ruleBritannia = [\n\"B\",1/4+1/8,\"B\",1/8,\"C+\",1/8,\"C+\",1/8+1/8,\"B\",1/8,\n\"C+\",1/8+1/16,\"B\",1/16,\"A\",1/8,\"G\",1/8,\"F\",1/4+1/8,\"A\",1/8,\n\"D+\",1/4,\"C+\",1/4,\"B\",1/16,\"G\",1/16,\"C+\",1/16,\"A\",1/16,\"D+\",1/8,\"C+\",1/8,\n\"B\",1/4,\"A\",1/4,\"G\",1/2\n]\nlet twinkleTwinkleLittleStar = [\n\"C\",1/4,\"C\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"A\",1/4,\"G\",1/2,\n\"F\",1/4,\"F\",1/4,\"E\",1/4,\"E\",1/4,\n\"D\",1/4,\"D\",1/4,\"C\",1/2,\n\"G\",1/4,\"G\",1/4,\"F\",1/4,\"F\",1/4,\n\"E\",1/4,\"E\",1/4,\"D\",1/2,\n\"G\",1/4,\"G\",1/4,\"F\",1/4,\"F\",1/4,\n\"E\",1/4,\"E\",1/4,\"D\",1/2,\n\"C\",1/4,\"C\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"A\",1/4,\"G\",1/2,\n\"F\",1/4,\"F\",1/4,\"E\",1/4,\"E\",1/4,\n\"D\",1/4,\"D\",1/4,\"C\",1/2,\n]\n/*\nlet enterSandman = [\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n//\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"E\",1/4,\"C\",1/8,\"D\",1/8,\"C\",1/8,\"D\",1/8,\"E\",1/8,\"D\",1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"E\",1/4,\"C\",1/8,\"D\",1/8,\"C\",1/8,\"D\",1/8,\"E\",1/8,\"D\",1/8,\n\"C\",1/4,\n\"G+\",1/8,\"G+\",1/8,\"G+\",1/4,\"D+\",1/8,\"E+\",1/8,\"E+\",1/4,\n\"G+\",1/8,\"G+\",1/8,\"G+\",1/8,\"A+\",1/4,\"G+\",1/8,\"E+\",1/4,\n\"E+\",1/8,\"E+\",1/8,\"E+\",1/8,\"B\",1/8,\"D+\",1/8,\"E+\",1/8,\n\"D+\",1/8,\"E+\",1/8+1/2\n]*/\nlet enterSandman = [\n\"E\",1/4,\"E+\",1/8,\"G+\",1/8,\"A#\",1/8,\"A\",1/4,\"E+\",1/8,\n\"E\",1/4,\"E+\",1/8,\"G+\",1/8,\"A#\",1/8,\"A\",1/4,\"E+\",1/8,\n\"C\",1/4,\"C+\",1/8,\"D#+\",1/8,\"C+\",1/8,\"D#+\",1/8,\"E+\",1/8,\"D#+\",1/8,\"C+\",1/4,\n//EGEF#EF#GF#E\n]\nlet maennerMitBaerten = [\n\"E\",1/8,\"F#\",1/8,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/8,\"G\",1/8,\"F#\",1/8, \"E\",1/4,\"C\",1/8, /* really B- */\n\"E\",1/4,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/4,\"F#\",1/8, \"E\",1/4+1/8, // b√§rten sein\n\"G\",1/4,\"A\",1/8,\"B\",1/4,\"A\",1/8,\n\"G\",1/4,\"A\",1/8,\"B\",1/4+1/8, // pitt\n\"E\",1/8,\"F#\",1/8,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/4,\"F#\",1/8,\"E\",1/4+1/8\n]\nlet drEisenbart = [\n\"D\",1/8,\n\"G\",1/8, \"D\",1/8, \"D\",1/8, \"D\",1/8,\n\"E\",1/8, \"D\",1/8, \"D\",1/4,\n\"D\",1/16, \"E\",1/16, \"F#\",1/16, \"G\",1/16, \"A\",1/8, \"F#\",1/8,\n\"G\",1/4+1/8, \"D\",1/8,\n\"G\",1/8, \"D\",1/8, \"D\",1/8, \"D\",1/8,\n\"E\",1/8, \"D\",1/8, \"D\",1/4,\n\"D\",1/16, \"E\",1/16, \"F#\",1/16, \"G\",1/16, \"A\",1/8, \"F#\",1/8,\n\"G\",1/4+1/8, \"B\",1/8,\n\"A\",1/8, \"B\",1/8, \"A\",1/8, \"B\",1/8,\n\"A\",1/8, \"B\",1/8, \"A\",1/4,\n\"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/8, \"G\",1/8,\n\"F#\",1/8, \"E\",1/8, \"D\",1/4,\n\"D\",1/8+1/16, \"G\",1/16, \"G\",1/8, \"G\",1/8,\n\"G\",1/8, \"B\",1/8, \"B\",1/4,\n\"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/16, \"B\",1/8, \"A\",1/8,\n\"G\",1/4,\n]\nlet jingleBells = [\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"G\",1/4, \"C\",1/4, \"D\",1/4,\n\"E\",1,\n\"F\",1/4, \"F\",1/4, \"F\",1/4, \"F\",1/4,\n\"F\",1/4, \"E\",1/4, \"E\",1/4, \"E\",1/4,\n\"E\",1/4, \"D\",1/4, \"D\",1/4, \"E\",1/4,\n\"D\",1/2, \"G\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"G\",1/4, \"C\",1/4, \"D\",1/4,\n\"E\",1,\n\"F\",1/4, \"F\",1/4, \"F\",1/4, \"F\",1/4,\n\"F\",1/4, \"E\",1/4, \"E\",1/4, \"E\",1/4,\n\"G\",1/4, \"G\",1/4, \"F\",1/4, \"D\",1/4,\n\"C\",1\n]\nfunction pickSong(callback) {\n  print(\"Pick a song:\")\n  button(\"Oh Suzanna\", () => callback(ohSuzannaChorus))\n  button(\"Twinkle Twinkle Little Star\", () => callback(twinkleTwinkleLittleStar))\n  button(\"The Wheels On The Bus\", () => callback(wheelsOnTheBus))\n  button(\"Katyusha\", () => callback(katyusha))\n  button(\"Enter Sandman\", () => callback(enterSandman))\n  button(\"Rule Britannia\", () => callback(ruleBritannia))\n  button(\"Alle Meine Entchen\", () => callback(alleMeineEntchen))\n  button(\"Fuchs Du Hast die Gans Gestohlen\", () => callback(fuchsDuHastDieGansGestohlen))\n  button(\"M√§nner mit B√§rten\", () => callback(maennerMitBaerten))\n  button(\"Dr. Eisenbart\", () => callback(drEisenbart))\n  button(\"Jingle Bells\", () => callback(jingleBells))\n  print(\"\")\n}\n</code>\n</aside>\n<p>And now it‚Äôs time to play them while following along on the sheet:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nasync function playSong(song) {\n  clear()\n  pickSong(playSong)\n  let sh = sheet(song)\n  let tempo = 1500\n  await buttonClick(\"play\")\n  for (let i = 0; i < song.length; i+=2) {\n    sh.draw(song, i)\n    let stop = playNote(song[i])\n    await sleep(song[i+1]*tempo)\n    stop()\n  }\n  sh.draw(song)\n  playSong(song)\n}\nplaySong(ohSuzannaChorus)\n</code>\n<h2>Piano Drills</h2>\n<p>The nice thing is that everything is programmable, so we can do something more advanced. Let‚Äôs put everything together and do some piano drills. We use a piano keyboard that advances the marker only when hitting the right note, and we draw the notes hit by the user below:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet showRecorded = false\nasync function drill(song) {\n  clear()\n  pickSong(drill)\n  let rec = []\n  let handler = (k,d) => {}\n  let sh1 = sheet(song)\n  let pi = piano2((k,d) => handler(k,d))\n  let sh2 = showRecorded ? sheet(rec) : null\n  let tempo = 1500\n  function notePlayed(k0,d0) {\n    return new Promise(resolve => handler = (k,d) => {\n      if (showRecorded) {\n        rec.push(k,d/1000*tempo); sh2.draw(rec)\n      }\n      if (k == k0) resolve() })\n  }\n  for (;;) {\n    for (let i = 0; i < song.length; i+=2) {\n      sh1.draw(song, i)\n      pi.draw([song[i],song[i+1],song[i+2],song[i+3],song[i+4],song[i+5]])\n      await notePlayed(song[i],song[i+1])\n    }\n    sh1.draw(song)\n    pi.draw()\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nshowRecorded = true\ndrill(ohSuzannaChorus)\n</code>\n<div class=\"cursive\">Have fun!</div>\n<h2>Hearing Practice</h2>\n<p>What else can we do? Let‚Äôs do some hearing practice. We play a random note, and have to hit the correct key on the piano keyboard.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nasync function ear() {\n  clear()\n  let handler = (k,d) => {}\n  let pi = piano2((k,d) => handler(k,d))\n  function notePlayed(k0) {\n    //print(\"want: \"+k0)\n    return new Promise(resolve => handler = (k,d) => {\n      if (k == k0) {\n        print(\"yay!\"); resolve()\n      }}) //else print(\"nope\")})\n  }\n  let rand = Math.floor(Math.random() * noteName.length);\n  let note = noteName[rand]\n  let stop = playNote(note)\n  let fut1 = sleep(2000)\n  let fut2 = notePlayed(note)\n  await fut1\n  stop()\n  await fut2\n  await sleep(1000)\n  await ear()\n}\nawait buttonClick(\"Go!\")\nawait ear()\n</code>\n</aside>\n<code class=\"runScript\" filter=\"coolEditor\">\ndrill(ohSuzannaChorus)\n</code>","fields":{"slug":"/Public/Generic/virtual-piano/"},"frontmatter":{"date":"2020-06-20","title":"Virtual Piano Practice","description":"Building an interactive piano app. Drawing the keyboard, playing notes using Web Audio, and drawing sheet music notation.","keywords":null,"tags":null}}},{"node":{"excerpt":"Automatic Differentiation (AD) is a programming technique that supports transparent and efficient computation of gradients for numeric code‚Ä¶","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Automatic Differentiation (AD) is a programming technique that supports transparent and efficient computation of gradients for numeric code in general-purpose programming languages.</p>\n<!-- We present a simple but powerful implementation of AD in JavaScript, with interactive examples. -->\n<aside>\n<h2>Context and Motivation</h2>\n<p>Deep learning crucially depends on the computation of gradients, and specifically on optimizing parameters of neural networks to fit a set of training samples using a process called gradient descent.</p>\n<p>Differentiable programming is a vision of generalizing deep learning from layer-oriented neural network architectures to training essentially arbitrary parameterized computations by gradient descent. AD is key enabler for such visions.</p>\n<p>Many explanations of AD are needlessly complex, and the topic often seems quite mysterious. The goal of this note is to provide a simple and interactive ‚Äúfrom scratch‚Äù implementation of both forward- and reverse-mode AD that can be easily understood <em>in toto</em>. As we will show, even reverse-mode AD (‚Äúbackpropagation‚Äù) can be almost ridiculously simple with the right techniques.</p>\n<p>For academically inclined readers, we refer to some of our recent publications that explain AD from a program transformation perspective:</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1803.10228\">Demystifying Differentiable Programming: Shift/Reset the Penultimate Backpropagator (Wang et al., ICFP ‚Äò19)</a></li>\n<li><a href=\"https://papers.nips.cc/paper/8221-backpropagation-with-callbacks-foundations-for-efficient-and-expressive-differentiable-programming\">Backpropagation with Continuation Callbacks: Foundations for Efficient and Expressive Differentiable Programming (Wang et al., NeurIPS ‚Äò19)</a></li>\n</ul>\n<p>Some utility code follows.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// some visualization utils\nlet cvs = null\nlet ctx = null\nlet plotScale = 1\nfunction newPlot(w,h) {\n    cvs = document.createElement(\"canvas\")\n    cvs.width = w\n    cvs.height = h\n    o.appendChild(cvs)\n    ctx = cvs.getContext(\"2d\")\n}\nfunction drawPoint(x,y) {\n    ctx.beginPath()\n    ctx.arc(x*plotScale,cvs.height-y*plotScale,4,0,2*Math.PI,true)\n    ctx.fill()\n}\nfunction drawPoints(data) {\n    for (let i = 0; i < data.length; i++)\n        drawPoint(data[2*i], data[2*i+1])\n}\nfunction drawFunction(f) {\n    ctx.beginPath()\n    ctx.moveTo(0,cvs.height-f(num(0)).val*plotScale)\n    for (let x = 1; x < cvs.width; x++)\n        ctx.lineTo(x,cvs.height-f((x)/plotScale)*plotScale)\n    ctx.stroke()\n}\nfunction drawLine(data) {\n    if (data.length == 0) return\n    let max = Math.max(...data)\n    let scaleY = 200/max\n    let scaleX = 200/data.length\n    ctx.beginPath()\n    ctx.moveTo(0, 200-data[0]*scaleY)\n    for (let i = 1; i < data.length; i++) {\n        ctx.lineTo(i*scaleX, 200-data[i]*scaleY)\n    }\n    ctx.stroke()\n}\nfunction randomInt(max) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n</code>\n</aside>\n<p>AD is a key enabler for deep learning and for visions of differentiable programming that generalize deep learning from layer-oriented neural networks to arbitrary computations.</p>\n<aside id=\"forward-mode-ad\">\n<h2>Forward-Mode AD</h2>\n<p>Let‚Äôs recall the standard rules for computing derivatives from high school:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(a+b)' = a' + b'\n(a-b)' = a' - b'\n(a*b)' = a'*b + b'*a\n...</code></pre></div>\n<p>Observe that the order of steps to compute a derivative follows exactly the order of steps to compute the normal result. The multiplication rule is perhaps non-obvious, but if <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">a'</code>, and <code class=\"language-text\">b'</code> are already computed, then we can compute <code class=\"language-text\">a*b</code> and <code class=\"language-text\">(a*b)'</code> at the same time.</p>\n<p>The basic idea behind forward-mode AD is to transform a program to do exactly that: compute derivatives in lockstep with every elementary arithmetic operation.</p>\n<h3>Implementation</h3>\n<p>We can implement forward-mode AD in any programming language by introducing a data type of <em>dual numbers</em>, with all arithmetic operations overriden to compute derivatives in addition to the standard (‚Äúprimal‚Äù) return values.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// dual number api\nfunction num(x, d=0) {\n    return { val: x, grad: d }\n}\nfunction plus(x,y) {\n    return num(x.val + y.val, x.grad + y.grad)\n}\nfunction minus(x,y) {\n    return num(x.val - y.val, x.grad - y.grad)\n}\nfunction times(x,y) {\n    return num(x.val * y.val, x.val * y.grad + y.val * x.grad)\n}\n</code>\n<p>Real operator overloading as in Python, Scala, etc. would make client code more readable, but is unfortunately not available in plain JS (though possible via preprocessing with Babel or Sweet.js).</p>\n<p>The rules to compute the derivative components are exactly the differentiation rules from highschool-level calculus.</p>\n<p>Given a function on dual numbers, we can define accessors to obtain only the standard (‚Äúprimal‚Äù) or the derivative component.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction primal(f) {\n    return (x => f(num(x,1)).val)\n}\nfunction deriv(f) {\n    return (x => f(num(x,1)).grad)\n}\n</code>\n<h3>Examples (Analytically)</h3>\n<p>Let‚Äôs verify that it works. Feel free to try some examples of your own:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// helper functions\nfunction expectFunc(f1,f2) {\n    for (let x = -10; x < 10; x++)\n        expect(f1(x), f2(x))\n}\nfunction testDeriv(label, f, d) {\n  test(label, () => expectFunc(deriv(f), d))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// test cases\ntestDeriv(\n  \"deriv(x^2) = 2x\",\n  x => times(x, x),\n  x => 2*x)\ntestDeriv(\n  \"deriv(2x^3) = 6x^2\",\n  x => times(num(2),times(x,times(x, x))),\n  x => 6*x*x)\n</code>\n<h3>Examples (Graphically)</h3>\n<p>We can also convince ourselves that we got it right by plotting a function along with its tangents at various points (try changing f or 0.8):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// draw tangent of f at x\nfunction drawTangent(f,x) {\n    let y = primal(f)(x)\n    let dy = deriv(f)(x)\n    let z = y-dy*x\n    drawPoint(x,y)\n    drawFunction(x1 => dy*x1+z)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example function (2(x-0.5))^2\nfunction sqr(x) {\n    return times(x,x)\n}\nfunction f(x) {\n    return sqr(times(num(2),minus(x,num(0.5))))\n}\n// draw it!\nnewPlot(200,200)\nplotScale = 200\ndrawFunction(primal(f))\ndrawTangent(f, 0.8) /* point for tangent -- play with it! */\n</code>\n<h3>Discussion</h3>\n<p>The beauty of AD is that we aren‚Äôt restricted to functions containing primitive arithmetic only. We can freely mix dual numbers with any other computation, including control flow, loops, recursion, objects, classes, etc.</p>\n<p>Of course we do not, in general, have any guarantee that a program with complex logic is differentiable in the mathematical sense across its entire input range. Basically, any <code class=\"language-text\">if</code> is a potential discontinuity. Thus, it is important to remember that the result of AD is only valid locally at the point it was computed, but it may not be valid in a neighborhood of that point. But since computer programs operate on discrete approximations rather than actual real numbers, talking about mathematical notions like continuity, smoothness, or differentiability in this context is murky anyways.</p>\n<p><strong>Exercise:</strong> how can we extend the scheme to compute partial derivatives for functions with multiple input arguments?</p>\n<p><strong>Exercise:</strong> what about higher (2nd, 3rd, ‚Ä¶) order derivatives?</p>\n<p><strong>Exercise:</strong> what about nested invocations of <code class=\"language-text\">grad</code> (of which higher-order derivatives are a special case)? Hint: read up on ‚Äúperturbation confusion‚Äù.</p>\n</aside>\n<p>Forward-mode AD computes derivatives for each intermediate result in lockstep with the normal program execution. It is straightforward but inefficient when computing gradients (i.e., many partial derivates), which is necessary for neural networks with many parameters.</p>\n<aside id=\"reverse-mode-ad\">\n<h2>Reverse-Mode AD (Backpropagation)</h2>\n<p><a href=\"/forward-mode-ad\">Forward-mode AD</a> can be extended to compute multiple partial derivatives (and therefore gradients) simultaneously by adding a field for each partial derivative to the dual number type. However, this is inefficient if the number of parameters gets large, as is the case for neural networks and many other practical applications.</p>\n<p>Reverse-mode AD solves the scalability issue of forward-mode AD through clever use of the chain rule of differentiation.</p>\n<h3>Intuition</h3>\n<p>Instead of computing derivates in lockstep with the normal computation as in forward-mode AD, we first execute the program normally to compute the primal result, and then we propagate gradient updates backwards for each intermediate result (this requires some bookkeeping).</p>\n<p>Mathematically speaking, we do not compute how each intermediate result changes in response to a change in the program input (as in forward-mode), but rather how the program output changes in response to a change in the intermediate value. At the end of the backward pass the result is the same: we obtain the change of the program output in response to a change in the program input.</p>\n<p>Consider as an example a program whose final output is <code class=\"language-text\">y</code> and whose intermediate computations include:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x3 = x1 + x2\n...\nx4 = x1 * x2\n...</code></pre></div>\n<p>Since we‚Äôre going backwards, we will have computed <code class=\"language-text\">dy/dx3</code> and <code class=\"language-text\">dy/dx4</code> at some point. These are the change of the program output relative to a change in <code class=\"language-text\">x3</code> and <code class=\"language-text\">x4</code>, respectively. Once these results are available, we can compute <code class=\"language-text\">dy/dx1</code> (and likewise <code class=\"language-text\">dy/dx2</code>) through the chain rule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dy/dx1 = dy/dx4 * dx4/dx1 + dy/dx3 * dx3/dx1</code></pre></div>\n<p>Not that the computation of <code class=\"language-text\">dy/dx1</code> has to sum over all occurrences of <code class=\"language-text\">x1</code>, in this case <code class=\"language-text\">x3</code> and <code class=\"language-text\">x4</code>. Intuitively, each occurrence of <code class=\"language-text\">x1</code> contributes through different pahts to the final result <code class=\"language-text\">z</code>, so to express how <code class=\"language-text\">z</code> changes overall in response to a delta in <code class=\"language-text\">x1</code>, we have to consider all these paths, as each contributes an additive delta to <code class=\"language-text\">z</code>.</p>\n<p>Operationally, it is useful to express this summation as a series of updates to a read-only accumulator. For each intermediate result we keep an accumulator and when we reach <code class=\"language-text\">x3</code> in the backwards pass, we add the delta <code class=\"language-text\">dy/dx3 * dx3/dx1</code> to the accumulator for <code class=\"language-text\">dy/dx1</code> (and analogous for <code class=\"language-text\">x2</code>). Note that <code class=\"language-text\">dx3/dx1</code> can be computed solely from the right-hand side of <code class=\"language-text\">x3 = ...</code>, but may require the primal value of <code class=\"language-text\">x1</code> computed in the forward pass. By the time we reach <code class=\"language-text\">x1</code> in the backward pass, we know we have accumulated all updates to <code class=\"language-text\">dy/dx1</code> and we can proceed propagation gradient updates for the inputs of the computation of <code class=\"language-text\">x1</code>.</p>\n<h3>Implementation</h3>\n<p>The forwards-then-backwards execution can be achieved in different ways. For programming language buffs, there is an especially appealing relation with continuation passing style (CPS). Here, we use a slightly modified dual number type and a stack data structure (often called the <em>tape</em>) that accumulates closures for the backward pass in the right order.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// stack to remember backward operations\nlet tape = []\n// dual number api\nfunction num(x) {\n    return { val: x, grad: 0 }\n}\nfunction plus(x,y) {\n    let z = num(x.val + y.val)\n    tape.push(() => { x.grad += z.grad; y.grad += z.grad })\n    return z\n}\nfunction minus(x,y) {\n    let z = num(x.val - y.val)\n    tape.push(() => { x.grad += z.grad; y.grad -= z.grad })\n    return z\n}\nfunction times(x,y) {\n    let z = num(x.val * y.val)\n    tape.push(() => { x.grad += y.val * z.grad; y.grad += x.val * z.grad })\n    return z\n}\n</code>\n<p>The function that computes gradients/derivatives needs to traverse the tape in reverse order, popping and running all the accumulated ‚Äúbackpropagator‚Äù closures.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// derivative/gradient api\nfunction grad(f) {\n    function d(x) {\n        // forward pass\n        let dx = num(x)\n        let dz = f(dx)\n        dz.grad = 1\n        // backward pass\n        for (b of tape.reverse()) b()\n        tape = []\n        return dx.grad\n    }\n    return d\n}\n</code>\n<p>This implementation of <code class=\"language-text\">grad</code> already demonstrates the key difference in capability/scalability to forward-mode AD.</p>\n<p><strong>Exercise:</strong> how to compute partial derivatives/gradients for functions with multiple arguments?</p>\n<p>All that is required is to change function <code class=\"language-text\">grad</code> to work with <code class=\"language-text\">dx1</code>,<code class=\"language-text\">dx2</code>, etc. instead of a singular <code class=\"language-text\">dx</code>. Crucially, no additional data needs to be computed and/or stored as part of the forward or backward pass.</p>\n<h3>Examples (Analytically)</h3>\n<p>Again we run some test cases, and we observe that we get the same, correct, result as in forward mode:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// helper functions\nfunction testGrad(label, f, d) {\n  test(label, () => expectFunc(grad(f), d))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// test cases\ntestGrad(\n  \"grad(x^2) = 2x\",\n  x => times(x, x),\n  x => 2*x)\ntestGrad(\n  \"grad(2x^3) = 6x^2\",\n  x => times(num(2),times(x,times(x, x))),\n  x => 6*x*x)\n</code>\n<h3>Examples (Graphically)</h3>\n<p>Visualization (try variations yourself):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// draw tangent of f at x\nfunction drawTangent(f,x) {\n    let y = primal(f)(x)\n    let dy = grad(f)(x)\n    let z = y-dy*x\n    drawPoint(x,y)\n    drawFunction(x1 => dy*x1+z)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example function (2(x-0.5))^2\nfunction sqr(x) {\n    return times(x,x)\n}\nfunction f(x) {\n    return sqr(times(num(2),minus(x,num(0.5))))\n}\n// draw it!\nnewPlot(200,200)\nplotScale = 200\ndrawFunction(primal(f))\ndrawTangent(f, 0.8) /* point for tangent -- play with it! */\n</code>\n<h3>Discussion</h3>\n<p>While we used the same single-argument examples as for forward-mode AD (mainly for consistency), it is important to stress once more that we can use the same code to compute partial derivatives and gradients for functions with multiple arguments, with only marginal overhead.</p>\n<p><strong>Exercise:</strong> consider a function with multiple <em>outputs</em>. Which variant is more efficient, forward- or reverse-mode AD?</p>\n</aside>\n<p>Reverse-mode AD solves the scalability issue of forward-mode AD through clever use of the chain rule of differentiation. The program is executed once to compute the normal result, and then traces back through each intermediate computation step to propagate gradient updates back to the input parameters.</p>\n<aside id=\"gradient-descent-optimization\">\n<h2>Gradient-Descent Optimization</h2>\n<p>What is <a href=\"/reverse-mode-ad\">AD</a> good for? The key motivation is optimization by gradient descent. We want to match a parameterized function (e.g., a neural network) to some observed data. To do so, we provide a function to compute the difference between the result computed based on the current parameter settings and the observed data (the loss function). Then, we compute the gradient of the loss function and adjust the parameters ever so slightly in the direction where the loss gets smaller.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction drawPoint(x,y) {\n    ctx.beginPath()\n    ctx.arc(x,200-y,4,0,2*Math.PI,true)\n    ctx.fill()\n}\nfunction drawFunction(f) {\n    ctx.beginPath()\n    ctx.moveTo(0,200-f(num(0)).val)\n    for (let x = 1; x < 200; x++)\n        ctx.lineTo(x,200-f(num(x)).val)\n    ctx.stroke()\n}\n</code>\n<p>We introduce an API to define optimizable parameters:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// basic functionality: keep track of\n// optimizable parameters\nlet params = []\nfunction param(x) {\n    const dx = num(x)\n    params.push(dx)\n    return dx\n}\n</code>\n<p>The second component is the optimization loop, which adjusts the parameter values based on the computed gradients:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// compute primal and gradient\nfunction compute(loss) {\n    tape = []\n    // forward\n    const d = loss()\n    // backprop\n    d.grad = 1\n    for (const b of tape.reverse()) b()\n    return d\n}\n// one optimization step\nlet lr = 0.0001 // learning rate\nfunction optimize(loss) {\n    const d = compute(loss)\n    // gradient descent\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        p.val -= lr * p.grad\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<h3>Example: Linear Regression</h3>\n<p>Here is an example. We define a linear function, which we want to fit to some data (linear regression).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nconst a0 = param(0)\nconst a1 = param(1)\nfunction approx(x) {\n    return plus(times(a1,x), a0)\n}\n</code>\n<p>We also define a sample data set. We use only two points for now, and since two points uniquely define a line, we should be able to fit the function to the data exactly:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// x,y stored in interleaved order\nlet data = [40,120,160,40]\nlet nSamples = data.length/2\n</code>\n<p>Let‚Äôs quickly plot the initial situation:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n</code>\n<p>Now to do the fitting, we first define the loss function (observed error) as the mean sum of squares:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction loss() {\n    let total = num(0)\n    for (let i = 0; i < nSamples; i++) {\n        const x = data[2*i]\n        const y = data[2*i+1]\n        const d = minus(num(y), approx(num(x)))\n        total = plus(total, times(d,d))\n    }\n    return times(total, num(1.0/nSamples))\n}\n</code>\n<p>Let‚Äôs plot some optimization steps (go ahead and change the learning rate or the loop bounds):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001 // <- try adding or removing a zero\nfor (let i = 0; i < 100; i++) {\n    optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\n</code>\n<p>We can see that the slope adjusts well initially, but then appears to get stuck. The y intercept by contrast doesn‚Äôt appear to move at all. When we increase the number of iterations we can see that it actually does move - however very very slowly. It takes around 10,000 iterations to see any visible change, and even at 100,000 iterations we aren‚Äôt anywhere close to where we want to be (try it!).</p>\n<p>Unfortunately, we cannot increase the learning rate to accelerate the process, because then the changes to the slope explode (try <code class=\"language-text\">lr = 0.0001</code>).</p>\n<p>Here are some variants with additional debug output to visualize how the overall error and the approximated values of <code class=\"language-text\">a0</code> and <code class=\"language-text\">a1</code> change from iteration to iteration:</p>\n<aside>\n<p>Batch mode</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<aside>\n<p>Batch size of 1</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    if (i%2 == 1)\n        data = [40,120]\n    else\n        data = [160,40]\n    nSamples = 1\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<aside>\n<p>Batch size of 1, randomized</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    if (randomInt(2) == 1)\n        data = [40,120]\n    else\n        data = [160,40]\n    nSamples = 1\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<h3>Stochastic Gradient Descent (SGD)</h3>\n<p>The variants with batch size 1 deserve a little bit of discussion. For large datasets, it is inefficient to adjust parameters only after processing the whole dataset (which may be gigabytes or even terabytes). Thus, in practice, it is common to compute the loss and update parameters based on a randomly selected ‚Äúminibatch‚Äù at a time. This is called <em>stochastic</em> gradient descent (SGD), and in the limit, with batch size 1, we update parameters after each and every processed training sample.</p>\n<h3>Discussion</h3>\n<p>In conclusion, plain gradient descent works but is brittle. It requires careful tuning of the initial parameter values and, especially, of the learning rate.</p>\n<p>Parameters change with wildly different rates, yet the learning rate must be small enough to ensure stability for all of them. This leads to overall slow convergence.</p>\n<p>What we would <em>really</em> like to have is <em>different</em> learning rates for different parameters. Fortunately, such variations of the gradient-descent approach exist (e.g., AdaGrad, ADAM, etc.) and they can even adapt learning rates dynamically to how parameters change. These algorithms are more robust, and more efficient in practice.</p>\n<p>Another option are second-order methods that include curvature information (variants of Newton‚Äôs method). For many applications, these methods tend to be more robust and converge faster, however they are also more computationally intensive and have a reputation (deserved or not) to get stuck in saddle points in high-dimensional spaces. For these reasons, they are not frequently used in machine learning.</p>\n<p>We will discuss <a href=\"/gradient-descent-with-adam\">ADAM next</a>.</p>\n</aside>\n<p>The key motivation for AD is optimization by gradient descent. We show the core algorithm, and discuss why it is almost never used in its pure form in practice.</p>\n<aside id=\"gradient-descent-with-adam\">\n<p>Gradient Descent with ADAM (Adaptive Moment Estimation)</p>\n<p>We have seen above that <a href=\"/gradient-descent-optimization\">standard gradient descent</a> is sensitive to initial conditions and, especially, the learning rate. Since the same learning rate is applied to all parameters and remains unchanged throughout the training/optimization process, it has to be chosen very small, which means that many iterations are necessary.</p>\n<p>Improving gradient descent has been an intense focus of research. A nice and comprehensive overview is given by Sebastian Ruder:</p>\n<ul>\n<li><a href=\"https://ruder.io/optimizing-gradient-descent/index.html\">An overview of gradient descent optimization algorithms</a></li>\n</ul>\n<p>We use the ADAM algorithm below, which combines two key ideas to adjust the learning rate for each parameter based on prior changes:</p>\n<ul>\n<li>exponentially decaying average of past gradients (momentum)</li>\n<li>exponentially decaying average of past squared gradients</li>\n</ul>\n<p>Roughly, one can view ADAM as behaving like a heavy ball (with momentum), rolling down a hill slope (the error surface), subject to friction. Thus the ball tends to prefer flat minima.</p>\n<p>As an intermediate step, here is an implementation using only momentum:</p>\n<aside>\n<h3>Gradient Descent with Momentum</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet lastV1 = params.map(x => 0)\nlet gamma = 0.9\nfunction optimize(f) {\n    const d = compute(loss)\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        const v = lastV1[j]\n        const v1 = gamma * v + lr * p.grad\n        p.val -= v1\n        lastV1[j] = v1\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\ngamma = 0.99\nlr = 0.0001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val+1 // shift b/c negative\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error: \"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + (p2[0]-1) + \" --> \" + (p2[p2.length-1]-1))\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<p>It converges in about 1000 steps for our linear regression example (down 2 orders of magnitude from over 100,000).</p>\n<p>With 1000 steps, it is interesting to note how <code class=\"language-text\">a0</code> ‚Äúovershoots‚Äù its target (due to momentum) and then settles back into the correct value.</p>\n<h3>ADAM</h3>\n<p>Here is the implementation:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet betaM = 0.9\nlet betaV = 0.999\nlet eps = 1e-8\nlet lastM = params.map(x => 0)\nlet lastV = params.map(x => 0)\nlet lastBetaM = betaM\nlet lastBetaV = betaV\nfunction optimize(f) {\n    const d = compute(loss)\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        const m = betaM * lastM[j] + (1-betaM) * p.grad\n        const v = betaV * lastV[j] + (1-betaV) * p.grad * p.grad\n        const m1 = m/(1-lastBetaM)\n        const v1 = v/(1-lastBetaV)\n        p.val -= lr * m1 / (Math.sqrt(v1) + eps)\n        lastM[j] = m\n        lastV[j] = v\n        lastBetaM *= betaM\n        lastBetaV *= betaV\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<h3>Example: Linear Regression</h3>\n<p>We apply ADAM to our running linear regression example.\nIn contrast to standard gradient descent, which needed about 300,000 iterations to converge and could not sustain learning rates of more than 0.00001, ADAM converges in only 150 iterations.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 2 // absurdly high learning rate, but ok for this example!\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 150; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val+1 // shift b/c negative\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error: \"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + (p2[0]-1) + \" --> \" + (p2[p2.length-1]-1))\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n<p>Looking at the curves above, we can see that <code class=\"language-text\">a0</code>, which stably moves in one direction, nicely accelerates but still manages a soft landing, and that <code class=\"language-text\">a1</code>, which oscillates a lot in the beginning due to the high learning rate, is slowed down to stabilize.</p>\n<h3>Discussion</h3>\n<p>Optimization algorithms for deep learning architectures are a subject of ongoing research. Some refinements to ADAM and similar algorithms were proposed based on the observation that SGD with momentum and careful learning-rate schedules tend to find better minima on certain classes of models:</p>\n<ul>\n<li><a href=\"https://johnchenresearch.github.io/demon/\">An updated overview of recent gradient descent algorithms. Chen, 2020</a></li>\n</ul>\n<p>Other topics worth mentioning are optimization methods based on higher-order gradients (not frequently used in deep learning because of computational overhead) and approaches to go meta and optimize hyperparameters such as the learning rate itself by gradient descent:</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1909.13371\">Gradient Descent: The Ultimate Optimizer. Chandra et al, 2019</a></li>\n</ul>\n</aside>\n<p>We discuss ADAM, a variant of gradient descent that performs well in many practical scenarios and hence is a popular  choice for training deep learning models.</p>\n<p><a href=\"/Public/Generic/differentiable-graphics\">Cool Application: Interactive Graphics</a></p>\n<p>As a neat application, we show how our small AD library can turn parameterized drawings into rich interactive diagrams.</p>","fields":{"slug":"/Public/Generic/differentiable-programming-in-js/"},"frontmatter":{"date":"2020-06-14","title":"Differentiable Programming in JavaScript","description":"Implementing AutoDiff from scratch in JS. Forward and reverse mode, gradient descent with momentum and Adam.","keywords":"Differentiable programming, Automatic Differentiation, AutoDiff, Gradient Descent, Linear Regression, JavaScript","tags":null}}},{"node":{"excerpt":"Knuth, Literate Programming: ‚Ä¶ a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most‚Ä¶","html":"<p>Knuth, Literate Programming:</p>\n<blockquote>\n<p>‚Ä¶ a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most important thing about a program is its structural relationships. A complex piece of software consists of simple parts and simple relations between those parts; the programmer‚Äôs task is to state those parts and those relationships, in whatever order is best for human comprehension not in some rigidly determined order like top-down or bottom-up.</p>\n</blockquote>\n<p>It‚Äôs nice to have <a href=\"/Public/Generic/interactive-coding\">interactive snippets</a> in web pages or <a href=\"/Public/Generic/octopus-notes\">Octopus Notes</a>, but we do not want to be restricted to isolated, self-contained, units.</p>\n<p>For larger documents, we want to develop code over a series of dependent snippets, and compose them freely.</p>\n<p>Importantly, we also want to be able to put code into asides and show the editor pane side by side with the output.</p>\n<aside>\n<p>How can we do that?</p>\n<p>Of course we can communicate through the global (window) scope. But there are issues with that:</p>\n<ul>\n<li>\n<p>Scope pollution: what if multiple articles define and use the same name?</p>\n</li>\n<li>\n<p>Order of evaluation: what if snippets are evaluated out of order?</p>\n<p>We can generally assume scripts within an article are executed top to bottom. But if we have an interactive editor, we may (re-)evaluate code at any time.</p>\n</li>\n</ul>\n<p>To solve these issues, we follow a relatively simple but robust idea to join multiple snippets:</p>\n<ul>\n<li>Remember the order of snippets</li>\n<li>Mark all that should form part of an inclusion chain</li>\n<li>Add them to the input of each following snippet</li>\n<li>Optional (not yet implemented): re-eval all following snippets if a previous one changes</li>\n</ul>\n<p>Why does this work even with asides?</p>\n<p>Because asides are extracted from the main article <em>after</em> scripts are run! Hence, no special treatment is necessary.</p>\n<p>Below are some tests and explanations.</p>\n<p>Here are some avenues for extension <a href=\"/Notes/todo-large\">tag:todo</a>:</p>\n<ul>\n<li>Right now we cannot modify preamble parts (actually we <em>can</em> modify them, but changes won‚Äôt be picked up by other snippets). We may or may not want to re-run all downstream dependencies for every change.</li>\n<li>Use <code class=\"language-text\">filter=\"editor\"</code> with attribute <code class=\"language-text\">preamble=\"set/add\"</code> instead of <code class=\"language-text\">filter=\"set/addPreamble</code>.</li>\n<li>We may want to support things like <code class=\"language-text\">preamble=\"push/pop\"</code>.</li>\n<li>Attribute <code class=\"language-text\">popout=true</code> could be generalized to <code class=\"language-text\">style=popout</code> to support other custom styles (think about plug-ins).</li>\n<li>Editor UX could be improved in various ways (syntax highlighting, smart editing, monospace console output, etc)</li>\n</ul>\n</aside>\n<p>Below are some examples and explanations. There are multiple avenues for extension.</p>\n<aside>\n<h2>What works right now</h2>\n<h3>Editor definition script</h3>\n<p>No visible output. We‚Äôd probably want to import this from a central location (once we‚Äôre done tweaking it globally).</p>\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<h3>Set Preamble</h3>\n<p>Putting <code class=\"language-text\">filter=\"setPreamble\"</code> on a script will prepend the code to any following script that uses the editor component.</p>\n<code class=\"runScript\" filter=\"setPreamble\">\nlet trace = []\ntrace.push(\"setPreamble1\")\n</code>\n<h3>Editor 1</h3>\n<p>Let‚Äôs verify this. This editor does not use <code class=\"language-text\">setPreamble</code>, so it will just execute the program (with the previously defined preamble prepended).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"editor1\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 1</h3>\n<p>Of course we don‚Äôt always want to set the preamble wholesale, but accumulate it piecewise. For this we can use <code class=\"language-text\">filter=\"addPreamble\"</code>:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"addPreamble1\")\n</code>\n<h3>Editor 2</h3>\n<p>Now we should see <code class=\"language-text\">setPreamble1</code>, <code class=\"language-text\">addPreamble1</code>, and <code class=\"language-text\">editor2</code> in the output, but not <code class=\"language-text\">editor1</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\ntrace.push(\"editor2\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>Aside 1</h3>\n<p>All of this works transparently with asides, since they are pulled out after scripts execute.</p>\n<p>Here is an aside that contains preamble material and editors.</p>\n<aside>\n<p>Let‚Äôs try this!</p>\n<h3>Editor 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"aside1.editor1\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 1</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"aside1.addPreamble1\")\n</code>\n<h3>Editor 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"aside1.editor2\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 2</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"aside1.addPreamble2\")\n</code>\n</aside>\n<h3>Editor 3</h3>\n<p>We can verify that we have <code class=\"language-text\">aside1.addPreamble1</code> and <code class=\"language-text\">aside1.addPreamble2</code> in the trace, in addition to what we had before.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"editor3\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>Aside 2 (Generated!)</h3>\n<p>A cool thing is that we can generate asides programmatically from scripts. Again, this works because asides are pulled out <em>after</em> scripts are run.</p>\n<code class=\"runScript\">\nconst aux = document.createElement(\"aside\")\naux.appendChild(document.createTextNode(\"Programmatically generated!\"))\naux\n</code>\n<h3>Editor 4 (Pop-Out!)</h3>\n<p>With this programmatic support we can also build editor components that show the results inline but put the code editor itself into an aside.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\ntrace.push(\"editor4\")\nfor (let e of trace)\n  emit(e)\n</code>\n<p>Editing the code in the aside will change the result displayed inline, as we expect.</p>\n</aside>","fields":{"slug":"/Public/Generic/interactive-literate-programming/"},"frontmatter":{"date":"2020-06-12","title":"Interactive Literate Programming","description":"Modular live code snippets across multiple notes.","keywords":"Live coding, literate programming","tags":null}}},{"node":{"excerpt":"Web pages can be turned into interactive tutorials with just a little bit of embedded JavaScript. We are particularly interested in‚Ä¶","html":"<!--\n<pre id=\"code-onload\" contenteditable=\"true\">\nconsole.log(\"code-onload\")\nfunction runX() {\n    eval((document.getElementById(\"code-X\").innerText))\n}\n</pre>\n\n<pre id=\"code-X\" contenteditable=\"true\">\nconsole.log(\"foo!\")\nfunction foobar() {\n    console.log(\"bar!\")\n}\n</pre>\n\n<script>\nconsole.log(\"boo!\");\n</script>\n\n<a href=\"javascript:runX()\">‚ñ∂ run</a>\n\n<img src=\"\" onerror=\"window.eval((document.getElementById('code-onload').innerText))\" width=\"0\" height=\"0\" />\n\n-->\n<p>Web pages can be turned into interactive tutorials with just a little bit of embedded JavaScript.</p>\n<p>We are particularly interested in interacting with editable and runnable code, inspired, among other things, by the work of <a href=\"http://worrydream.com/LearnableProgramming/\">Bret Victor</a>. Of course interactive documents are also useful in other fields (physics, math, music, etc).</p>\n<p>Below we explore a series of simple code interaction patterns, such as repls (read-eval-print loops) and embedded editable code snippets that are connected to live elements of the page.\nWe‚Äôre not aiming for maximal flashiness, but for simplicity.</p>\n<aside>\n<h2>Basic DOM manipulation</h2>\n<code class=\"runScript\">\nconst e = document.createElement(\"div\")\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"‚ñ∂ ping\"\na.addEventListener(\"click\", function(ev) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(\"Ping!\"))\n    e.appendChild(l)\n    ev.preventDefault()\n})\ne.appendChild(a)\ne\n</code>\n<h2>Eval expression on click</h2>\n<code class=\"runScript\">\nconst editInput = \"3+4\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"‚ñ∂ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction run() {\n    try {\n        const res = eval(p.innerText)\n        emit(res)\n    } catch(err) {\n        emit(err)\n    }\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run()\n})\ne.appendChild(a)\ne.appendChild(p)\ne.appendChild(o)\ne\n</code>\n</aside>\n<aside>\n<h2>Basic REPL</h2>\n<code class=\"runScript\">\nconst editInput = \"3+4\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nlet history = [editInput]\nlet historyIndex = 0\nlet historyCur = \"\"\nfunction run() {\n    try {\n        const src = p.innerText.trim()\n        if (src) {\n        // record in history, if not empty and not equal previous\n        if ((history.length < 2 || history[history.length - 2] != src) && src != \"\") {\n            history[history.length - 1] = src\n            history.push(\"\")\n        } else {\n            history[history.length - 1] = \"\"\n        }\n        historyIndex = 0\n        emit(\"> \"+src)\n        const res = eval(src)\n        if (res) emit(\"< \"+res)\n        }\n    } catch(err) {\n        emit(err)\n    }\n    p.innerText = \"\"\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"‚ñ∂ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run()\n})\np.addEventListener(\"keydown\", function(ev) {\n    if (ev.code == \"Enter\" && !ev.shiftKey) {\n        ev.preventDefault()\n        run()\n    } else if (ev.code == \"KeyK\" && ev.metaKey) {\n        ev.preventDefault()\n        clear()\n    } else if (ev.code == \"ArrowUp\") {\n        if (historyIndex < history.length - 1) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex + 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    } else if (ev.code == \"ArrowDown\") {\n        if (historyIndex > 0) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex - 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    }\n})\nconst c = document.createElement(\"a\")\nc.href = \"\"\nc.innerText = \"clear\"\nc.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    clear()\n})\ne.appendChild(o)\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(document.createTextNode(\" \"))\ne.appendChild(c)\ne\n</code>\n<p>Functionality / key bindings:</p>\n<ul>\n<li>Run command (Return)</li>\n<li>Line break (Shift-Return)</li>\n<li>Clear output (Cmd-k)</li>\n<li>Up/down arrows: history</li>\n<li>enter ‚Äúemit(..)‚Äù to print</li>\n</ul>\n<h2>Basic DOM and canvas in REPL</h2>\n<p>Below is a scripted repl session that creates a canvas and draws in it.</p>\n<code class=\"runScript\">\n// code is copied from above -- should definitely factor out!\nconst editInput = \"\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nlet history = [editInput]\nlet historyIndex = 0\nlet historyCur = \"\"\nfunction run(src) {\n    try {\n        if (src) {\n        // record in history, if not empty and not equal previous\n        if ((history.length < 2 || history[history.length - 2] != src) && src != \"\") {\n            history[history.length - 1] = src\n            history.push(\"\")\n        } else {\n            history[history.length - 1] = \"\"\n        }\n        historyIndex = 0\n        emit(\"> \"+src)\n        const res = eval(src)\n        if (res) emit(\"< \"+res)\n        }\n    } catch(err) {\n        emit(err)\n    }\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"‚ñ∂ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run(p.innerText.trim())\n    p.innerText = \"\"\n})\np.addEventListener(\"keydown\", function(ev) {\n    if (ev.code == \"Enter\" && !ev.shiftKey) {\n        ev.preventDefault()\n        run(p.innerText.trim())\n        p.innerText = \"\"\n    } else if (ev.code == \"KeyK\" && ev.metaKey) {\n        ev.preventDefault()\n        clear()\n    } else if (ev.code == \"ArrowUp\") {\n        if (historyIndex < history.length - 1) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex + 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    } else if (ev.code == \"ArrowDown\") {\n        if (historyIndex > 0) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex - 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    }\n})\nconst c = document.createElement(\"a\")\nc.href = \"\"\nc.innerText = \"clear\"\nc.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    clear()\n})\ne.appendChild(o)\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(document.createTextNode(\" \"))\ne.appendChild(c)\n// run stuff!\nrun('cvs = document.createElement(\"canvas\")')\nrun('cvs.width = 200')\nrun('cvs.height = 200')\nrun('o.appendChild(cvs)')\nrun('ctx = cvs.getContext(\"2d\")')\nrun('ctx.fillRect(10,10,100,100)')\nrun('ctx.fillRect(100,100,200,200)')\nrun('ctx.fillStyle = \"white\"')\nrun('ctx.fillRect(100,100,10,10)')\ne\n</code>\n</aside>\n<p>The key to a truly interactive feel is to eliminate the edit-compile-run cycle and immediately visualize how a change in the program affects its behavior.</p>\n<aside>\n<h2>Re-eval on edit</h2>\n<p>A text pane that re-evaluates output on the fly, on every edit.</p>\n<code class=\"runScript\">\nconst editInput = `const cvs = document.createElement(\"canvas\")\ncvs.width = 200\ncvs.height = 200\no.appendChild(cvs)\nconst ctx = cvs.getContext(\"2d\")\nctx.fillRect(10,10,100,100)\nctx.fillRect(100,100,200,200)\nctx.fillStyle = \"white\"\nctx.fillRect(100,100,10,10)\nemit(\"Do you like it?\")\nawait buttonClick(\"Yes!!!\")\nemit(\"Good!\")`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n<p>Try changing something that results in a syntax error, and note how the previous output remains visible (we might want to turn it gray or something).</p>\n<p>Note the <code class=\"language-text\">await</code> and how the button behaves.</p>\n<p>One could think about a richer programmatic UI library, including commands to open new dialog screens (graphics or text), to select options (e.g., <code class=\"language-text\">await pickOne(\"A\", \"B\", \"C\")</code> might show multiple buttons), and so on.</p>\n<h2>Test-driven development (TDD)</h2>\n<p>Basic unit testing facilty. Test are re-run on each edit.</p>\n<code class=\"runScript\">\nconst editInput = `\ntest(\"foo\", function() {\n    assert(7 == 8)\n})\ntest(\"bar\", function() {\n    assert(7 == 7)\n})\ntest(\"foo\", function() {\n    expect(7,8)\n})\ntest(\"bar\", function() {\n    expect(7,7)\n})`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n</aside>\n<p>The most generally useful baseline widget seems to be an interactive editor that contains the source code for a component of the page. The editor re-runs the program on every keystroke, maintaining an always up-to-date output panel along with the source code.</p>\n<code class=\"runScript\">\nconst editInput = `\nprint(\"Hello World!\") // edit me\nprint(6*7)\n`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction print(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n<p>Graphics and user input are supported, too. See link above for details.</p>","fields":{"slug":"/Public/Generic/interactive-coding/"},"frontmatter":{"date":"2020-06-06","title":"Interacting with Code","description":"How to turn web pages into interactive live-coding environments, with nothing but plain JavaScript.","keywords":"JavaScript, REPL, live coding, live programming","tags":null}}},{"node":{"excerpt":"Structuring complex information is difficult, whether it is for clarity of one‚Äôs own thought or for effective presentation. Specifically, it‚Ä¶","html":"<p>Structuring complex information is difficult, whether it is for clarity of one‚Äôs own thought or for effective presentation. Specifically, it‚Äôs difficult to decide:</p>\n<ul>\n<li>In which order?</li>\n<li>At which level of detail?</li>\n</ul>\n<p>And often, there is no single right answer.</p>\n<p>Octopus Notes, the prototype system you‚Äôre using to view this note, is an attempt at creating easily-browsable associative knowledge bases that sidestep these questions.\nLike other systems, the underlying idea is to structure information as a collection of densely linked, self-contained, notes.\nBut unlike other systems, the focus is on visually presenting linked information in context.</p>\n<aside>\n<h2>Presenting information in context, at multiple resolutions</h2>\n<p>This is a linked note that provides additional information and further details that are omitted from the main article.</p>\n<p>We can have as many notes and links as we want, nested arbitrarily deep, and we can open and close them selectively, while viewing them side-by-side with the more condensed material from the main article.</p>\n<p>We can follow arbitrary paths through the knowledge graph with ease, but in contrast to typical web navigation, we do not lose the context where we came from.</p>\n<p>We can access information at multiple resolutions, or levels of detail, simultaneously and selectively. We can view multiple levels of detail side-by-side and we can drill down as deep as we find useful, or remain at the surface for the tl;dr.</p>\n<p>Authors can add additional information anywhere without disrupting the flow of the main content.</p>\n</aside>\n<p>Clicking a link like the one above will not navigate away from the current page, but instead it will open the link target in an additional scrollable panel with an attached ‚Äútentacle‚Äù.\nThis enables engaging with information at multiple levels of detail simultaneously.</p>\n<aside>\n<h2>Features and implementation</h2>\n<p>User-facing features:</p>\n<ul>\n<li>Multi-resolution display of information</li>\n<li>Bidirectional links</li>\n<li>Interactive documents with live code</li>\n</ul>\n<p>Tech stack:</p>\n<ul>\n<li>Jamstack, single-page-app front-end</li>\n<li>Markdown syntax</li>\n</ul>\n<p>More information:</p>\n<ul>\n<li>\n<aside>\n<h2>Markdown reference</h2>\n<p>Octopus Notes supports standard markdown syntax, as defined by the static generation pipeline (currently Gatsby and Remark).</p>\n<p>A few things are worth highlighting.</p>\n<h3>Inline notes via ‚Äúaside‚Äù</h3>\n<p>Notes are typically created as individual <code class=\"language-text\">.md</code> files. However it can be annoying to create a new file for every little side note. Hence, Octopus Notes support the definition of inline notes using html <code class=\"language-text\">&lt;aside></code> elements.</p>\n<p>As an example, here is the definition of the current note:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  More information:\n\n  - &lt;aside>\n\n      ## Markdown reference\n\n      Octopus note supports ...\n\n      &lt;/aside>\n\n  - ...</code></pre></div>\n<p>Note that:</p>\n<ul>\n<li>It is important to leave a blank line before and after <code class=\"language-text\">&lt;aside></code> or other HTML tags (otherwise adjacant markdown will be treated as HTML)</li>\n<li>Asides can be placed in lists or other elements; they are always pulled out and replaced with a link</li>\n<li>The link text is automatically extracted from text of the aside (usually the first line, but may be shorter, e.g, when hitting a ‚Äù:‚Äú)</li>\n</ul>\n<h3>Embedded code snippets</h3>\n<p>Notes can contain standard JavaScript <code class=\"language-text\">&lt;script></code> tags that are executed when the data is loaded.</p>\n<p>Often, a bit more control is needed, so Octopus Notes also supports script blocks of the form:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  &lt;code class=\"runScript\" filter=\"...\">\n  ...\n  &lt;/code></code></pre></div>\n<p>Such code blocks may return a DOM element that will replace the script element in the DOM (highly useful for interactive documents).</p>\n<p>If the optional filter argument is given it is evaluated first, and the result is then called with the contents of the code block as argument. This way, code may be preprocessed in arbitrary ways.</p>\n<p>A key use case is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  &lt;code class=\"runScript\" filter=\"coolEditor\">\n  ...\n  &lt;/code></code></pre></div>\n<p>which produces an inline-editable code snippet (<a href=\"/Public/Generic/interactive-coding\">Interactive code</a>).</p>\n<p>There are various helpers to enable interaction between such snippets (<a href=\"/Public/Generic/interactive-literate-programming\">Interactive code across multiple snippets</a>).</p>\n  </aside>\n</li>\n<li>\n<aside>\n<h2>Static site generation</h2>\n<p>Octopus Notes currently uses Gatsby and Remark to turn Markdown input into static html.</p>\n<p>Right now we do not use the actual Gatsby site generation facility, and use Gatsby only to perform aggregation via GraphQL, resulting in a single <code class=\"language-text\">page-data.json</code> file that is then processed client-side by the custom Octopus front-end.</p>\n  </aside>\n</li>\n<li>\n<p><a href=\"/Public/Generic/interactive-coding\">Interactive code</a></p>\n</li>\n<li>\n<p><a href=\"/Public/Generic/interactive-literate-programming\">Interactive code across multiple notes</a></p>\n</li>\n</ul>\n</aside>\n<p>The system is built on markdown and modern web front-end technologies, and it supports rich interactive content.</p>\n<aside>\n<h2>Inspiration and related work</h2>\n<p>Original ideas:</p>\n<ul>\n<li>Niklas Luhmann (Zettelkasten)</li>\n<li>Ted Nelson (Xanadu)</li>\n<li>Ward Cunningham (Wikis)</li>\n</ul>\n<p>Further inspiration:</p>\n<ul>\n<li>S√∂nke Ahrens (How to Take Smart Notes)</li>\n<li>Andy Matuschak (Evergreen Notes)</li>\n</ul>\n<p>Other software:</p>\n<ul>\n<li>Trilium, Obsidian, Notion, Gingko, Roam</li>\n</ul>\n</aside>\n<p>There is plenty of inspirational prior work, including Luhmann‚Äôs Zettelkasten method and Nelson‚Äôs original hyperlink concept.</p>","fields":{"slug":"/Public/Generic/octopus-notes/"},"frontmatter":{"date":"2020-05-30","title":"Octopus Notes","description":"A system for presenting structured information and networked thought. Multiple levels of detail. Hyperlinks side-by-side with source. For knowledge bases, note taking, wikis, blogs, interactive books and tutorials. Based on Markdown.","keywords":"bidirectional links, zettelkasten, note-taking, personal wiki, knowledge bases, second brain","tags":null}}}]}},"pageContext":{}},"staticQueryHashes":["63159454"]}