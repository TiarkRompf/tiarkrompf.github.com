{"componentChunkName":"component---src-pages-public-js","path":"/public/","result":{"data":{"site":{"siteMetadata":{"title":"KB"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"Recent Updates: Implementing Affine Non-Escaping Delimited Continuations with a Single Auxiliary Stack Differentiable Programming for…","html":"<p>Recent Updates:</p>\n<ul>\n<li>\n<p><a href=\"/Public/Generic/affine-continuations\">Implementing Affine Non-Escaping Delimited Continuations with a Single Auxiliary Stack</a></p>\n<div><small>20/07/14</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/differentiable-graphics\">Differentiable Programming for Interactive Graphics</a></p>\n<div><small>20/07/11</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/deconstructing-react\">Deconstructing React</a></p>\n<div><small>20/07/07</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/touch-camera-device-apis\">Touch, Camera, and Other Device APIs</a></p>\n<div><small>20/07/04</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/drawing-graphs\">Drawing Graphs Like GraphViz</a></p>\n<div><small>20/06/28</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/virtual-piano\">Virtual Piano Practice</a></p>\n<div><small>20/06/20</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/differentiable-programming-in-js\">Differentiable Programming in JS</a></p>\n<div><small>20/06/14</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/interactive-literate-programming\">Interactive Literate Programming</a></p>\n<div><small>20/06/12</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/interactive-coding\">Interacting With Code</a></p>\n<div><small>20/06/06</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/octopus-notes\">Octopus Notes</a></p>\n<div><small>20/05/30</small></div>\n</li>\n</ul>\n<!--\nPublications:\n\n- [By year](/Public/Papers/)\n- By topic\n-->\n<p><small>Copyright © 2020 <a href=\"https://tiarkrompf.github.io\">Tiark Rompf</a></small></p>","fields":{"slug":"/Public/Generic/public/"},"frontmatter":{"date":null,"title":"Notes - Start Page","description":null,"keywords":null,"tags":null}}},{"node":{"excerpt":"Delimited continuations are a powerful and generic control abstraction. Fully-general implementations tend to be heavyweight (full CPS…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        invokeOnClear()\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nlet clearHook = null\nfunction onclear(f) {\n  clearHook = f\n}\nfunction invokeOnClear() {\n  if (clearHook) {\n    clearHook()\n    clearHook = null\n  }\n}\nfunction clear() {\n    invokeOnClear()\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Delimited continuations are a powerful and generic control abstraction. Fully-general implementations tend to be heavyweight (full CPS: runtime overhead; selective CPS: type/syntax overhead; stack copying: different kind of runtime overhead). But often, restricted models are sufficient, and lead to a cheaper implementation.</p>\n<p>Here we consider delimited continuations restricted to affine and non-escaping use: we assume a control operator <code class=\"language-text\">shift(k =&gt; ...)</code> that permits invocation of k once or not at all, and only within the operator’s dynamic extent.</p>\n<p>We will show that we can implement this operator efficiently, using a single auxiliary stack in addition to the standard call stack.</p>\n<p>Our implementation is in JavaScript, so the restrictions aren’t enforced, but type systems exist that could provide corresponding static guarantees.</p>\n<p>Use cases:</p>\n<ul>\n<li><a href=\"/Public/Generic/differentiable-programming-in-js\">AutoDiff</a> (backward pass to propagate gradient updates)</li>\n<li>Automatic resource management (clean up resource after use)</li>\n<li>Algebraic effects (certain classes)</li>\n</ul>\n<p>Restriction:</p>\n<pre>\nshift(k => k() * 2)         // ok: linear (1 use)\nshift(k => 2)               // ok: not linear but still affine (0 uses)\n// shift(k => k() + k())    // not affine (2 uses)\n// shift(k => outer = k)    // not affine (k escapes)\n</pre>\n<p>Running Example:</p>\n<pre>\nreset(() => {\n    4 + shift(k => k(3) * 2)\n})\n// result: (4 + 3) * 2 = 14\n</pre>\n<h2>Key Idea</h2>\n<aside>\n<h2>Recall the general implementation using CPS</h2>\n<p>The original semantics for shift/reset is expressed in terms of whole-program CPS transformation. In that case, there is an implicit reset around the shift body. This is useful for uniformity, but we don’t strictly have to do it.</p>\n<p>It is often useful to implement a selective CPS transform. In this case we have distinct CPS and non-CPS code paths in the same program. We can keep the two worlds apart using a type system (as in Scala) or using syntax annotations (monadic do, async/await). In either case, we can leave the shift body in direct style.</p>\n<p>Example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// result: (4 + 3) * 2 = 14\nlet res = (k1 => {\n    let k = (r => k1(4 + r));\n    return (k => k(3) * 2)(k)\n})(r1 => r1)\nprint(res)\n</code>\n<p>Transformation rules:</p>\n<pre>\n[[ reset(f) ]]    = [[ f ]](r => r)\n[[ shift(f) ]](k) = f(k)\n</pre>\n</aside>\n<p>Here’s what’s different:</p>\n<ul>\n<li>\n<p>Standard shift/reset</p>\n<ul>\n<li>Materialize the continuation (the return path) of shift</li>\n<li>Selectively CPS-transform the code outside of shift (up to enclosing reset)</li>\n<li>Code inside shift is in direct style</li>\n<li>Shift body invokes k as desired, metacontinuation (what happens after calling k) is implicit</li>\n<li>Reset applies identity continuation to extract result</li>\n</ul>\n</li>\n<li>\n<p>Affine, non-escaping shift/reset</p>\n<ul>\n<li>Materialize the metacontinuation (the “cleanup” code, what to do after returning)</li>\n<li>Selectively CPS-transform the code inside of shift</li>\n<li>Code outside shift is in direct style</li>\n<li>Shift returns normally, but pushes explicit metacontinuation (continuation of calling k) on a stack</li>\n<li>Reset empties the stack to execute metacontinuation and extract result</li>\n</ul>\n</li>\n</ul>\n<h2>Technical Details</h2>\n<p>Recall running Example:</p>\n<pre>\nreset(() => {\n    4 + shift(k => k(3) * 2)\n})\n// result: (4 + 3) * 2 = 14\n</pre>\n<p>Proposed implementation (example):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet stack = []\nstack.push(r => r * 2)\nlet r = 4 + 3\nstack.pop()(r)\n</code>\n<p>Proposed implementation (generic, linear case):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet stack = []\nfunction shift(f) {\n  let rval\n  f((z,k2) => { rval = z; stack.push(k2) })\n  return rval\n}\nfunction reset(f) {\n  let save = stack.length\n  let r = f()\n  // exception handling elided\n  while (stack.length > save)\n    r = stack.pop()(r)\n  return r\n}\n</code>\n<p>Let’s try it on our example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(reset(() => 4 + shift(k => k(3, r => r*2))))\n</code>\n<p>Another example (multiple shifts):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction foo() {\n    let x1 = shift(k => k(\"1\", r => r + \"A\"))\n    let x2 = shift(k => k(\"2\", r => r + \"B\"))\n    let x3 = shift(k => k(\"3\", r => r + \"C\"))\n    return (x1+x2+x3)\n}\nprint(reset(foo))\n</code>\n<h3>Linear to Affine</h3>\n<p>The code shown above only implements the linear case (exactly 1 use of k). To deal with the affine case (k not used at all), we can throw an exception when we detect that the function passed to shift returns without having invoked k. This exception can communicate the result value outward until caught by reset.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h3>Sync to Async, Non-Escaping to Escaping</h3>\n<p>Since our implementation returns normally (using the regular call stack) we cannot use our version of shift to actually interrupt the program, and, say, continue later by calling k from an event handler.</p>\n<p>Many languages these days implement async/await or generators with <code class=\"language-text\">yield</code>. Essentially, these are one-shot <em>undelimited</em> continuations. This differs from our non-escaping model in that asynchronous interruption is supported, using some variant of CPS underneath the covers (typically chaining futures and promises).</p>\n<p>Using the auxiliary stack technique shown above, we can extend these existing facilities to (potentially escaping) one-shot <em>delimited</em> continuations.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h3>The CPS Hierarchy</h3>\n<p>How to support nested continuations (e.g. for higher-order derivatives in AD)? Maintain a separate stack for each level of nesting, so that shift-n can push to the level-n stack anywhere.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h2>Discussion</h2>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://dev.to/yelouafi/algebraic-effects-in-javascript-part-3---delimited-continuations-42hj\">https://dev.to/yelouafi/algebraic-effects-in-javascript-part-3---delimited-continuations-42hj</a></li>\n<li><a href=\"https://gist.github.com/yelouafi/44f5ed9bcdd1100b1902bcdb80aa32da\">https://gist.github.com/yelouafi/44f5ed9bcdd1100b1902bcdb80aa32da</a></li>\n</ul>","fields":{"slug":"/Public/Generic/affine-continuations/"},"frontmatter":{"date":"July 14, 2020","title":"Implementing Affine Non-Escaping Delimited Continuations with a Single Auxiliary Stack","description":"Instead of materializing the continuation (the return path) of 'shift', we materialize the metacontinuation (the 'cleanup' code) on a stack that is drained by 'reset'.","keywords":"Delimited Continuations, Shift/Reset, Async","tags":null}}},{"node":{"excerpt":"Differentiable programming enables a form of backwards execution of programs: specify a computation based on tunable parameters, provide a…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        invokeOnClear()\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nlet clearHook = null\nfunction onclear(f) {\n  clearHook = f\n}\nfunction invokeOnClear() {\n  if (clearHook) {\n    clearHook()\n    clearHook = null\n  }\n}\nfunction clear() {\n    invokeOnClear()\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Differentiable programming enables a form of backwards execution of programs: specify a computation based on tunable parameters, provide a desired result, and then use gradient descent to derive the correct parameter values from the desired output.</p>\n<p>Let’s explore this idea in the context of interative graphics. We’ll implement just the drawing logic, and obtain an interactive environment that enables interaction with the drawn shapes subject to constraints inherent in the program structure.</p>\n<p>The code is based on the <a href=\"/Public/Generic/differentiable-programming-in-js\">minimal AD toolkit presented in a companion note</a>.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// stack to remember backward operations\nlet tape = []\n// dual number api\nfunction num(x) {\n    return { val: x, grad: 0 }\n}\nfunction plus(x,y) {\n    let z = num(x.val + y.val)\n    tape.push(() => { x.grad += z.grad; y.grad += z.grad })\n    return z\n}\nfunction minus(x,y) {\n    let z = num(x.val - y.val)\n    tape.push(() => { x.grad += z.grad; y.grad -= z.grad })\n    return z\n}\nfunction times(x,y) {\n    let z = num(x.val * y.val)\n    tape.push(() => { x.grad += y.val * z.grad; y.grad += x.val * z.grad })\n    return z\n}\nfunction sin(x) {\n    let z = num(Math.sin(x.val))\n    tape.push(() => { x.grad += z.grad * Math.cos(x.val) })\n    return z\n}\nfunction cos(x) {\n    let z = num(Math.cos(x.val))\n    tape.push(() => { x.grad += -z.grad * Math.sin(x.val) })\n    return z\n}\n// derivative api\nfunction deriv(f) {\n    function d(x) {\n        // forward pass\n        let dx = num(x)\n        let dz = f(dx)\n        dz.grad = 1\n        // backward pass\n        for (b of tape.reverse()) b()\n        tape = []\n        return dx.grad\n    }\n    return d\n}\n// optimizable parameters\nlet params = []\nfunction param(x) {\n    const dx = num(x)\n    params.push(dx)\n    return dx\n}\n// compute primal and gradient\nfunction compute(loss) {\n    tape = []\n    // forward\n    const d = loss()\n    // backprop\n    d.grad = 1\n    for (const b of tape.reverse()) b()\n    return d\n}\n// one optimization step\nlet lr = 0.0001 // learning rate\nfunction optimize(loss) {\n    const d = compute(loss)\n    // gradient descent\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        p.val -= lr * p.grad\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// basic drawing code\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 300\ncvs.height = 150\nlet ctx = cvs.getContext(\"2d\")\no.appendChild(cvs)\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n}\n</code>\n<p>Let’s define a parameterized drawing. We pick an example from the <a href=\"https://ravichugh.github.io/sketch-n-sketch/\">Sketch-n-Sketch</a> bidirectional programming environment):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet y = param(10)\nlet w = param(20)\nlet h = param(100)\nlet d = param(40)\nfunction draw() {\n    drawRect(times(num(1), d), y, w, h)\n    drawRect(times(num(2), d), y, w, h)\n    drawRect(times(num(3), d), y, w, h)\n    drawRect(times(num(4), d), y, w, h)\n}\n</code>\n<p>Regular forward computation, will plot it to the screen:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndraw()\n</code>\n<h2>Interactivity</h2>\n<p>Now let’s make it interactive. We do this by introducing a set of “active” (draggable) points, that are coupled to differentiable coordinates.</p>\n<p>Whenever we move such a point, we set its gradient to the delta between the last drawn position and the current mouse position, and then run gradient descent to adjust the parameters of the drawing.</p>\n<p>This will tweak as many parametric aspects of the drawing as necessary to move the desired point to its new position.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet active = []\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n  active.push({x,y})\n  active.push({x: plus(x,w), y: plus(y,h)})\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawActive() {\n  ctx.strokeStyle = \"#aaaaaa\"\n  ctx.lineWidth = 2\n  for (let {x,y} of active) {\n    ctx.beginPath()\n    ctx.arc(x.val, y.val, 5, 0, 2*Math.PI)\n    ctx.stroke()\n  }\n  ctx.strokeStyle = \"black\"\n}\nfunction drawAll() {\n  tape = []\n  active = []\n  ctx.clearRect(0,0,300,150)\n  draw()\n  drawActive()\n}\nfunction findActivePoint(offsetX,offsetY) {\n  for (let i in active) {\n    let {x,y} = active[i]\n    const dx = x.val - offsetX\n    const dy = y.val - offsetY\n    if (Math.sqrt(dx*dx + dy*dy) < 5)\n      return i\n  }\n  return -1\n}\nfunction dragActivePoint(dragging,offsetX,offsetY) {\n  for (let i = 0; i<200; i++){\n    let {x,y} = active[dragging]\n    x.grad += offsetX - x.val\n    y.grad += offsetY - y.val\n    optimize()\n    drawAll()\n  }\n}\nlr = 0.01\nfunction optimize() {\n  // backprop\n  for (b of tape.reverse()) b()\n  tape = []\n  // gradient descent\n  let totaldiff = 0\n  for (let p of params) {\n    totaldiff += p.grad*p.grad\n    p.val += lr * p.grad\n    p.grad = 0\n  }\n}\ncvs.addEventListener(\"mousedown\", ev => {\n  let dragging = findActivePoint(ev.offsetX, ev.offsetY)\n  if (dragging >= 0) {\n    let drag = ev => dragActivePoint(dragging,ev.offsetX,ev.offsetY)\n    document.addEventListener(\"mousemove\", drag)\n    document.addEventListener(\"mouseup\", ev => {\n      document.removeEventListener(\"mousemove\", drag)\n    })\n  }\n})\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawAll()\n</code>\n<p>Note how dragging the top left corners only moves the rectangles, while dragging the bottom right corners also resizes them. This is because the bottom right corners create gradient updates for <code class=\"language-text\">x</code>,<code class=\"language-text\">y</code> and <code class=\"language-text\">w</code>,<code class=\"language-text\">h</code> to equals parts, instead of just <code class=\"language-text\">x</code>,<code class=\"language-text\">y</code>.</p>\n<h2>More Constraints</h2>\n<p>What if we want to have more control, such as a control handle that <em>only</em> resizes, without moving?</p>\n<p>Fortunately, we can achieve this with a relatively small change. We allow each active point to specify others that should <em>not</em> move, e.g., opposite corners of a rectangle.</p>\n<p>This is just another form of constraints. Active points are constrained to follow the mouse pointer when dragged (by setting their gradient to the delta between current and desired position), and stationary points are constrained to stay fixed by adjusting their gradient to the delta between their current position (which may have shifted) and the position at the start of the drag, effectively keeping them in place.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n  // center\n  active.push({x: plus(x, times(w, num(0.5))),\n               y: plus(y, times(h, num(0.5))),\n               constraint: [w,h]})\n  // top left\n  active.push({x: x, y: y, constraint: [plus(x,w),plus(y,h)]})\n  // top right\n  active.push({x: plus(x,w), y: y, constraint: [x,plus(y,h)]})\n  // bottom left\n  active.push({x: x, y: plus(y,h), constraint: [plus(x,w),y]})\n  // bottom right\n  active.push({x: plus(x,w), y: plus(y,h), constraint: [x,y]})\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet constraint = []\nfunction findActivePoint(offsetX,offsetY) {\n  for (let i in active) {\n    let p = active[i]\n    const dx = p.x.val - offsetX\n    const dy = p.y.val - offsetY\n    if (Math.sqrt(dx*dx + dy*dy) < 5) {\n      constraint = (p.constraint || []).map(x => x.val)\n      return i\n    }\n  }\n  return -1\n}\nfunction dragActivePoint(dragging,offsetX,offsetY) {\n  for (let i = 0; i<200; i++){\n    let p = active[dragging]\n    p.x.grad += offsetX - p.x.val\n    p.y.grad += offsetY - p.y.val\n    for (let i in p.constraint) {\n      p.constraint[i].grad += constraint[i] - p.constraint[i].val\n    }\n    optimize()\n    drawAll()\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawAll()\n</code>\n<p>Other forms of constraints are of course possible as well, e.g., to keep shape non-overlapping, or a certain distance apart.</p>\n<h2>More Examples</h2>\n<h3>Sine Wave</h3>\n<p>Here is another example from Sketch-n-Sketch. We fix the starting x,y coordinate so dragging will be directed to only change the amplitude, not the overall position of the curve:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet [x0,y0] = [10,50]\nlet [pw,ph,psep,pamp] = [15,50,20,40].map(param)\nlet n = 14\nfunction draw() {\n  function box(i) {\n   let x = plus(num(x0), times(num(i), psep))\n   let y = minus(num(y0), times(pamp, sin(num(i*2*Math.PI/n))))\n   drawRect(x,y,pw,ph)\n  }\n  for (let i = 0; i < n; i++) box(i)\n}\ndrawAll()\n</code>\n<h3>Sliders</h3>\n<p>We can create UI elements such as interconnected sliders:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet p1 = param(20)\nlet p2 = param(20)\nfunction draw() {\n  let [x0,y0,] = [10,20]\n  function slider(p,min,max,label) {\n    ctx.fillText(label,x0+110,y0+3)\n    ctx.fillRect(x0,y0-2,100,4)\n    if (p.val < min) p.val = min\n    if (p.val > max) p.val = max\n    active.push({x:plus(num(x0),times(p,num(100/(max-min)))),y:num(y0)})\n    y0 += 20\n  }\n  slider(p1,0,100,\"p1\")\n  slider(p2,0,100,\"p2\")\n  slider(plus(p1,p2),0,200,\"p1+p2\")\n  slider(times(p1,p2),0,10000,\"p1*p2\")\n  slider(minus(num(200),plus(p1,p2)),0,200,\"200-p1-p2\")\n  slider(minus(num(100),p1),0,100,\"100-p1\")\n  slider(minus(num(100),p2),0,100,\"100-p2\")\n}\ndrawAll()\n</code>\n<p>Note how dragging the <code class=\"language-text\">p1+p2</code> or <code class=\"language-text\">p1*p2</code> will update <code class=\"language-text\">p1</code> and <code class=\"language-text\">p2</code> without any explicit backward calculation. Note also the clamping to <code class=\"language-text\">min</code> and <code class=\"language-text\">max</code> using regular control flow (an alternative would be soft clamping via gradients).</p>\n<h3>Connected Points and Circles</h3>\n<p>Some more examples, this time from <a href=\"http://omrelli.ug/g9/gallery/\">g9.js</a>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet px = param(80)\nlet py = param(70)\nfunction draw() {\n  active.push({x:px,y:py})\n  active.push({x:py,y:px})\n}\ndrawAll()\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet pradius = param(50)\nlet pangle = param(0)\nfunction draw() {\nlr = 0.0001\n    let [mx,my] = [num(75),num(75)]\n    let sides = 10\n    for (var i=0; i < sides; i++) {\n        let a = plus(pangle, num(i/sides * Math.PI * 2))\n        let a1 = times(num(-1),a)\n        let r1 = pradius\n        let r2 = times(r1, num(0.5))\n        active.push({x: plus(mx, times(r1, cos( a))), y: plus(my, times(r1, sin( a))) })\n        active.push({x: plus(mx, times(r2, cos(a1))), y: plus(my, times(r2, sin(a1))) })\n    }\n}\ndrawAll()\n</code>\n<p>The last one is interesting as it computes derivates for <code class=\"language-text\">sin</code> and <code class=\"language-text\">cos</code>. This requires a smaller learning rate. <a href=\"/gradient-descent-with-adam\">Adaptive optimizers such as Adam</a> might perform better on this example than the plain vanilla gradient descent we’re currently using.</p>\n<h2>Discussion</h2>\n<p>Related:</p>\n<ul>\n<li>G9 <a href=\"http://omrelli.ug/g9/\">http://omrelli.ug/g9/</a></li>\n<li>Basalt <a href=\"https://www.anishathalye.com/2019/12/12/constraint-based-graphic-design/\">https://www.anishathalye.com/2019/12/12/constraint-based-graphic-design/</a></li>\n<li>HN discussion of Basalt, mentions other pieces of related work <a href=\"https://news.ycombinator.com/item?id=21774018\">https://news.ycombinator.com/item?id=21774018</a></li>\n<li>Sketch-n-Sketch <a href=\"https://ravichugh.github.io/sketch-n-sketch/\">https://ravichugh.github.io/sketch-n-sketch/</a></li>\n<li>Apparatus <a href=\"http://aprt.us\">http://aprt.us</a></li>\n</ul>","fields":{"slug":"/Public/Generic/differentiable-graphics/"},"frontmatter":{"date":"July 12, 2020","title":"Differentiable Programming for Interactive Graphics","description":"From parameterized drawings to interactive diagrams with differentiable programming and gradient descent.","keywords":"Gradient Descent, Interactive Graphics, AutoDiff","tags":null}}},{"node":{"excerpt":"React is a JavaScript library for building interactive user interfaces. Contrary to traditional, imperative, approaches to UI programming…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        invokeOnClear()\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nlet clearHook = null\nfunction onclear(f) {\n  clearHook = f\n}\nfunction invokeOnClear() {\n  if (clearHook) {\n    clearHook()\n    clearHook = null\n  }\n}\nfunction clear() {\n    invokeOnClear()\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>React is a JavaScript library for building interactive user interfaces. Contrary to traditional, imperative, approaches to UI programming, React embraces ideas from functional programming.</p>\n<aside>\n<h2>Creating Web UIs Programmatically</h2>\n<p>Traditionally, web pages were largely based on static HTML, perhaps generated by server-side application logic, and maybe with a bit of JavaScript sprinkled in for interactivity.</p>\n<p>React and similar frameworks turn this model upside-down, and generate the entire DOM presentation programmatically from JS.\nClearly, a good API for this is key. The traditional, imperative, DOM API is verbose and cumbersome. Hence, React code is typically written using JSX — JavaScript enriched with quasiquotations to embed HTML syntax — but this layer of syntactic sugar is entirely optional.</p>\n<p>We’ll use a more direct API as our starting point. Our first version (which we will gradually refine) recomputes the full DOM for every change, which is limiting in several ways. First, it is inefficient. Second, while it supports persistent/global state, it does not support ephemeral/local state.</p>\n<p>The essence of this API is a single function <code class=\"language-text\">createElement</code> (which we’ll alias to <code class=\"language-text\">e</code>) to create DOM nodes with a given set of properties and children.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  // Set properties\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  // Add children\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\n</code>\n<p>Here is a basic example. Note how we’re essentially using s-expression syntax to build DOM trees:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction greet(name) {\n  return e(\"div\",{},\"Hello, \",e(\"i\",{},name),\"!\")\n}\nrender(greet(\"World\"))\n</code>\n<p>Properties may include event listeners, so we can support basic interactivity. True to our goal, we recompute the whole UI on every change:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nconst state = [{label: \"A\", count: 1}, {label: \"B\", count: 1}]\nfunction App() {\n  return e(\"div\", {}, ...state.map(Counter))\n}\nfunction Counter(state) {\n  return e(\"div\",\n    { onClick: () => update(state.count += 1) },\n    state.label, \": \", state.count)\n}\nfunction update() {\n  render(App())\n}\nrender(App())\n</code>\n<p>Note how we can freely use functional abstraction to build components. In the current implementation, these functions are just evaluated to compute UI components, but they do not become part of the computed UI. Thinking about this more formally, the language of UI components does not include a case for function application. Instead, all function applications are fully normalized (beta-reduced) while computing the UI.</p>\n<p>This works OK here because the <em>entire</em> UI state is determined by the global model.</p>\n<p>But this is not always the case. Here is an example that doesn’t work so well. Let’s build a temperature converter:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nconst state = { val: 30 }\nfunction App() {\n  return e(\"div\", {},\n    Field(state, \"°F: \", 9/5, 32),\n    Field(state, \"°C: \", 1, 0))\n}\nfunction Field(state, label, factor, offset) {\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state.val*factor+offset),\n      onInput: (e) => update(state.val = (event.target.value-offset)/factor) }))\n}\nfunction update() {\n  render(App())\n}\nrender(App())\n</code>\n<p>Using this interface is quite a pain. Every time we change one of the fields, an input event is triggered that deletes the existing text fields and replaces them with identical ones. And in doing so, we throw away the ephemeral state of the input fields: keyboard focus, cursor position, etc.</p>\n</aside>\n<p>Notably, React is based on a programming model that treats the UI as immutable, which means that (conceptually) the entire UI is regenerated from a data model after every change.</p>\n<aside>\n<h2>Virtual DOM and Diff Algorithm</h2>\n<p>The key idea behind React is to prevent the situation in the previous section by decoupling ephemeral presentation state from persistent application state and to preserve the presentation state for pieces of application state that didn’t change.</p>\n<p>React introduces a “virtual DOM” layer, i.e., a shallow representation of UI elements as plain JavaScript objects. How to detect change? Keep the previous version and do a diff! This process is called “reconciliation” in React.</p>\n<p>Here is our revised implementation. Function <code class=\"language-text\">createElement</code> just wraps its parameters in an object for later use:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: props,\n      children: children.map(child =>\n        typeof child === \"object\"\n          ? child\n          : createTextElement(child)\n      ),\n  }\n}\n// special case for plain strings\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: String(text),\n    },\n    children: [],\n  }\n}\n// create an actual DOM node\nfunction createDom(type) {\n  const dom = type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(type)\n  return dom\n}\n</code>\n<p>Given a real DOM node and old and new virtual DOM nodes, we can diff and patch object properties including event listeners:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//const isEvent = key => key.startsWith(\"on\")\nconst isProperty = key =>\n  !isEvent(key)\nconst isNew = (prev, next) => key =>\n  prev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)\n// TODO: cleanup!\nfunction updateProperties(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key =>\n        !(key in nextProps) ||\n        isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.removeEventListener(\n        eventType,\n        prevProps[name]\n      )\n    })\n  // Remove old properties\n  Object.keys(prevProps)\n    .filter(isProperty)\n    .filter(isGone(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = \"\"\n    })\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      if (dom[name] != nextProps[name])\n      dom[name] = nextProps[name]\n    })\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      const eventType = name\n        .toLowerCase()\n        .substring(2)\n      dom.addEventListener(\n        eventType,\n        nextProps[name]\n      )\n    })\n}\n</code>\n<p>And we proceed recursively to diff and patch DOM children, dealing with newly inserted and removed nodes appropriately:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      newChild.dom = oldChild.dom\n      updateProperties(newChild.dom, oldChild.props, newChild.props)\n      updateChildren(newChild.dom, oldChild.children, newChild.children)\n    } else {\n    if (oldChild) {\n      domParent.removeChild(oldChild.dom)\n    }\n    if (newChild) {\n      newChild.dom = createDom(newChild.type),\n      updateProperties(newChild.dom, {}, newChild.props)\n      updateChildren(newChild.dom, [], newChild.children)\n      domParent.appendChild(newChild.dom)\n    }\n    }\n  }\n}\n</code>\n<p>Finally, the <code class=\"language-text\">render</code> method remembers the previous version\nand triggers reconciliation:\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nlet currentRoot = []\nfunction render(element, container=o) {\nupdateChildren(container, currentRoot, [element])\ncurrentRoot = [element]\n}\n// internal: cleanup on recompile\nonclear(() => updateChildren(o,currentRoot,[]))\n</code></p>\n<p>Here is the temperature converter example again (code is unchanged):</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nconst state = { val: 30 }\nfunction App() {\n  return e(\"div\", {},\n    Field(state, \"°F: \", 9/5, 32),\n    Field(state, \"°C: \", 1, 0))\n}\nfunction Field(state, label, factor, offset) {\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state.val*factor+offset),\n      onInput: (e) => update(state.val = (event.target.value-offset)/factor) }))\n}\nfunction update() {\n  render(App(),o)\n}\nrender(App(),o)\n</code>\n<p>This is much better than before! Since physical DOM nodes are preserved, we no longer lose any ephemeral state.</p>\n<p>The diff algorithm used here (also in the real React) is quite simplistic. This is a conscious choice. Doing a “proper” diff would be too expensive for many uses, with unclear practical benefits.</p>\n<p>Clearly there are cases where this is too simple, in particular when elements are reordered. For such situations, React provides a facility to diff by a computed key instead of by numeric index within the parent.</p>\n<p><strong>Exercise:</strong> implement reconciliation by key.</p>\n</aside>\n<p>A key obstacle to making this approach work in practice is that UIs contain a lot of ephemeral state that is not determined by the data model (selections, cursor and scroll positions, etc). To deal with this, React diffs the new UI from the previous version, and carefully patches underlying mutable UI widgets to preserve local emphemeral state across updates.</p>\n<aside>\n<h2>Components, Life Cycle, State</h2>\n<p>Of course we want to be able to define our own local state in higher-level UI components, in addition to state embedded in DOM nodes. For example, which tab is shown, which items are selected, etc.</p>\n<p>The key idea is to replicate what we did for the physical DOM in the virtual DOM: maintain a mutable component instance that, once created, is shared by all “versions” of the component.</p>\n<p>In addition, we want to support local updates to the tree. Whenever a component changes, only the components below should be recomputed, not the whole tree.</p>\n<p>Finally, we want to suppport lifecycle callbacks. In many cases, a component needs to perform some cleanup once it’s removed from the tree (e.g., close a network connection or deinstall a timer).</p>\n<p>The basics of the implementation remain the same. Only the diff and update code gets some extra cases:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction renderSubTree(newChildInst) {\n  let newSub = [newChildInst.type(newChildInst)]\n  updateChildren(newChildInst.domParent, newChildInst.sub, newSub)\n  newChildInst.sub = newSub\n}\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      if (newChild.type instanceof Function) {\n        let oldSub = oldChild.instance.sub\n        newChild.instance = oldChild.instance\n        newChild.instance.type = newChild.type\n        newChild.instance.props = newChild.props\n        newChild.instance.children = newChild.children\n        newChild.instance.domParent = domParent\n        newChild.instance.sub = [newChild.type(newChild.instance)]\n        updateChildren(domParent, oldSub, newChild.instance.sub)\n      } else {\n        newChild.dom = oldChild.dom\n        updateProperties(newChild.dom, oldChild.props, newChild.props)\n        updateChildren(newChild.dom, oldChild.children, newChild.children)\n      }\n    } else {\n      if (oldChild) {\n        if (oldChild.type instanceof Function) {\n          if (oldChild.instance.componentWillUnmount)\n            oldChild.instance.componentWillUnmount()\n          updateChildren(domParent, oldChild.instance.sub, [])\n        } else {\n          domParent.removeChild(oldChild.dom)\n          // make sure all cleanup handlers are called\n          updateChildren(oldChild.dom, oldChild.children, [])\n        }\n      }\n      if (newChild) {\n        if (newChild.type instanceof Function) {\n          // instance is uninitialized\n          newChild.instance = {}\n          newChild.instance.type = newChild.type\n          newChild.instance.props = newChild.props\n          newChild.instance.children = newChild.children\n          newChild.instance.domParent = domParent\n          newChild.instance.sub = [newChild.type(newChild.instance)]\n          updateChildren(domParent, [], newChild.instance.sub)\n        } else {\n          newChild.dom = createDom(newChild.type),\n          updateProperties(newChild.dom, {}, newChild.props)\n          updateChildren(newChild.dom, [], newChild.children)\n          domParent.appendChild(newChild.dom)\n        }\n      }\n    }\n  }\n}\n</code>\n<p>Here is the temperature converter again, now using local component state:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example\nfunction App(self) {\n  if (self.state == undefined)\n    self.state = 30\n  const setState = (x => self.state = x)\n  return e(\"div\", {}, \"Foo\",\n    e(Field, { state: self.state, setState: setState, label: \"°F: \", factor: 9/5, offset: 32}),\n    e(Field, { state: self.state, setState: setState, label: \"°C: \", factor: 1, offset: 0}))\n}\nfunction Field(self) {\n  const { state, setState, label, factor, offset } = self.props\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state*factor+offset),\n      onInput: (e) => setState((event.target.value-offset)/factor) }))\n}\nrender(e(App,{}),o)\n</code>\n<p>Other things work as expected, too:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer(self) {\n  if (self.v == undefined)\n    self.v = 0\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(self) {\n  const [oSt,oSetSt] = self.props.outerState\n  if (self.v == undefined)\n    self.v = oSt\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nrender(e(Outer),o)\n</code>\n<p>And we can even support asynchronous interaction:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer(self) {\n  if (self.v == undefined)\n    self.v = 0\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  return e(Inner,{outerState: [self.v, setState]})\n}\nfunction Inner(self) {\n  const [oSt,oSetSt] = self.props.outerState\n  if (self.v == undefined)\n    self.v = oSt\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  if (self.timer == undefined) {\n    self.timer = setInterval(() => iSetSt(s=>s-1), 1000)\n    console.log(\"start \",self.timer)\n  }\n  self.componentWillUnmount = () => {\n    console.log(\"stop \",self.timer)\n    clearInterval(self.timer)\n  }\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n</aside>\n<p>React implements a tree of components, with data flowing unidirectionally from parents to children. The conceptual model of a component is a function from data to UI, with lifecycle callbacks (invoked when added/removed from tree), and optional local state. Whenever a child component wants to update state higher up in the tree, the corresponding subtree will be regenerated based on the new state of the ancestor.</p>\n<aside>\n<h2>State and Effect Hooks API</h2>\n<p>It is useful to encapsulate state and lifecycle management further, using functional abstractions. React provides a “hooks” API, which developers can use to parameterize, compose, and abstracted over component behavior using functional techniques.</p>\n<p>The use of hooks allows us to hide the mutable component instance from the user-facing API entirely, accessing it only internally in a sort of dynamically scoped way during component evaluation.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet currentInstance = null\nfunction useState(init) {\n  let inst = currentInstance.self\n  let i = currentInstance.hookIndex++\n  if (i < inst.hooks.length)\n    return inst.hooks[i]\n  let update = (f => renderSubTree(inst, inst.hooks[i][0] = f(inst.hooks[i][0])))\n  return inst.hooks[i] = [init, update]\n}\nfunction useEffect(f,watch) {\n  let inst = currentInstance.self\n  let i = currentInstance.effectIndex++\n  if (i < inst.effects.length) {\n    let [g1,w1] = inst.effects[i]\n    if (watch != undefined && arraysMatch(w1,watch))\n      return\n    if (g1) g1()\n  }\n  inst.effects[i] = [f(),watch]\n}\nfunction arraysMatch(arr1, arr2) {\n  if (arr1.length !== arr2.length) return false;\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) return false;\n  }\n  return true;\n}\nfunction renderInstance(instance) {\n  let save = currentInstance\n  currentInstance = { self: instance, hookIndex: 0, effectIndex: 0 }\n  let res = instance.type(instance.props, instance.children)\n  currentInstance = save\n  return res\n}\n</code>\n<p>We refactor <code class=\"language-text\">updateChildren</code> slightly to reduce code duplication between the insert and update cases.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction renderSubTree(instance) {\n  let oldSub = instance.sub\n  instance.sub = [renderInstance(instance)]\n  updateChildren(instance.domParent, oldSub, instance.sub)\n}\nfunction updateInstance(domParent, instance, newChild) {\n  let oldSub = instance.sub\n  newChild.instance = instance\n  instance.type = newChild.type\n  instance.props = newChild.props\n  instance.children = newChild.children\n  instance.domParent = domParent\n  instance.sub = [renderInstance(instance)]\n  updateChildren(domParent, oldSub, instance.sub)\n}\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      if (newChild.type instanceof Function) {\n        updateInstance(domParent, oldChild.instance, newChild)\n      } else {\n        newChild.dom = oldChild.dom\n        updateProperties(newChild.dom, oldChild.props, newChild.props)\n        updateChildren(newChild.dom, oldChild.children, newChild.children)\n      }\n    } else {\n      if (oldChild) {\n        if (oldChild.type instanceof Function) {\n          for (let [g,w] of oldChild.instance.effects) if (g) g()\n          updateChildren(domParent, oldChild.instance.sub, [])\n        } else {\n          domParent.removeChild(oldChild.dom)\n          // make sure all cleanup handlers are called\n          updateChildren(oldChild.dom, oldChild.children, [])\n        }\n      }\n      if (newChild) {\n        if (newChild.type instanceof Function) {\n          // instance is uninitialized\n          updateInstance(domParent, {sub: [], hooks: [], effects: []}, newChild)\n        } else {\n          newChild.dom = createDom(newChild.type),\n          updateProperties(newChild.dom, {}, newChild.props)\n          updateChildren(newChild.dom, [], newChild.children)\n          domParent.appendChild(newChild.dom)\n        }\n      }\n    }\n  }\n}\n</code>\n<p>Here is the timer example again, using hooks <code class=\"language-text\">useState</code> and <code class=\"language-text\">useEffect</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer() {\n  const [iSt,iSetSt] = useState(0)\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(props) {\n  const [oSt,oSetSt] = props.outerState\n  const [iSt,iSetSt] = useState(oSt)\n  useEffect(() => {\n    let timer = setInterval(() => iSetSt(s=>s-1), 1000)\n    return () => clearInterval(timer)\n  }, [])\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n<p>The <code class=\"language-text\">useEffect</code> hook executes the provided function on\ncomponent insertion, and on updates whenever the second\nargument changes (<code class=\"language-text\">[]</code> in this case, so never).\nThe function returned from the provided one is installed\nas a cleanup callback.</p>\n<p>Based on this definition, we can extract the timer handling\ninto a new custom hook, <code class=\"language-text\">useTimer</code>, which can be reused by\nother components:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet useTimer = (f, n) => useEffect(() => {\n  let timer = setInterval(f, n)\n  return () => clearInterval(timer)\n}, [])\nfunction Outer() {\n  const [iSt,iSetSt] = useState(0)\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(props) {\n  const [oSt,oSetSt] = props.outerState\n  const [iSt,iSetSt] = useState(oSt)\n  useTimer(() => iSetSt(s=>s-1), 1000)\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n</aside>\n<p>State management and other side effects are defined as “hooks” in React, using a higher-order functional API. This means that component behavior can be parameterized, composed, and abstracted over using functional\ntechniques.</p>\n<aside>\n<h2>Asynchronous Updates</h2>\n<p>Right now we update (re-render) only the relevant subtrees, which is good. But we’re updating them synchronously. If there are two subsequent modifications of the same component, we’ll update it twice. If we modify a child, then the parent, the child gets updated twice.</p>\n<h3>Async updates</h3>\n<p>Better idea: schedule updates in a work queue, and batch-process them later. When processing, order by distance from the root. This way, parents are processed before children. Maintain a dirty flag on components, so that redundant children can be skipped.</p>\n<h3>Async state management</h3>\n<p>Directly modifying component state but processing DOM updates asynchronously may lead to some inconsistencies (state is state, so inconsistencies may have other causes as well).</p>\n<p>To reduce inconsistencies, do not modify component state directly, but schedule state updates <code class=\"language-text\">s =&gt; f(s)</code> for batch processing, too (can be done during reconciliation).</p>\n<p>The dirty flag on components becomes a queue of state transitions to apply. If empty, the component is up to date and doesn’t need re-rendering (unless props have changed).</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://github.com/facebook/react/issues/11527\">https://github.com/facebook/react/issues/11527</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/11527#issuecomment-360199710\">https://github.com/facebook/react/issues/11527#issuecomment-360199710</a></li>\n</ul>\n<h3>Incremental reconciliation</h3>\n<p>Reconciliation may take time, so there are benefits in making it interruptible. This is easy to do at the granularity of a worklist (non-overlapping subtrees), but for large trees it is worth to chunk up traversal of children. Standard methods exist to make a recursive traversal interruptible. React uses a Zipper-like data structure they call a fiber (a tree node with parent and sibling pointers). A simpler option in JS is async/await.</p>\n<p>It is still important that DOM modifications are applied atomically. After all, we don’t want to see a partially updated UI. Hence, React splits processing into a “render” and a “commit” phase. The (interruptible) render phase does all the diffing and determines necessary DOM changes, and the commit phase applies the final changes in a single atomic step.</p>\n<p>There is some overhead associated with maintaining data structures for this phase separation. Presumably these are outweighed by the benefits of incrementality in some cases but not all.</p>\n<h3>Concurrency</h3>\n<p>It is sometimes desirable to not process updates strictly in order, but according to priorities. This way, a response to clicks or key presses may be processed immediately, while, for example, updates due to incoming network data may be batched a little bit to enable processing in larger chunks (to keep the UI responsive to user actions).</p>\n</aside>\n<p>React always keeps the component tree in a consistent state, which provides considerable freedom for asynchronous processing, such as batching or prioritizing updates.</p>\n<aside>\n<h2>References</h2>\n<p>Resources:</p>\n<ul>\n<li><a href=\"https://pomb.us/build-your-own-react/\">Build your own React</a> by Rodrigo Pompbo</li>\n<li><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a></li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation</a> from the React.js docs</li>\n<li>State handling <a href=\"https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key\">broken</a> and <a href=\"https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key\">fixed</a> using keys</li>\n<li><a href=\"http://todomvc.com/examples/react/#/\">TodoMvc</a> example in React</li>\n<li>Dealing with input React Mental Models: Working With <code class=\"language-text\">&lt;input&gt;</code> | Learn React.Design Backstories <a href=\"https://learnreact.design/2020/03/31/react-mental-models-working-with-input\">https://learnreact.design/2020/03/31/react-mental-models-working-with-input</a> HN: React Mental Models: Working with Input | Hacker News <a href=\"https://news.ycombinator.com/item?id=22761622\">https://news.ycombinator.com/item?id=22761622</a></li>\n<li>A visual guide to React Mental models, part 2: useState, useEffect and lifecycles | Obed Parlapiano - JavaScript Engineer &#x26; Writer <a href=\"https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/\">https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/</a></li>\n</ul>\n</aside>","fields":{"slug":"/Public/Generic/deconstructing-react/"},"frontmatter":{"date":"July 07, 2020","title":"Deconstructing React","description":"How does React work internally? Let's build a React clone from scratch to understand.","keywords":"JavaScript, React, State, Hook, Virtual DOM, Diff, Reconciliation, Async","tags":null}}},{"node":{"excerpt":"Device APIs allow web pages to interface with the physical world, blending the boundary between web and native apps.\nPhones and tablets come…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Device APIs allow web pages to interface with the physical world, blending the boundary between web and native apps.\nPhones and tablets come with a variety of sensors, and web APIs exist for many of them. Below are examples for the most interesting ones.</p>\n<p>References:</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals\">Google developer pages</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API\">Mozilla developer’s network (MDN)</a></li>\n</ul>\n<h2>Touch</h2>\n<p>Finger and stylus, sensitive to touch size, pressure, tilt.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!window.PointerEvent)\n  return print(\"PointerEvent not supported\")\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 600\ncvs.height = 300\nlet ctx = cvs.getContext(\"2d\")\nctx.strokeRect(0,0,cvs.width,cvs.height)\no.appendChild(cvs)\nlet msg = document.createElement(\"small\")\no.appendChild(msg)\nfunction show(e) {\n  msg.innerText = e+\"\\n\"\n}\nshow(\"navigator.maxTouchPoints: \"+ navigator.maxTouchPoints)\ncvs.style.touchAction=\"none\" // prevent scrolling\ncvs.addEventListener(\"pointerdown\", ev => {\n  cvs.setPointerCapture(ev.pointerId)\n  ev.preventDefault()\n  ev.stopPropagation()\n  // ev.stopImmediatePropagation() // necessary?\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointermove\", ev => {\n  ev.preventDefault()\n  ev.stopPropagation()\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointerup\", ev => {\n  ev.preventDefault()\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointercancel\", ev => {\n  ev.preventDefault()\n  drawTouch(ev)\n})\nfunction drawTouch(ev) {\n  show(ev.type + \"/\" + ev.pointerType + \"\\n\"+\n   \"width: \"+ev.width +\", \" +\n   \"height: \"+ev.height +\"\\n\" +\n   \"button: \"+ev.button +\", \" +\n   \"buttons: \"+ev.buttons +\"\\n\" +\n   \"pressure: \"+ev.pressure +\", \" +\n   \"tangentialPressure: \"+ev.tangentialPressure +\", \" +\n   \"webkitForce: \"+ev.webkitForce +\"\\n\" +\n   \"tiltX: \"+ev.tiltX +\", \" +\n   \"tiltY: \"+ev.tiltY\n  )\n  // debug: print all fields\n  // for (k in ev) msg.innerText += (k+\"\\n\")\n  let rect = cvs.getBoundingClientRect()\n  let x = ev.clientX-rect.left\n  let y = ev.clientY-rect.top\n  if (ev.pointerType == \"touch\") {\n    let rx = ev.width\n    let ry = ev.height\n    ctx.fillStyle = \"white\"\n    ctx.fillRect(x-rx/2,y-ry/2,rx,ry)\n    ctx.strokeRect(x-rx/2,y-ry/2,rx,ry)\n  } else if (ev.pointerType == \"pen\") {\n    let r = ev.pressure * 100\n    let tanX = Math.tan(ev.tiltX/180*Math.PI)\n    let tanY = Math.tan(ev.tiltY/180*Math.PI)\n    let azimuth = Math.atan2(tanY,tanX)\n    let altitude =Math.atan2(1, Math.sqrt(tanX*tanX+tanY*tanY))\n    let rx = r+Math.cos(altitude) * r\n    let ry = r\n    ctx.beginPath()\n    ctx.ellipse(x,y,rx,ry,azimuth,0,2*Math.PI)\n    ctx.fillStyle = \"white\"\n    ctx.closePath()\n    ctx.fill()\n    ctx.stroke()\n  } else {\n    let rx = ev.width\n    let ry = ev.height\n    ctx.fillStyle = \"white\"\n    ctx.fillRect(x-rx/2,y-ry/2,rx,ry)\n    ctx.strokeRect(x-rx/2,y-ry/2,rx,ry)\n  }\n}\n</code>\n<p>This example uses ‘pointer events’, which are the new emerging standard for unifying touch and mouse events. Tested on a 2018 iPad Pro with Apple Pencil, running Safari 13.</p>\n<p>Some notes: <code class=\"language-text\">setPointerCapture</code> is necessary to continue receiving <code class=\"language-text\">pointermove</code> events after leaving the canvas, <code class=\"language-text\">touch-action=none</code> is necessary to prevent scrolling. On iPad, finger touches have size but no pressure. The first touch with a pencil appears to register with higher pressure than subsequent ones. Finger and stylus touches are mutually exclusive, presumably to enable hand-resting on the surface while drawing or writing.</p>\n<p>Desktop Safari (13.1) currently doesn’t report trackpad pressure for pointer events. There is a separate and non-standard set of events for this (<code class=\"language-text\">webkitmouseforcewillbegin</code>, <code class=\"language-text\">webkitmouseforcedown</code>,<code class=\"language-text\">webkitmouseforcechanged</code>, <code class=\"language-text\">webkitmouseforceup</code>).</p>\n<p>See also: <a href=\"https://patrickhlauke.github.io/getting-touchy-presentation/\">https://patrickhlauke.github.io/getting-touchy-presentation/</a></p>\n<h2>Motion &#x26; Orientation</h2>\n<p>Accelerometer, Gyroscope, Compass.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!window.DeviceMotionEvent)\n  return print(\"DeviceMotionEvent not supported\")\nsizeX = 300\nsizeY = 150\nlet cvs = document.createElement(\"canvas\")\ncvs.width = sizeX\ncvs.height = sizeY\nlet ctx = cvs.getContext(\"2d\")\no.appendChild(cvs)\nlet msg = document.createElement(\"small\")\no.appendChild(msg)\nfunction show(e) {\n  msg.innerText = e+\"\\n\"\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => { DeviceMotionEvent.requestPermission().then(res => {\n  if (res != 'granted')\n    return print(\"Error: \"+res)\n  window.addEventListener(\"devicemotion\", motion)\n  window.addEventListener(\"deviceorientation\", orientation)\n  let a = document.createElement(\"div\")\n  let b = document.createElement(\"div\")\n  let g = document.createElement(\"div\")\n  let c = document.createElement(\"div\")\n  let x = document.createElement(\"div\")\n  let y = document.createElement(\"div\")\n  let z = document.createElement(\"div\")\n  o.appendChild(x)\n  o.appendChild(y)\n  o.appendChild(z)\n  o.appendChild(a)\n  o.appendChild(b)\n  o.appendChild(g)\n  o.appendChild(c)\n  function motion(ev) {\n    ctx.clearRect(0,0,100,sizeY)\n    ctx.fillRect(10,sizeY/2,20,-10*ev.acceleration.x)\n    ctx.fillRect(40,sizeY/2,20,-10*ev.acceleration.y)\n    ctx.fillRect(70,sizeY/2,20,-10*ev.acceleration.z)\n    x.innerText = \"\"+ev.acceleration.x\n    y.innerText = \"\"+ ev.acceleration.y\n    z.innerText = \"\"+ ev.acceleration.z\n  }\n  function orientation(ev) {\n    ctx.clearRect(100,0,sizeX,sizeY)\n    let r = 15\n    function drawDial(x,angle) {\n      let dx = r * Math.cos(angle/180*Math.PI)\n      let dy = r * Math.sin(angle/180*Math.PI)\n      ctx.beginPath()\n      ctx.moveTo(x,sizeY/2)\n      ctx.lineTo(x+dx,sizeY/2+dy)\n      ctx.stroke()\n      ctx.beginPath()\n      ctx.arc(x,sizeY/2,r,0,2*Math.PI)\n      ctx.stroke()\n    }\n    drawDial(110,ev.alpha)\n    drawDial(140,ev.beta)\n    drawDial(170,ev.gamma)\n    drawDial(210,ev.webkitCompassHeading)\n    a.innerText = \"\"+ev.alpha\n    b.innerText = \"\"+ ev.beta\n    g.innerText = \"\"+ ev.gamma\n    c.innerText = \"\"+ ev.webkitCompassHeading\n  }\n  button(\"stop\", () => {\n    window.removeEventListener(\"devicemotion\", motion)\n    window.removeEventListener(\"deviceorientation\", orientation)\n  })\n})})\n</code>\n<h2>Location</h2>\n<p>Via GPS or Wifi.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!navigator.geolocation)\n  return print(\"geolocation not supported\")\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nbutton(\"start\", ev => {\n  function success(pos) {\n    print(\"Latitude: \" + pos.coords.latitude)\n    print(\"Longitude: \" + pos.coords.longitude)\n  }\n  function error(err) {\n    print(\"Error: \"+err.message)\n  }\n  navigator.geolocation.getCurrentPosition(success, error)\n})\n</code>\n<p>In addition to <code class=\"language-text\">getCurrentPosition</code>, there is also <code class=\"language-text\">watchCurrentPosition</code>, which provides continuous updates (returns a watch id, clean up with <code class=\"language-text\">clearWatch</code>). Both calls support some options (passed as third argument): <code class=\"language-text\">enableHighAccuracy</code>, <code class=\"language-text\">maximumAge</code>, <code class=\"language-text\">timeout</code>.</p>\n<h2>Microphone</h2>\n<p>Capture audio input, do an FFT on the fly, and draw a frequency spectrum.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => {\n  navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(handleSuccess)})\nfunction handleSuccess(stream) {\n    // console.log(stream)\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      // console.log(devices)\n      for (d of devices) print(d.kind,d.label)\n    })\n    // set up canvas\n    let WIDTH = 600\n    let HEIGHT = 100\n    let cvs = document.createElement(\"canvas\")\n    cvs.width = WIDTH\n    cvs.height = HEIGHT\n    let ctx = cvs.getContext(\"2d\")\n    o.appendChild(cvs)\n    print(\"\")\n    let msg = document.createElement(\"small\")\n    o.appendChild(msg)\n    print(\"\")\n    // set up audio\n    if (!window.audioContext)\n      window.audioContext = new (window.webkitAudioContext||AudioContext)();\n    const context = window.audioContext\n    const source = context.createMediaStreamSource(stream);\n    const analyser = context.createAnalyser()\n    analyser.minDecibels = -50;\n    analyser.maxDecibels = -5;\n    analyser.smoothingTimeConstant = 0.85;\n    source.connect(analyser);\n    // analyser.connect(context.destination); // if we want sound output\n    analyser.fftSize = 4096;\n    var bufferLength = analyser.frequencyBinCount;\n    var dataArray = new Float32Array(bufferLength);\n    // stop button\n    button(\"stop\", ev => {\n      stream.getTracks().forEach(track=>track.stop())\n      source.disconnect()\n      analyser.disconnect()\n      cancelAnimationFrame(drawId)\n    })\n    // drawing loop\n    let drawId = requestAnimationFrame(draw)\n    function draw() {\n      analyser.getFloatFrequencyData(dataArray);\n      // compute peak frequency\n      let max = 0\n      let maxi = 0\n      for(let i = 20; i < bufferLength; i++) {\n        if (dataArray[i]+200 > max) {\n          max = dataArray[i]+200\n          maxi = i\n        }\n      }\n/*\nWhat is the frequency at i?\nLinear scale from 0 to window.audioContext.sampleRate/2 (typically 44100/2 = 22050, so each step is 22050/fftSize)\n*/\n// Some note indexes, calibrated by xylophone\n// (these are C6, C7, ...):\n// C  97 194\n// D 109 218\n// E 122 245\n// F 130 259\n// G 146\n// A 163\n// H 183\n      let freq = window.audioContext.sampleRate/2/(bufferLength-1)*maxi\n      msg.innerText = \"peak: \" + Math.round(freq) + \" Hz (index \" + maxi + \")\"\n      // draw spectrum\n      ctx.clearRect(0, 0, WIDTH, HEIGHT)\n      let barCount = bufferLength/2\n      let barWidth = (WIDTH / barCount) * 2.5\n      let barHeight\n      let x = 0\n      for(let i = 0; i < barCount; i++) {\n        barHeight = (dataArray[i] + 100)*2\n        //ctx.fillStyle = 'rgb(' + Math.floor(barHeight+100) + ',50,50)'\n        ctx.fillRect(x,HEIGHT-barHeight/2,barWidth,barHeight/2)\n        x += barWidth + 1\n      }\n      drawId = requestAnimationFrame(draw)\n    }\n}\n/*\n    Alternative to manually process raw audio:\n    const processor = context.createScriptProcessor(1024, 1, 1)\n    source.connect(processor)\n    processor.connect(context.destination)\n    processor.onaudioprocess = function(e) {\n      // Process the data ...\n      //console.log(e.inputBuffer)\n    }\n*/\n</code>\n<p>Given the frequency spectrum data we can detect peaks using a simple threshold scheme. This is almost useable as a guitar tuner, but not quite (resolution of FFT at low frequencies is not high enough, so typical tuner apps use other algorithms, typically based on autocorrelation in the time domain).</p>\n<p>See also: <a href=\"https://mdn.github.io/voice-change-o-matic/\">https://mdn.github.io/voice-change-o-matic/</a></p>\n<h2>Camera</h2>\n<p>Show camera input, and grab frames by drawing to a canvas.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => {\n  navigator.mediaDevices.getUserMedia({ audio: true, video: true }).then(handleSuccess)})\nfunction handleSuccess(stream) {\n    // console.log(stream)\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      // console.log(devices)\n      for (d of devices) print(d.kind,d.label)\n    })\n    // set up canvas\n    let WIDTH = 600\n    let HEIGHT = WIDTH/4*3\n    // msg not used ...\n    // let msg = document.createElement(\"small\")\n    // o.appendChild(msg)\n    print(\"\")\n    // video elem\n    let vid = document.createElement(\"video\")\n    vid.autoplay = true\n    vid.width = WIDTH\n    vid.height = HEIGHT\n    vid.srcObject = stream\n    o.appendChild(vid)\n    print(\"\")\n    // snapshot button\n    button(\"snapshot\", ev => {\n      let cvs = document.createElement(\"canvas\")\n      cvs.width = WIDTH/3\n      cvs.height = HEIGHT/3\n      o.appendChild(cvs)\n      let ctx = cvs.getContext(\"2d\")\n      ctx.drawImage(vid,0,0,cvs.width,cvs.height)\n    })\n    // stop button\n    button(\"stop\", ev => {\n      stream.getTracks().forEach(track=>track.stop())\n      cancelAnimationFrame(drawId)\n    })\n    // drawing loop\n    //let drawId = requestAnimationFrame(draw)\n    //function draw() {\n    //  drawId = requestAnimationFrame(draw)\n    //}\n}\n</code>\n<p>Video DOM elements can be styled using CSS, so it’s possible to add filters or other transformations in that way. Video frames can be drawn to a canvas (like above) or also serve as texture in a WebGL context.</p>\n<p>See also: <a href=\"https://www.html5rocks.com/en/tutorials/getusermedia/intro/\">https://www.html5rocks.com/en/tutorials/getusermedia/intro/</a></p>\n<p>To get access to raw pixel data, first draw a video frame to a canvas, and then read back pixel data from the canvas using <code class=\"language-text\">ctx.getImageData</code>. This enables CPU processing using JS or, potentially, WASM. For GPU processing, once loaded as a WebGL texture, a video frame can be processed using vertex and fragment shaders.</p>\n<p>See also: <a href=\"https://developers.google.com/web/fundamentals/media/manipulating/live-effects\">https://developers.google.com/web/fundamentals/media/manipulating/live-effects</a></p>","fields":{"slug":"/Public/Generic/touch-camera-device-apis/"},"frontmatter":{"date":"July 04, 2020","title":"Touch, Camera, and Other Device APIs","description":"How to enable touch and stylus input, and access the accelerometer, compass, GPS, microphone, and camera in your device from JS.","keywords":"Device API, Touch Events, Pointer Events, Stylus, DeviceMotion Event, Accelerometer, Geolocation, Microphone, Camera, Web, JavaScript","tags":null}}},{"node":{"excerpt":"Graphs are everywhere, and it’s often useful to visualize them. We can use tools like GraphViz to do so, or TikZ, Mathematica, or D3. But…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Graphs are everywhere, and it’s often useful to visualize them. We can use tools like GraphViz to do so, or TikZ, Mathematica, or D3. But how does GraphViz work? And what if we wanted to draw nice-looking graphs ourselves from scratch?</p>\n<p>We can think about drawing graphs as two separate problems. One is determining where to place each node and edge (“Frontend”). The other is to actually draw them once positions are determined (“Backend”). We’ll go bottom-up and start with the backend.</p>\n<aside>\n<h2>Backend</h2>\n<p>In this section we’ll assume we already know where to place graph nodes. We’ll treat ways to automate this below under <a href=\"/graphs-frontend\">Frontend</a>.</p>\n<p>Let’s create a place to draw.</p>\n<code class=\"runScript\" filter=\"setPreamble\" popout=\"true\">\nlet cvs = null\nlet ctx = null\nlet sizeX = 300\nlet sizeY = 100\nfunction createCanvas() {\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.width = sizeX\n  cvs.height = sizeY\n  ctx = cvs.getContext(\"2d\")\n  ctx.lineWidth = 1\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n}\n</code>\n<h3>Boxes</h3>\n<p>Here’s our first graph. Just a single node, i.e., a box and a label:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\nctx.strokeRect(10, 10, 80, 80)\nctx.fillText(\"A\", 50, 50)\n</code>\n<p>We’re going to draw more boxes, so let’s define\na few auxiliaries.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// Fix some parameters\nlet boxX = 20\nlet boxY = 20\n</code>\n<p>Wrap it up in a function that draws labeled boxes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// Draw a box with label n centered around point x,y\nfunction drawBox(n, x, y) {\n  ctx.strokeRect(x-boxX/2, y-boxY/2, boxX, boxY)\n  ctx.fillText(n, x, y, boxX)\n}\n</code>\n<p>Cool. Now this works:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\n</code>\n<h3>Lines</h3>\n<p>Now let’s draw some lines:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction drawLine(x1, y1, x2, y2) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawLine(20, 20, 80, 20)\ndrawLine(20, 20, 80, 80)\n</code>\n<p>That’s not ideal. We want lines to stop at the edges of boxes. An easy way is to adjust by <code class=\"language-text\">boxX/2</code> or <code class=\"language-text\">boxY/2</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawLine(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const skipX = dx < dy  ? 0 : x2 > x1 ? boxX/2 : -boxX/2\n  const skipY = dx >= dy ? 0 : y2 > y1 ? boxY/2 : -boxY/2\n  ctx.beginPath()\n  ctx.moveTo(x1+skipX, y1+skipY)\n  ctx.lineTo(x2-skipX, y2-skipY)\n  ctx.stroke()\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawBox(\"D\", 20, 80)\ndrawLine(20, 20, 80, 20)\ndrawLine(20, 20, 80, 80)\ndrawLine(20, 20, 20, 80)\n</code>\n<p>The result always connects the centerpoints of the opposing faces. Good enough for now, but we’ll consider alternatives below.</p>\n<h3>Arrows</h3>\n<p>Here’s how to draw basic arrow heads:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawArrowHead(x, y, angle) {\n  ctx.save()\n  ctx.translate(x,y)\n  ctx.rotate(angle)\n  ctx.beginPath()\n  ctx.moveTo(0,0)\n  ctx.lineTo(-6,-3)\n  ctx.lineTo(-5,0)\n  ctx.lineTo(-6,3)\n  ctx.lineTo(0,0)\n  ctx.fill()\n  ctx.restore()\n}\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = x2 - x1\n  const dy = y2 - y1\n  const angle = Math.atan2(dy, dx)\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n  drawArrowHead(x2, y2, angle)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawArrow(10,50,40,50)\ndrawArrow(50,40,70,60)\ndrawArrow(90,35,90,65)\ndrawArrow(110,60,140,40)\n</code>\n<p>Now we put it back together with the rest of the line drawing code:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const skipX = dx < dy  ? 0 : x2 > x1 ? boxX/2 : -boxX/2\n  const skipY = dx >= dy ? 0 : y2 > y1 ? boxY/2 : -boxY/2\n  const angle = Math.atan2(dy, dx)\n  ctx.beginPath()\n  ctx.moveTo(x1+skipX, y1+skipY)\n  ctx.lineTo(x2-skipX, y2-skipY)\n  ctx.stroke()\n  drawArrowHead(x2-skipX, y2-skipY, angle)\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawBox(\"D\", 20, 80)\ndrawArrow(20, 20, 80, 20)\ndrawArrow(20, 20, 80, 80)\ndrawArrow(20, 20, 20, 80)\n</code>\n<p>Pretty neat, huh?</p>\n<h3>Lines: targeting the center</h3>\n<p>This style gets a bit crowded if many arrows point to the same node. All the arrow heads will point to the same exact location and partly overlap there (which doesn’t look nice).</p>\n<p><strong>Exercise:</strong> Try it!</p>\n<p>An alternative is to plan drawing the lines into the center of the box and then cut them short where they cross the box outline:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = x2 - x1\n  const dy = y2 - y1\n  if (Math.abs(dx) > Math.abs(dy)) {\n    const slope = dy / dx\n    const angle = Math.atan2(dy, dx)\n    const skip = dx >= 0 ? boxX/2 : -boxX/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skip, y1+skip*slope)\n    ctx.lineTo(x2-skip, y1+(dx-skip)*slope)\n    ctx.stroke()\n    drawArrowHead(x2-skip, y1+(dx-skip)*slope, angle)\n  } else {\n    const slope = dx / dy\n    const angle = Math.atan2(dy, dx)\n    const skip = dy >= 0 ? boxY/2 : -boxY/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skip*slope, y1+skip)\n    ctx.lineTo(x1+(dy-skip)*slope, y2-skip)\n    ctx.stroke()\n    drawArrowHead(x1+(dy-skip)*slope, y2-skip, angle)\n  }\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 140, 20)\ndrawBox(\"D\", 20, 80)\ndrawBox(\"E\", 80, 80)\ndrawBox(\"F\", 140, 80)\ndrawArrow(20, 20, 80, 80) // A->E right down\ndrawArrow(20, 80, 80, 20) // D->B right up\ndrawArrow(140, 80, 80, 20) // C -> E left down\ndrawArrow(140, 20, 80, 80) // F -> B left up\ndrawArrow(20, 20, 20, 80) // A->D down\ndrawArrow(140, 80, 140, 20) // F->C up\n\"done\"\n</code>\n<p>This approach generalizes pretty well to other node shapes (circles, etc.).</p>\n<p><strong>Exercise</strong>: Try it!</p>\n<h3>Lines: straight segments</h3>\n<p>Sometimes we don’t want to draw lines at arbitrary angles but have something more orthogonal.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawStraightArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  if (dx > dy) {\n    const skipX = x2 > x1 ? boxX/2 : -boxX/2\n    const midX = (x1+skipX+x2-skipX)/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skipX, y1)\n    ctx.lineTo(midX, y1)\n    ctx.lineTo(midX, y2)\n    ctx.lineTo(x2-skipX, y2)\n    ctx.stroke()\n    drawArrowHead(x2-skipX, y2, x2 > x1 ? 0 : Math.PI)\n  } else {\n    const skipY = y2 > y1 ? boxY/2 : -boxY/2\n    const midY = (y1+skipY+y2-skipY)/2\n    ctx.beginPath()\n    ctx.moveTo(x1, y1+skipY)\n    ctx.lineTo(x1, midY)\n    ctx.lineTo(x2, midY)\n    ctx.lineTo(x2, y2-skipY)\n    ctx.stroke()\n    drawArrowHead(x2, y2-skipY, y2 > y1 ? Math.PI/2 : 3*Math.PI/2)\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 120, 20)\ndrawBox(\"C\", 120, 80)\ndrawBox(\"D\", 40, 80)\ndrawStraightArrow(20, 20, 120, 20)\ndrawStraightArrow(20, 20, 120, 80)\ndrawStraightArrow(20, 20, 40, 80)\n</code>\n<h3>Lines: curved segments</h3>\n<p>If these right angles look too rigid, we can also use Bezier curves.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawCurvedArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const bend = 0.75 // play with this factor!\n  if (dx > dy) {\n    const skipX = x2 > x1 ? boxX/2 : -boxX/2\n    const ctrlX = bend*(x2-x1-2*skipX)\n    ctx.beginPath()\n    ctx.moveTo(x1+skipX, y1)\n    ctx.bezierCurveTo(\n      x1+skipX + ctrlX, y1,\n      x2-skipX - ctrlX, y2,\n      x2-skipX, y2)\n    ctx.stroke()\n    drawArrowHead(x2-skipX, y2, x2 > x1 ? 0 : Math.PI)\n  } else {\n    const skipY = y2 > y1 ? boxY/2 : -boxY/2\n    const ctrlY = bend*(y2-y1-2*skipY)\n    ctx.beginPath()\n    ctx.moveTo(x1, y1+skipY)\n    ctx.bezierCurveTo(\n      x1, y1+skipY+ctrlY,\n      x2, y2-skipY-ctrlY,\n      x2, y2-skipY)\n    ctx.stroke()\n    drawArrowHead(x2, y2-skipY, y2 > y1 ? Math.PI/2 : 3*Math.PI/2)\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 120, 20)\ndrawBox(\"C\", 120, 80)\ndrawBox(\"D\", 40, 80)\ndrawCurvedArrow(20, 20, 120, 20)\ndrawCurvedArrow(20, 20, 120, 80)\ndrawCurvedArrow(20, 20, 40, 80)\n</code>\n<p>It’s also possible to draw curves using circle segments or quadratic curves instead of cubic bezier curves.</p>\n<p><strong>Exercise:</strong> Try it!</p>\n<!--\n// Understanding arcto\n\net r = 20\n\nfunction arc(x2,y2,d) {\nlet [x1,y1] = [x2-100,y2-d]\nlet [x3,y3] = [x2-100,y2+d]\nctx.beginPath()\nctx.moveTo(x1,y1)\nctx.arcTo(x2,y2,x3,y3,r)\nctx.lineTo(x3,y3)\nctx.stroke()\n\nctx.beginPath()\nctx.arc(x2,y2,3,0,2*Math.PI)\nctx.fill()\nctx.beginPath()\nctx.arc(x2,y2,r,0,2*Math.PI)\nctx.stroke()\n}\n\n\narc(220,150, 100)\narc(220,150, 90)\narc(220,150, 80)\narc(220,150, 70)\narc(220,150, 60)\narc(220,150, 50)\narc(220,150, 40)\narc(220,150, 30)\narc(220,150, 21)\narc(220,150, 20)\narc(220,150, 19)\narc(220,150, 18)\narc(220,150, 17)\narc(220,150, 16)\narc(220,150, 15)\narc(220,150, 14)\narc(220,150, 13)\narc(220,150, 12)\narc(220,150, 11)\narc(220,150, 10)\n\n\narc(460,150, 60)\narc(460,150, 60)\narc(460,150, 40)\narc(460,150, 20)\narc(460,150, 10)\n\n  -->\n<h3>Lines: specifying connectors and waypoints</h3>\n<p><strong>Exercise:</strong> Let the user specify which side of a box a line should be attached to.</p>\n<p>This may require drawing multiple line segments, for example when node A is above B and we want to connect the top of node A with the bottom of node B.</p>\n<p>As a generalization we provide a function that draws a line through an arbitrary number of waypoints. It’s also useful to introduce a special case for cycles.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet edgeBend = 20\nfunction drawCircle(n, x, y) {\n  ctx.beginPath();\n  ctx.arc(x, y, boxX/2, 0, 2 * Math.PI);\n  ctx.stroke();\n  ctx.fillText(n, x, y, boxX)\n}\nfunction drawArrowHead(x, y, angle) {\n  ctx.save()\n  ctx.translate(x,y)\n  ctx.rotate(angle)\n  ctx.beginPath()\n  ctx.moveTo(0,0)\n  ctx.lineTo(-6,-3)\n  ctx.lineTo(-5,0)\n  ctx.lineTo(-6,3)\n  ctx.lineTo(0,0)\n  ctx.fill()\n  ctx.restore()\n}\nfunction drawArrow(u1, v1, u2, v2) {\n  drawArrowN([u1, v1, u2, v2])\n}\nfunction drawArrowN(points) {\n  let [x1,y1,x2,y2] = points\n  let dx = x2 - x1\n  let dy = y2 - y1\n  let angle = Math.atan2(dy, dx)\n  x1 += Math.cos(angle) * boxX/2\n  y1 += Math.sin(angle) * boxX/2\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  for (let j = 4; j < points.length; j+=2) {\n    let [x3,y3] = [points[j],points[j+1]]\n    ctx.arcTo(x2, y2, x3, y3, edgeBend);\n    x1 = x2; y1 = y2\n    x2 = x3; y2 = y3\n  }\n  dx = x2 - x1\n  dy = y2 - y1\n  angle = Math.atan2(dy, dx)\n  x2 -= Math.cos(angle) * boxX/2\n  y2 -= Math.sin(angle) * boxX/2\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n  drawArrowHead(x2, y2, angle)\n}\nfunction drawCycle(x,y) {\n  ctx.beginPath()\n  let r1 = boxX/2\n  let r2 = 15\n  let a = 2*Math.asin(0.5*r1/r2)\n  ctx.arc(x+r2,y,r2,Math.PI+a,3*Math.PI-a)\n  ctx.stroke()\n  drawArrowHead(x+r2+r2*Math.cos(Math.PI+a),y+r2*Math.sin(Math.PI+a),Math.PI-a)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawCircle(\"A\",20,20)\ndrawCircle(\"B\",180,20)\ndrawArrowN([20,20,60,60,140,60,180,20])\ndrawCycle(180,20)\n</code>\n<h3>Lines: avoiding overlap</h3>\n<p><strong>Exercise:</strong> Keep track of where line segments are, and move new ones slightly off to the side. Hint: see <a href=\"/graphs-frontend\">Frontend</a> section below for a variant that does this for back-edges</p>\n<h3>Deferred mode</h3>\n<p>So far, we have drawing functions that produce immediate graphical output at the given coordinates.</p>\n<p>Remembering all these coordinate values is a bit cumbersome, so let’s introduce a layer that allows us to assign node coordinates first, and then draw nodes and edges based on the assigned positions in a second step.</p>\n<p>This model has a number of other advantages. We become independent of a specific drawing backend (e.g., we could use positioned HTML or SVG nodes instead of canvas), and of course we have a better foundation for computing positions programmatically later on.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet gridX = 50\nlet gridY = 50\nlet originX = 20\nlet originY = 20\nlet pos = {}\nfunction placeNode(n, u, v) {\n  pos[n] = [u*gridX, v*gridY]\n}\nfunction drawNode(n1) {\n  let [x,y] = pos[n1]\n  drawCircle(n1, originX + x, originY + y)\n}\nfunction drawEdge(n1,n2) { // TODO: N\n  let [x1,y1] = pos[n1]\n  let [x2,y2] = pos[n2]\n  drawArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n}\nfunction createCanvas() {\n  let minX = Number.MAX_VALUE\n  let maxX = Number.MIN_VALUE\n  let minY = Number.MAX_VALUE\n  let maxY = Number.MIN_VALUE\n  for (let n in pos) {\n    let [x,y] = pos[n]\n    minX = Math.min(minX, x-boxX/2)\n    maxX = Math.max(maxX, x+boxX/2)\n    minY = Math.min(minY, y-boxY/2)\n    maxY = Math.max(maxY, y+boxY/2)\n  }\n  minX -= 20\n  maxX += 20\n  minY -= 20\n  maxY += 20\n  originX = -minX\n  originY = -minY\n  sizeX = maxX - minX\n  sizeY = maxY - minY\n  // super.createCanvas\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.height = sizeY\n  cvs.width = sizeX\n  ctx = cvs.getContext(\"2d\")\n  ctx.lineWidth = 1\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 1, 0)\nplaceNode(\"C\", 1, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\n</code>\n</aside>\n<p>Now we have tools to draw various forms of lines and boxes:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 1, 0)\nplaceNode(\"C\", 1, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawArrow = drawStraightArrow\ndrawCircle = drawBox\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 2, 0)\nplaceNode(\"C\", 2, 1)\nplaceNode(\"D\", 0.5, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawNode(\"D\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\ndrawEdge(\"A\",\"D\")\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawArrow = drawCurvedArrow\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 2, 0)\nplaceNode(\"C\", 2, 1)\nplaceNode(\"D\", 0.5, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawNode(\"D\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\ndrawEdge(\"A\",\"D\")\n</code>\n<p>Deciding how exactly to draw connecting edges (between which faces, when to draw an “S” vs “L” shape, etc.) already requires some nontrivial geometry.</p>\n<aside>\n<h2>Frontend - Drawing Trees</h2>\n<p>Before we tackle general graphs, let’s take a look at trees. Trees are of course a very important subclass of graphs, but they are actually quite interesting in their own right.</p>\n<h3>Algorithm 1</h3>\n<p>Preliminaries:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//let g = {5: {11: {0:{},2:{},4:{}}, 1.3: { 7.9: {6:{}, 8:{}, 10:{} }}}}\nlet g = { 1: { 2: { 3: { 4: {5: {}}, 6: {7:{}, 8:{}, 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\nfunction succ(n) {\n  return Object.entries(n)\n}\nfunction drawForest(g,p) {\n  for (let [k,v] of succ(g)) {\n    drawForest(v, k)\n    drawNode(k)\n    if (p != null) drawEdge(p,k)\n  }\n}\n</code>\n<p>How to place the nodes? Let’s start on one end of\nthe canvas and keep track of how many we’ve drawn at each level:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    placeForest(v, d+1)\n    placeNode(k, d, fringe[d])\n    fringe[d] += 1\n  }\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>Looks like a good start, but obviously not great.</p>\n<h3>Algorithm 2</h3>\n<p>An easy idea to improve the layout is to center nodes at each level. We can do this in two passes:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet extent = []\nfunction layoutForest(g,d) {\n  extent[d] = extent[d] || 0\n  for (let [k,v] of succ(g)) {\n    layoutForest(v, d+1, extent[d])\n    extent[d] += 1\n  }\n}\nlet max = 4\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    const pos = (max-extent[d])/2 + fringe[d]\n    placeForest(v, d+1)\n    placeNode(k, d, pos)\n    fringe[d] += 1\n  }\n}\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This is better, but still not optimal. The placement of parents with respect to children is awkward.</p>\n<h3>Algorithm 3</h3>\n<p>We’d like to place parents in the middle above of their children. We’ll implement a version of an algorithm attributed to Reingold and Tilford.</p>\n<p>First cut:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) { return Object.entries(g).reverse() }\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let childpos = []\n  for (let [k,v] of succ(g)) {\n    const cp = placeForest(v, d+1)\n    let pos = fringe[d]\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid > pos) pos = mid\n    }\n    placeNode(k, d, pos)\n    fringe[d] = pos+1\n    childpos.push(pos)\n  }\n  return childpos\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This is better, but misses the case where a subtree would need to be moved after it has been drawn.</p>\n<p>We switch back to a two-pass process and add a function to move already-positioned subtrees:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n// annoying: converting between screen and grid pos\nfunction succ(g) { return Object.entries(g).reverse() }\nlet fringe = []\nfunction moveForest(g,d,off) {\n  for (let [k,v] of succ(g)) {\n    moveForest(v,d+1,off)\n    pos[k][1] += off*gridY\n    let scaled = pos[k][1]/gridY\n    if (scaled + 1 > fringe[d])\n      fringe[d] = scaled + 1\n  }\n}\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    let p = fringe[d]\n    placeForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => pos[k1][1]/gridY)\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid >= p) {\n        p = mid\n      } else {\n        // move children and adjust fringe below!\n        moveForest(v, d+1, p-mid)\n      }\n    }\n    fringe[d] = p+1\n    placeNode(k,d,p)\n  }\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This works great! But it’s horribly inefficient. The recursive invocation of <code class=\"language-text\">moveForest</code> makes the implementation exponential (compare recursion pattern to naive Fibonacci).</p>\n<p>We’ll be back to linear performance if we manage to remove recursion from <code class=\"language-text\">moveForest</code>. But how can we do that?</p>\n<p>Function <code class=\"language-text\">moveForest</code> does two things: it updates the position of each node (shifting by <code class=\"language-text\">off</code>), and it updates the fringe accordingly.</p>\n<p>Updating node positions can be done in constant time if we just record the offset, and add it in later while drawing.</p>\n<p>This means that we no longer need to traverse the full subtree to move, but we still need to traverse the fringe (up to the depth of the subtree) to adjust the offset.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    let off = 0\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1.pos)\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid >= pos) {\n        pos = mid\n      } else {\n        off = pos-mid\n        // children move lazily, but still need\n        // to update fringe (up to depth of child tree)\n        for (let d1 = 0; d1 < cd; d1++)\n          fringe[d+1+d1] += off\n      }\n    }\n    fringe[d] = pos+1\n    v.pos = pos\n    v.off = off\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,off) {\n  for (let [k,v] of succ(g)) {\n    const pos = v.pos\n    placeForest(v, d+1, off+v.off, pos+off)\n    placeNode(k, d, pos+off)\n  }\n}\nlayoutForest(g,0)\nplaceForest(g,0,0)\ncreateCanvas()\ndrawForest(g)</code>\n<p>This is much better, but still not ideal in terms of performance.</p>\n<p><strong>Exercise:</strong> what is the worst case complexity? Prove it.</p>\n<p>What can we do to make it linear?</p>\n<p>The key idea is to make fringe entries relative to the parent. Then we only need to adjust the value at <code class=\"language-text\">d+1</code> and set it back at <code class=\"language-text\">d+cd+1</code> (where <code class=\"language-text\">cd</code> is the depth of the child tree)!</p>\n<p>This works best when tree positions are also relative to the parent. So we get rid of the relative <code class=\"language-text\">off</code> field and just use the normal <code class=\"language-text\">pos</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1)\n    if (cp.length > 0) {\n      const mid = (cp[0].pos + cp[cp.length-1].pos)/2\n      cp.forEach(v1 => v1.pos -= mid)\n      if (mid >= 0) {\n        pos += mid\n      } else {\n        // children are relative, fringe also relative\n        fringe[d+1] -= mid\n        fringe[d+1+cd] += mid\n      }\n    }\n    fringe[d+1] += fringe[d] - (pos+1)\n    fringe[d] = pos+1\n    v.pos = pos\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,p) {\n  for (let [k,v] of succ(g)) {\n    const pos = (p||0) + v.pos\n    placeForest(v, d+1, pos)\n    placeNode(k, d, pos)\n  }\n}\ng = { 1: {\n2: { 3: { 4: {5: {50:{501:{},502:{}}}}, 6: {7:{71:{},72:{},73:{}}, /*8:{80:{} },*/ 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>Now we’re done, and we have a nice and efficient method for drawing trees.</p>\n<p><strong>Exercise:</strong> why do we need the line <code class=\"language-text\">fringe[d+1+cd] += mid</code>? Find a test case.</p>\n<h3>Discussion</h3>\n<p>References:</p>\n<ul>\n<li>Reingold and Tilford <a href=\"https://reingold.co/tidier-drawings.pdf\">https://reingold.co/tidier-drawings.pdf</a></li>\n<li>Brüggemann-Klein and Wood <a href=\"http://cajun.cs.nott.ac.uk/compsci/epo/papers/volume2/issue2/epabk022.pdf\">http://cajun.cs.nott.ac.uk/compsci/epo/papers/volume2/issue2/epabk022.pdf</a></li>\n<li>TikZ manual <a href=\"https://pgf-tikz.github.io/pgf/pgfmanual.pdf\">https://pgf-tikz.github.io/pgf/pgfmanual.pdf</a></li>\n</ul>\n</aside>\n<p>Trees are an important subclass of graphs that deserves special attention. While simpler than the case of general graphs, drawing trees with automatic layout already requires careful planning where to place children and parents with respect to each other, to make efficient use of space available at each layer:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1)\n    if (cp.length > 0) {\n      const mid = (cp[0].pos + cp[cp.length-1].pos)/2\n      cp.forEach(v1 => v1.pos -= mid)\n      if (mid >= 0) {\n        pos += mid\n      } else {\n        // children are relative, fringe also relative\n        fringe[d+1] -= mid\n        fringe[d+1+cd] += mid\n      }\n    }\n    fringe[d+1] += fringe[d] - (pos+1)\n    fringe[d] = pos+1\n    v.pos = pos\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,p) {\n  for (let [k,v] of succ(g)) {\n    const pos = (p||0) + v.pos\n    placeForest(v, d+1, pos)\n    placeNode(k, d, pos)\n  }\n}\ng = { 1: {\n2: { 3: { 4: {5: {}}, 6: {7:{}, 8:{}, 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\ngridY = 30\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<aside id=\"graphs-frontend\">\n<h2>Frontend - Drawing Graphs</h2>\n<h3>Algorithm 1: Spanning Trees</h3>\n<p>Find a spanning tree of the graph, draw it as a tree, then draw the remaining edges.</p>\n<p><strong>Exercise:</strong> implement it!</p>\n<h3>Algorithm 2: Layered Graph Drawing</h3>\n<p>Steps:</p>\n<ul>\n<li>Compute node ranks</li>\n<li>Route edges by creating dummy nodes</li>\n<li>Shuffle to minimize crossings</li>\n<li>Draw</li>\n</ul>\n<p>In rough pseudo-code:</p>\n<pre>\ncomputeRank()\ncomputePositions()\ncreateCanvas()\ndrawGraph()\n</pre>\n<p>Let’s fill it with life. As a first cut we assign positions by distributing the vertical space within each rank:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// Compute succ/pred relations from edge list\nfunction computeGraph(edges) {\n  let nodes = new Set(edges.flat())\n  let pred = {}\n  let succ = {}\n  for (let [n1,n2] of edges) {\n    if (pred[n2]) pred[n2].push(n1)\n    else pred[n2] = [n1]\n    if (succ[n1]) succ[n1].push(n2)\n    else succ[n1] = [n2]\n  }\n  return {\n     start: Array.from(nodes),//.filter(n => !pred[n]),\n    succ: succ, pred: pred\n  }\n}\n// Compute the rank of each node\nfunction computeRank(start, succ) {\n  const rank = {}\n  const mark = {} // is node on current path\n  const path = []\n  function visit(node) {\n    if (mark[node]) return // cycle\n    if (path.length < rank[node]) return // want to compute the max rank ...\n    rank[node] = path.length\n    mark[node] = true\n    path.push(node)\n    for (let n of succ[node]||[])\n      visit(n)\n    path.pop()\n    mark[node] = undefined\n  }\n  for (let n of start)\n    visit(n)\n  return rank\n}\n// Compute a list of nodes ordered by rank\nfunction computeLayout(rank) {\n  // Now compute ranked list of nodes\n  const layout = []\n  for (let n in rank) {\n    let ns = layout[rank[n]] || (layout[rank[n]] = [] )\n    ns.push(n)\n  }\n  return layout\n}\n// Compute positions based on layout\nfunction computePositions(layout) {\n  const pos = {}\n  const countX = layout.length\n  let countY = 0\n  for (let x = 0; x < countX; x++) {\n    countY = Math.max(countY, layout[x].length)\n  }\n  for (let x = 0; x < countX; x++) {\n    const ns = layout[x]\n    const freeY = (countY - ns.length)/2\n    for (let y = 0; y < ns.length; y++) {\n      pos[ns[y]] = { x: x, y: y + freeY}\n    }\n  }\n  //return { pos1: pos, width: countX, height: countY }\n  return pos\n}\nfunction placeGraph(pos1) {\n  for (let n in pos1) {\n    placeNode(n, pos1[n].x, pos1[n].y)\n  }\n}\nfunction drawGraph(succ) {\n  for (let n in pos) {\n    drawNode(n)\n    for (let n2 of g.succ[n]||[])\n      drawEdge(n,n2)\n  }\n}\n</code>\n<p>Let’s try it on an example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,1]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\ngridX = 100\ngridY = 100 // more space\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>Pretty cool!</p>\n<p>But we don’t pay any special attention to edges yet. So edges may overlap, cross, etc. Especially back-edges are annoying:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"C\"],[\"D\",\"A\"]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\ngridX = 100\ngridY = 100 // more space\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>The first idea is to do something relatively simple. Let’s move those back edges out of the way.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet lastBackEdge = {}\nlet countBackEdge = {}\nfunction drawRaisedBackArrow(x1,y1,x2,y2) {\n  let dx = x2-x1\n  let dy = y2-y1\n  let h = -Math.min(0,dy) + 10\n  let u = y1-boxY/2-h\n  while (lastBackEdge[u] && x2 < lastBackEdge[u]) u -= 3\n  let v = (countBackEdge[x1]||0) * 3\n  let w = (countBackEdge[x2]||0) * 3\n  ctx.beginPath()\n  ctx.moveTo(x1+v, y1-boxY/2)\n  ctx.lineTo(x1+v, u)\n  ctx.lineTo(x2+w, u)\n  ctx.lineTo(x2+w, y2-boxY/2)\n  ctx.stroke()\n  drawArrowHead(x2+w,  y2-boxY/2, Math.PI/2)\n  lastBackEdge[u] = x1\n  countBackEdge[x1] = (countBackEdge[x1]||0) + 1\n  countBackEdge[x2] = (countBackEdge[x2]||0) + 1\n}\nfunction drawEdge(n1,n2) {\n  let [x1,y1] = pos[n1]\n  let [x2,y2] = pos[n2]\n  if (x1 < x2) {\n    drawArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n  } else {\n    drawRaisedBackArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n  }\n}\n//\nfunction plotGraph(edges) {\n  pos = []\n  lastBackEdge = {}\n  countBackEdge = {}\n  g = computeGraph(edges)\n  g.rank = computeRank(g.start, g.succ)\n  const layout = computeLayout(g.rank)\n  const pos1 = computePositions(layout)\n  gridX = 100\n  gridY = 100 // more space\n  placeGraph(pos1)\n  createCanvas()\n  drawGraph(g.succ)\n  print(\"\")\n}\nplotGraph([[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,1]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"B\"]])\nplotGraph([[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"A\"],[\"C\",\"A\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"B\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"B\"],[\"D\",\"A\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"C\"],[\"D\",\"A\"]])\n</code>\n<p>This produces already some pretty neat results.</p>\n<h3>Algorithm 3: Layered with Edge Routing</h3>\n<p>A more principled idea is to insert dummy nodes along edges that traverse a layer, and then position nodes to minimize edge crossings.</p>\n<h4>Edge Routing</h4>\n<p>Let’s look at dummy nodes first. We need to create them:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction computeDummyEdges(edges,rank) {\n  // currently modifying rank table in place,\n  // could also return a new one\n  let edges1 = []\n  for (let [n1,n2] of edges) {\n    let links = []\n    const d = rank[n2] - rank[n1]\n    if (Math.abs(d) > 1) {\n      let m1 = n1\n      for (let j = 1; j < d; j++) {\n        let m2 = n1+\"-#\"+j+\"-\"+n2\n        links.push([m1,m2])\n        rank[m2] = rank[m1] + 1\n        m1 = m2\n      }\n      links.push([m1, n2])\n    } else {\n      links.push([n1,n2])\n    }\n    edges1.push(...links)\n  }\n  return edges1\n}\n</code>\n<p>And be able to draw them:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawPath(n,n2) {\n  let [[x1,y1],[x2,y2]] = [pos[n],pos[n2]]\n  if (n2 == n) {\n    drawCycle(originX + x1, originY + y1)\n  } else {\n    let points = [originX + x1, originY + y1, originX + x2, originY + y2]\n    // follow path to the next regular node\n    while (n2.toString().indexOf(\"#\") >= 0) {\n      n2 = g.succ[n2][0] // we know we have only a single successor\n      points.push(originX + pos[n2][0], originY + pos[n2][1])\n    }\n    drawArrowN(points)\n  }\n}\nfunction drawGraph(succ) {\n  for (let n in pos) {\n    if (n.indexOf(\"#\") < 0) {\n      drawNode(n)\n      for (let n2 of succ[n]||[])\n        drawPath(n,n2)\n    }\n  }\n}\n</code>\n<p>Here’s an example:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,2]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>As we can see, we have some proper routed edges now, but the overall layout isn’t great.</p>\n<p>So let’s go ahead and minimize crossings.</p>\n<h4>Minimizing Edge Crossings</h4>\n<p>We’ll use a heuristic that proceeds layer by layer, and assigns each node the average (“barycentric”, alternative: median) position of its parents.</p>\n<p>The process works best when iterated, alternating forward and backward passes. There’s some theory that says it actually minimizes crossings.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// Assign each node the average pos of its parents\nfunction recomputeLayerPositions(g, layout, pos, l, dir) {\n  for (let n2 of layout[l]) {\n    let nsy = dir > 0 ? (g.pred[n2]||[]) : (g.succ[n2]||[])\n    nsy = nsy.filter(n => g.rank[n] == l-dir).map(n => pos[n].y)\n    // TODO: include succ[n2] where rank = l-1 (outgoing back-edges)?\n    if (nsy.length > 0)\n      pos[n2].y = (Math.min(...nsy) + Math.max(...nsy))/2\n    // NOTES:\n    // GraphViz: also greedily swap adjacent nodes if that removes a crossing\n    // Note: we're computing screen positions, this may lead to overlap!\n    // Example: two nodes have same parents --> assign same position\n    // Solution step 1: sort by position (layout[l] = sortBy(pos))\n    // Solution step 2: move apart verlet-style (possible in 2 passes, but need more for best result)\n    // Alternative idea: GraphViz, run ranking in other dimension (extended constraint graph)\n  }\n}\nfunction recomputeLayerLayout(g, layout, pos, l) {\n  layout[l].sort((n1,n2) => pos[n1].y - pos[n2].y)\n}\n// Move apart overlapping nodes within a layer\nlet edgeSep = 0.15\nlet nodeSep = 0.25\nlet removeOverlapIterCount = 5\nfunction recomputeLayerOverlap(g, layout, pos, l) {\n  let rn = nodeSep // relative to grid\n  let re = edgeSep\n  for (let k = 0; k < removeOverlapIterCount; k++) {\n    for (let j = 1; j < layout[l].length; j++) {\n      let n1 = layout[l][j-1]\n      let n2 = layout[l][j]\n      let d = pos[n2].y - pos[n1].y\n      let dd1 = ((n1.indexOf(\"#\") < 0) ? rn : re)\n      let dd2 = ((n2.indexOf(\"#\") < 0) ? rn : re)\n      let dd = dd1 + dd2\n      if (d < dd) {\n        pos[n1].y -= (dd-d)*0.5//(dd2/dd)\n        pos[n2].y += (dd-d)*0.5//(dd1/dd)\n      }\n    }\n    for (let j = layout[l].length-1; j > 0; j--) {\n      let n1 = layout[l][j-1]\n      let n2 = layout[l][j]\n      let d = pos[n2].y - pos[n1].y\n      let dd1 = ((n1.indexOf(\"#\") < 0) ? rn : re)\n      let dd2 = ((n2.indexOf(\"#\") < 0) ? rn : re)\n      let dd = dd1 + dd2\n      if (d < dd) {\n        pos[n1].y -= (dd-d)*0.5//(dd2/dd)\n        pos[n2].y += (dd-d)*0.5//(dd1/dd)\n      }\n    }\n  }\n}\n// Client should iterate fwd/bwd a few times\nfunction improvePositions(g, layout, pos) {\n  for (let l = 1; l < layout.length; l++) {\n    recomputeLayerPositions(g, layout, pos, l, 1)\n    recomputeLayerLayout(g, layout, pos, l)\n    recomputeLayerOverlap(g, layout, pos, l)\n  }\n}\nfunction improvePositionsReverse(g, layout, pos) {\n  for (let l = layout.length-2; l >= 0; l--) {\n    recomputeLayerPositions(g, layout, pos, l, -1)\n    recomputeLayerLayout(g, layout, pos, l)\n    recomputeLayerOverlap(g, layout, pos, l)\n  }\n}\n</code>\n<p>Let’s try it!</p>\n<h3>Examples</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,2]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\nimprovePositions(g,layout,pos1)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>About as good as it gets for this graph, right? And already in a single pass of improving positions.</p>\n<p>Let’s try another one. This one stresses the elimination of overlap within a layer.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 11], [1, 12], [1, 13], [1, 14], [2, 21], [2, 22], [2, 23], [2, 24]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\nimprovePositions(g,layout,pos1)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>Here’s a larger example from the TikZ manual:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [\n  [\"Thompson\",\"Mashey\"],\n  [\"Thompson\",\"Bourne\"],\n  [\"Thompson\",\"csh\"],\n  [\"csh\",\"tcsh\"],\n  [\"Bourne\",\"ksh\"],\n  [\"Bourne\",\"esh\"],\n  [\"Bourne\",\"vsh\"],\n  [\"Bourne\",\"System-V\"],\n  [\"Bourne\",\"v9sh\"],\n  [\"v9sh\",\"rc\"],\n  [\"Bourne\",\"Bash\"],\n  [\"ksh-i\",\"Bash\"],\n  [\"KornShell\",\"Bash\"],\n  [\"esh\",\"ksh\"],\n  [\"vsh\",\"ksh\"],\n  [\"Formshell\",\"ksh\"],\n  [\"csh\",\"ksh\"],\n  [\"KornShell\",\"POSIX\"],\n  [\"System-V\",\"POSIX\"],\n  [\"ksh\",\"ksh-i\"],\n  [\"ksh-i\",\"KornShell\"],\n  [\"KornShell\",\"ksh-POSIX\"],\n  [\"Bourne\",\"Formshell\"],\n  [1972,1976],\n  [1976,1978],\n  [1978,1980],\n  [1980,1982],\n  [1982,1984],\n  [1984,1986],\n  [1986,1988],\n  [1988,1990],\n  [1990,\"future\"],\n]\nlet rank = {\n  \"1972\": 0,\n  \"Thompson\": 0,\n  \"1976\": 1,\n  \"Mashey\": 1,\n  \"Bourne\": 1,\n  \"1978\": 2,\n  \"Formshell\": 2,\n  \"csh\": 2,\n  \"1980\": 3,\n  \"esh\": 3,\n  \"vsh\": 3,\n  \"1982\": 4,\n  \"ksh\": 4,\n  \"System-V\": 4,\n  \"1984\": 5,\n  \"v9sh\": 5,\n  \"tcsh\": 5,\n  \"1986\": 6,\n  \"ksh-i\": 6,\n  \"1988\": 7,\n  \"KornShell\": 7,\n  //\"Perl\": 7,\n  \"rc\": 7,\n  \"1990\": 8,\n  //\"tcl\": 8,\n  \"Bash\": 8,\n  \"future\": 9,\n  \"POSIX\": 9,\n  \"ksh-POSIX\": 9,\n}\ng = computeGraph(edges)\ng.rank = rank // manually ranked, according to years\n//g.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nlet pos1 = computePositions(layout)\nedgeSep = 0.15\nnodeSep = 0.25\nimprovePositions(g,layout,pos1)\nimprovePositionsReverse(g,layout,pos1)\nimprovePositions(g,layout,pos1)\n//improvePositionsReverse(g,layout,pos1)\n//pos1 = computePositions(layout) // try this as well!\n// draw\nedgeBend = 30\ngridY = 80\ngridX = 50\nboxX = 30\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p><strong>Exercise:</strong> try more examples, e.g., from Pohlmann’s thesis, TikZ manual, Tamassia’s handbook.</p>\n<h3>Algorithm 4: Layered with clusters</h3>\n<ul>\n<li>See, e.g., layout of compound directed graphs <a href=\"https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/25862\">https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/25862</a></li>\n</ul>\n<h3>Algorithm 5: Force-Based</h3>\n<ul>\n<li>See, e.g., Pohlmann’s thesis.</li>\n</ul>\n<h3>Discussion</h3>\n<p>References:</p>\n<ul>\n<li>Methods for visual understanding of hierarchical system structures. K. Sugiyama, S. Tagawa, and M. Toda, 1981 <a href=\"https://ieeexplore.ieee.org/abstract/document/4308636\">https://ieeexplore.ieee.org/abstract/document/4308636</a></li>\n<li>A Technique for Drawing Directed Graphs. Emden R. Gansner, Eleftherios Koutsofios, Stephen C. North, Kiem-Phong Vo, 1993 <a href=\"https://www.graphviz.org/Documentation/TSE93.pdf\">https://www.graphviz.org/Documentation/TSE93.pdf</a> (GraphViz)</li>\n<li>Configurable Graph Drawing Algorithms for the TikZ Graphics Description Language. Jannis Pohlmann, MS Thesis, 2011\n<a href=\"http://www.tcs.uni-luebeck.de/downloads/papers/2011/2011-configurable-graph-drawing-algorithms-jannis-pohlmann.pdf\">http://www.tcs.uni-luebeck.de/downloads/papers/2011/2011-configurable-graph-drawing-algorithms-jannis-pohlmann.pdf</a> (TikZ)</li>\n<li>Handbook of Graph Drawing and Visualization. Roberto Tamassia, Editor, 2013, <a href=\"http://cs.brown.edu/people/rtamassi/gdhandbook/\">http://cs.brown.edu/people/rtamassi/gdhandbook/</a> (Chapter 13: Hierarchical drawing algorithms by Healy &#x26; Nikolov <a href=\"http://cs.brown.edu/people/rtamassi/gdhandbook/chapters/hierarchical.pdf\">http://cs.brown.edu/people/rtamassi/gdhandbook/chapters/hierarchical.pdf</a>)</li>\n</ul>\n</aside>\n<p>GraphViz and similar tools are based on an approach known as the Sugiyama framework. This approach first partitions the graph into layers by assigning each node a rank, then routes edges by inserting dummy nodes whenever an edge traverses a layer, and finally minimizes edge crossings by shuffling nodes within each layer:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [\n  [\"Th\",\"Ma\"],\n  [\"Th\",\"Bo\"],\n  [\"Th\",\"cs\"],\n  [\"cs\",\"tc\"],\n  [\"Bo\",\"ks\"],\n  [\"Bo\",\"es\"],\n  [\"Bo\",\"vs\"],\n  [\"Bo\",\"Sy\"],\n  [\"Bo\",\"v9\"],\n  [\"v9\",\"rc\"],\n  [\"Bo\",\"Ba\"],\n  [\"ks\",\"Ba\"],\n  [\"Ko\",\"Ba\"],\n  [\"es\",\"ks\"],\n  [\"vs\",\"ks\"],\n  [\"Fo\",\"ks\"],\n  [\"cs\",\"ks\"],\n  [\"Ko\",\"PO\"],\n  [\"Sy\",\"PO\"],\n  [\"ks\",\"ki\"],\n  [\"ki\",\"Ko\"],\n  [\"Ko\",\"kP\"],\n  [\"Bo\",\"Fo\"],\n  [\"kP\",\"kP\"],\n]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nlet pos1 = computePositions(layout)\nedgeSep = 0.15\nnodeSep = 0.25\nimprovePositions(g,layout,pos1)\nimprovePositionsReverse(g,layout,pos1)\nimprovePositions(g,layout,pos1)\n//improvePositionsReverse(g,layout,pos1)\n//pos1 = computePositions(layout) // try this as well!\n// draw\nedgeBend = 20\ngridY = 80\ngridX = 60\nboxX = 20\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<aside>\n<h2>Discussion</h2>\n<p>The algorithms discussed here achieve visually pleasing results with a relatively simple and modular implementation, which can be tweaked in many different ways to achieve particular visualization styles.</p>\n<p>The tree layout algorithm is commonly attributed to Reingold and Tilford, the graph layout framework to Sugiyama. Many variations and extensions exist, including for clustered graphs that include a form of hierarchy, i.e., super nodes that visually contain other nodes.</p>\n<p>Force-based layout is an alternative to the rank-based graph layout approach discussed here, based on the simulation of physical attraction and repulsion forces between nodes. This approach is implemented in D3.js and various other tools.</p>\n</aside>\n<p>These algorithms achieve good results and provide many tuning knobs. An alternative graph layout model, used for example by D3.js, is based on simulating physical forces between nodes.</p>","fields":{"slug":"/Public/Generic/drawing-graphs/"},"frontmatter":{"date":"June 28, 2020","title":"Drawing Graphs like GraphViz","description":"Automatic graph and tree layout. The core of GraphViz, implemented from scratch in JavaScript.","keywords":"Graphs, Graph Drawing, GraphViz, Sugiyama Framework, JavaScript","tags":null}}},{"node":{"excerpt":"I wanted to implement a piano practice app for my little son. Here’s what I came up with. Virtual Piano Implementation Preliminaries: we’ll…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>I wanted to implement a piano practice app for my little son. Here’s what I came up with.</p>\n<aside>\n<h2>Virtual Piano Implementation</h2>\n<aside>\n<p>Preliminaries: we’ll need buttons.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nbutton(\"click\", () => print(\"click\"))\n</code>\n</aside>\n<p>Let’s see how we can get our web browser to play sound.</p>\n<aside>\n<h2>Playing a sound</h2>\n<p>Let’s get started. Here’s how to play sounds in a web browser, using the WebAudio API:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet fadeOut = 0.5\nfunction play(freq) {\n  // recycle AudioContext instances, Browser won't\n  // let us create a lot of them\n  if (!window.audio)\n      window.audio = new (window.AudioContext || window.webkitAudioContext)()\n  let osc = audio.createOscillator()\n  let gain = audio.createGain()\n  osc.type = \"sine\"\n  osc.frequency.value = freq\n  gain.gain.value = 0.3 // without this, weird interference\n  osc.connect(gain)\n  gain.connect(audio.destination)\n  let startPlay = audio.currentTime\n  osc.start(audio.currentTime)\n  function stop() {\n    let startFade = audio.currentTime\n    let stopFade = startFade + fadeOut\n    // avoid weird click sound when turning off\n    // in the middle of a sine wave (exp decay)\n    gain.gain.setValueAtTime(gain.gain.value, startFade);\n    gain.gain.linearRampToValueAtTime(0.0001, stopFade);\n    osc.stop(stopFade)\n    return startFade - startPlay\n  }\n  return stop\n}\n</code>\n<p>Try it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nawait buttonClick(\"play\")\nlet stop = play(440)\nawait buttonClick(\"stop\")\nstop()\n</code>\n<p>There are a couple issues worth pointing at and how they are solved:</p>\n<ul>\n<li>Auto-play prevention (solution: lazy init, start in response to user action)</li>\n<li>Browser limits (solution: share audio context)</li>\n<li>Weird click sound at end (solution: fade out)</li>\n<li>Weird interference when playing multiple sounds (solution: reduce gain)</li>\n</ul>\n<p>The bottom line is that sound is disturbance of air pressure. A tone is rhythmic disturbance (sine wave, or other waveform) with a certain frequency.</p>\n</aside>\n<p>Now we can do this:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nawait buttonClick(\"play\")\nlet stop = play(440)\nawait buttonClick(\"stop\")\nstop()\n</code>\n<p>But what are the sounds that make up music? We have to work out which frequencies notes like C, D, E, etc. correspond to.</p>\n<aside>\n<h2>Playing a note</h2>\n<p>Raw frequencies are kinda boring. So let’s play some actual notes. For that we need to understand a bit about music.</p>\n<p>We know that notes C, D, E, F, G, A, B form an octave. We can go an octave lower or higher and have the same notes.</p>\n<p>The frequency we played, 440 Hz, is the middle A note, A4.</p>\n<p>Human perception of sound is logarithmic. What we perceive as one step higher or lower is actually a multiplication in frequency. We perceive sounds as similar if we double or halve the frequency (low C vs high C). And we find certain ratios <em>harmonic</em> but others not.</p>\n<p>An octave corresponds to a doubling or halving in frequency. So in addition to the A4 note at 440 Hz, there are A sounds at 55 Hz, 110 Hz, 220 Hz, 440 Hz, 880 Hz, and so on.</p>\n<p>An octave is typically split into 12 <em>half tones</em>, called\nC, C#, D, D#, E, F, F#, G, G#, A, A#, B. Note that there is no E# and no B#, so E, F and B,C are just half tones apart, unlike for example C,D or F,G.</p>\n<p>(This division by 12 is called the chromatic scale. There are other ways to divide an octave, e.g., pentatonic music has 5 notes per octave, some Jazz has 8.)</p>\n<p>Given that we know where the A’s are, how can we calculate the frequencies for other notes? The next A from, say, 220 Hz is a multiplication by 2 away, so we want to do 1/12 of that step to reach the next half tone. This means that the factor we are looking for is the 12th root of 2, or 2 to the power of 1/12 (since (2^(1/12))^12 = 2).</p>\n<p>The steps are easy to compute programmatically:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"A\",\"A#\",\"B\",\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\n\"G\",\"G#\"]\nawait buttonClick(\"play\")\nfor (let i = 0; i < 13; i++) {\n  print(notes[i%notes.length], 220*Math.pow(2,i/12))\n  let stop = play(220*Math.pow(2,i/12))\n  await sleep(300)\n  stop()\n}\n</code>\n<p>So let’s collect those in a table (for two octaves) and define a helper function to play notes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet noteName = [\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\",\"C+\",\"C#+\",\"D+\",\"D#+\",\"E+\",\"F+\",\"F#+\",\"G+\",\"G#+\",\"A+\",\"A#+\",\"B+\"]\nlet noteIndx = {}\nlet noteFreq = {}\nfor (let i = 0; i < noteName.length; i++) {\n  let k = i + 3 // \"A\",\"A#\",\"B\",\"C\"\n  noteIndx[noteName[i]] = i\n  noteFreq[noteName[i]] = 220*Math.pow(2,k/12)\n}\nfunction playNote(k) {\n  return play(noteFreq[k])\n}\n</code>\n<p>Knowing how notes correspond to frequencies,\nwe can play a simple scale (this is the\nstandard “C Major” scale):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\nawait buttonClick(\"play\")\nfor (let i = 0; i < notes.length; i++) {\n  let stop = playNote(notes[i])\n  await sleep(300)\n  stop()\n}\n</code>\n</aside>\n<p>Knowing how notes correspond to frequencies, we can start playing interactively.</p>\n<aside>\n<h2>Drawing a piano keyboard</h2>\n<p>We can already support basic interactivity:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\nfor (let i = 0; i < notes.length; i++) {\n  button(notes[i], () => {\n    let stop = playNote(notes[i])\n    sleep(300).then(stop)\n  })\n}\n</code>\n<p>But we’d really like to have a better UI.</p>\n<p>So here we go for our first cut:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction piano(keys) {\n  let keyInputMap = [\"a\",\"s\",\"d\",\"f\",\"g\",\"h\",\"j\"] // kl;'\n  let width = 300\n  let height = 150\n  let cvs = document.createElement(\"canvas\")\n  cvs.width = width\n  cvs.height = height\n  o.appendChild(cvs)\n  // drawing\n  let ctx = cvs.getContext(\"2d\")\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n  let d = width/keys.length\n  function drawKey(k, pressed) {\n    ctx.save()\n    let bg = \"white\"\n    let fg = \"black\"\n    if (pressed) {\n      bg = \"black\"\n      fg = \"white\"\n    }\n    ctx.fillStyle = bg\n    ctx.fillRect(k*d, 0, d, height)\n    ctx.strokeStyle = fg\n    ctx.strokeRect(k*d, 0, d, height)\n    ctx.fillStyle = fg\n    if (keyInputMap[k])\n      ctx.fillText(keyInputMap[k],k*d+d/2, height-20)\n    ctx.fillText(keys[k],k*d+d/2, height-10)\n    ctx.restore()\n  }\n  for (let i = 0; i < keys.length; i++) {\n    drawKey(i,false)\n  }\n  // interactivity\n  let playing = []\n  let pressed = null\n  let touchDevice = false\n  function play(k) {\n      if (!playing[k]) {\n          drawKey(k,true)\n          playing[k] = playNote(keys[k])\n      }\n  }\n  function playStop(k) {\n      drawKey(k,false)\n      if (playing[k]) {\n          let stop = playing[k]\n          playing[k] = null\n          stop()\n      }\n  }\n  cvs.addEventListener(\"keydown\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          play(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"keyup\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          playStop(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"mouseenter\", (e) => {\n      // enable key input focus if not using touch\n      if (!touchDevice) {\n        cvs.setAttribute(\"contentEditable\", \"true\")\n        cvs.focus()\n      }\n  })\n  cvs.addEventListener(\"mousedown\", (e) => {\n      let x = e.offsetX\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n      }\n  })\n  cvs.addEventListener(\"mouseup\", (e) => {\n      playStop(pressed)\n  })\n  // could register this dynamically on mouse\n  // down with document and remove on mouse up\n  cvs.addEventListener(\"mousemove\", (e) => {\n      if (!e.buttons) return\n      let x = e.offsetX\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchstart\", (e) => {\n      touchDevice = true\n      let bounds = cvs.getBoundingClientRect()\n      let x = e.changedTouches[0].clientX-bounds.left\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n        e.preventDefault()\n        e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"touchmove\", (e) => {\n      let bounds = cvs.getBoundingClientRect()\n      let x = e.changedTouches[0].clientX-bounds.left\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchend\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchcancel\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n}\n</code>\n<p>Here’s how we use it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\npiano(notes)\n</code>\n<p>This is good and we could extend it to include half tones\nor multiple octaves by just adding more keys.</p>\n<p>However we prefer a layout that corresponds to a physical\npiano.</p>\n<p>Here is the more advanced version:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction piano2(callback) {\n  let keys = [\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\",\n  \"C+\",\"C#+\",\"D+\",\"D#+\",\"E+\",\"F+\",\"F#+\",\"G+\",\"G#+\",\"A+\",\"A#+\",\"B+\"]\n  let keyNames = keys\n  let keyInputMap = [\"a\",\"w\",\"s\",\"e\",\"d\",\"f\",\"t\",\n  \"g\",\"y\",\"h\",\"u\",\"j\",\"k\",\"o\",\"l\",\"p\",\";\",\"'\",\"0\",\"[\",\"-\",\"]\",\"=\",\"\\\\\"]\n  let width = 600\n  let height = 200\n  let upperHeight = height-40\n  let cvs = document.createElement(\"canvas\")\n  cvs.width = width\n  cvs.height = height\n  // enable key input focus\n  cvs.setAttribute(\"contentEditable\", \"true\")\n  o.appendChild(cvs)\n  // drawing\n  let ctx = cvs.getContext(\"2d\")\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n  let upperKeys = [1,3,null,6,8,10,null,13,15,null,18,20,22]\n  let lowerKeys = [0,2,4,5,7,9,11,12,14,16,17,19,21,23]\n  let d = width/lowerKeys.length\n  let upperD = d-10//d/2\n  let playing = []\n  let highlight = []\n  function drawKey1(k0, bgnd, upper) {\n    let k = upper ? upperKeys[k0] : lowerKeys[k0]\n    if (k == null) return\n    let xoffset = 0\n    let xgap = 0\n    let h = height\n    let pressed = playing[k]\n    if (upper) {\n      h = upperHeight\n      xgap = d - upperD\n      xoffset = d/2\n    }\n    let x = k0*d+xoffset\n    ctx.save()\n    let bg = upper ? \"black\" : \"white\"\n    let fg = upper ? \"white\" : \"black\"\n    if (pressed) {\n      bg = \"yellow\"\n      fg = \"black\"\n    }\n    if (bgnd) {\n      ctx.fillStyle = bg\n      ctx.fillRect(x+xgap/2, 0, d-xgap, h)\n    } else {\n      ctx.strokeStyle = \"black\"\n      ctx.strokeRect(x+xgap/2, 0, d-xgap, h)\n      ctx.fillStyle = fg\n      ctx.fillText(keyInputMap[k],x+d/2, h-20)\n      ctx.fillText(keys[k],x+d/2, h-10)\n    }\n    ctx.restore()\n  }\n  function drawHighlight(k,dur,start,i) {\n    let k0 = upperKeys.indexOf(k)\n    let upper = k0 >= 0\n    if (!upper) k0 = lowerKeys.indexOf(k)\n    let xoffset = 0\n    let xgap = 0\n    let h = upperKeys.indexOf(highlight[0])>=0 ? upperHeight : height\n    if (upper) {\n      xgap = d-upperD\n      xoffset = d/2\n    }\n    let x = k0*d+xoffset\n    const fill = [\"#FF0000\",\"#ff9999\",\"#ffe6e6\"]\n    ctx.save()\n    ctx.fillStyle = fill[Math.min(i,fill.length-1)]\n    let y = h-start*h\n    ctx.fillRect(x+xgap/2, y, d-xgap, -h*dur)\n    ctx.restore()\n  }\n  function redraw() {\n  // lower keys\n  for (let i = 0; i < lowerKeys.length; i++) {\n    drawKey1(i,true,false)\n  }\n  let start = 0\n  for (let i = 0; i < highlight?.length; i+=2) {\n    if (upperKeys.indexOf(highlight[i])<0)\n    drawHighlight(highlight[i],highlight[i+1],start,i/2)\n      start = start + highlight[i+1]\n  }\n  for (let i = 0; i < lowerKeys.length; i++) {\n    drawKey1(i,false,false)\n  }\n  for (let i = 0; i < upperKeys.length; i++) {\n    drawKey1(i,true,true)\n  }\n  // upper keys\n  start = 0\n  for (let i = 0; i < highlight?.length; i+=2) {\n    if (upperKeys.indexOf(highlight[i])>=0)\n    drawHighlight(highlight[i],highlight[i+1],start,i/2)\n      start = start + highlight[i+1]\n  }\n  for (let i = 0; i < upperKeys.length; i++) {\n    drawKey1(i,false,true)\n  }\n  }\n  function drawKey(i,pressed) {\n    redraw()\n  }\n  redraw()\n  // interactivity\n  let pressed = null\n  let touchDevice = false\n  function hit(x,y) {\n    if (y < upperHeight && x > d/2) { // try upper first\n      let u = upperKeys[Math.floor((x-d/2)/d)]\n      if (u) return u\n    }\n    return lowerKeys[Math.floor(x/d)]\n  }\n  function play(k) {\n      if (!playing[k]) {\n          playing[k] = playNote(keys[k])\n          drawKey(k,true)\n      }\n  }\n  function playStop(k) {\n      if (playing[k]) {\n          let stop = playing[k]\n          playing[k] = null\n          drawKey(k,false)\n          const d = stop()\n          if (callback) callback(keys[k],d)\n      }\n  }\n  cvs.addEventListener(\"keydown\", (e) => {\n      window.lastEvent = e\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          play(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"keyup\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          playStop(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"mouseenter\", (e) => {\n      // enable key input focus if not using touch\n      if (!touchDevice) {\n        cvs.setAttribute(\"contentEditable\", \"true\")\n        cvs.focus()\n      }\n  })\n  cvs.addEventListener(\"mousedown\", (e) => {\n      let k = hit(e.offsetX,e.offsetY)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n      }\n  })\n  cvs.addEventListener(\"mouseup\", (e) => {\n      playStop(pressed)\n  })\n  cvs.addEventListener(\"mousemove\", (e) => {\n      if (!e.buttons) return\n      let k = hit(e.offsetX,e.offsetY)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchstart\", (e) => {\n      touchDevice = true\n      let bounds = cvs.getBoundingClientRect()\n      let k = hit(e.changedTouches[0].clientX-bounds.left,e.changedTouches[0].clientY-bounds.top)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n        e.preventDefault()\n        e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"touchmove\", (e) => {\n      let bounds = cvs.getBoundingClientRect()\n      let k = hit(e.changedTouches[0].clientX-bounds.left,e.changedTouches[0].clientY-bounds.top)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchend\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchcancel\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  return { draw: (hl) => {\n    highlight = []\n    if (hl) for (let i = 0; i < hl.length; i+=2) {\n      let k = keys.indexOf(hl[i])\n      if (k >= 0) highlight.push(k, hl[i+1])\n    }\n    return redraw()\n  }}\n}\n</code>\n<p>Try it!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2()\n</code>\n<p>The code includes a facility to highlight some keys. This is extremely\nuseful when learning to play (hightlight the next ones to play).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2().draw([\"C\",1/4,\"F#\",1/2,\"F\",1/4])\n</code>\n</aside>\n<p>Try this on a phone or tablet!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2()\n</code>\n<p>Cool, we can make some music now. But how do we play a song? We have to hit the right note at the right time, for the right duration.</p>\n<aside>\n<h2>Note durations</h2>\n<p>Notes are typically played for a power-of-two ratio of the duration of a full note, i.e., as one-eighth, quarter, or half notes. The duration of a full note is anchored to the tempo.</p>\n<p>Putting things together we can define helper functions to play notes for a given duration, and to play songs, which are lists of notes with their respective duration:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet tempo = 2000\nasync function playNote(k,d) {\n  let stop = play(noteFreq[k], d * tempo)\n  await sleep(d*tempo)\n  stop()\n}\nasync function playSong(song) {\n  for (let i = 0; i < song.length; i+=2)\n    await playNote(song[i], song[i+1])\n}\n// Now play a scale\nawait buttonClick(\"play\")\nawait playSong([\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\"G\",1/4,\"A\",1/4,\"B\",1/4,\"C+\",1/4])\n</code>\n<p>The “song” we play ist just a simple scale. We use quarter notes and a base tempo of 2 seconds for a full note. This means 2 quarter notes per second, or 120 per minute. We often find tempo specified in this way as beats per minute (BPM).</p>\n<p>Sometimes we want to play multiple notes together (chords). It is straightforward to extend the definitions above to do that. Exercise!</p>\n</aside>\n<p>Let’s define a song (this is a popular german children’s rhyme about some little ducklings).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet song = [\n\"C\",1/8,\"D\",1/8,\"E\",1/8,\"F\",1/8,\n\"G\",1/4,\"G\",1/4,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"F\",1/8,\"F\",1/8,\"F\",1/8,\"F\",1/8,\n\"E\",1/4,\"E\",1/4,\n\"D\",1/8,\"D\",1/8,\"D\",1/8,\"D\",1/8,\n\"C\",1/2\n]\n</code>\n<p>The 1/8, 1/4, etc. are the duration of each note, as fraction of a full base note. This is how we play it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet tempo = 2000\nawait buttonClick(\"play\")\nfor (let i = 0; i < song.length; i+=2) {\n  let stop = playNote(song[i])\n  await sleep(song[i+1]*tempo)\n  stop()\n}\n</code>\n<p>If you want to play it on a piano, just run the code above in your head and implement <code class=\"language-text\">playNote</code> using your fingers. It’s easy once you got the song memorized. But until then, reading a sequence like <code class=\"language-text\">&quot;C&quot;,1/8,&quot;D&quot;,1/8,...</code> isn’t very natural for humans.</p>\n<p>No wonder that people came up with different notations. Let’s learn about sheet music notation.</p>\n<aside>\n<h2>Sheet music notation</h2>\n<p>A good reference is here: <a href=\"https://www.musicnotes.com/now/tips/how-to-read-sheet-music/\">How To Read Sheet Music: Step-by-Step Instructions</a></p>\n<p>The implementation is below. It might be useful to break it down into smaller increments, but for now this is what we have.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction sheet(song) {\n  let width = 600\n  let height = 100\n  let rows = 3\n  let keyIndex = {C:0, \"C#\":0, D:1, \"D#\":1, E:2, F:3, \"F#\":3, G:4, \"G#\":4, A:5, \"A#\":5, B:6,\n  \"C+\":7,\"C#+\":7,\"D+\":8,\"D#+\":8,\"E+\":9,\"F+\":10,\"F#+\":10,\"G+\":11,\"G#+\":11,\"A+\":12,\"A#+\":12,\"B+\":13}\n  let cvs2 = document.createElement(\"canvas\")\n  cvs2.width = width\n  cvs2.height = rows*height\n  o.appendChild(cvs2)\n  // drawing\n  let ctx2 = cvs2.getContext(\"2d\")\n  ctx2.strokeStyle = \"black\"\n  ctx2.lineWidth = 1\n  ctx2.textAlign = \"center\"\n  ctx2.textBaseline = \"middle\"\n  function hline(row,k) {\n    ctx2.beginPath()\n    ctx2.moveTo(0,row*100+20+k*10)\n    ctx2.lineTo(width-0,row*100+20+k*10)\n    ctx2.stroke()\n  }\n  function vline(row,k) {\n    let w = 30\n    ctx2.beginPath()\n    ctx2.moveTo(k*w,row*100+20)\n    ctx2.lineTo(k*w,row*100+60)\n    ctx2.stroke()\n  }\n  function drawSheet(rows, cols) {\n    for (let row = 0; row < rows; row++){\n      for (let j = 0; j < 5; j++) {\n        hline(row,j)\n      }\n      for (let j = 4; j <= 20; j+=4) {\n        vline(row,j)\n      }\n    }\n  }\n  function note(row,x,key,d,mark) {\n    let k = keyIndex[key]\n    let r = 5\n    let w = 15\n    let ox = w/2\n    let y = row*100+20+(5-k/2)*10\n    let o = 0\n    if (k < 0) return\n    //if (d == 4) o+=20 // if we'd want to center align notes\n    if (mark) {\n      ctx2.save()\n      ctx2.fillStyle = \"#00FFFF99\"\n      ctx2.beginPath()\n      //ctx2.arc(ox+x*w+o,y,r+r,0,2*Math.PI)\n      ctx2.rect(x*w+o,row*100+10,w,60)\n      ctx2.fill()\n      ctx2.restore()\n    }\n    ctx2.beginPath()\n    ctx2.arc(ox+x*w+o,y,r,0,2*Math.PI)\n    if (d >= 4) ctx2.fill()\n    else ctx2.stroke()\n    if (d >= 2) {\n      ctx2.beginPath()\n      ctx2.moveTo(ox+x*w+r-1+o,y)\n      ctx2.lineTo(ox+x*w+r+o,y-35)\n      ctx2.stroke()\n    }\n    if (d >= 8) { // draw 2 for 1/16, 3 for 1/32 etc\n      ctx2.beginPath()\n      ctx2.moveTo(ox+x*w+r+o,y-35)\n      ctx2.lineTo(ox+x*w+10+o,y-20)\n      ctx2.stroke()\n    }\n    //ctx2.fillText(keyInputMap[k],10+x*w+o,row*100+75)\n    ctx2.fillText(key,10+x*w+o,row*100+75)\n    ctx2.fillText(Math.ceil(d),10+x*w+o,row*100+90)\n  }\n  function drawSong(song,mark) {\n    let x = 0\n    let r = 0\n    for (let j = 0; j < song.length; j+=2) {\n      note(r,x,song[j],1/song[j+1],j==mark)\n      x+=8*song[j+1]\n      if (x >= 40) {\n        r += 1\n        x -= 40\n      }\n    }\n  }\n  drawSheet(rows)\n  drawSong(song,-1)\n  return { draw: function(song,mark) {\n    ctx2.clearRect(0,0,cvs2.width,cvs2.height)\n    drawSheet(rows)\n    drawSong(song,mark)\n  }}\n}\n</code>\n<p>Let’s use it to visualize (and play) a simple scale. We use quarter notes and a base of 2 seconds for a full note, which means 2 quarter notes per second, or 120 beats per minute (BPM).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nsong = [\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\"G\",1/4,\"A\",1/4,\"B\",1/4,\"C+\",1/4]\nlet sh = sheet(song)\nlet tempo = 2000\nawait buttonClick(\"play\")\nfor (let i = 0; i < song.length; i+=2) {\n  sh.draw(song, i)\n  let stop = playNote(song[i])\n  await sleep(song[i+1]*tempo)\n  stop()\n}\nsh.draw(song)\n</code>\n</aside>\n<p>We also define some more songs.</p>\n<aside>\n<h2>More Songs</h2>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction convertSong(song) {\nlet out = []\nfor (let j = 0; j < song.length; j+=2) {\nout[j] = keyNames[song[j]]\nout[j+1] = 1/song[j+1]\n}\nreturn out\n}\n// Oh Suzanna\nlet osz0 = [\n1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,1,4,\n2,2,/**/1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,2,4,\n1,2,/**/]\nlet osz1 = [\n4,2,4,2,\n6,4,6,2,6,4,\n5,4,5,4,3,4,1,4,\n2,2,/**/1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,2,4,\n1,2,\n]\nlet alleMeineEntchen = [\n\"C\",1/8,\"D\",1/8,\"E\",1/8,\"F\",1/8,\n\"G\",1/4,\"G\",1/4,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"F\",1/8,\"F\",1/8,\"F\",1/8,\"F\",1/8,\n\"E\",1/4,\"E\",1/4,\n\"D\",1/8,\"D\",1/8,\"D\",1/8,\"D\",1/8,\n\"C\",1/2\n]\nlet ohSuzannaChorus = [\n\"G\",0.5,\"G\",0.5,\n\"B\",0.25,\"B\",0.5,\"B\",0.25,\n\"A\",0.25,\"A\",0.25,\"F#\",0.25,\"D\",0.25,\n\"E\",0.5+0.25,\"D\",0.125,\"E\",0.125,\n\"F#\",0.25,\"A\",0.25,\"A\",0.25+0.125,\"B\",0.125,\n\"A\",0.25,\"F#\",0.25,\"D\",0.25+0.125,\"E\",0.125,\n\"F#\",0.25,\"F#\",0.25,\"E\",0.25,\"E\",0.25,\n\"D\",0.5\n]\nlet fuchsDuHastDieGansGestohlen = [\n\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\n\"G\",1/4,\"G\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"F\",1/4,\"C+\",1/4,\"A\",1/4,\n\"G\",1,\n\"A\",1/4,\"F\",1/4,\"C+\",1/4,\"A\",1/4,\n\"G\",1,\n\"G\",1/4,\"F\",1/4,\"F\",1/4,\"F\",1/4,\n\"F\",1/4,\"E\",1/4,\"E\",1/4,\"E\",1/4,\n\"E\",1/4,\"D\",1/4,\"E\",1/4,\"D\",1/4,\n\"C\",1/4,\"E\",1/4,\"G\",1/2,\n\"G\",1/4,\"F\",1/4,\"F\",1/4,\"F\",1/4,\n\"F\",1/4,\"E\",1/4,\"E\",1/4,\"E\",1/4,\n\"E\",1/4,\"D\",1/4,\"E\",1/4,\"D\",1/4,\n\"C\",1\n]\nlet katyusha = [\n\"A\",1/4+1/8,\"B\",1/8,\n\"C+\",1/4+1/8,\"A\",1/8,\n\"C+\",1/8,\"C+\",1/8,\"B\",1/8,\"A\",1/8,\n\"B\",1/4,\"E\",1/4,\n\"B\",1/4+1/8,\"C+\",1/8,\n\"D+\",1/4+1/8,\"B\",1/8,\n\"D+\",1/8,\"D+\",1/8,\"C+\",1/8,\"B\",1/8,\n\"A\",1/2,\n//\n\"E+\",1/4,\"A+\",1/4,\n\"G+\",1/4,\"A+\",1/8,\"G+\",1/8,\n\"F+\",1/8,\"F+\",1/8,\"E+\",1/8,\"D+\",1/8,\n\"E+\",1/4,\"A\",1/4,\n\"F+\",1/4+1/8,\"D+\",1/8,\n\"E+\",1/4+1/8,\"C+\",1/8,\n\"B\",1/8,\"E\",1/8,\"C+\",1/8,\"B\",1/8,\n\"A\",1/2,\n]\nlet wheelsOnTheBus = [\n\"D\",1/4,\n\"G\",1/4,\"G\",1/8,\"G\",1/8,\"G\",1/4,\"B\",1/4,\n\"D+\",1/4,\"B\",1/4,\"G\",1/2,\n\"A\",1/4,\"F#\",1/4,\"D\",1/2,\n\"D+\",1/4,\"B\",1/4,\"G\",1/4,\"D\",1/4,\n\"G\",1/4,\"G\",1/8,\"G\",1/8,\"G\",1/4,\"B\",1/4,\n\"D+\",1/4,\"B\",1/4,\"G\",1/2,\n\"A\",1/2,\"D\",1/4,\"D\",1/4,\"G\",1/2\n]\nlet ruleBritannia = [\n\"B\",1/4+1/8,\"B\",1/8,\"C+\",1/8,\"C+\",1/8+1/8,\"B\",1/8,\n\"C+\",1/8+1/16,\"B\",1/16,\"A\",1/8,\"G\",1/8,\"F\",1/4+1/8,\"A\",1/8,\n\"D+\",1/4,\"C+\",1/4,\"B\",1/16,\"G\",1/16,\"C+\",1/16,\"A\",1/16,\"D+\",1/8,\"C+\",1/8,\n\"B\",1/4,\"A\",1/4,\"G\",1/2\n]\nlet twinkleTwinkleLittleStar = [\n\"C\",1/4,\"C\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"A\",1/4,\"G\",1/2,\n\"F\",1/4,\"F\",1/4,\"E\",1/4,\"E\",1/4,\n\"D\",1/4,\"D\",1/4,\"C\",1/2,\n\"G\",1/4,\"G\",1/4,\"F\",1/4,\"F\",1/4,\n\"E\",1/4,\"E\",1/4,\"D\",1/2,\n\"G\",1/4,\"G\",1/4,\"F\",1/4,\"F\",1/4,\n\"E\",1/4,\"E\",1/4,\"D\",1/2,\n\"C\",1/4,\"C\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"A\",1/4,\"G\",1/2,\n\"F\",1/4,\"F\",1/4,\"E\",1/4,\"E\",1/4,\n\"D\",1/4,\"D\",1/4,\"C\",1/2,\n]\n/*\nlet enterSandman = [\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n//\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"E\",1/4,\"C\",1/8,\"D\",1/8,\"C\",1/8,\"D\",1/8,\"E\",1/8,\"D\",1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"E\",1/4,\"C\",1/8,\"D\",1/8,\"C\",1/8,\"D\",1/8,\"E\",1/8,\"D\",1/8,\n\"C\",1/4,\n\"G+\",1/8,\"G+\",1/8,\"G+\",1/4,\"D+\",1/8,\"E+\",1/8,\"E+\",1/4,\n\"G+\",1/8,\"G+\",1/8,\"G+\",1/8,\"A+\",1/4,\"G+\",1/8,\"E+\",1/4,\n\"E+\",1/8,\"E+\",1/8,\"E+\",1/8,\"B\",1/8,\"D+\",1/8,\"E+\",1/8,\n\"D+\",1/8,\"E+\",1/8+1/2\n]*/\nlet enterSandman = [\n\"E\",1/4,\"E+\",1/8,\"G+\",1/8,\"A#\",1/8,\"A\",1/4,\"E+\",1/8,\n\"E\",1/4,\"E+\",1/8,\"G+\",1/8,\"A#\",1/8,\"A\",1/4,\"E+\",1/8,\n\"C\",1/4,\"C+\",1/8,\"D#+\",1/8,\"C+\",1/8,\"D#+\",1/8,\"E+\",1/8,\"D#+\",1/8,\"C+\",1/4,\n//EGEF#EF#GF#E\n]\nlet maennerMitBaerten = [\n\"E\",1/8,\"F#\",1/8,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/8,\"G\",1/8,\"F#\",1/8, \"E\",1/4,\"C\",1/8, /* really B- */\n\"E\",1/4,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/4,\"F#\",1/8, \"E\",1/4+1/8, // bärten sein\n\"G\",1/4,\"A\",1/8,\"B\",1/4,\"A\",1/8,\n\"G\",1/4,\"A\",1/8,\"B\",1/4+1/8, // pitt\n\"E\",1/8,\"F#\",1/8,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/4,\"F#\",1/8,\"E\",1/4+1/8\n]\nlet drEisenbart = [\n\"D\",1/8,\n\"G\",1/8, \"D\",1/8, \"D\",1/8, \"D\",1/8,\n\"E\",1/8, \"D\",1/8, \"D\",1/4,\n\"D\",1/16, \"E\",1/16, \"F#\",1/16, \"G\",1/16, \"A\",1/8, \"F#\",1/8,\n\"G\",1/4+1/8, \"D\",1/8,\n\"G\",1/8, \"D\",1/8, \"D\",1/8, \"D\",1/8,\n\"E\",1/8, \"D\",1/8, \"D\",1/4,\n\"D\",1/16, \"E\",1/16, \"F#\",1/16, \"G\",1/16, \"A\",1/8, \"F#\",1/8,\n\"G\",1/4+1/8, \"B\",1/8,\n\"A\",1/8, \"B\",1/8, \"A\",1/8, \"B\",1/8,\n\"A\",1/8, \"B\",1/8, \"A\",1/4,\n\"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/8, \"G\",1/8,\n\"F#\",1/8, \"E\",1/8, \"D\",1/4,\n\"D\",1/8+1/16, \"G\",1/16, \"G\",1/8, \"G\",1/8,\n\"G\",1/8, \"B\",1/8, \"B\",1/4,\n\"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/16, \"B\",1/8, \"A\",1/8,\n\"G\",1/4,\n]\nlet jingleBells = [\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"G\",1/4, \"C\",1/4, \"D\",1/4,\n\"E\",1,\n\"F\",1/4, \"F\",1/4, \"F\",1/4, \"F\",1/4,\n\"F\",1/4, \"E\",1/4, \"E\",1/4, \"E\",1/4,\n\"E\",1/4, \"D\",1/4, \"D\",1/4, \"E\",1/4,\n\"D\",1/2, \"G\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"G\",1/4, \"C\",1/4, \"D\",1/4,\n\"E\",1,\n\"F\",1/4, \"F\",1/4, \"F\",1/4, \"F\",1/4,\n\"F\",1/4, \"E\",1/4, \"E\",1/4, \"E\",1/4,\n\"G\",1/4, \"G\",1/4, \"F\",1/4, \"D\",1/4,\n\"C\",1\n]\nfunction pickSong(callback) {\n  print(\"Pick a song:\")\n  button(\"Oh Suzanna\", () => callback(ohSuzannaChorus))\n  button(\"Twinkle Twinkle Little Star\", () => callback(twinkleTwinkleLittleStar))\n  button(\"The Wheels On The Bus\", () => callback(wheelsOnTheBus))\n  button(\"Katyusha\", () => callback(katyusha))\n  button(\"Enter Sandman\", () => callback(enterSandman))\n  button(\"Rule Britannia\", () => callback(ruleBritannia))\n  button(\"Alle Meine Entchen\", () => callback(alleMeineEntchen))\n  button(\"Fuchs Du Hast die Gans Gestohlen\", () => callback(fuchsDuHastDieGansGestohlen))\n  button(\"Männer mit Bärten\", () => callback(maennerMitBaerten))\n  button(\"Dr. Eisenbart\", () => callback(drEisenbart))\n  button(\"Jingle Bells\", () => callback(jingleBells))\n  print(\"\")\n}\n</code>\n</aside>\n<p>And now it’s time to play them while following along on the sheet:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nasync function playSong(song) {\n  clear()\n  pickSong(playSong)\n  let sh = sheet(song)\n  let tempo = 1500\n  await buttonClick(\"play\")\n  for (let i = 0; i < song.length; i+=2) {\n    sh.draw(song, i)\n    let stop = playNote(song[i])\n    await sleep(song[i+1]*tempo)\n    stop()\n  }\n  sh.draw(song)\n  playSong(song)\n}\nplaySong(ohSuzannaChorus)\n</code>\n<h2>Piano Drills</h2>\n<p>The nice thing is that everything is programmable, so we can do something more advanced. Let’s put everything together and do some piano drills. We use a piano keyboard that advances the marker only when hitting the right note, and we draw the notes hit by the user below:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet showRecorded = false\nasync function drill(song) {\n  clear()\n  pickSong(drill)\n  let rec = []\n  let handler = (k,d) => {}\n  let sh1 = sheet(song)\n  let pi = piano2((k,d) => handler(k,d))\n  let sh2 = showRecorded ? sheet(rec) : null\n  let tempo = 1500\n  function notePlayed(k0,d0) {\n    return new Promise(resolve => handler = (k,d) => {\n      if (showRecorded) {\n        rec.push(k,d/1000*tempo); sh2.draw(rec)\n      }\n      if (k == k0) resolve() })\n  }\n  for (;;) {\n    for (let i = 0; i < song.length; i+=2) {\n      sh1.draw(song, i)\n      pi.draw([song[i],song[i+1],song[i+2],song[i+3],song[i+4],song[i+5]])\n      await notePlayed(song[i],song[i+1])\n    }\n    sh1.draw(song)\n    pi.draw()\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nshowRecorded = true\ndrill(ohSuzannaChorus)\n</code>\n<div class=\"cursive\">Have fun!</div>\n<h2>Hearing Practice</h2>\n<p>What else can we do? Let’s do some hearing practice. We play a random note, and have to hit the correct key on the piano keyboard.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nasync function ear() {\n  clear()\n  let handler = (k,d) => {}\n  let pi = piano2((k,d) => handler(k,d))\n  function notePlayed(k0) {\n    //print(\"want: \"+k0)\n    return new Promise(resolve => handler = (k,d) => {\n      if (k == k0) {\n        print(\"yay!\"); resolve()\n      }}) //else print(\"nope\")})\n  }\n  let rand = Math.floor(Math.random() * noteName.length);\n  let note = noteName[rand]\n  let stop = playNote(note)\n  let fut1 = sleep(2000)\n  let fut2 = notePlayed(note)\n  await fut1\n  stop()\n  await fut2\n  await sleep(1000)\n  await ear()\n}\nawait buttonClick(\"Go!\")\nawait ear()\n</code>\n</aside>\n<code class=\"runScript\" filter=\"coolEditor\">\ndrill(ohSuzannaChorus)\n</code>","fields":{"slug":"/Public/Generic/virtual-piano/"},"frontmatter":{"date":"June 20, 2020","title":"Virtual Piano Practice","description":"Building an interactive piano app. Drawing the keyboard, playing notes using Web Audio, and drawing sheet music notation.","keywords":null,"tags":null}}},{"node":{"excerpt":"Automatic Differentiation (AD) is a programming technique that supports transparent and efficient computation of gradients for numeric code…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Automatic Differentiation (AD) is a programming technique that supports transparent and efficient computation of gradients for numeric code in general-purpose programming languages.</p>\n<!-- We present a simple but powerful implementation of AD in JavaScript, with interactive examples. -->\n<aside>\n<h2>Context and Motivation</h2>\n<p>Deep learning crucially depends on the computation of gradients, and specifically on optimizing parameters of neural networks to fit a set of training samples using a process called gradient descent.</p>\n<p>Differentiable programming is a vision of generalizing deep learning from layer-oriented neural network architectures to training essentially arbitrary parameterized computations by gradient descent. AD is key enabler for such visions.</p>\n<p>Many explanations of AD are needlessly complex, and the topic often seems quite mysterious. The goal of this note is to provide a simple and interactive “from scratch” implementation of both forward- and reverse-mode AD that can be easily understood <em>in toto</em>. As we will show, even reverse-mode AD (“backpropagation”) can be almost ridiculously simple with the right techniques.</p>\n<p>For academically inclined readers, we refer to some of our recent publications that explain AD from a program transformation perspective:</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1803.10228\">Demystifying Differentiable Programming: Shift/Reset the Penultimate Backpropagator (Wang et al., ICFP ‘19)</a></li>\n<li><a href=\"https://papers.nips.cc/paper/8221-backpropagation-with-callbacks-foundations-for-efficient-and-expressive-differentiable-programming\">Backpropagation with Continuation Callbacks: Foundations for Efficient and Expressive Differentiable Programming (Wang et al., NeurIPS ‘19)</a></li>\n</ul>\n<p>Some utility code follows.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// some visualization utils\nlet cvs = null\nlet ctx = null\nlet plotScale = 1\nfunction newPlot(w,h) {\n    cvs = document.createElement(\"canvas\")\n    cvs.width = w\n    cvs.height = h\n    o.appendChild(cvs)\n    ctx = cvs.getContext(\"2d\")\n}\nfunction drawPoint(x,y) {\n    ctx.beginPath()\n    ctx.arc(x*plotScale,cvs.height-y*plotScale,4,0,2*Math.PI,true)\n    ctx.fill()\n}\nfunction drawPoints(data) {\n    for (let i = 0; i < data.length; i++)\n        drawPoint(data[2*i], data[2*i+1])\n}\nfunction drawFunction(f) {\n    ctx.beginPath()\n    ctx.moveTo(0,cvs.height-f(num(0)).val*plotScale)\n    for (let x = 1; x < cvs.width; x++)\n        ctx.lineTo(x,cvs.height-f((x)/plotScale)*plotScale)\n    ctx.stroke()\n}\nfunction drawLine(data) {\n    if (data.length == 0) return\n    let max = Math.max(...data)\n    let scaleY = 200/max\n    let scaleX = 200/data.length\n    ctx.beginPath()\n    ctx.moveTo(0, 200-data[0]*scaleY)\n    for (let i = 1; i < data.length; i++) {\n        ctx.lineTo(i*scaleX, 200-data[i]*scaleY)\n    }\n    ctx.stroke()\n}\nfunction randomInt(max) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n</code>\n</aside>\n<p>AD is a key enabler for deep learning and for visions of differentiable programming that generalize deep learning from layer-oriented neural networks to arbitrary computations.</p>\n<aside id=\"forward-mode-ad\">\n<h2>Forward-Mode AD</h2>\n<p>Let’s recall the standard rules for computing derivatives from high school:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(a+b)&#39; = a&#39; + b&#39;\n(a-b)&#39; = a&#39; - b&#39;\n(a*b)&#39; = a&#39;*b + b&#39;*a\n...</code></pre></div>\n<p>Observe that the order of steps to compute a derivative follows exactly the order of steps to compute the normal result. The multiplication rule is perhaps non-obvious, but if <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">a&#39;</code>, and <code class=\"language-text\">b&#39;</code> are already computed, then we can compute <code class=\"language-text\">a*b</code> and <code class=\"language-text\">(a*b)&#39;</code> at the same time.</p>\n<p>The basic idea behind forward-mode AD is to transform a program to do exactly that: compute derivatives in lockstep with every elementary arithmetic operation.</p>\n<h3>Implementation</h3>\n<p>We can implement forward-mode AD in any programming language by introducing a data type of <em>dual numbers</em>, with all arithmetic operations overriden to compute derivatives in addition to the standard (“primal”) return values.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// dual number api\nfunction num(x, d=0) {\n    return { val: x, grad: d }\n}\nfunction plus(x,y) {\n    return num(x.val + y.val, x.grad - y.grad)\n}\nfunction minus(x,y) {\n    return num(x.val - y.val, x.grad - y.grad)\n}\nfunction times(x,y) {\n    return num(x.val * y.val, x.val * y.grad + y.val * x.grad)\n}\n</code>\n<p>Real operator overloading as in Python, Scala, etc. would make client code more readable, but is unfortunately not available in plain JS (though possible via preprocessing with Babel or Sweet.js).</p>\n<p>The rules to compute the derivative components are exactly the differentiation rules from highschool-level calculus.</p>\n<p>Given a function on dual numbers, we can define accessors to obtain only the standard (“primal”) or the derivative component.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction primal(f) {\n    return (x => f(num(x,1)).val)\n}\nfunction deriv(f) {\n    return (x => f(num(x,1)).grad)\n}\n</code>\n<h3>Examples (Analytically)</h3>\n<p>Let’s verify that it works. Feel free to try some examples of your own:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// helper functions\nfunction expectFunc(f1,f2) {\n    for (let x = -10; x < 10; x++)\n        expect(f1(x), f2(x))\n}\nfunction testDeriv(label, f, d) {\n  test(label, () => expectFunc(deriv(f), d))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// test cases\ntestDeriv(\n  \"deriv(x^2) = 2x\",\n  x => times(x, x),\n  x => 2*x)\ntestDeriv(\n  \"deriv(2x^3) = 6x^2\",\n  x => times(num(2),times(x,times(x, x))),\n  x => 6*x*x)\n</code>\n<h3>Examples (Graphically)</h3>\n<p>We can also convince ourselves that we got it right by plotting a function along with its tangents at various points (try changing f or 0.8):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// draw tangent of f at x\nfunction drawTangent(f,x) {\n    let y = primal(f)(x)\n    let dy = deriv(f)(x)\n    let z = y-dy*x\n    drawPoint(x,y)\n    drawFunction(x1 => dy*x1+z)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example function (2(x-0.5))^2\nfunction sqr(x) {\n    return times(x,x)\n}\nfunction f(x) {\n    return sqr(times(num(2),minus(x,num(0.5))))\n}\n// draw it!\nnewPlot(200,200)\nplotScale = 200\ndrawFunction(primal(f))\ndrawTangent(f, 0.8) /* point for tangent -- play with it! */\n</code>\n<h3>Discussion</h3>\n<p>The beauty of AD is that we aren’t restricted to functions containing primitive arithmetic only. We can freely mix dual numbers with any other computation, including control flow, loops, recursion, objects, classes, etc.</p>\n<p>Of course we do not, in general, have any guarantee that a program with complex logic is differentiable in the mathematical sense across its entire input range. Basically, any <code class=\"language-text\">if</code> is a potential discontinuity. Thus, it is important to remember that the result of AD is only valid locally at the point it was computed, but it may not be valid in a neighborhood of that point. But since computer programs operate on discrete approximations rather than actual real numbers, talking about mathematical notions like continuity, smoothness, or differentiability in this context is murky anyways.</p>\n<p><strong>Exercise:</strong> how can we extend the scheme to compute partial derivatives for functions with multiple input arguments?</p>\n<p><strong>Exercise:</strong> what about higher (2nd, 3rd, …) order derivatives?</p>\n<p><strong>Exercise:</strong> what about nested invocations of <code class=\"language-text\">grad</code> (of which higher-order derivatives are a special case)? Hint: read up on “perturbation confusion”.</p>\n</aside>\n<p>Forward-mode AD computes derivatives for each intermediate result in lockstep with the normal program execution. It is straightforward but inefficient when computing gradients (i.e., many partial derivates), which is necessary for neural networks with many parameters.</p>\n<aside id=\"reverse-mode-ad\">\n<h2>Reverse-Mode AD (Backpropagation)</h2>\n<p><a href=\"/forward-mode-ad\">Forward-mode AD</a> can be extended to compute multiple partial derivatives (and therefore gradients) simultaneously by adding a field for each partial derivative to the dual number type. However, this is inefficient if the number of parameters gets large, as is the case for neural networks and many other practical applications.</p>\n<p>Reverse-mode AD solves the scalability issue of forward-mode AD through clever use of the chain rule of differentiation.</p>\n<h3>Intuition</h3>\n<p>Instead of computing derivates in lockstep with the normal computation as in forward-mode AD, we first execute the program normally to compute the primal result, and then we propagate gradient updates backwards for each intermediate result (this requires some bookkeeping).</p>\n<p>Mathematically speaking, we do not compute how each intermediate result changes in response to a change in the program input (as in forward-mode), but rather how the program output changes in response to a change in the intermediate value. At the end of the backward pass the result is the same: we obtain the change of the program output in response to a change in the program input.</p>\n<p>Consider as an example a program whose final output is <code class=\"language-text\">y</code> and whose intermediate computations include:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x3 = x1 + x2\n...\nx4 = x1 * x2\n...</code></pre></div>\n<p>Since we’re going backwards, we will have computed <code class=\"language-text\">dy/dx3</code> and <code class=\"language-text\">dy/dx4</code> at some point. These are the change of the program output relative to a change in <code class=\"language-text\">x3</code> and <code class=\"language-text\">x4</code>, respectively. Once these results are available, we can compute <code class=\"language-text\">dy/dx1</code> (and likewise <code class=\"language-text\">dy/dx2</code>) through the chain rule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dy/dx1 = dy/dx4 * dx4/dx1 + dy/dx3 * dx3/dx1</code></pre></div>\n<p>Not that the computation of <code class=\"language-text\">dy/dx1</code> has to sum over all occurrences of <code class=\"language-text\">x1</code>, in this case <code class=\"language-text\">x3</code> and <code class=\"language-text\">x4</code>. Intuitively, each occurrence of <code class=\"language-text\">x1</code> contributes through different pahts to the final result <code class=\"language-text\">z</code>, so to express how <code class=\"language-text\">z</code> changes overall in response to a delta in <code class=\"language-text\">x1</code>, we have to consider all these paths, as each contributes an additive delta to <code class=\"language-text\">z</code>.</p>\n<p>Operationally, it is useful to express this summation as a series of updates to a read-only accumulator. For each intermediate result we keep an accumulator and when we reach <code class=\"language-text\">x3</code> in the backwards pass, we add the delta <code class=\"language-text\">dy/dx3 * dx3/dx1</code> to the accumulator for <code class=\"language-text\">dy/dx1</code> (and analogous for <code class=\"language-text\">x2</code>). Note that <code class=\"language-text\">dx3/dx1</code> can be computed solely from the right-hand side of <code class=\"language-text\">x3 = ...</code>, but may require the primal value of <code class=\"language-text\">x1</code> computed in the forward pass. By the time we reach <code class=\"language-text\">x1</code> in the backward pass, we know we have accumulated all updates to <code class=\"language-text\">dy/dx1</code> and we can proceed propagation gradient updates for the inputs of the computation of <code class=\"language-text\">x1</code>.</p>\n<h3>Implementation</h3>\n<p>The forwards-then-backwards execution can be achieved in different ways. For programming language buffs, there is an especially appealing relation with continuation passing style (CPS). Here, we use a slightly modified dual number type and a stack data structure (often called the <em>tape</em>) that accumulates closures for the backward pass in the right order.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// stack to remember backward operations\nlet tape = []\n// dual number api\nfunction num(x) {\n    return { val: x, grad: 0 }\n}\nfunction plus(x,y) {\n    let z = num(x.val + y.val)\n    tape.push(() => { x.grad += z.grad; y.grad += z.grad })\n    return z\n}\nfunction minus(x,y) {\n    let z = num(x.val - y.val)\n    tape.push(() => { x.grad += z.grad; y.grad -= z.grad })\n    return z\n}\nfunction times(x,y) {\n    let z = num(x.val * y.val)\n    tape.push(() => { x.grad += y.val * z.grad; y.grad += x.val * z.grad })\n    return z\n}\n</code>\n<p>The function that computes gradients/derivatives needs to traverse the tape in reverse order, popping and running all the accumulated “backpropagator” closures.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// derivative/gradient api\nfunction grad(f) {\n    function d(x) {\n        // forward pass\n        let dx = num(x)\n        let dz = f(dx)\n        dz.grad = 1\n        // backward pass\n        for (b of tape.reverse()) b()\n        tape = []\n        return dx.grad\n    }\n    return d\n}\n</code>\n<p>This implementation of <code class=\"language-text\">grad</code> already demonstrates the key difference in capability/scalability to forward-mode AD.</p>\n<p><strong>Exercise:</strong> how to compute partial derivatives/gradients for functions with multiple arguments?</p>\n<p>All that is required is to change function <code class=\"language-text\">grad</code> to work with <code class=\"language-text\">dx1</code>,<code class=\"language-text\">dx2</code>, etc. instead of a singular <code class=\"language-text\">dx</code>. Crucially, no additional data needs to be computed and/or stored as part of the forward or backward pass.</p>\n<h3>Examples (Analytically)</h3>\n<p>Again we run some test cases, and we observe that we get the same, correct, result as in forward mode:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// helper functions\nfunction testGrad(label, f, d) {\n  test(label, () => expectFunc(grad(f), d))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// test cases\ntestGrad(\n  \"grad(x^2) = 2x\",\n  x => times(x, x),\n  x => 2*x)\ntestGrad(\n  \"grad(2x^3) = 6x^2\",\n  x => times(num(2),times(x,times(x, x))),\n  x => 6*x*x)\n</code>\n<h3>Examples (Graphically)</h3>\n<p>Visualization (try variations yourself):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// draw tangent of f at x\nfunction drawTangent(f,x) {\n    let y = primal(f)(x)\n    let dy = grad(f)(x)\n    let z = y-dy*x\n    drawPoint(x,y)\n    drawFunction(x1 => dy*x1+z)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example function (2(x-0.5))^2\nfunction sqr(x) {\n    return times(x,x)\n}\nfunction f(x) {\n    return sqr(times(num(2),minus(x,num(0.5))))\n}\n// draw it!\nnewPlot(200,200)\nplotScale = 200\ndrawFunction(primal(f))\ndrawTangent(f, 0.8) /* point for tangent -- play with it! */\n</code>\n<h3>Discussion</h3>\n<p>While we used the same single-argument examples as for forward-mode AD (mainly for consistency), it is important to stress once more that we can use the same code to compute partial derivatives and gradients for functions with multiple arguments, with only marginal overhead.</p>\n<p><strong>Exercise:</strong> consider a function with multiple <em>outputs</em>. Which variant is more efficient, forward- or reverse-mode AD?</p>\n</aside>\n<p>Reverse-mode AD solves the scalability issue of forward-mode AD through clever use of the chain rule of differentiation. The program is executed once to compute the normal result, and then traces back through each intermediate computation step to propagate gradient updates back to the input parameters.</p>\n<aside id=\"gradient-descent-optimization\">\n<h2>Gradient-Descent Optimization</h2>\n<p>What is <a href=\"/reverse-mode-ad\">AD</a> good for? The key motivation is optimization by gradient descent. We want to match a parameterized function (e.g., a neural network) to some observed data. To do so, we provide a function to compute the difference between the result computed based on the current parameter settings and the observed data (the loss function). Then, we compute the gradient of the loss function and adjust the parameters ever so slightly in the direction where the loss gets smaller.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction drawPoint(x,y) {\n    ctx.beginPath()\n    ctx.arc(x,200-y,4,0,2*Math.PI,true)\n    ctx.fill()\n}\nfunction drawFunction(f) {\n    ctx.beginPath()\n    ctx.moveTo(0,200-f(num(0)).val)\n    for (let x = 1; x < 200; x++)\n        ctx.lineTo(x,200-f(num(x)).val)\n    ctx.stroke()\n}\n</code>\n<p>We introduce an API to define optimizable parameters:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// basic functionality: keep track of\n// optimizable parameters\nlet params = []\nfunction param(x) {\n    const dx = num(x)\n    params.push(dx)\n    return dx\n}\n</code>\n<p>The second component is the optimization loop, which adjusts the parameter values based on the computed gradients:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// compute primal and gradient\nfunction compute(loss) {\n    tape = []\n    // forward\n    const d = loss()\n    // backprop\n    d.grad = 1\n    for (const b of tape.reverse()) b()\n    return d\n}\n// one optimization step\nlet lr = 0.0001 // learning rate\nfunction optimize(loss) {\n    const d = compute(loss)\n    // gradient descent\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        p.val -= lr * p.grad\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<h3>Example: Linear Regression</h3>\n<p>Here is an example. We define a linear function, which we want to fit to some data (linear regression).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nconst a0 = param(0)\nconst a1 = param(1)\nfunction approx(x) {\n    return plus(times(a1,x), a0)\n}\n</code>\n<p>We also define a sample data set. We use only two points for now, and since two points uniquely define a line, we should be able to fit the function to the data exactly:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// x,y stored in interleaved order\nlet data = [40,120,160,40]\nlet nSamples = data.length/2\n</code>\n<p>Let’s quickly plot the initial situation:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n</code>\n<p>Now to do the fitting, we first define the loss function (observed error) as the mean sum of squares:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction loss() {\n    let total = num(0)\n    for (let i = 0; i < nSamples; i++) {\n        const x = data[2*i]\n        const y = data[2*i+1]\n        const d = minus(num(y), approx(num(x)))\n        total = plus(total, times(d,d))\n    }\n    return times(total, num(1.0/nSamples))\n}\n</code>\n<p>Let’s plot some optimization steps (go ahead and change the learning rate or the loop bounds):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001 // <- try adding or removing a zero\nfor (let i = 0; i < 100; i++) {\n    optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\n</code>\n<p>We can see that the slope adjusts well initially, but then appears to get stuck. The y intercept by contrast doesn’t appear to move at all. When we increase the number of iterations we can see that it actually does move - however very very slowly. It takes around 10,000 iterations to see any visible change, and even at 100,000 iterations we aren’t anywhere close to where we want to be (try it!).</p>\n<p>Unfortunately, we cannot increase the learning rate to accelerate the process, because then the changes to the slope explode (try <code class=\"language-text\">lr = 0.0001</code>).</p>\n<p>Here are some variants with additional debug output to visualize how the overall error and the approximated values of <code class=\"language-text\">a0</code> and <code class=\"language-text\">a1</code> change from iteration to iteration:</p>\n<aside>\n<p>Batch mode</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<aside>\n<p>Batch size of 1</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    if (i%2 == 1)\n        data = [40,120]\n    else\n        data = [160,40]\n    nSamples = 1\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<aside>\n<p>Batch size of 1, randomized</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    if (randomInt(2) == 1)\n        data = [40,120]\n    else\n        data = [160,40]\n    nSamples = 1\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<h3>Stochastic Gradient Descent (SGD)</h3>\n<p>The variants with batch size 1 deserve a little bit of discussion. For large datasets, it is inefficient to adjust parameters only after processing the whole dataset (which may be gigabytes or even terabytes). Thus, in practice, it is common to compute the loss and update parameters based on a randomly selected “minibatch” at a time. This is called <em>stochastic</em> gradient descent (SGD), and in the limit, with batch size 1, we update parameters after each and every processed training sample.</p>\n<h3>Discussion</h3>\n<p>In conclusion, plain gradient descent works but is brittle. It requires careful tuning of the initial parameter values and, especially, of the learning rate.</p>\n<p>Parameters change with wildly different rates, yet the learning rate must be small enough to ensure stability for all of them. This leads to overall slow convergence.</p>\n<p>What we would <em>really</em> like to have is <em>different</em> learning rates for different parameters. Fortunately, such variations of the gradient-descent approach exist (e.g., AdaGrad, ADAM, etc.) and they can even adapt learning rates dynamically to how parameters change. These algorithms are more robust, and more efficient in practice.</p>\n<p>Another option are second-order methods that include curvature information (variants of Newton’s method). For many applications, these methods tend to be more robust and converge faster, however they are also more computationally intensive and have a reputation (deserved or not) to get stuck in saddle points in high-dimensional spaces. For these reasons, they are not frequently used in machine learning.</p>\n<p>We will discuss <a href=\"/gradient-descent-with-adam\">ADAM next</a>.</p>\n</aside>\n<p>The key motivation for AD is optimization by gradient descent. We show the core algorithm, and discuss why it is almost never used in its pure form in practice.</p>\n<aside id=\"gradient-descent-with-adam\">\n<p>Gradient Descent with ADAM (Adaptive Moment Estimation)</p>\n<p>We have seen above that <a href=\"/gradient-descent-optimization\">standard gradient descent</a> is sensitive to initial conditions and, especially, the learning rate. Since the same learning rate is applied to all parameters and remains unchanged throughout the training/optimization process, it has to be chosen very small, which means that many iterations are necessary.</p>\n<p>Improving gradient descent has been an intense focus of research. A nice and comprehensive overview is given by Sebastian Ruder:</p>\n<ul>\n<li><a href=\"https://ruder.io/optimizing-gradient-descent/index.html\">An overview of gradient descent optimization algorithms</a></li>\n</ul>\n<p>We use the ADAM algorithm below, which combines two key ideas to adjust the learning rate for each parameter based on prior changes:</p>\n<ul>\n<li>exponentially decaying average of past gradients (momentum)</li>\n<li>exponentially decaying average of past squared gradients</li>\n</ul>\n<p>Roughly, one can view ADAM as behaving like a heavy ball (with momentum), rolling down a hill slope (the error surface), subject to friction. Thus the ball tends to prefer flat minima.</p>\n<p>As an intermediate step, here is an implementation using only momentum:</p>\n<aside>\n<h3>Gradient Descent with Momentum</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet lastV1 = params.map(x => 0)\nlet gamma = 0.9\nfunction optimize(f) {\n    const d = compute(loss)\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        const v = lastV1[j]\n        const v1 = gamma * v + lr * p.grad\n        p.val -= v1\n        lastV1[j] = v1\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\ngamma = 0.99\nlr = 0.0001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val+1 // shift b/c negative\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error: \"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + (p2[0]-1) + \" --> \" + (p2[p2.length-1]-1))\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<p>It converges in about 1000 steps for our linear regression example (down 2 orders of magnitude from over 100,000).</p>\n<p>With 1000 steps, it is interesting to note how <code class=\"language-text\">a0</code> “overshoots” its target (due to momentum) and then settles back into the correct value.</p>\n<h3>ADAM</h3>\n<p>Here is the implementation:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet betaM = 0.9\nlet betaV = 0.999\nlet eps = 1e-8\nlet lastM = params.map(x => 0)\nlet lastV = params.map(x => 0)\nlet lastBetaM = betaM\nlet lastBetaV = betaV\nfunction optimize(f) {\n    const d = compute(loss)\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        const m = betaM * lastM[j] + (1-betaM) * p.grad\n        const v = betaV * lastV[j] + (1-betaV) * p.grad * p.grad\n        const m1 = m/(1-lastBetaM)\n        const v1 = v/(1-lastBetaV)\n        p.val -= lr * m1 / (Math.sqrt(v1) + eps)\n        lastM[j] = m\n        lastV[j] = v\n        lastBetaM *= betaM\n        lastBetaV *= betaV\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<h3>Example: Linear Regression</h3>\n<p>We apply ADAM to our running linear regression example.\nIn contrast to standard gradient descent, which needed about 300,000 iterations to converge and could not sustain learning rates of more than 0.00001, ADAM converges in only 150 iterations.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 2 // absurdly high learning rate, but ok for this example!\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 150; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val+1 // shift b/c negative\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error: \"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + (p2[0]-1) + \" --> \" + (p2[p2.length-1]-1))\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n<p>Looking at the curves above, we can see that <code class=\"language-text\">a0</code>, which stably moves in one direction, nicely accelerates but still manages a soft landing, and that <code class=\"language-text\">a1</code>, which oscillates a lot in the beginning due to the high learning rate, is slowed down to stabilize.</p>\n<h3>Discussion</h3>\n<p>Optimization algorithms for deep learning architectures are a subject of ongoing research. Some refinements to ADAM and similar algorithms were proposed based on the observation that SGD with momentum and careful learning-rate schedules tend to find better minima on certain classes of models:</p>\n<ul>\n<li><a href=\"https://johnchenresearch.github.io/demon/\">An updated overview of recent gradient descent algorithms. Chen, 2020</a></li>\n</ul>\n<p>Other topics worth mentioning are optimization methods based on higher-order gradients (not frequently used in deep learning because of computational overhead) and approaches to go meta and optimize hyperparameters such as the learning rate itself by gradient descent:</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1909.13371\">Gradient Descent: The Ultimate Optimizer. Chandra et al, 2019</a></li>\n</ul>\n</aside>\n<p>We discuss ADAM, a variant of gradient descent that performs well in many practical scenarios and hence is a popular  choice for training deep learning models.</p>\n<p><a href=\"/Public/Generic/differentiable-graphics\">Cool Application: Interactive Graphics</a></p>\n<p>As a neat application, we show how our small AD library can turn parameterized drawings into rich interactive diagrams.</p>","fields":{"slug":"/Public/Generic/differentiable-programming-in-js/"},"frontmatter":{"date":"June 14, 2020","title":"Differentiable Programming in JavaScript","description":"Implementing AutoDiff from scratch in JS. Forward and reverse mode, gradient descent with momentum and Adam.","keywords":"Differentiable programming, Automatic Differentiation, AutoDiff, Gradient Descent, Linear Regression, JavaScript","tags":null}}},{"node":{"excerpt":"Knuth, Literate Programming: … a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most…","html":"<p>Knuth, Literate Programming:</p>\n<blockquote>\n<p>… a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most important thing about a program is its structural relationships. A complex piece of software consists of simple parts and simple relations between those parts; the programmer’s task is to state those parts and those relationships, in whatever order is best for human comprehension not in some rigidly determined order like top-down or bottom-up.</p>\n</blockquote>\n<p>It’s nice to have <a href=\"/Public/Generic/interactive-coding\">interactive snippets</a> in web pages or <a href=\"/Public/Generic/octopus-notes\">Octopus Notes</a>, but we do not want to be restricted to isolated, self-contained, units.</p>\n<p>For larger documents, we want to develop code over a series of dependent snippets, and compose them freely.</p>\n<p>Importantly, we also want to be able to put code into asides and show the editor pane side by side with the output.</p>\n<aside>\n<p>How can we do that?</p>\n<p>Of course we can communicate through the global (window) scope. But there are issues with that:</p>\n<ul>\n<li>Scope pollution: what if multiple articles define and use the same name?</li>\n<li>\n<p>Order of evaluation: what if snippets are evaluated out of order?</p>\n<p>We can generally assume scripts within an article are executed top to bottom. But if we have an interactive editor, we may (re-)evaluate code at any time.</p>\n</li>\n</ul>\n<p>To solve these issues, we follow a relatively simple but robust idea to join multiple snippets:</p>\n<ul>\n<li>Remember the order of snippets</li>\n<li>Mark all that should form part of an inclusion chain</li>\n<li>Add them to the input of each following snippet</li>\n<li>Optional (not yet implemented): re-eval all following snippets if a previous one changes</li>\n</ul>\n<p>Why does this work even with asides?</p>\n<p>Because asides are extracted from the main article <em>after</em> scripts are run! Hence, no special treatment is necessary.</p>\n<p>Below are some tests and explanations.</p>\n<p>Here are some avenues for extension <a href=\"/Notes/todo-large\">tag:todo</a>:</p>\n<ul>\n<li>Right now we cannot modify preamble parts (actually we <em>can</em> modify them, but changes won’t be picked up by other snippets). We may or may not want to re-run all downstream dependencies for every change.</li>\n<li>Use <code class=\"language-text\">filter=&quot;editor&quot;</code> with attribute <code class=\"language-text\">preamble=&quot;set/add&quot;</code> instead of <code class=\"language-text\">filter=&quot;set/addPreamble</code>.</li>\n<li>We may want to support things like <code class=\"language-text\">preamble=&quot;push/pop&quot;</code>.</li>\n<li>Attribute <code class=\"language-text\">popout=true</code> could be generalized to <code class=\"language-text\">style=popout</code> to support other custom styles (think about plug-ins).</li>\n<li>Editor UX could be improved in various ways (syntax highlighting, smart editing, monospace console output, etc)</li>\n</ul>\n</aside>\n<p>Below are some examples and explanations. There are multiple avenues for extension.</p>\n<aside>\n<h2>What works right now</h2>\n<h3>Editor definition script</h3>\n<p>No visible output. We’d probably want to import this from a central location (once we’re done tweaking it globally).</p>\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<h3>Set Preamble</h3>\n<p>Putting <code class=\"language-text\">filter=&quot;setPreamble&quot;</code> on a script will prepend the code to any following script that uses the editor component.</p>\n<code class=\"runScript\" filter=\"setPreamble\">\nlet trace = []\ntrace.push(\"setPreamble1\")\n</code>\n<h3>Editor 1</h3>\n<p>Let’s verify this. This editor does not use <code class=\"language-text\">setPreamble</code>, so it will just execute the program (with the previously defined preamble prepended).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"editor1\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 1</h3>\n<p>Of course we don’t always want to set the preamble wholesale, but accumulate it piecewise. For this we can use <code class=\"language-text\">filter=&quot;addPreamble&quot;</code>:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"addPreamble1\")\n</code>\n<h3>Editor 2</h3>\n<p>Now we should see <code class=\"language-text\">setPreamble1</code>, <code class=\"language-text\">addPreamble1</code>, and <code class=\"language-text\">editor2</code> in the output, but not <code class=\"language-text\">editor1</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\ntrace.push(\"editor2\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>Aside 1</h3>\n<p>All of this works transparently with asides, since they are pulled out after scripts execute.</p>\n<p>Here is an aside that contains preamble material and editors.</p>\n<aside>\n<p>Let’s try this!</p>\n<h3>Editor 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"aside1.editor1\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 1</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"aside1.addPreamble1\")\n</code>\n<h3>Editor 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"aside1.editor2\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 2</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"aside1.addPreamble2\")\n</code>\n</aside>\n<h3>Editor 3</h3>\n<p>We can verify that we have <code class=\"language-text\">aside1.addPreamble1</code> and <code class=\"language-text\">aside1.addPreamble2</code> in the trace, in addition to what we had before.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"editor3\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>Aside 2 (Generated!)</h3>\n<p>A cool thing is that we can generate asides programmatically from scripts. Again, this works because asides are pulled out <em>after</em> scripts are run.</p>\n<code class=\"runScript\">\nconst aux = document.createElement(\"aside\")\naux.appendChild(document.createTextNode(\"Programmatically generated!\"))\naux\n</code>\n<h3>Editor 4 (Pop-Out!)</h3>\n<p>With this programmatic support we can also build editor components that show the results inline but put the code editor itself into an aside.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\ntrace.push(\"editor4\")\nfor (let e of trace)\n  emit(e)\n</code>\n<p>Editing the code in the aside will change the result displayed inline, as we expect.</p>\n</aside>","fields":{"slug":"/Public/Generic/interactive-literate-programming/"},"frontmatter":{"date":"June 12, 2020","title":"Interactive Literate Programming","description":"Modular live code snippets across multiple notes.","keywords":"Live coding, literate programming","tags":null}}},{"node":{"excerpt":"Web pages can be turned into interactive tutorials with just a little bit of embedded JavaScript. We are particularly interested in…","html":"<!--\n<pre id=\"code-onload\" contenteditable=\"true\">\nconsole.log(\"code-onload\")\nfunction runX() {\n    eval((document.getElementById(\"code-X\").innerText))\n}\n</pre>\n\n<pre id=\"code-X\" contenteditable=\"true\">\nconsole.log(\"foo!\")\nfunction foobar() {\n    console.log(\"bar!\")\n}\n</pre>\n\n<script>\nconsole.log(\"boo!\");\n</script>\n\n<a href=\"javascript:runX()\">▶ run</a>\n\n<img src=\"\" onerror=\"window.eval((document.getElementById('code-onload').innerText))\" width=\"0\" height=\"0\" />\n\n-->\n<p>Web pages can be turned into interactive tutorials with just a little bit of embedded JavaScript.</p>\n<p>We are particularly interested in interacting with editable and runnable code, inspired, among other things, by the work of <a href=\"http://worrydream.com/LearnableProgramming/\">Bret Victor</a>. Of course interactive documents are also useful in other fields (physics, math, music, etc).</p>\n<p>Below we explore a series of simple code interaction patterns, such as repls (read-eval-print loops) and embedded editable code snippets that are connected to live elements of the page.\nWe’re not aiming for maximal flashiness, but for simplicity.</p>\n<aside>\n<h2>Basic DOM manipulation</h2>\n<code class=\"runScript\">\nconst e = document.createElement(\"div\")\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ ping\"\na.addEventListener(\"click\", function(ev) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(\"Ping!\"))\n    e.appendChild(l)\n    ev.preventDefault()\n})\ne.appendChild(a)\ne\n</code>\n<h2>Eval expression on click</h2>\n<code class=\"runScript\">\nconst editInput = \"3+4\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction run() {\n    try {\n        const res = eval(p.innerText)\n        emit(res)\n    } catch(err) {\n        emit(err)\n    }\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run()\n})\ne.appendChild(a)\ne.appendChild(p)\ne.appendChild(o)\ne\n</code>\n</aside>\n<aside>\n<h2>Basic REPL</h2>\n<code class=\"runScript\">\nconst editInput = \"3+4\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nlet history = [editInput]\nlet historyIndex = 0\nlet historyCur = \"\"\nfunction run() {\n    try {\n        const src = p.innerText.trim()\n        if (src) {\n        // record in history, if not empty and not equal previous\n        if ((history.length < 2 || history[history.length - 2] != src) && src != \"\") {\n            history[history.length - 1] = src\n            history.push(\"\")\n        } else {\n            history[history.length - 1] = \"\"\n        }\n        historyIndex = 0\n        emit(\"> \"+src)\n        const res = eval(src)\n        if (res) emit(\"< \"+res)\n        }\n    } catch(err) {\n        emit(err)\n    }\n    p.innerText = \"\"\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run()\n})\np.addEventListener(\"keydown\", function(ev) {\n    if (ev.code == \"Enter\" && !ev.shiftKey) {\n        ev.preventDefault()\n        run()\n    } else if (ev.code == \"KeyK\" && ev.metaKey) {\n        ev.preventDefault()\n        clear()\n    } else if (ev.code == \"ArrowUp\") {\n        if (historyIndex < history.length - 1) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex + 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    } else if (ev.code == \"ArrowDown\") {\n        if (historyIndex > 0) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex - 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    }\n})\nconst c = document.createElement(\"a\")\nc.href = \"\"\nc.innerText = \"clear\"\nc.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    clear()\n})\ne.appendChild(o)\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(document.createTextNode(\" \"))\ne.appendChild(c)\ne\n</code>\n<p>Functionality / key bindings:</p>\n<ul>\n<li>Run command (Return)</li>\n<li>Line break (Shift-Return)</li>\n<li>Clear output (Cmd-k)</li>\n<li>Up/down arrows: history</li>\n<li>enter “emit(..)” to print</li>\n</ul>\n<h2>Basic DOM and canvas in REPL</h2>\n<p>Below is a scripted repl session that creates a canvas and draws in it.</p>\n<code class=\"runScript\">\n// code is copied from above -- should definitely factor out!\nconst editInput = \"\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nlet history = [editInput]\nlet historyIndex = 0\nlet historyCur = \"\"\nfunction run(src) {\n    try {\n        if (src) {\n        // record in history, if not empty and not equal previous\n        if ((history.length < 2 || history[history.length - 2] != src) && src != \"\") {\n            history[history.length - 1] = src\n            history.push(\"\")\n        } else {\n            history[history.length - 1] = \"\"\n        }\n        historyIndex = 0\n        emit(\"> \"+src)\n        const res = eval(src)\n        if (res) emit(\"< \"+res)\n        }\n    } catch(err) {\n        emit(err)\n    }\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run(p.innerText.trim())\n    p.innerText = \"\"\n})\np.addEventListener(\"keydown\", function(ev) {\n    if (ev.code == \"Enter\" && !ev.shiftKey) {\n        ev.preventDefault()\n        run(p.innerText.trim())\n        p.innerText = \"\"\n    } else if (ev.code == \"KeyK\" && ev.metaKey) {\n        ev.preventDefault()\n        clear()\n    } else if (ev.code == \"ArrowUp\") {\n        if (historyIndex < history.length - 1) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex + 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    } else if (ev.code == \"ArrowDown\") {\n        if (historyIndex > 0) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex - 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    }\n})\nconst c = document.createElement(\"a\")\nc.href = \"\"\nc.innerText = \"clear\"\nc.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    clear()\n})\ne.appendChild(o)\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(document.createTextNode(\" \"))\ne.appendChild(c)\n// run stuff!\nrun('cvs = document.createElement(\"canvas\")')\nrun('cvs.width = 200')\nrun('cvs.height = 200')\nrun('o.appendChild(cvs)')\nrun('ctx = cvs.getContext(\"2d\")')\nrun('ctx.fillRect(10,10,100,100)')\nrun('ctx.fillRect(100,100,200,200)')\nrun('ctx.fillStyle = \"white\"')\nrun('ctx.fillRect(100,100,10,10)')\ne\n</code>\n</aside>\n<p>The key to a truly interactive feel is to eliminate the edit-compile-run cycle and immediately visualize how a change in the program affects its behavior.</p>\n<aside>\n<h2>Re-eval on edit</h2>\n<p>A text pane that re-evaluates output on the fly, on every edit.</p>\n<code class=\"runScript\">\nconst editInput = `const cvs = document.createElement(\"canvas\")\ncvs.width = 200\ncvs.height = 200\no.appendChild(cvs)\nconst ctx = cvs.getContext(\"2d\")\nctx.fillRect(10,10,100,100)\nctx.fillRect(100,100,200,200)\nctx.fillStyle = \"white\"\nctx.fillRect(100,100,10,10)\nemit(\"Do you like it?\")\nawait buttonClick(\"Yes!!!\")\nemit(\"Good!\")`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n<p>Try changing something that results in a syntax error, and note how the previous output remains visible (we might want to turn it gray or something).</p>\n<p>Note the <code class=\"language-text\">await</code> and how the button behaves.</p>\n<p>One could think about a richer programmatic UI library, including commands to open new dialog screens (graphics or text), to select options (e.g., <code class=\"language-text\">await pickOne(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code> might show multiple buttons), and so on.</p>\n<h2>Test-driven development (TDD)</h2>\n<p>Basic unit testing facilty. Test are re-run on each edit.</p>\n<code class=\"runScript\">\nconst editInput = `\ntest(\"foo\", function() {\n    assert(7 == 8)\n})\ntest(\"bar\", function() {\n    assert(7 == 7)\n})\ntest(\"foo\", function() {\n    expect(7,8)\n})\ntest(\"bar\", function() {\n    expect(7,7)\n})`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n</aside>\n<p>The most generally useful baseline widget seems to be an interactive editor that contains the source code for a component of the page. The editor re-runs the program on every keystroke, maintaining an always up-to-date output panel along with the source code.</p>\n<code class=\"runScript\">\nconst editInput = `\nprint(\"Hello World!\") // edit me\nprint(6*7)\n`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction print(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n<p>Graphics and user input are supported, too. See link above for details.</p>","fields":{"slug":"/Public/Generic/interactive-coding/"},"frontmatter":{"date":"June 06, 2020","title":"Interacting with Code","description":"How to turn web pages into interactive live-coding environments, with nothing but plain JavaScript.","keywords":"JavaScript, REPL, live coding, live programming","tags":null}}},{"node":{"excerpt":"Structuring complex information is difficult, whether it is for clarity of one’s own thought or for effective presentation. Specifically, it…","html":"<p>Structuring complex information is difficult, whether it is for clarity of one’s own thought or for effective presentation. Specifically, it’s difficult to decide:</p>\n<ul>\n<li>In which order?</li>\n<li>At which level of detail?</li>\n</ul>\n<p>And often, there is no single right answer.</p>\n<p>Octopus Notes, the prototype system you’re using to view this note, is an attempt at creating easily-browsable associative knowledge bases that sidestep these questions.\nLike other systems, the underlying idea is to structure information as a collection of densely linked, self-contained, notes.\nBut unlike other systems, the focus is on visually presenting linked information in context.</p>\n<aside>\n<h2>Presenting information in context, at multiple resolutions</h2>\n<p>This is a linked note that provides additional information and further details that are omitted from the main article.</p>\n<p>We can have as many notes and links as we want, nested arbitrarily deep, and we can open and close them selectively, while viewing them side-by-side with the more condensed material from the main article.</p>\n<p>We can follow arbitrary paths through the knowledge graph with ease, but in contrast to typical web navigation, we do not lose the context where we came from.</p>\n<p>We can access information at multiple resolutions, or levels of detail, simultaneously and selectively. We can view multiple levels of detail side-by-side and we can drill down as deep as we find useful, or remain at the surface for the tl;dr.</p>\n<p>Authors can add additional information anywhere without disrupting the flow of the main content.</p>\n</aside>\n<p>Clicking a link like the one above will not navigate away from the current page, but instead it will open the link target in an additional scrollable panel with an attached “tentacle”.\nThis enables engaging with information at multiple levels of detail simultaneously.</p>\n<aside>\n<h2>Features and implementation</h2>\n<p>User-facing features:</p>\n<ul>\n<li>Multi-resolution display of information</li>\n<li>Bidirectional links</li>\n<li>Interactive documents with live code</li>\n</ul>\n<p>Tech stack:</p>\n<ul>\n<li>Jamstack, single-page-app front-end</li>\n<li>Markdown syntax</li>\n</ul>\n<p>More information:</p>\n<ul>\n<li>\n<aside>\n<h2>Markdown reference</h2>\n<p>Octopus Notes supports standard markdown syntax, as defined by the static generation pipeline (currently Gatsby and Remark).</p>\n<p>A few things are worth highlighting.</p>\n<h3>Inline notes via “aside”</h3>\n<p>Notes are typically created as individual <code class=\"language-text\">.md</code> files. However it can be annoying to create a new file for every little side note. Hence, Octopus Notes support the definition of inline notes using html <code class=\"language-text\">&lt;aside&gt;</code> elements.</p>\n<p>As an example, here is the definition of the current note:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">More information:\n\n- &lt;aside&gt;\n\n    ## Markdown reference\n\n    Octopus note supports ...\n\n    &lt;/aside&gt;\n\n- ...</code></pre></div>\n<p>Note that:</p>\n<ul>\n<li>It is important to leave a blank line before and after <code class=\"language-text\">&lt;aside&gt;</code> or other HTML tags (otherwise adjacant markdown will be treated as HTML)</li>\n<li>Asides can be placed in lists or other elements; they are always pulled out and replaced with a link</li>\n<li>The link text is automatically extracted from text of the aside (usually the first line, but may be shorter, e.g, when hitting a ”:“)</li>\n</ul>\n<h3>Embedded code snippets</h3>\n<p>Notes can contain standard JavaScript <code class=\"language-text\">&lt;script&gt;</code> tags that are executed when the data is loaded.</p>\n<p>Often, a bit more control is needed, so Octopus Notes also supports script blocks of the form:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;code class=&quot;runScript&quot; filter=&quot;...&quot;&gt;\n...\n&lt;/code&gt;</code></pre></div>\n<p>Such code blocks may return a DOM element that will replace the script element in the DOM (highly useful for interactive documents).</p>\n<p>If the optional filter argument is given it is evaluated first, and the result is then called with the contents of the code block as argument. This way, code may be preprocessed in arbitrary ways.</p>\n<p>A key use case is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;code class=&quot;runScript&quot; filter=&quot;coolEditor&quot;&gt;\n...\n&lt;/code&gt;</code></pre></div>\n<p>which produces an inline-editable code snippet (<a href=\"/Public/Generic/interactive-coding\">Interactive code</a>).</p>\n<p>There are various helpers to enable interaction between such snippets (<a href=\"/Public/Generic/interactive-literate-programming\">Interactive code across multiple snippets</a>).</p>\n</aside>\n</li>\n<li>\n<aside>\n<h2>Static site generation</h2>\n<p>Octopus Notes currently uses Gatsby and Remark to turn Markdown input into static html.</p>\n<p>Right now we do not use the actual Gatsby site generation facility, and use Gatsby only to perform aggregation via GraphQL, resulting in a single <code class=\"language-text\">page-data.json</code> file that is then processed client-side by the custom Octopus front-end.</p>\n</aside>\n</li>\n<li><a href=\"/Public/Generic/interactive-coding\">Interactive code</a></li>\n<li><a href=\"/Public/Generic/interactive-literate-programming\">Interactive code across multiple notes</a></li>\n</ul>\n</aside>\n<p>The system is built on markdown and modern web front-end technologies, and it supports rich interactive content.</p>\n<aside>\n<h2>Inspiration and related work</h2>\n<p>Original ideas:</p>\n<ul>\n<li>Niklas Luhmann (Zettelkasten)</li>\n<li>Ted Nelson (Xanadu)</li>\n<li>Ward Cunningham (Wikis)</li>\n</ul>\n<p>Further inspiration:</p>\n<ul>\n<li>Sönke Ahrens (How to Take Smart Notes)</li>\n<li>Andy Matuschak (Evergreen Notes)</li>\n</ul>\n<p>Other software:</p>\n<ul>\n<li>Trilium, Obsidian, Notion, Gingko, Roam</li>\n</ul>\n</aside>\n<p>There is plenty of inspirational prior work, including Luhmann’s Zettelkasten method and Nelson’s original hyperlink concept.</p>","fields":{"slug":"/Public/Generic/octopus-notes/"},"frontmatter":{"date":"May 30, 2020","title":"Octopus Notes","description":"A system for presenting structured information and networked thought. Multiple levels of detail. Hyperlinks side-by-side with source. For knowledge bases, note taking, wikis, blogs, interactive books and tutorials. Based on Markdown.","keywords":"bidirectional links, zettelkasten, note-taking, personal wiki, knowledge bases, second brain","tags":null}}}]}},"pageContext":{}}}