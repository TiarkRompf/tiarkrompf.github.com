{"componentChunkName":"component---src-pages-public-js","path":"/public/","result":{"data":{"site":{"siteMetadata":{"title":"KB"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"Recent Updates: Let’s Build a Microprocessor Fun With Particle Animation Just Write the #!%/* Parser Implementing Affine Non-Escaping…","html":"<p>Recent Updates:</p>\n<ul>\n<li>\n<p><a href=\"/Public/Generic/lets-build-a-microprocessor\">Let’s Build a Microprocessor</a></p>\n<div><small>20/12/23</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/particles\">Fun With Particle Animation</a></p>\n<div><small>20/12/22</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/just-write-the-parser\">Just Write the #!%/* Parser</a></p>\n<div><small>20/10/19</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/affine-continuations\">Implementing Affine Non-Escaping Delimited Continuations with a Single Auxiliary Stack</a></p>\n<div><small>20/07/14</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/differentiable-graphics\">Differentiable Programming for Interactive Graphics</a></p>\n<div><small>20/07/11</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/deconstructing-react\">Deconstructing React</a></p>\n<div><small>20/07/07</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/touch-camera-device-apis\">Touch, Camera, and Other Device APIs</a></p>\n<div><small>20/07/04</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/drawing-graphs\">Drawing Graphs Like GraphViz</a></p>\n<div><small>20/06/28</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/virtual-piano\">Virtual Piano Practice</a></p>\n<div><small>20/06/20</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/differentiable-programming-in-js\">Differentiable Programming in JS</a></p>\n<div><small>20/06/14</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/interactive-literate-programming\">Interactive Literate Programming</a></p>\n<div><small>20/06/12</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/interactive-coding\">Interacting With Code</a></p>\n<div><small>20/06/06</small></div>\n</li>\n<li>\n<p><a href=\"/Public/Generic/octopus-notes\">Octopus Notes</a></p>\n<div><small>20/05/30</small></div>\n</li>\n</ul>\n<!--\nPublications:\n\n- [By year](/Public/Papers/)\n- By topic\n-->\n<div style=\"display:none\">\n<p><a href=\"/Public/Generic/regions-borrowing-coeffects\">/Public/Generic/regions-borrowing-coeffects</a>\n<a href=\"/Public/Generic/graph-ir\">/Public/Generic/graph-ir</a></p>\n</div>\n<p><small>Copyright © 2020 <a href=\"https://tiarkrompf.github.io\">Tiark Rompf</a></small></p>","fields":{"slug":"/Public/Generic/public/"},"frontmatter":{"date":null,"title":"Notes - Start Page","description":null,"keywords":null,"tags":null}}},{"node":{"excerpt":"December. Year of the plague. What better time for some recreational hacking. Why not play with some particle effects? Implementation Notes…","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>December. Year of the plague. What better time for some recreational hacking. Why not play with some particle effects?</p>\n<aside>\n<p>Implementation Notes</p>\n<p>First we need to set up a canvas</p>\n<code class=\"runScript\" filter=\"setPreamble\" popout=\"true\">\nlet cvs = null\nlet ctx = null\nlet sizeX = 300\nlet sizeY = 100\nfunction createCanvas() {\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.width = sizeX\n  cvs.height = sizeY\n  ctx = cvs.getContext(\"2d\")\n}\n</code>\n<p>Now we’re ready to draw something. Let’s paint a bunch of circles and gradually vary position, color, etc.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\nlet cx = 0\nlet cy = 50\nlet size = 30\nlet db = size\nlet x = cx\nlet y = cy\nlet vx = 5\nlet vy = 0//-db/2\nlet ay = 1\nlet ax = 1\nlet d = db/2 //+ random(db/2)\nlet red = 255\nlet green = 255\nlet blue = 255\nlet alpha = 1.0\n// stations: white, yellow, red, black\nfunction particle() {\n  let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n  ctx.lineWidth = d;\n  ctx.fillStyle = color\n  ctx.strokeStyle = color\n  ctx.lineCap = \"round\";\n  ctx.beginPath();\n  ctx.moveTo(x,y);\n  ctx.lineTo(x+1,y+1);\n  ctx.stroke();\n  y += vy\n  x += vx\n  if (vy < -1.5) vy *= 0.9\n  d += 0.55\n  if (blue > 15)\n      blue -= 15\n  if (green > 3)\n      green -= 3\n  if (green <= 100 && red > 5)\n      red -= 5\n  alpha -= 0.02\n  if (alpha > 0 && d > 0) {\n      particle()\n  }\n}\nparticle()\n</code>\n<p>How to bring this to life? First step: randomness!</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction random(x) {\n  return Math.random() * x\n}\nfunction choice(x) {\n  return Math.random() < x\n}\n</code>\n<p>Let’s try again (click “done” or edit the code to re-run):</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\nlet cx = 0\nlet cy = 50\nlet size = 30\nlet db = size\nlet x = cx\nlet y = cy\nlet vx = 5\nlet vy = 0//-db/2\nlet ay = 1\nlet ax = 1\nlet d = db/2\nlet red = 255\nlet green = 255\nlet blue = 255\nlet alpha = 1.0\n// stations: white, yellow, red, black\nfunction particle() {\n  let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n  ctx.lineWidth = d;\n  ctx.fillStyle = color\n  ctx.strokeStyle = color\n  ctx.lineCap = \"round\";\n  ctx.beginPath();\n  ctx.moveTo(x,y);\n  ctx.lineTo(x+1,y+1);\n  ctx.stroke();\n  y += vy\n  x += vx\n  if (vy < -1.5) vy *= 0.9\n  vy = -db/6 + random(db/3)\n  d = db/2 + random(db/2)\n  if (blue > 15)\n      blue -= 15\n  if (green > 3)\n      green -= 3\n  if (green <= 100 && red > 5)\n      red -= 5\n  alpha -= 0.02\n  if (alpha > 0 && d > 0) {\n      particle()\n  }\n}\nparticle()\n</code>\n<p>What next? Animate!</p>\n<p>We’ll use a pretty generic animation solution, based on a work list for concurrent execution.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet queue = []\nfunction schedule(fun) {\n  queue.push(fun)\n}\nlet time = 0\nlet canvasVisible = false\nfunction animate () {\n  time += 100\n  ctx.clearRect(0,0,sizeX,sizeY)\n  var items = queue\n  queue = []\n  for (i in items) {\n    var fun = items[i]\n    fun.apply(fun)\n  }\n  if (canvasVisible)\n    setTimeout(animate, 0)\n}\n</code>\n<p>Each piece in the animation is a conceptual thread that can schedule itself again for the next frame, as well as create new particles, each one spawned off as a new thread.\nA neat aspect is that state can be maintained across multiple of these threads using closures.</p>\n<p>To draw a niece cozy fire, we’ll use a code skeleton roughly like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">schedule(function fire() {\n  ...\n  // start a new flame at a random position\n  ...\n  schedule(function flame() {\n    ...\n    // emit one or more new fire particles\n    ...\n    schedule(function particle() {\n      ...\n      // move particle up, change color, etc\n      ...\n      if (!burntOut)\n        schedule(particle)\n    }\n    if (!extinguished)\n      schedule(flame) // keep burning\n  })\n  schedule(fire)\n})</code></pre></div>\n<p>To prevent hogging the CPU we want to start/stop the animation based on visibility of the canvas.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction respondToVisibility(element, callback) {\n  let options = {\n    root: document.documentElement\n  }\n  let observer = new IntersectionObserver((entries, observer) => {\n    entries.forEach(entry => {\n      callback(entry.intersectionRatio > 0);\n    })\n  }, options)\n  observer.observe(element);\n}\nfunction createSmallCanvas() {\n  sizeX = 150\n  sizeY = 150\n  createCanvas()\n  respondToVisibility(cvs, visible => {\n    if (!canvasVisible && visible)\n      setTimeout(animate, 0)\n    canvasVisible = visible\n  })\n}\n</code>\n<p>Now we’re ready to draw our first animated flame. Be sure to play with the parameters (color, position, etc)!</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateSmallCanvas()\nlet cx = sizeX/2\nlet cy = sizeY\nlet size = sizeY/10\nlet t0 = time\nschedule(function burn() {\n  let db = size// * Math.log((time-t0))\n  let x = cx\n  let y = cy\n  let vx = 0\n  let vy = -db/2\n  let ay = 1\n  let ax = 1\n  let d = db/2 + random(db/2)\n  let red = 255\n  let green = 255\n  let blue = 255\n  let alpha = 1.0\n  // stations: white, yellow, red, black\n  schedule(function particle() {\n    let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n    ctx.lineWidth = d;\n    ctx.fillStyle = color\n    ctx.strokeStyle = color\n    ctx.lineCap = \"round\";\n    ctx.beginPath();\n    ctx.moveTo(x,y);\n    ctx.lineTo(x+1,y+1);\n    ctx.stroke();\n    y += vy\n    x += vx\n    vx = -db/6 + random(db/3)\n    if (vy < -1.5) vy *= 0.9\n    d -= 0.03\n    if (blue > 15)\n        blue -= 15\n    if (green > 3)\n        green -= 3\n    if (green <= 100 && red > 5)\n        red -= 5\n    alpha -= 0.02\n    if (alpha > 0 && d > 0)\n        schedule(this)\n  })\n  schedule(burn)\n})\n</code>\n<p>Now let’s draw our water jet. The setup is the same. A minor difference is that we chose to emit not one but ten new particles in each animation step. Yes, it really is a high-pressure jet:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateSmallCanvas()\nlet mx = sizeX/2\nlet my = sizeY-10;\nschedule(function spray() {\n  function emit() {\n    let red = 0\n    let green = 255\n    let blue = 255\n    let alpha = 1.0\n    let angle = 0.3*Math.PI + random(0.4 * Math.PI)\n    let vx =  Math.cos(angle)\n    let vy = (6)*-Math.sin(angle)\n    let x = mx\n    let y = my\n    let d = 5 + random(15)\n    schedule(function particle() {\n      let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n      ctx.lineWidth = d;\n      ctx.fillStyle = color\n      ctx.strokeStyle = color\n      ctx.lineCap = \"round\";\n      ctx.beginPath();\n      ctx.moveTo(x,y);\n      ctx.lineTo(x+1,y+1);\n      ctx.stroke();\n      y += vy\n      x += vx\n      alpha -= 0.05\n      if (alpha > 0 && d > 0)\n        schedule(this)\n    })\n  }\n  for (var i = 0; i < 10; i++)\n    schedule(emit)\n  schedule(this)\n})\n</code>\n<p>Now it’s time to put everything together. Add some event listeners and we’re ready to play:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nsizeX = 600\nsizeY = 300\ncreateCanvas()\nvar dimx = sizeX\nvar dimy = sizeY\nvar score = 0\nvar draw= false;\nvar mx = 0\nvar my = 0\ncvs.style.touchAction=\"none\" // prevent scrolling\ncvs.addEventListener(\"pointerdown\", ev => {\n  draw = true\n  cvs.setPointerCapture(ev.pointerId)\n  ev.preventDefault()\n  ev.stopPropagation()\n  // ev.stopImmediatePropagation() // necessary?\n})\ncvs.addEventListener(\"pointermove\", ev => {\n  mx = e.offsetX\n  my = e.offsetY\n  ev.preventDefault()\n  ev.stopPropagation()\n})\ncvs.addEventListener(\"pointerup\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"pointercancel\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"mousedown\", e => draw=true)\ncvs.addEventListener(\"mouseup\", e => draw=false)\ncvs.addEventListener(\"mousemove\", e => {\n    mx = e.offsetX\n    my = e.offsetY\n})\nrespondToVisibility(cvs, visible => {\n  if (!canvasVisible && visible)\n    setTimeout(animate, 0)\n  canvasVisible = visible\n})\nschedule(function spray() {\n  if (draw) {\n    function emit() {\n      let red = 0\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      let angle = 0.3*Math.PI + random(0.4 * Math.PI)\n      let vx =  Math.cos(angle)\n      let vy = (6)*-Math.sin(angle)\n      let x = mx\n      let y = my\n      let d = 5 + random(15)\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        alpha -= 0.05\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n    }\n    for (var i = 0; i < 10; i++)\n      schedule(emit)\n  }\n  schedule(this)\n})\nschedule(function fire() {\n  if (choice(0.1)) {\n    let cx = random(dimx)\n    let cy = dimy/2+random(dimy/2)\n    let size = 3 + random(10)\n    let t0 = time\n    schedule(function burn() {\n      let db = size// * Math.log((time-t0))\n      let x = cx\n      let y = cy\n      let vx = 0\n      let vy = -db/2\n      let ay = 1\n      let ax = 1\n      let d = db/2 + random(db/2)\n      let red = 255\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      // stations: white, yellow, red, black\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        vx = -db/6 + random(db/3)\n        if (vy < -1.5) vy *= 0.9\n        d -= 0.03\n        if (blue > 15)\n            blue -= 15\n        if (green > 3)\n            green -= 3\n        if (green <= 100 && red > 5)\n            red -= 5\n        alpha -= 0.02\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n      if (draw && (my-cy) > 0 && (my-cy) < 20 && Math.abs(mx-cx) < 10)\n        score += Math.round(db)\n      else\n        schedule(burn)\n    })\n  }\n  schedule(fire)\n})\n</code>\n<p>The code is editable. Go ahead and adjust the parameters to adjust the level of difficulty!</p>\n</aside>\n<p>Oh no, this has gotten out of hand. Quick, quick! Get the fire extinguisher and put out those flames!</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nsizeX = 400\nsizeY = 400\ncreateCanvas()\ncvs.style.backgroundImage=\"url(http://tiarkrompf.github.io/notes/img/xmas-tree.jpg)\"\ncvs.style.backgroundSize=\"cover\"\nlet q = document.createElement(\"div\")\nq.innerText = \"Score: 0\"\nq.style.backgroundColor = \"black\"\nq.style.marginTop = \"-10px\"\nq.style.color = \"white\"\nlet p = document.createElement(\"div\")\np.style.width=\"400px\"\np.appendChild(cvs)\np.appendChild(q)\no.appendChild(p)\nvar dimx = sizeX\nvar dimy = sizeY\nvar score = 0\nvar draw= false;\nvar mx = 0\nvar my = 0\ncvs.style.touchAction=\"none\" // prevent scrolling\ncvs.addEventListener(\"pointerdown\", ev => {\n  draw = true\n  cvs.setPointerCapture(ev.pointerId)\n  ev.preventDefault()\n  ev.stopPropagation()\n  // ev.stopImmediatePropagation() // necessary?\n})\ncvs.addEventListener(\"pointermove\", ev => {\n  mx = ev.offsetX\n  my = ev.offsetY\n  ev.preventDefault()\n  ev.stopPropagation()\n})\ncvs.addEventListener(\"pointerup\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"pointercancel\", ev => {\n  draw = false\n  ev.preventDefault()\n})\ncvs.addEventListener(\"mousedown\", e => draw=true)\ncvs.addEventListener(\"mouseup\", e => draw=false)\ncvs.addEventListener(\"mousemove\", e => {\n    mx = e.offsetX\n    my = e.offsetY\n})\nrespondToVisibility(cvs, visible => {\n  if (!canvasVisible && visible)\n    setTimeout(animate, 0)\n  canvasVisible = visible\n})\nschedule(function spray() {\n  if (draw) {\n    function emit() {\n      let red = 0\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      let angle = 0.3*Math.PI + random(0.4 * Math.PI)\n      let vx =  Math.cos(angle)\n      let vy = (6)*-Math.sin(angle)\n      let x = mx\n      let y = my\n      let d = 5 + random(15)\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        alpha -= 0.05\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n    }\n    for (var i = 0; i < 10; i++)\n      schedule(emit)\n  }\n  schedule(this)\n})\nschedule(function fire() {\n  if (choice(0.02)) {\n    let cx = random(dimx)\n    let cy = random(dimy)\n    let size = 3 + random(10)\n    let t0 = time\n    schedule(function burn() {\n      let db = size// * Math.log((time-t0))\n      let x = cx\n      let y = cy\n      let vx = 0\n      let vy = -db/2\n      let ay = 1\n      let ax = 1\n      let d = db/2 + random(db/2)\n      let red = 255\n      let green = 255\n      let blue = 255\n      let alpha = 1.0\n      // stations: white, yellow, red, black\n      schedule(function particle() {\n        let color = \"rgba(\"+red+\", \"+green+\", \"+blue+\", \"+alpha+\")\";\n        ctx.lineWidth = d;\n        ctx.fillStyle = color\n        ctx.strokeStyle = color\n        ctx.lineCap = \"round\";\n        ctx.beginPath();\n        ctx.moveTo(x,y);\n        ctx.lineTo(x+1,y+1);\n        ctx.stroke();\n        y += vy\n        x += vx\n        vx = -db/6 + random(db/3)\n        if (vy < -1.5) vy *= 0.9\n        d -= 0.03\n        if (blue > 15)\n            blue -= 15\n        if (green > 3)\n            green -= 3\n        if (green <= 100 && red > 5)\n            red -= 5\n        alpha -= 0.02\n        if (alpha > 0 && d > 0)\n            schedule(this)\n      })\n      if (draw && (my-cy) > 0 && (my-cy) < 20 && Math.abs(mx-cx) < 10) {\n        score += Math.round(db)\n        q.innerText = \"Score: \"+score\n      } else\n        schedule(burn)\n    })\n  }\n  schedule(fire)\n})\n</code>\n<p>Photo from <a href=\"https://unsplash.com\">Unsplash</a></p>\n<p>Happy Holidays and Merry Christmas everyone. Stay safe out there (and in there!)</p>","fields":{"slug":"/Public/Generic/particles/"},"frontmatter":{"date":"December 20, 2020","title":"Fun With Particle Animation","description":"","keywords":null,"tags":null}}},{"node":{"excerpt":"Why? Designing a CPU, just like writing an OS or a compiler, is one of those things that is often thought to require fundamentally different…","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>Why? Designing a CPU, just like writing an OS or a compiler, is one of those things that is often thought to require fundamentally different skills from, say, writing front-end code in JavaScript.</p>\n<p>We’ll show below that this is not the case. In fact, JavaScript makes a fine HDL (hardware description language) and some very modest programming skills are all we need to generate and simulate circuits in the browser, all the way to a simple but functional RISC CPU.</p>\n<p>Before we dive in, it is worth reflecting on some of the big ideas in computing: analog computers, digital computers, stored programs, metaprogramming.</p>\n<aside>\n<p>Big ideas in computing</p>\n<p>Analog computers, digital computers, stored programs, metaprogramming</p>\n<h3>Computing by machine</h3>\n<p>To build a machine that can compute things, map those things to physical quantities (mass, force, pressure, current, voltage) and design a device whose physics correspond to the desired computation. Read out the results by measurement. This is the idea of an analog computer.</p>\n<h3>Discretized computation</h3>\n<p>While analog computers have and had their uses, there are issues with recision and range of values, and in particular it is difficult to robustly encode non-numerical data as analog physical quantities. To solve this, discretize continuous quantities to bits (two states, on or off), and continuous time to a clock signal. This is the idea of a digital computer.</p>\n<h3>Stored programs</h3>\n<p>Instead of building a computer to execute a specific fixed program, treat instructions as data. Load the program from memory, just like the data it operates on. The computer then <em>interprets</em> program instructions one by one. This is the idea of a universal computer that can compute any function that’s computable in principle.</p>\n<h3>Metaprogramming</h3>\n<p>Instead of drawing circuits or encoding instructions by hand, write a program that generates primitive instructions from a higher-level description (program). This is the idea behind compilers and behind modern generative programming approaches that use a high-level programming language as a macro system to generate programs or circuits in highly parameterized ways.</p>\n</aside>\n<p>With that, let’s get started:</p>\n<aside>\n<p>Defining and simulating circuits</p>\n<p>Circuits consist of wires and gates.</p>\n<p>Wires can hold a single bit of information (low voltage or high voltage) and as we will see, we’ll only need one type of gate, the almighty NAND.</p>\n<p>We’ll use a form of generative programming to define circuits, similar in style to state-of-the-art tools like <a href=\"https://www.chisel-lang.org\">Chisel</a> or <a href=\"https://www.spatial-lang.org\">Spatial</a>.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet wires = []\nlet gates = []\nfunction input() {\n  let n = wires.length\n  wires.push(0)\n  return n\n}\nfunction nand(a,b) {\n  let c = wires.length\n  wires.push(0)\n  gates.push({a,b,c})\n  return c\n}\nfunction simulate() {\n  for (let g of gates) {\n    let a = wires[g.a]\n    let b = wires[g.b]\n    wires[g.c] = (~(a&b))&1\n  }\n}\n</code>\n<p>Here’s how to define and simulate our first circuit, consisting of a single NAND gate:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// create circuit:\nlet a = input()\nlet b = input()\nlet c = nand(a,b)\n// and simulate it!\nwires[a] = 0\nwires[b] = 0\nsimulate()\nprint(`NAND(${wires[a]},${wires[b]}) = ${wires[c]}`)\n</code>\n<p><strong>Exercise:</strong> change the wire assignments above to try different\ninputs and observe how the result changes.</p>\n<p>In fact, let’s factor out some useful testing code\nto print truth tables:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction test(s,a,b,c) {\n  for (let u of [0,1]) {\n    for (let v of [0,1]) {\n      wires[a] = u\n      wires[b] = v\n      simulate()\n      print(`${s}(${u},${v}) = ${wires[c]}`)\n    }\n  }\n}\n</code>\n<p>Here we go, the truth table of our simple\nNAND circuit at a single glance:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = input()\nlet c = nand(a,b)\ntest(\"NAND\",a,b,c)\n</code>\n</aside>\n<p>Wires and gates, and how to use JS as a HDL</p>\n<aside>\n<p>Binary logic</p>\n<h3>1-Bit Logic</h3>\n<p>With NAND as a built-in:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = input()\nlet c = nand(a,b)\ntest(\"NAND\",a,b,c)\n</code>\n<p>We can derive all other logical operations:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// !a = !(a&a)\nfunction not(a) {\n  return nand(a,a)\n}\n// a&b = !!(a&b)\nfunction and(a,b) {\n  return not(nand(a,b))\n}\n// a|b = !!(a|b) = !(!a&!b)\nfunction or(a,b) {\n  return nand(not(a),not(b))\n}\n// a^b = a|b & !(a&b) = ...\nfunction xor(a,b) {\n  let c = nand(a,b)\n  return nand(nand(a,c),nand(b,c))\n}\n</code>\n<p>To see how, first realize that logical negation\n!a is !(a&#x26;a). With negation, we obtain AND\nand then, via de Morgan’s rules, OR.</p>\n<p>Let’s test the derived operations:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = input()\nlet c = and(a,b)\nlet d = or(a,b)\nlet e = xor(a,b)\ntest(\"AND\",a,b,c)\ntest(\"OR\",a,b,d)\ntest(\"XOR\",a,b,e)\n</code>\n<h3>N-Bit Logic</h3>\n<p>The basic logic operations extend straightforwardly to\nmultiple bits at a time. We use JS arrays to represent\nmulti-bit wires and values:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction inputN(n) {\n  return Array.from(Array(n), () => input())\n}\nfunction orN(as) {\n  return as.reduce(or)\n}\nfunction andN(as) {\n  return as.reduce(and)\n}\n</code>\n<p>For convenience we also provide functions to initialize and read\nthe value of multiple wires at the same time from and to a\nbitstring. Note that by convention, these bitstrings are ordered\nright to left:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction readDigits(as) {\n  return as.map(i => wires[i]).reverse().join(\"\")\n}\nfunction writeDigits(as,digits) {\n  assert(digits.length == as.length)\n  for (let j in as) {\n    wires[as[j]] = parseInt(digits[as.length-j-1])\n  }\n}\n</code>\n<p>Let’s try it out:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet as = inputN(8)\nlet b = andN(as)\nlet c = orN(as)\nwriteDigits(as, \"11001011\")\nsimulate()\nprint(\"AND: \"+wires[b])\nprint(\"OR:  \"+wires[c])\n</code>\n<p><strong>Exercise:</strong> implement versions of AND and OR operating pairwise on n-bit bitstrings.</p>\n</aside>\n<p>Nand is built-in, everything else is derived</p>\n<aside>\n<h2>Binary arithmetic</h2>\n<h3>Binary Numbers</h3>\n<p>Let’s recap binary numbers. First, recall that a decimal numbers are composed of powers of ten:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">12345 = 1*10000 + 2*1000 + 3*100  + 4*10   + 5*1\n      = 1*10^5  + 2*10^4 + 3*10^3 + 4*10^1 + 5*10^0</code></pre></div>\n<p>Likewise, binary numbers are composed of powers of two:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">11000000111001 = 1*2^13 + 1*2^12 + 1*2^5 + 1*2^4 + 1*2^3 + 1*2^0</code></pre></div>\n<p>Let’s verify our understanding, remembering that <code class=\"language-text\">2^n</code> is a bit shift <code class=\"language-text\">1&lt;&lt;n</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint((1<<13) + (1<<12) + (1<<5) + (1<<4) + (1<<3) + (1<<0))\nprint((12345).toString(2))\n</code>\n<p>We could implement the conversion to and from binary numbers ourselves but JS provides some handy conversion function that we can use directly:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction readInt(as) {\n  let digits = readDigits(as)\n  return parseInt(digits,2)\n}\nfunction writeInt(as,n) {\n  let digits = n.toString(2).padStart(as.length,\"0\")\n  writeDigits(as,digits)\n}\n</code>\n<h3>Two’s Complement</h3>\n<p>How do we deal with negative numbers? We’ll use the standard two’s complement representation. The highest bit is the sign bit (1 means negative), and to negate a number, flip all the bits and add one.</p>\n<p>Sometimes it is necessary to stretch, say, an 8-bit number to 16 bits. For positive numbers we can just add zeros, but if the number is negative that would be wrong; we’d have to pad with ones instead. So in the general case, we pad with whatever is the highest bit (sign extension).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction signExtend(as,n) {\n  assert(as.length <= n)\n  return [...as,...Array(n-as.length).fill(as[as.length-1])]\n}\n</code>\n<h3>1-Bit Addition</h3>\n<p>How to add binary numbers? Just like decimals: for each digit we compute the single-digit sum and a potential carry.</p>\n<p>For single-digit binary numbers, we compute the 1-bit sum using XOR, and the carry using AND, i.e., we have an overflow if both inputs are one. This circuit is called a half adder.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction halfAdder(a,b) {\n  let sum = xor(a,b)\n  let carry = and(a,b)\n  return {sum,carry}\n}\n</code>\n<p>A full adder adds three inputs (the last one is typically an input carry from another digit). The result is again two bits, sum and carry.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction fullAdder(a,b,c) {\n  let ab = halfAdder(a,b)\n  let abc = halfAdder(ab.sum,c)\n  let sum = abc.sum\n  let carry = or (ab.carry, abc.carry)\n  return {sum,carry}\n}\n</code>\n<h3>N-Bit Addition</h3>\n<p>To extend binary addition to n bits, we chain full adders and propagate the carry bit from digit to digit:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction zero() {\n  let z = input(); return xor(z,z)\n}\nfunction nBitParallelAdder(as,bs,c) {\n  let carry = c || zero()\n  let sum = []\n  for (let i in as) {\n    let temp = fullAdder(as[i],bs[i],carry)\n    sum.push(temp.sum)\n    carry = temp.carry\n  }\n  return {sum,carry}\n}\n</code>\n<p>Let’s test it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet as = inputN(4)\nlet bs = inputN(4)\nlet cs = nBitParallelAdder(as,bs).sum\n// compute 4 + 5 = 9\nwriteInt(as,4)\nwriteInt(bs,5)\nsimulate()\n// 4 + 5 = 9  -->  0100 + 0101 = 1001\")\nprint(readInt(as)+\" + \"+readInt(bs)+\" = \"+readInt(cs))\nprint(readDigits(as)+\" + \"+readDigits(bs)+\" = \"+readDigits(cs))\n</code>\n<p><strong>Exercise:</strong> refactor nBitParallelAdder to use the reduce combinator.</p>\n<p><strong>Exercise:</strong> refactor nBitParallelAdder to perform tree reduction instead of linear reduction (result: log-depth circuit instead of linear depth).</p>\n<p><strong>Exercise:</strong> implement subtraction. Hint: recall two’s complement representation. To negate, flip all bits and add one. Implement <code class=\"language-text\">a-b</code> as <code class=\"language-text\">a+(-b)</code>. Can you do better than two additions? Hint: use carry input.</p>\n<p><strong>Exercise:</strong> think about how to implement multiplication (hints: <a href=\"http://www.andraka.com/multipli.php\">http://www.andraka.com/multipli.php</a>).</p>\n</aside>\n<p>Binary numbers, two’s complement, adder circuits</p>\n<aside>\n<p>Structured data</p>\n<p>In addition to flat bitstrings and n-bit numbers we want to operate on structured and compound data. Lookup tables are a key example, which can be queried given a numeric index or a binary search key. We’ll build up to facilities to select from and update such tables below.</p>\n<h3>1-Bit Mux and Demux</h3>\n<p>The basic circuit to select between alternatives\nis the multiplexer. This is basically an if-then-else\noperation, which selects one of two inputs a,b based\non a flag s:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction mux(a,b,s) {\n  return or(and(a,not(s)),and(b,s))\n}\n</code>\n<p>The inverse is the demultiplexer, which forwards\nan input signal to one of two outputs:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction demux(a,s) {\n  return [and(a,not(s)), and(a,s)]\n}\n</code>\n<h3>N-Bit Mux and Select</h3>\n<p>How can we extend the binary mux to select from four\ninstead of two inputs? We add another control wire\nand arrange three binary muxes in a tree shape:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction select4(a,b,c,d,s1,s2) {\n  let ab = mux(a,b,s1)\n  let cd = mux(c,d,s1)\n  return mux(ab,cd,s2)\n}\n</code>\n<p>This pattern generalizes to larger sizes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction selectM(as,ix) {\n  assert(as.length == 1 << ix)\n  // can do this recursively or with a while loop\n  if (as.length >= 2) {\n    // select between neighbors\n    let cs = []\n    for (let j = 0; j < as.length/2; j++) {\n      cs.push(mux(as[2*j],as[2*j+1],ix[0]))\n    }\n    // recurse\n    return selectM(cs,ix.slice(1))\n  } else\n    return as[0]\n}\n</code>\n<p>In another dimension, we can select between n-bit strings:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction select2N(as,bs,s) {\n  // zipWith(as,bs)(select2(_,_,s))\n  assert(as.length == bs.length)\n  let cs = []\n  for (let j in as)\n    cs.push(mux(as[j],bs[j],s))\n  return cs\n}\n</code>\n<p>Putting these two together, we can select between m n-bit strings:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction selectMN(as,ix) {\n  assert(as.length == 1 << ix.length)\n  // can do this recursively or with a while loop\n  if (as.length >= 2) {\n    // select between neighbors\n    let cs = []\n    for (let j = 0; j < as.length/2; j++) {\n      cs.push(select2N(as[2*j],as[2*j+1],ix[0]))\n    }\n    // recurse\n    return selectMN(cs,ix.slice(1))\n  } else\n    return as[0]\n}\nfunction select(as,ix) {\n  let w = as[0].length\n  assert(as.length == 1 << ix.length)\n  as.forEach(x => assert(x.length == w))\n  return selectMN(as,ix)\n}\n</code>\n<h3>N-Bit Demux and Update</h3>\n<p>We proceed in a similar way for demuxes, first of size 4,\nthen of size n:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction demux2(a,s) {\n  return [and(a,not(s)), and(a,s)]\n}\nfunction demux4(a,s1,s2) {\n  let [a1,a2] = demux2(a,s2)\n  return [demux2(a1,s1),demux2(a2,s1)].flat()\n}\nfunction demuxN(a,ix) {\n  if (ix.length == 0)\n    return [a]\n  let [a1,a2] = demux(a,ix[ix.length-1])\n  let ix1 = ix.slice(0,ix.length-1)\n  return [demuxN(a1,ix1),demuxN(a2,ix1)].flat()\n}\n</code>\n<p>Let’s try those.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet ix = inputN(4)\nlet cs = demuxN(a,ix)\nwires[a] = 1\nfor (let n of [0,1,2,3,4,5,6,7]) {\n  writeInt(ix,n)\n  simulate()\n  print(\"2^\"+n+\" = \"+readInt(cs))\n}\n</code>\n<p>Demuxes give us an update facility:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction updateN(as,ix,a,e) {\n  let bs = demuxN(e,ix) // 'enable' flag\n  assert(as.length == bs.length)\n  let cs = []\n  for (let j in as) {\n    cs.push(mux(as[j],a,bs[j])) // select old or new\n  }\n  return cs\n}\nfunction updateMN(as,ix,a,e) {\n  let bs = demuxN(e,ix) // 'enable' flag\n  assert(as.length == bs.length)\n  let cs = []\n  for (let j in as) {\n    cs.push(select2N(as[j],a,bs[j])) // select old or new\n  }\n  return cs\n}\n</code>\n<h3>Select and Update Example</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\n// selectively set a bit to 0\nlet as = inputN(8)\nlet ix = inputN(3)\nlet a = input(1)\nlet bs = updateN(as, ix, a, not(a))\nwriteInt(ix,7)\nwriteInt(as,255)\nprint(readInt(as))\nsimulate()\nprint(readInt(bs))\n</code>\n<p><strong>Exercise:</strong> implement a multiplier circuit that has a complete multiplication table hardwired in a lookup table (LUT).</p>\n</aside>\n<p>Mux and demux, selecting and updating parts of compound data</p>\n<aside>\n<p>State and mutation</p>\n<p>So far our circuits were connected unidirectionally. Data flows in one direction. Evaluating the same circuit multiple times with the same inputs always produces the same result: mathematically, a pure function from inputs to outputs. Such circuits are called <em>combinational</em>. Below, we will make the step to <em>sequential</em> logic, which allows us to implement memory components and other time- and history-dependent computation.</p>\n<h3>State via Recursion</h3>\n<p>What happens if we create cycles? Let’s add functionality to do that.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction rewire(c,b) {\n  let g = gates[gates.length-1]\n  assert(g.c == c, \"can only rewire last gate created!\")\n  g.c = b\n  return b\n}\nfunction cycle(f) {\n  let b = input()\n  let c = f(b)\n  return rewire(c, b)\n}\n//\n// debugging utils\n//\nlet waveforms = {}\nfunction logWires(kvs) {\n  for (let k in kvs) {\n    let w = kvs[k]\n    if (!waveforms[k]) waveforms[k] = []\n    waveforms[k].push(wires[w])\n  }\n}\nfunction printWaveforms() {\n  for (let k in waveforms)\n    print(k+\": \"+waveforms[k].join(\"\"))\n}\n</code>\n<p>Now we wire up the output of an OR gate back to its input:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet a = input()\nlet b = cycle(b => or(a,b))\n// simulate 20 steps, and pulse a=1 once at step 5\nfor (let i = 0; i < 20; i++) {\n  wires[a] = i == 5 ? \"1\" : \"0\"\n  simulate()\n  logWires({a,b})\n}\nprintWaveforms()\n</code>\n<p>We can see that the 1 pulse on input a triggered\na permanent state change, flipping b to 1.\nIntuitively the result of the circuit is the OR\nover all past inputs a.</p>\n<p>Creating cycles is the key idea behind stateful circuits.</p>\n<p>Note: In real hardware, cycles are a bit tricky and need\nto be synchronized with a central clock signal. For us, each\ncall to <code class=\"language-text\">simulate</code> is an implicit clock tick so we don’t\nneed to worry about this (but see aside below for more).</p>\n<aside>\n<h3>Flip Flop Basics, From Async Logic to Sync Logic</h3>\n<p>In real hardware, cycles are a bit tricky because of timing.\nChanges in voltage propagate asynchronously so additional\nmeasures are needed for deterministic behavior.\nThat’s why computer chips use a central clock signal\n(010101010101 etc.) to sychronize state changes.</p>\n<p>Our simulator is synchronous so we don’t have to worry\nabout it here. Every step is a tick of the clock signal,\nand our <code class=\"language-text\">cycle</code> abstraction implicitly delays the the\nresult by one iteration. In a physical circuit this\nbehavior can be implemented using NAND gates as well\n(read more in the aside below).</p>\n<p>How can we turn the output back to 0 after we\nflipped it to 1? Let’s build a set-reset latch (SR latch).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction setResetNandLatch(s,r) {\n  let q = input()\n  let notq = input()\n  let q1 = nand(s,notq)\n  rewire(q1,q)\n  let notq1 = nand(r,q)\n  rewire(notq1,notq)\n  return {q,notq}\n}\nfunction setResetLatch(s,r) {\n  return setResetNandLatch(not(s),not(r)).q\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet s = input()\nlet r = input()\nlet q = setResetLatch(s,r)\n// simulate 20 steps\nfor (let i = 0; i < 20; i++) {\n  wires[s] = i % 5 == 0 ? \"1\" : \"0\"\n  wires[r] = i % 5 == 2 ? \"1\" : \"0\"\n  simulate()\n  logWires({S:s,R:r,Q:q})\n}\nprintWaveforms()\n</code>\n<p>Neat. What else could we want? A flip flop that stores a value from one input when given a signal on another input.</p>\n<p>This is the D Latch.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction dataLatch(d,e) {\n  let s = and(d,e)\n  let r = and(not(d),e)\n  return setResetLatch(s,r)\n}\n</code>\n<p>We introduce a clock c and switch on the rising clock edge. One clock cycle takes 8 simulation steps (4 high, 4 low). This needs to be large enough to allow the propagation through all cycles in the circuit to settle:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet d = input()\nlet clock = input()\nlet q = dataLatch(d,clock)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 5 ? \"1\" : \"0\"\n  if (i % 4 == 0)wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,q})\n}\nprintWaveforms()\n</code>\n<p>Remaining issue: while the clock signal is on, the circuit is “open” and directly propagates D to Q. So if D changes during a clock cycle the output will change as well (we say that the D-Latch is transparent and level-sensitive).</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet d = input()\nlet clock = input()\nlet q = dataLatch(d,clock)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 9 ? \"1\" : \"0\"\n  if (i % 4 == 0)wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,q})\n}\nprintWaveforms()\n</code>\n<p>Fix: remember value until next cycle. Use two latches: the result is the D Flip-Flop (or D Register).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction dFlipFlop(d,e) {\n  let q1 = dataLatch(d,not(e))\n  let q2 = dataLatch(q1,e)\n  return q2\n}\n</code>\n<p>Now switches in both directions are stable and synchronized with the rising edge of the clock signal:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet d = input()\nlet clock = input()\nlet q = dFlipFlop(d,clock)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 5 ? \"1\" : \"0\"\n  if (i % 4 == 0)wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,q})\n}\nprintWaveforms()\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet d = input()\nlet clock = input()\nlet q = dFlipFlop(d,clock)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 9 ? \"1\" : \"0\"\n  if (i % 4 == 0)wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,q})\n}\nprintWaveforms()\n</code>\n<p>We have a stable memory cell: a 1-bit register.</p>\n<h3>Abstract One Step</h3>\n<p>Let’s do an alternative. Treat the delay latch as built-in. Our simulation is discrete, so we can obtain the desired behavior directly. Benefit: more clarity, disregard timing issues, one clock cycle corresponds to one simulation step.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction delay(a) {\n  let b0 = input()\n  let b = or(b0,b0)\n  let b1 = or(a,a)\n  rewire(b1,b0)\n  return b\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet clock = input()\nlet d = delay(clock)\nlet e = delay(d)\nfor (let i = 0; i < 20; i++) {\n  wires[clock] = 1-wires[clock]\n  simulate()\n  logWires({c:clock,d,e})\n}\nprintWaveforms()\n</code>\n<p>The way our cycle construct is implemented it already has a delay built in. This means that we can implement a 1-bit register directly by selecting (using a mux) whether we want to keep the previous value or use the new one.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction register(d,e) {\n  return cycle(r => mux(r,d,e))\n}\n</code>\n<p>As we would expect, the register updates its value whenever the e input gets a pulse:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet clock = input()\nlet d = input()\nlet e = input()\nlet q = register(d,e)\nfor (let i = 0; i < 20; i++) {\n  wires[clock] = 1-wires[clock]\n  wires[d] = i < 5 || i > 12 ? \"0\" : \"1\"\n  wires[e] = i == 9 || i == 15 ? \"1\" : \"0\"\n  simulate()\n  logWires({c:clock,d,e,q})\n}\nprintWaveforms()\n</code>\n</aside>\n<p>How can we turn the output back to 0 after we flipped it to 1? Let’s build a register cell (a flip-flip). We use an additional input line to decide whether we want to keep the previous value or use the new one, and a mux to implement the switch.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction register(d,e) {\n  return cycle(r => mux(r,d,e))\n}\n</code>\n<p>The register updates its value to d whenever input e gets a pulse:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet d = input()\nlet e = input()\nlet q = register(d,e)\nfor (let i = 0; i < 20; i++) {\n  wires[d] = i < 5 || i > 12 ? \"0\" : \"1\"\n  wires[e] = i == 9 || i == 15 ? \"1\" : \"0\"\n  simulate()\n  logWires({d,e,q})\n}\nprintWaveforms()\n</code>\n<h3>Feedback Loops with Structured Data</h3>\n<p>Cycles extend straightforwardly to n-bit data:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction cycleN(n,f) {\n  let bs = inputN(n)\n  let cs = f(bs)\n  for (let i in cs) {\n    rewire(or(cs[i],cs[i]), bs[i])\n  }\n  return bs\n}\n</code>\n<p>And we can go even further, adding an automatic\nlayer of flattening and unflattening based on\na given data descriptor (an array that contains\nthe size in bits of each field):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction flatten(ns,as) {\n  return as.flat()\n}\nfunction unflatten(ns,as) {\n  let bs = []\n  let k = 0\n  for (let j in ns) {\n    bs.push(as.slice(k,k+ns[j]))\n    k += ns[j]\n  }\n  assert(k == as.length)\n  return bs\n}\nfunction cycleS(ns,f) {\n  let n = ns.reduce((a,b)=>a+b)\n  return unflatten(ns,cycleN(n,\n    a => flatten(ns,f(unflatten(ns,a)))))\n}\n</code>\n<p>Although not done here, it would be straightforward\nto support multiple levels of nesting and\nflatten/unflatten recursively.</p>\n<p><strong>Exercise:</strong> implement recursive flatten/unflatten.</p>\n</aside>\n<p>Implement state using recursion (feedback loops)</p>\n<aside>\n<p>Translating programs to circuits</p>\n<h3>From Programs to Hardware</h3>\n<p>By now we have built up a rich set of circuit structures, so\nwe can translate many kinds of programs to hardware:</p>\n<ul>\n<li>Numbers are encoded in binary, we’ve seen circuits for arithmetic</li>\n<li>Mutable variables become registers</li>\n<li>Arrays becomes register banks (structured sets of registers)</li>\n<li>Loops are expressed through sequential logic</li>\n</ul>\n<p><strong>Exercise:</strong> how to implement functions?</p>\n<p>To go as far and implement functions, we can follow one of the following ideas (listed by increasing complexity):</p>\n<ol>\n<li>Inline all function calls, i.e., treat functions as macros (leads to size blowup, and only works for non-recursive functions)</li>\n<li>Allocate one register for each function to store an identifier of the calling function (solves the circuit size problem at the expense of latency, but still cannot support recursion)</li>\n<li>Use a memory component / register bank to represent a call stack (supports first-order recursive functions)</li>\n<li>Use a memory component to represent a heap and allocate functions as closures (supports higher-order functions)</li>\n</ol>\n<h3>Example: Counters using Sequential Logic</h3>\n<p>Without going into the details of all these, let’s consider a tractable but interesting example: a loop that independently increments two counters of different bit-widths:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet d = inputN(3)\nlet [c8,c1] = cycleS([3,1], ([c8,c1]) =>\n  [nBitParallelAdder(c8,d).sum,\n   nBitParallelAdder(c1,d).sum])\nwriteInt(d,1)\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"C8: \"+readInt(c8) + \" C1: \"+ readInt(c1))\n}\n</code>\n<p><strong>Exercise:</strong> increment one of the counters at a fractional speed, i.e., only every second (or third, or fourth) iteration.</p>\n<p><strong>Exercise:</strong> implement a multiplication circuit using sequential logic.</p>\n</aside>\n<p>Putting things together</p>\n<aside>\n<p>The CPU and assembler</p>\n<p>We’ve discussed how to translate more or less arbitrary programs to circuits. We’ll now apply this idea to a special kind of program: an interpreter for computing instructions encoded in binary.</p>\n<h3>Basic Control Loop</h3>\n<p>We’ll use a helper function to create a chunk of memory:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction readOnlyMemory(memsize,wordsize) {\n  let shape = Array(memsize).fill(wordsize)\n  return unflatten(shape, inputN(memsize*wordsize))\n}\n</code>\n<p>The basic control loop for our CPU will look as follows.\nIn every cycle we fetch an instruction from memory at the\naddress indicated by the PC (program counter), execute\nit (left for later), and increment the PC to point to the\nnext instruction:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet pcsize = 8\n// inputs/aux\nlet one = inputN(pcsize)\nwriteInt(one,1)\n// control loop\nlet [pc] = cycleS([pcsize], ([pc]) => {\n  // fetch instruction\n  let instr = select(memory,pc)\n  //\n  // TODO: decode and execute instruction!\n  //\n  // update pc\n  let pc1 = nBitParallelAdder(pc,one).sum\n  return [pc1]\n})\n// simulation\nfor (let i = 0; i < 5; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc))\n}\n</code>\n<h3>Add a Register File</h3>\n<p>In addition to the PC register, our CPU has a\nregister file consisting of 8 16-bit registers which\ncan be inspected and modified by CPU instructions:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet nregs = 8\nlet pcsize = 8\nlet wordsize = 16\n// inputs/aux\nlet memory = readOnlyMemory(256,wordsize)\nlet regshape = Array(nregs).fill(wordsize)\nlet one = inputN(pcsize)\nwriteInt(one,1)\n// control loop\nlet [pc,regfile] = cycleS([pcsize,nregs*wordsize], ([pc,regfile]) => {\n  // fetch instruction\n  let instr = select(memory,pc)\n  // load registers\n  let regs = unflatten(regshape, regfile)\n  //\n  // TODO: decode and execute instruction!\n  //       (arithmetic + update registers)\n  //\n  // store registers\n  let regfile1 = flatten(regshape,regs)\n  // update pc: either inc or jmp\n  let pc1 = nBitParallelAdder(pc,one).sum\n  return [pc1,regfile1]\n})\nlet regs = unflatten(regshape, regfile)\n// simulation\nfor (let i = 0; i < 5; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1]))\n}\n</code>\n<h3>Code is Data: Defining the ISA</h3>\n<p>With the basic control logic set up it’s time to define\nour ISA (Instruction Set Architecture), i.e., the language\nof instructions our CPU will interpret.</p>\n<p>Our CPU supports only four instructions, given below as\nassembly mnemomics and specifying their semantics in\npseudocode:</p>\n<ul>\n<li>\n<p>add rd ra</p>\n<p><code class=\"language-text\">regs(rd) += regs(ra); pc += 1</code></p>\n</li>\n<li>\n<p>sub rd ra</p>\n<p><code class=\"language-text\">regs(rd) -= regs(ra); pc += 1</code></p>\n</li>\n<li>\n<p>li rd imm</p>\n<p><code class=\"language-text\">regs(rd) = imm; pc += 1</code></p>\n</li>\n<li>\n<p>bnz rd imm</p>\n<p><code class=\"language-text\">if (regs(rd) != 0) pc = imm else pc += 1</code></p>\n</li>\n</ul>\n<p>All four instructions are encoded using the\nfollowing binary format:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">16               8      5      2    0\n+-----------------------------------+\n|       imm      |  ra  |  rd  | op |\n+-----------------------------------+</code></pre></div>\n<p>The field <code class=\"language-text\">op</code> contains the binary “opcode”: 0 for add, 1 for sub, 2 for li (“load immediate”), 3 for bnz (“branch if non-zero”). Field <code class=\"language-text\">rd</code> specifies the destination register (3-bits, i.e. 0..8), field <code class=\"language-text\">ra</code> the source register, field <code class=\"language-text\">imm</code> an immediate numeric value encoded in the instruction.</p>\n<h3>The CPU</h3>\n<p>With the ISA spec’ed out, we’re ready to fill in the logic that interprets individual instructions, which completes the full CPU:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction cpu() {\n  let nregs = 8\n  let pcsize = 8\n  let wordsize = 16\n  // inputs/aux\n  let regshape = Array(nregs).fill(wordsize)\n  let one = inputN(pcsize)\n  writeInt(one,1)\n  // control loop\n  let [pc,regfile] = cycleS([pcsize,nregs*wordsize], ([pc,regfile]) => {\n    // fetch instruction\n    let instr = select(memory,pc)\n    let [opc,rd,ra,imm] = unflatten([2,3,3,8],instr)\n    // load registers\n    let regs = unflatten(regshape, regfile)\n    let vrd = select(regs,rd)\n    let vra = select(regs,ra)\n    // arithmetic computation\n    let neg = opc[0] // add or sub?\n    let vra1 = select2N(vra, vra.map(a => not(a)), neg)\n    let vadd = nBitParallelAdder(vrd,vra1,neg).sum // add/sub use same adder\n    let vimm = signExtend(imm,wordsize)\n    // update registers\n    let vrd1 = select([vadd,vadd,vimm,vrd],opc)\n    let regs1 = updateMN(regs,rd,vrd1,one[0])\n    let regfile1 = flatten(regshape,regs1)\n    // update pc: either inc or jmp\n    let pc1 = nBitParallelAdder(pc,one).sum\n    let jmp = select2N(pc1,imm,vrd.reduce(or)) // branch if non zero\n    let pc2 = select([pc1,pc1,pc1,jmp],opc)\n    return [pc2,regfile1]\n  })\n  let regs = unflatten(regshape, regfile)\n  return [pc,regs]\n}\n</code>\n<h3>Example: Countdown</h3>\n<p>Let’s try our CPU on a simple but nontrivial example program that counts down from 8 by 2 until reaching 0 and then starts over:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet [pc,regs] = cpu(memory)\n// program in machine language\nwriteDigits(memory[0],\"00001000\"+\"000\"+\"000\"+\"10\") // li r0 8\nwriteDigits(memory[1],\"00000010\"+\"000\"+\"001\"+\"10\") // li r1 2\nwriteDigits(memory[2],\"00000000\"+\"001\"+\"000\"+\"01\") // sub r0 r1\nwriteDigits(memory[3],\"00000010\"+\"000\"+\"000\"+\"11\") // bnz r0 2\nwriteDigits(memory[4],\"00000000\"+\"000\"+\"001\"+\"11\") // bnz r1 0\n// simulation\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1]))\n}\n</code>\n<p>Nice!!! But programming in binary is a pain. Let’s build an assembler!</p>\n<h3>Building an Assembler</h3>\n<p>Again we use a form of generative\nprogramming, so that we can use assembly instructions as if\nwe were writing normal code.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet label = 0\nfunction digits(n,width) {\n  assert(n < (1 << width))\n  return n.toString(2).padStart(width,\"0\")\n}\nfunction emitInstr(opc,rd,ra,imm) {\n  let ds = digits(imm,8)+digits(ra,3)+digits(rd,3)+digits(opc,2)\n  writeDigits(memory[label++],ds)\n}\nlet asm = {\n  add: function(rd, ra) {\n    emitInstr(0,rd,ra,0)\n  },\n  sub: function(rd, ra) {\n    emitInstr(1,rd,ra,0)\n  },\n  li: function(rd, imm) {\n    emitInstr(2,rd,0,imm)\n  },\n  bnz: function(rd, imm) {\n    emitInstr(3,rd,0,imm)\n  }\n}\n</code>\n<p>Let’s run our countdown program again, this\ntime written using proper assembly instructions:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet [pc,regs] = cpu(memory)\n// assembly program\nasm.li(0,8)\nasm.li(1,2)\nasm.sub(0,1)\nasm.bnz(0,2)\nasm.bnz(1,0)\n// simulation\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1]))\n}\n</code>\n<p>Sweet! Can we do something else? Why don’t we multiply\nsome numbers.</p>\n<h3>Example: Multiplication in ASM</h3>\n<p>Let’s compute the equivalent of <code class=\"language-text\">r0 = r1 * r2</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet memory = readOnlyMemory(256,16)\nlet [pc,regs] = cpu(memory)\n// assembly program\nasm.li(0,0) // r0 holds result\nasm.li(1,3) // r1 = 3\nasm.li(2,4) // r2 = 4\nasm.li(3,1)\nlet loop = label\nasm.add(0,1) // r0 += r1\nasm.sub(2,3) // r2 -= 1\nasm.bnz(2,loop)\nasm.bnz(3,label) // inf loop to stop\n// simulation\nfor (let i = 0; i < 20; i++) {\n  simulate()\n  print(\"PC: \"+readInt(pc)+\n       \" R0: \"+readInt(regs[0])+\n       \" R1: \"+readInt(regs[1])+\n       \" R2: \"+readInt(regs[2]))\n}\n</code>\n<p>Neato. Now where are we and what’s missing?</p>\n<h3>Where are we?</h3>\n<p>We’ve gotten far for a tutorial and simulated a CPU from the ground up using nothing but NAND gates. But of course we’ve barely scratched the space of CPU design yet.</p>\n<p>The most immediate limitation right now is that memory is currently read-only, and only used to load instructions.</p>\n<p><strong>Exercise:</strong> make memory accessible for user programs using load/store instructions.</p>\n<p>There are some complications if we don’t want to duplicate the memory access logic. This is one reason why real CPUs split instruction execution into multiple phases, so that the memory controller can be used through different paths in each phase.</p>\n<p>Apart from that, there is a host of additional functionality that could be implemented, for example:</p>\n<ul>\n<li>memory loads/stores, bitshifts, logical operations, multiplication, division, interrupts, privileged mode, virtual memory, floating point, SIMD, multicore, …</li>\n</ul>\n<p>There are also important optimizations in real-word CPU designs that could be implemented here:</p>\n<ul>\n<li>pipelining, caches, out-of-order execution, branch prediction, …</li>\n</ul>\n<p>Another fun exercise would be to synthesize the CPU and run it on an FPGA instead of simulating it in the browser.</p>\n<p><strong>Exercise:</strong> implement a code generator that takes a circuit definition (wires and gates) and emits Verilog code, suitable for FPGA synthesis (or perhaps <a href=\"https://www.chisel-lang.org/firrtl/\">FIRRTL</a> as alternative).</p>\n</aside>\n<p>There we are!</p>\n<aside>\n<p>Appendix</p>\n<h3>Where to go from here</h3>\n<p>Important take-aways: code is data, hardware is the new software.</p>\n<ul>\n<li>Translate programs to circuits</li>\n<li>Special case: ISA interpreter = CPU</li>\n<li>Generative programming, like in Chisel or Spatial</li>\n</ul>\n<p>Things to try next:</p>\n<ul>\n<li>Add features, use a standard ISA (e.g. RISV-V)</li>\n<li>Optimizations: pipelining, caches, etc.</li>\n<li>Build a SoC (System on Chip), add IO, etc</li>\n<li>Run on an FPGA</li>\n</ul>\n<h3>Resources</h3>\n<p>Hardware design</p>\n<ul>\n<li><a href=\"https://computationstructures.org\">MIT 6.004 Computation Structures (2017)</a></li>\n<li><a href=\"https://eater.net\">Build an 8-bit CPU from scratch</a></li>\n<li><a href=\"https://eater.net\">NAND game</a></li>\n</ul>\n<p>Tiny CPUs</p>\n<ul>\n<li><a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/assignments/optional.pdf\">MIT 6.189 CPU design assignment</a></li>\n<li><a href=\"http://people.inf.ethz.ch/wirth/FPGA-relatedWork/\">Niklaus Wirth: Experiments in Computer System Design</a></li>\n<li><a href=\"https://www.cl.cam.ac.uk/teaching/1112/ECAD+Arch/files/Thacker-A_Tiny_Computer-3.pdf\">Chuck Thacker: A Tiny Computer</a></li>\n</ul>\n<p>Full-system design</p>\n<ul>\n<li><a href=\"https://www.nand2tetris.org\">Nand to Tetris</a></li>\n<li><a href=\"http://selfie.cs.uni-salzburg.at\">Selfie</a></li>\n<li><a href=\"https://people.inf.ethz.ch/wirth/ProjectOberon/index.html\">Oberon</a></li>\n</ul>\n<p>Modern HDL tools</p>\n<ul>\n<li><a href=\"https://www.chisel-lang.org\">Chisel</a></li>\n<li><a href=\"https://www.spatial-lang.org\">Spatial</a></li>\n</ul>\n<p>RISC-V</p>\n<ul>\n<li><a href=\"https://gitlab.com/nedopc/npc5/blob/master/emu-rv32i.c\">RISC-V emulator in one file</a></li>\n<li><a href=\"https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/\">RISC-V online</a></li>\n<li><a href=\"https://bellard.org/tinyemu/\">Fabrice Bellard: TinyEmu</a></li>\n<li><a href=\"https://inst.eecs.berkeley.edu//~cs61c/resources/RISCV_Green_Sheet.pdf\">RISC-V Green Sheet</a></li>\n<li><a href=\"https://msyksphinz-self.github.io/riscv-isadoc/\">RISC-V ISA docs</a></li>\n</ul>\n</aside>\n<p>Where to go next and resources</p>","fields":{"slug":"/Public/Generic/lets-build-a-microprocessor/"},"frontmatter":{"date":"December 14, 2020","title":"Let's Build a Microprocessor!","description":"From NAND to RISC, using JavaScript as a HDL","keywords":null,"tags":null}}},{"node":{"excerpt":"This is a whirlwind tour of writing parsers by hand. Why would you want to do that, when tools like Yacc exist to do it for you? It’s highly…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        invokeOnClear()\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nlet clearHook = null\nfunction onclear(f) {\n  clearHook = f\n}\nfunction invokeOnClear() {\n  if (clearHook) {\n    clearHook()\n    clearHook = null\n  }\n}\nfunction clear() {\n    invokeOnClear()\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>This is a whirlwind tour of writing parsers by hand. Why would you want to do that, when tools like Yacc exist to do it for you?</p>\n<ul>\n<li>It’s highly instructive, in a way that using a parser generator is not. To quote Feynman: “What I cannot create, I do not understand”</li>\n<li>It’s an important skill: most real-world compilers use hand-written parsers because they provide more control over error handling, significant whitespace, etc.</li>\n<li>It’s not actually difficult!</li>\n</ul>\n<p>If you’re an educator, here are some additional thoughts:</p>\n<aside>\n<p>The role of parsing in compiler classes</p>\n<p>Nothing gets CS academics and amateur compiler <a href=\"https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/\">astronauts</a> more excited than the zoo of parsing techniques and their relative strengths and weaknesses.</p>\n<p>Your average compiler class? Expect several weeks of grammar formalisms (LL, LR, LALR, SLR, etc) and automata construction. Instructors love it because it feels “deep” and because students don’t <em>really</em> have to understand it. In the end, they can just hack their grammar definition until Yacc (or the instructor’s equivalent tool of choice) stops complaining about shift/reduce conflicts.</p>\n<p>My take? The theory of formal languages and their relation to automata, logic, and complexity is beautiful. But if the goal is to convey practical compiler-building skills I believe we should forget about most of the formalisms focused on subclasses of context-free languages and instead teach students straightforward methods to write parsers by hand:</p>\n<ul>\n<li>Very few compiler classes treat formal languages at an <em>actual</em> rigorous level (theorems, proofs, etc.) so this topic is best served by a dedicated theory of computation class (think Myhill-Nerode, Chomsky-Schützenberger, LBA theorem, etc.).</li>\n<li>The large focus on parsing takes away time and space from teaching other interesting (and arguably more relevant) aspects of compilers: compiling expressive language features, optimizations, advanced static checking, or dynamic runtimes.</li>\n<li>Context-free grammar formalisms are less relevant than one might think. Most realistic compilers need degrees of context-sensitivity and thus use hand-written parsers: either because the core language grammar is context-sensitive (e.g., significant whitespace as in Python) or because the general user experience profits from context-sensitivity (e.g., error handling, feedback in IDEs).</li>\n</ul>\n<p>So should we just not teach parsing at all? Just use a tool and be done with it? Absolutely not. Parsing is an important topic and can be quite insightful when taught the right way.</p>\n<p>Blindly using a tool without understanding what it does is never a good idea.\nBy contrast, writing a recursive-descent parser from scratch:</p>\n<ul>\n<li>is highly instructive, in a way that using a parser generator is not (Feynman: “What I cannot create, I do not understand”)</li>\n<li>is a highly relevant practical skill, given that most real-world compilers use hand-written parsers (for reasons noted above)</li>\n<li>is not actually difficult!</li>\n</ul>\n<p>Clearly, there is more to be said about teaching effective compiler classes (topic for another post!). But finding the right angle to cover parsing appears to be a key ingredient — it certainly has been for me in redesigning <a href=\"https://tiarkrompf.github.io/cs502/\">my classes at Purdue</a>.</p>\n</aside>\n<h3>The Result</h3>\n<p>We focus on arithmetic expressions, but the concepts and techniques immediately generalize to richer languages.</p>\n<p>Enter an expression on the left and see the parse tree change!</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n//\n// core dom utils\n//\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\n//\n// text selection utils\n//\nfunction findOffsetInParent(node, pos, top) {\n  if (node == top)\n    return pos;\n  while (node.previousSibling) {\n    node = node.previousSibling;\n    var len = node.nodeType == 3 ? node.length : node.innerText.length;\n    pos = len + pos;\n  }\n  return findOffsetInParent(node.parentNode, pos, top);\n}\nfunction findChildForOffset(node, pos) {\n  var len = node.nodeType == 3 ? node.length : node.innerText.length;\n  if (pos > len)\n    return findChildForOffset(node.nextSibling, pos - len);\n  if (node.firstChild)\n    return findChildForOffset(node.firstChild, pos);\n  return {node: node, pos: pos};\n}\n//\n// text editor\n//\nlet text\nlet p = document.createElement(\"pre\")\nlet d = document.createElement(\"pre\")\nlet row = document.createElement(\"div\")\nd.style[\"border\"] = \"1px solid black\"\nrow.style[\"display\"] = \"flex\"\nrow.appendChild(p)\nrow.appendChild(d)\no.appendChild(row)\np.setAttribute(\"contenteditable\", false)\np.setAttribute(\"spellcheck\", false)\np.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\np.style[\"border\"] = \"1px solid black\"\np.style[\"width\"] = \"250px\"\np.style[\"height\"] = \"200px\"\np.style[\"outline\"] = \"none\"\np.style[\"overflow\"] = \"scroll\"\nd.style[\"width\"] = \"250px\"\nd.style[\"height\"] = \"200px\"\nd.style[\"margin-left\"] = \"10px\"\nd.style[\"overflow\"] = \"scroll\"\np.addEventListener(\"beforeinput\", ev => {\n  ev.preventDefault()\n  let data = ev.data || ev.dataTransfer?.getData(\"text/plain\") || \"\"\n  if (ev.inputType == \"insertLineBreak\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  // CHROME WORKAROUND!\n  let startOffset = 0\n  if (!range) {\n    range = window.getSelection().getRangeAt(0)\n    if (ev.inputType==\"deleteContentBackward\" && range.startContainer == range.endContainer && range.startOffset == range.endOffset)\n      startOffset = 1\n  }\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  if (start > 0) start -= startOffset\n  edit(start, end, data)\n  select(start + data.length, start + data.length)\n})\nfunction edit(start, end, data) {\n  text = text.substring(0, start) + data + text.substring(end, text.length)\n  p.innerText = \"\"\n  d.innerText = \"\"\n  try {\n    let txt = parse(text)\n    let ast = walk(txt)\n    p.appendChild(txt)\n    d.appendChild(ast)\n  } catch(ex) {\n    print(ex)\n  }\n}\nfunction select(start, end) {\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\n//\n// parser state & lexer\n//\nlet input, pos, peek\nlet gap\nlet str\nlet indent\nlet seq\nfunction init(s) {\n  seq = []\n  input = s;\n  pos = 0;\n  indent = gap = whitespace();\n  read()\n}\nfunction next() {\n  if (gap > 0) seq.push(\"\".padStart(gap, ' ')) // FIXME: comments!\n  if (peek != str && peek != '\\n')\n    seq.push(dom(peek, \"\", str))\n  else\n    seq.push(str)\n  let c = peek;\n  gap = whitespace();\n  read()\n  return c\n}\nfunction read() {\n  let isdigit = () => '0' <= input[pos] && input[pos] <= '9'\n  let isletter = () => 'a' <= input[pos] && input[pos] <= 'z' || 'A' <= input[pos] && input[pos] <= 'Z'\n  let start = pos\n  if (isdigit()) {\n    while (isdigit()) pos++\n    peek = \"num\"\n  } else if (isletter()) {\n    while (isletter() || isdigit()) pos++\n    peek = \"ident\"\n  } else if (input[pos] == '\\n') {\n    while (input[pos] == '\\n') {\n      peek = input[pos++]\n      indent = whitespace()\n    }\n  } else {\n    peek = input[pos++]\n  }\n  str = input.substring(start,pos)\n}\nfunction whitespace() {\n  let start = pos\n  while (input[pos] == ' ') ++pos\n  if (input[pos] == '/' && input[pos+1] == '/') {\n    pos += 2\n    while (input[pos] && input[pos] != '\\n') ++pos\n  }\n  return pos - start\n}\n//\n// parser aux\n//\nfunction dom(key, info, children) {\n  let d = e(\"span\",{key,info},...children)\n  if (key == \"error\") {\n    d.style[\"padding\"] = \"1px\"\n    d.style[\"background\"] = \"red\"\n  }\n  return d\n}\nfunction collect(k,f) {\n  let save = seq\n  let res = []\n  seq = res\n  try { f() } finally {\n  seq = save\n  let d = dom(k,\"\",res)\n  seq.push(d)\n  }\n  return res\n}\nfunction error(msg) {\n  seq.push(dom(\"error\", msg, []))\n  collect(\"skip\", () => {\n    while (peek && peek != '\\n' && peek != '*' && peek != '+' && peek != ')')\n      next()\n  })\n  throw new Error(msg)\n}\nfunction expect(d) {\n  if (peek == d) {\n    next()\n  } else {\n    try { error(d+\" expected\") }\n    catch (ex) {\n      if (peek == d) next(); else throw ex\n    }\n  }\n}\n//\n// main parser logic\n//\nfunction split(d,f) {\n  collect(d, () => {\n    for (;;) { try { f(); } catch (ex) {}; if (peek == d) next(); else break }    })\n}\nfunction splitNL(d,f) {\n    for (;;) { f(); if (peek == '\\n' && indent == d) next(); else break }\n}\nfunction block(ind) {\n  function expr() {\n    split('=', () => {\n      split('+', () => {\n        split('*', () => {\n          if (peek == '\\n' && indent > ind) {\n            collect('I'+indent, () => {\n              next()\n              block(indent)\n              if (peek == '\\n' && indent == ind) next()\n            })\n          } else if (peek == '(') {\n            collect('()', () => {\n              next()\n              try { expr() } catch(ex) {} // could rethrow if no match\n              expect(')')\n            })\n          } else if (peek == \"num\" || peek == \"ident\") {\n            next()\n          } else {\n            error(\"atom expected\")\n          }\n        })\n      })\n    })\n  }\n  splitNL(ind, () => {\n    if (peek && peek != '\\n')\n      expr()\n  })\n}\n//\n// string -> cst (concrete syntax tree: structured text as html dom)\n//\nfunction parse(text) {\n  try {\n    init(text)\n    block(indent)\n    let max = 20\n    while (peek && max--) {\n      try { error(\"unexpected \"+peek) } catch(ex) {}\n      //if (isDelimiter(peek))\n        next()\n      block(indent)\n    }\n    if (peek) error(\"unexpected \"+peek)\n    // Q: need to emit last gap?\n  } catch (ex) {}\n  if (pos-1 < text.length) {\n    seq.push(dom(\"skipped\",\"\",[text.substring(pos-1,text.length)]))\n  }\n  return dom(\"P\",\"\",seq)\n}\n//\n// cst -> ast (abstract syntax tree: html dom formatted as tree)\n//\nfunction walk(a) {\n  let ch = []\n  for (let c of a.children) ch.push(walk(c))\n  //if (a.key in {'+':0,'*':0,'⏎':0,'=':0,'T':0} && ch.length == 1) return ch[0]\n  if (ch.length == 1) return ch[0]\n  let l = (a.key + \" \\\"\"+ (a.info||a.textContent) + \"\\\"\").replaceAll(\"\\n\",\"⏎\");    let d = e(\"div\", {}, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  return d\n}\n//\n// main\n//\n{\n  text = \"3+4*5*(1+2)\\n\"\n  let txt = parse(text)\n  let ast = walk(txt)\n  p.appendChild(txt)\n  d.appendChild(ast)\n}\n</code>\n<h3>Step by Step</h3>\n<aside>\n<h3>Step 1 - Arithmetic Expressions and Operator Precedence</h3>\n<p>One thing that’s often thought to be a challenge for hand-written parsers is parsing arithmetic expressions with the proper operator precedence, e.g., parsing <code class=\"language-text\">2*6+4*5</code> as <code class=\"language-text\">(2*6)+(4*5)</code>.</p>\n<p>But faster than you can say recursive descent, LL(1), factoring, left recursion, Pratt parsing, etc., I’ll show you how to do it in 10 lines of JavaScript.</p>\n<p>Ready? Here you go (imperative style):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet input = \"2*6+4*5\"\nlet sum = 0\nfor (let term of input.split(\"+\")) {\n  let prod = 1\n  for (let factor of term.split(\"*\")) {\n    prod *= Number.parseInt(factor)\n  }\n  sum += prod\n}\nprint(sum + \" == \" + (2*6+4*5))\n</code>\n<p>Oh, you prefer a functional style? Bam, 2 lines.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet prod = s => s.split(\"*\").map(Number).reduce((x,y)=>x*y)\nlet sum  = s => s.split(\"+\").map(prod).reduce((x,y)=>x+y)\nprint(sum(\"2*6+4*5\") + \" == \" + (2*6+4*5))\n</code>\n<p>The code snippets above are editable, so feel free to play around!</p>\n<p>Clearly this is not the end of the road. But if parsing simple expressions with the right precedence (”<code class=\"language-text\">*</code>” before ”<code class=\"language-text\">+</code>”) is all you wanted to do <em>you can stop right here!</em> Nothing else is needed.</p>\n<p>Even if you want to go further, it’s important to realize that the basic idea behind operator precedence and in fact most other parsing tasks is <em>right there</em>:</p>\n<blockquote>\n<p>Repeatedly group the input based on delimiter characters</p>\n</blockquote>\n<p><strong>Exercise:</strong> the code above is editable - change it to build an AST instead of computing the result directly. Hint: use JS arrays to build S-expressions such as <code class=\"language-text\">[&quot;+&quot;, [&quot;*&quot;, 2, 6], [&quot;*&quot;, 4, 5]]</code>.</p>\n<p><strong>Exercise:</strong> prove that the input language is a regular language (corollary: no context-free grammar or parsing approach is necessary so far, a deterministic finite automaton (DFA) is sufficient). Hint: provide a regular expression that describes the input language or a DFA that parses it.</p>\n</aside>\n<aside>\n<h3>Step 2 - Parsing in a Single Pass</h3>\n<p>The first implementation above is inefficient: it traverses and copies the input string multiple times. This may not actually matter in practice, but sometimes it does. It also makes it a bit harder to add certain other features, some of which are important.</p>\n<p><strong>Exercise:</strong> think about how you’d add support for parentheses (”<code class=\"language-text\">(...)</code>”) above. Will your idea deal with <code class=\"language-text\">(1+2)+7*((3+4)*7)+5</code> correctly?</p>\n<p>Let’s change the code to process the input strictly left to right. What’s the best way to guarantee this? We’ll use an iterator interface that only allows to inspect the current character and advance to the next.</p>\n<code class=\"runScript\" filter=\"setPreamble\">\nlet input, pos, peek\nfunction init(s) { input = s; pos = 0; peek = input[pos++] }\nfunction next() { let c = peek; peek = input[pos++]; return c }\n</code>\n<p>Instead of using JS’s built-in <code class=\"language-text\">String.split</code> function, we implement our own replacement. Since we don’t want to return a string (which would need to be traversed again) we take a callback function as argument:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction split(d,f) {\n  for (;;) { f(); if (peek == d) next(); else break }\n}\n</code>\n<p>The way we use <code class=\"language-text\">split</code> is as follows. It’s really similar to what we had before — the main difference is that the string to be split is now implicit.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction expr() {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\n</code>\n<p>We’re modularizing things a little bit on the way. The core expression parsing logic has moved to its own function <code class=\"language-text\">expr</code>, and we add a driver function <code class=\"language-text\">parse</code> to run it.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction parse(s) {\n  init(s)\n  let res = expr()\n  assert(!peek, \"unexpected input: \"+peek)\n  return res\n}\n</code>\n<p>The top-level function <code class=\"language-text\">parse</code> also checks that we’ve consumed the entire input. This is important, because:</p>\n<blockquote>\n<p>Internal routines are set up to stop consuming input when they can’t make sense of the next character.</p>\n</blockquote>\n<p>The last missing piece is our own function to parse numbers:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction number() {\n  let isdigit = () => '0' <= peek && peek <= '9'\n  assert(isdigit(), \"expected a number: \"+peek)\n  let n = Number(next())\n  while (isdigit())\n    n = n * 10 + Number(next())\n  return n\n}\n</code>\n<p>The <code class=\"language-text\">assert</code> serves to assure that there is at least one digit.</p>\n<p>Now we’re ready to run examples:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"2*6+4*5\") + \" == \" + (2*6+4*5))\n</code>\n<p><strong>Exercise:</strong> how much faster is this version? (a) asymptotically, in big-O terms (b) experimentally, in milliseconds on sufficiently large inputs.</p>\n</aside>\n<aside>\n<h3>Step 3 - Parentheses and Recursive Grouping</h3>\n<p>Let’s add parentheses! These can be arbitrarily nested, so our parser becomes recursive. Hence, the approach is called “recursive descent”:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction expr() {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      if (peek == '(') {\n        next()           // consume opening paren\n        prod *= expr()   // parse nested expression\n        assert(peek == ')', \"expected ')': \"+peek)\n        next()           // consume closing paren\n      } else\n        prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\n</code>\n<p>Done!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"2*(6+4)*5\") + \" == \" + (2*(6+4)*5))\n</code>\n<p>Looking at the formal language side of things, recursion without parameters means that the grammar is <em>context-free</em>: an expression is always parsed the same way, independent of the context it appears in.</p>\n</aside>\n<aside>\n<h3>Step 4 - Whitespace and Basic Tokenization</h3>\n<p>Wouldn’t it be nice to be able to add spaces anywhere?</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction whitespace() {\n  while (input[pos] == ' ' || input[pos] == '\\n') pos++\n}\nfunction init(s) { input = s; pos = 0; read() }\nfunction read() { whitespace(); peek = input[pos++] }\nfunction next() { let c = peek; read(); return c }\n</code>\n<p>Done! We no longer return every character but chose to skip some we want to ignore.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"2 * ( 6 + 4 ) * 5\") + \" == \" + (2*(6+4)*5))\n</code>\n<p>Our handling of whitespace is an instance of an important pattern: lexical scanning or <em>tokenization</em>. Instead of blindly iterating over raw characters, iterate over meaningful chunks of characters (“tokens”).</p>\n<p><strong>Exercise:</strong> add line comments: skip to end of line when seeing <code class=\"language-text\">#</code> or <code class=\"language-text\">//</code></p>\n<p><strong>Exercise:</strong> add delimited comments: skip parts enclosed between <code class=\"language-text\">/*</code> and <code class=\"language-text\">*/</code>. There is a design choice whether these should be nestable. Try both versions!</p>\n<p>Note that the current implementation literally allows spaces <em>everywhere</em>, including as part of a number. This may or may not be what we want!</p>\n<p><strong>Exercise:</strong> treat numbers as atomic <em>tokens</em>. Hint: modify <code class=\"language-text\">number</code> so that it can be invoked from <code class=\"language-text\">read</code>.</p>\n<aside>\n<p>Solution</p>\n<p>Here is a fairly complete tokenizer solution that also recognizes identifiers and line comments, for good measure:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet str\nfunction read() {\n  let isdigit = () => '0' <= input[pos] && input[pos] <= '9'\n  let isletter = () => 'a' <= input[pos] && input[pos] <= 'z' || 'A' <= input[pos] && input[pos] <= 'Z'\n  let start = pos\n  if (isdigit()) {\n    while (isdigit()) pos++\n    peek = \"num\"\n  } else if (isletter()) {\n    while (isletter() || isdigit()) pos++\n    peek = \"ident\"\n  } else if (input[pos] == '\\n') {\n    while (input[pos] == '\\n') {\n      peek = input[pos++]\n      indent = whitespace()\n    }\n  } else {\n    peek = input[pos++]\n  }\n  str = input.substring(start,pos)\n}\nfunction whitespace() {\n  let start = pos\n  while (input[pos] == ' ') ++pos\n  if (input[pos] == '/' && input[pos+1] == '/') {\n    pos += 2\n    while (input[pos] && input[pos] != '\\n') ++pos\n  }\n  return pos - start\n}\n</code>\n<p>Note that <code class=\"language-text\">peek</code> will be set to string literals <code class=\"language-text\">&quot;num&quot;</code> or <code class=\"language-text\">&quot;ident&quot;</code>, whereas <code class=\"language-text\">str</code> will hold the data actually read. Conversion to an actual number is elided in the snippet above.</p>\n</aside>\n<p>Tokenization is not essential (“scannerless” parsers exist), but it is a useful design pattern and can be seen as an optimization. In particular it enables distinguishing between keywords (e.g., <code class=\"language-text\">if</code>,<code class=\"language-text\">else</code>, etc.) and identifiers (i.e., potential variable names) without backtracking.</p>\n</aside>\n<aside>\n<h3>Step 5 - Significant Whitespace</h3>\n<p>Some languages like Python attach meaning to whitespace and use indentation to indicate grouping, much like braces or parantheses in other languages.</p>\n<p>How can we achieve this in our parser? We need two small changes. First, we no longer skip newlines (only spaces) and we keep track of the number of spaces at the beginning of a line:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction whitespace() {\n  let start = pos\n  while (input[pos] == ' ') pos++\n  return pos - start\n}\nlet indent\nfunction init(s) { input = s; pos = 0; indent = whitespace(); read() }\nfunction next() { let c = peek; read(); return c }\nfunction read() {\n  whitespace(); peek = input[pos++]\n  if (peek == '\\n') indent = whitespace()\n}\n</code>\n<p>Second, we keep track of the current indentation of each expression and proceed much like we do for parentheses when we detect a newline with increased indentation:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction expr(ind) {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      if (peek == '\\n' && indent > ind) {\n        next()\n        prod *= expr(indent)\n        if (peek == '\\n' && indent == ind) next()\n      } else if (peek == '(') {\n        next()\n        prod *= expr(ind)\n        assert(peek == ')', \"expected ')': \"+peek); next()\n      } else\n        prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\nfunction parse(s) {\n  init(s)\n  let res = expr(indent)\n  assert(!peek, \"unexpected input: \"+peek)\n  return res\n}\n</code>\n<p>Now we can parse indented blocks as an alternative grouping mechanism to parentheses, or both in combination. An example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet inp = `3*(\n 1+4*\n  2\n+2)`\nprint(parse(inp) + \" == \" + (3*((1+4*(2))+2)))\n</code>\n<p>From a formal language perspective, our input language is now <em>context-sensitive</em>: how exactly an expression is parsed depends on the context it occurs in. Note how this is easily and efficiently implemented by parameterizing the recursive function <code class=\"language-text\">expr</code> with a context abstraction <code class=\"language-text\">ind</code>.</p>\n<p><strong>Exercise</strong>: observe that our parser always requires a closing paranthesis but leaves “exdentation” optional. Why is this a reasonable choice, and what would change if exdentation were required? Try it out!</p>\n</aside>\n<aside>\n<h3>Step 6 - Error Handling and Recovery</h3>\n<p>Right now our parser immediately throws an exception and aborts when\nencountering an error in the program.</p>\n<p>This can be a reasonable strategy, but it’s often more useful to see if there are additional errors in a program so that the programmer can decide which one to fix first (clearly, there are trade-offs!).</p>\n<p>A useful strategy is to skip input until the next known delimiter whenever we hit an error:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction error(msg) {\n  while (peek && peek != '\\n' && peek != '*' && peek != '+' && peek != ')')\n    next()\n  throw new Error(msg)\n}\n</code>\n<p>We now want to unwind the stack as much as necessary to pick up the right case (<code class=\"language-text\">*</code> or <code class=\"language-text\">+</code> or <code class=\"language-text\">)</code> etc.)</p>\n<p>To achieve this, the code that deals with delimiters is modified to try proceeding normally after an error:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction split(d,f) {\n  for (;;) {\n    try { f() } catch (ex) { }\n    // we know that we stopped at a delimiter,\n    // let's see if it was possibly ours\n    if (peek == d) next(); else break\n  }\n}\n</code>\n<p>Note how this strategy maps very closely to standard exception handling patterns in a recursive-descent context.</p>\n<p>For cases where we expect a specific token such as a closing parenthesis, we can implement a helper function <code class=\"language-text\">expect</code> that tries to skip ahead if the token is not found immediately and either continues if the token is found in this way or propagates the error if a non-matching delimiter was found instead:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction expect(d) {\n  if (peek == d) {\n    next()\n  } else {\n    try { error(d+\" expected\") }\n    catch (ex) {\n      if (peek == d) next(); else throw ex\n    }\n  }\n}\n</code>\n<p>Another missing piece is that we might hit an error after parsing a perfectly valid prefix of the program. This means that we terminate early with some input left over. To deal with such situations, we need to insert pieces of retry logic in critical places, including at the very top:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction parse(text) {\n  init(text)\n  expr(indent)\n  let max = 20\n  while (peek && max--) {\n    try { error(\"unexpected input:\"+peek) } catch(ex) {};\n    if (isDelimiter(peek)) next()\n    expr(indent)\n  }\n  if (peek) error(\"unexpected input:\"+peek) // exceeded max, skip rest\n}\n</code>\n<p>In general, it’s a good idea to impose an upper bound on the number of such retries.</p>\n<p>These forms of error handling are all included in the example on the front page of this post.</p>\n</code>\n</aside>\n<aside>\n<p>Step 7 - Scaling Up</p>\n<p>The language we’ve considered has remained simple on purpose, but the techniques we discussed scale to much more complicated scenarios.</p>\n<p>To conclude, let’s discuss just one extension, namely a general design pattern to support many more operators with varying precedence levels and left- or right associativity (commonly attributed to Vaughan Pratt).</p>\n<p>Recall our initial implementation of <code class=\"language-text\">expr</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction expr() {\n  let sum = 0\n  split('+', () => {\n    let prod = 1\n    split('*', () => {\n      if (peek == '(') {\n        next()\n        prod *= expr()\n        assert(peek == ')', \"expected ')': \"+peek)\n        next()\n      } else\n        prod *= number()\n    })\n    sum += prod\n  })\n  return sum\n}\n</code>\n<p>How should we add support for <code class=\"language-text\">-</code>, <code class=\"language-text\">/</code>, and potentially many others? Clearly we can extend <code class=\"language-text\">split</code> to look for sets of operators but we still have to list all possible precedence levels explicitly and implement the right evaluation logic in one place. This could get hairy!</p>\n<p>Let’s refactor:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet eval = {\n  '+': (x,y) => x+y,\n  '-': (x,y) => x-y,\n  '*': (x,y) => x*y,\n  '/': (x,y) => x/y\n}\nfunction factor() {\n  if (peek == '(') {\n    next()\n    let res = expr()\n    assert(peek == ')', \"expected ')': \"+peek)\n    next()\n    return res\n  } else\n    return number()\n}\nfunction term() {\n  let res = factor()\n  while (peek == '*' || peek == '/')\n    res = eval[next()](res, factor())\n  return res\n}\nfunction expr() {\n  let res = term()\n  while (peek == '+' || peek == '-')\n    res = eval[next()](res, term())\n  return res\n}\n</code>\n<p>On the surface we haven’t gained much as we still have only two levels of precedence — but it turns out that we can actually use a single function if we extract the current level of precedence as a parameter:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// precedence: higher binds tighter\nlet prec = {\n  '+': 100,\n  '-': 100,\n  '*': 200,\n  '/': 200\n}\n// associativity: 1 for left, 0 for right\nlet assoc = {\n  '+': 1,\n  '-': 1,\n  '*': 1,\n  '/': 1\n}\nfunction binop(min) {\n  let res = factor()\n  while (peek in prec && prec[peek] >= min) {\n    let nextMin = prec[peek] + assoc[peek] // + 1 for left assoc\n    res = eval[next()](res, binop(nextMin))\n  }\n  return res\n}\nfunction expr() {\n  return binop(0)\n}\n</code>\n<p>Voilà, now we can support an arbitrary number of operators with varying precedence levels and associativity behavior.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(parse(\"8-12/3\") + \" == \" + (8-12/3))\n</code>\n</aside>\n<!--\n\nPart 2: More Mechanics and Extensions (left for a future update!)\n\nStep 6 - Tokenization<br/>\nStep 7 - Error Handling<br/>\nStep 8 - Statements<br/>\nStep 9 - Arbitrary Operators<br/>\n\n\n<aside>\n\n### Step 6 - Tokenization\n\n\nAdd let, perhaps prints\n\n</aside>\n\n\n\n<aside>\n\n### Step 7 - Error Handling\n\nKeep stack of delimiters, skip ahead to next one. Need to return to right enclosing one.\n\n</aside>\n\n\n<aside>\n\n### Step 8 - Statements\n\nLet's add statements, delimited by newlines.\n\nTODO: idents, def, let, call, etc?\n\nSo far: as part of an indented block, consume the \"exdent\", the closing newline with parent indent. This means that we can continue reading input on that line as part of the starting expression.\n\nWhen we use newlines also to delimit statements this means that we won't \"see\" the same newline as delimiter because it is already consumed as exdent.\n\nExample:\n\n<pre>\ndef foo(x) =\n  3 + 4\nprint(7)\n</pre>\n\nWould currently be parsed as:\n\n<pre>\ndef foo(x) = (3 + 4) print(7)\n</pre>\n\nSo we'll need to rewrite it with an additional newline as\n\n<pre>\ndef foo(x) =\n  3 + 4\n\nprint(7)\n</pre>\n\nto get it parsed correctly.\n\nIf this is not what we want, there is a simple fix: just don't consume the exdent newline. Instead, leave it to be picked up as statement delimiter.\n\nThis rules out\n\n<pre>\n3 *\n  1 + 2\n+ 5\n</pre>\n\nwhich is unavoidable, but it also rules out\n\n<pre>\n3 * (\n  1 + 2\n) + 5\n</pre>\n\nforcing it to be written as\n\n<pre>\n3 * (\n  1 + 2) + 5\n</pre>\n\nwhich is less desirable.\n\nFortunately there is again a simple fix by allowing an optional exdent before a closing paren.\n\nCode:\n\n\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction splitNL(d,f) {\n    for (;;) { f(); if (peek == '\\n' && indent == d) next(); else break }\n}\nfunction expr(ind) {\n  function expr1() { // single line\n    let sum = 0\n    split('+', () => {\n      let prod = 1\n      split('*', () => {\n        if (peek == '\\n' && indent > ind) {\n          next()\n          prod *= expr(indent)\n          // do not consume exdent\n          //if (peek == '\\n' && indent == ind) next()\n        } else if (peek == '(') {\n          next()\n          prod *= expr1()\n          // allow exdented closing paren\n          if (peek == '\\n' && indent == ind) next()\n          assert(peek == ')', \"expected ')': \"+peek); next()\n        } else\n          prod *= number()\n      })\n      sum += prod\n    })\n    return sum\n  }\n  let last = 0\n  splitNL(ind, () => {\n    last = expr1()\n    print(ind+\": \"+last)\n  })\n  return last\n}\n</code>\n\nExample:\n\n<code class=\"runScript\" filter=\"coolEditor\">\nlet inp = `1\n2\n3+(\n 9\n 8+\n   7\n)+\n   9\n   2\n5`\nprint(parse(inp) + \" == \" + (3*((1+4*(2))+2)))\n</code>\n\n\n</aside>\n\n\n\n\n\n<aside>\n\n### Step 9 - Arbitrary Operators\n\nPrecedence and associativity tables\n\n</aside>\n\n-->","fields":{"slug":"/Public/Generic/just-write-the-parser/"},"frontmatter":{"date":"October 19, 2020","title":"Just write the #!%/* parser","description":"Writing parsers from scratch. Why simpler is better and why you don't need a parser generator.","keywords":"parsing, grammar, operator precedence, associativity, whitespace, Python, indentation, LL(1), LR(1), LALR(1), recursive descent","tags":null}}},{"node":{"excerpt":"We propose a generic system of qualified types as unifying basis for traditionally disparate features, including regions, borrowing, non…","html":"<p>We propose a generic system of qualified types as unifying basis for traditionally disparate features, including regions, borrowing, non-escaping, stack allocation, aliasing, effect tracking, etc.</p>\n<h3>Intuition</h3>\n<p>The key idea is to reflect the qualifiers of variables a function closes over in the type of the function. An example:</p>\n<pre>\nval u = ...            // type: A^α\nval v = ...            // type: B^β\ndef f(x:T):U =\n  ... use u and v ...  // type (T -> U)^(α ⨆ β)\n</pre>\n<p>Qualifiers on T and U are possible as well but not used here.</p>\n<p>The system is a generalization of the type system for “2nd-class values” presented in the following paper:</p>\n<ul>\n<li><a href=\"https://www.cs.purdue.edu/homes/rompf/papers/osvald-oopsla16.pdf\">Gentrification Gone too Far? Affordable 2nd-Class Values for Fun and (Co-)Effect</a>.\nLeo Osvald, Grégory Essertel, Xilun Wu, Lilliam I. González-Alayón, Tiark Rompf. OOPSLA ‘16</li>\n</ul>\n<h3>Applications</h3>\n<ul>\n<li><aside>\n<h2>Region-Based Memory</h2>\n<p>Type qualifiers can denote a separation of the heap into disjoint memory regions. The type system ensures that closures are allocated in the same region as the values they close over. Closing over multiple values from different regions would be prohibited in the simplest model.</p>\n<p>A partial ordering between regions relaxes this constraint, and permits references to region <code class=\"language-text\">α</code> from region <code class=\"language-text\">β</code> iff <code class=\"language-text\">α ≤ β</code> (meaning <code class=\"language-text\">α</code> has a lifetime at least as long as <code class=\"language-text\">β</code>). The default region <code class=\"language-text\">⊥</code> is the smallest according to this order (with the longest lifetime), allowing incoming references from all other regions but no outgoing references.</p>\n<p><strong>Exercise</strong>: relate formally to Tofte &#x26; Talpin’s stack-of-regions system (and/or others from the literature).</p>\n<p><strong>Exercise</strong>: recast region system case study from OOPSLA’16 in the formalism presented here.</p>\n</aside>\n<p>Warm-up</p>\n<li><aside>\n<h2>Guaranteed Stack Allocation</h2>\n<p>Consider two regions <code class=\"language-text\">heap</code> and <code class=\"language-text\">stack</code>, with <code class=\"language-text\">heap ≤ stack</code>. Now restrict function types to <code class=\"language-text\">T1^α -&gt; T2^heap</code>.</p>\n<p>See OOPSLA’16 paper (Osvald et al.) for formalization and proof.</p>\n<p>Note that by subsumption, we can treat any <code class=\"language-text\">T^heap</code> value as <code class=\"language-text\">T^stack</code>, so the approximation is one-sided (“may stack” but not “must stack”).</p>\n<p>But if an allocation statement (e.g., a λ-expression or other introduction form) is typed as <code class=\"language-text\">stack</code> we know that we can indeed safely allocate it on the stack. Since functions can never return <code class=\"language-text\">stack</code> values, we can safely deallocate the ones created during a function call on function exit.</p>\n<p>See further down below for a refinement of this idea!</p>\n</aside>\n<p>OOPSLA’16</p>\n<li><aside>\n<h2>Non-Escaping (“Borrowed”) Effect Capabilities (Co-Effects)</h2>\n<p>Stack allocation is a useful optimization if the language runtime supports it, but there are other uses for non-escaping guarantees as well. Identifying “heap” values as 1st-class (unrestricted) and “stack” values as 2nd-class (with some restrictions) turns out to enable a range of interesting programming patterns. A particularly attractive use case is to use 2nd-class values as <em>effect capabilities</em> that are guaranteed to be valid only during the dynamic extent of a particular function call.</p>\n<p>Such capabilities represent a new take on checked effect systems (co-effects, in the terminology of Petricek et al.). A key benefit compared to standard type-and-effect systems is a more flexible approach to effect polymorphism that requires fewer user-facing annotations.</p>\n<p>See OOPSLA’16 paper (Osvald et al.) for details.</p>\n<p>The paper includes a large case study on adding checked exceptions to the Scala standard library. Of particular interest are higher-order functions like <code class=\"language-text\">map</code>, <code class=\"language-text\">flatMap</code>, etc. in the collections library, especially variants for parallel and non-strict collections.</p>\n<p>Qualifier polymorphism elegantly supports all these different variants. The implementation (and formalism) permits arbitrary Scala types (incl. abstract, bounded, etc. types) as qualifiers and thus unifies the Scala type lattice with the qualifier lattice.</p>\n</aside>\n<p>OOPSLA’16</p>\n<li><aside>\n<h2>Non-Escaping Continuations that are Compiled to Jumps</h2>\n<p>Traditionally, converting a program into continuation-passing style (CPS) turns blocks into closures and jumps into function calls. Since functions no longer return, the notion of a call stack disappears, and the program relies on heap allocation exclusively.</p>\n<p>Using our system of qualified types, we can introduce continuations with stack-bounded lifetimes, meaning that a stack discipline of function calls is preserved across CPS conversion (similar to earlier work by Kennedy, but more flexible).</p>\n<p>See ICFP’19 paper (Cong et al.) for details.</p>\n<p>The formal model includes returning and non-returning functions and combines a type-directed selective CPS transform with the present type sytem for escaping and non-escaping values.</p>\n<p><strong>Exercise</strong>: extend the formal model (the available control operators and the selective CPS transform) to the full CPS hierarchy, including multiple levels of delimited continuations.</p>\n</aside>\n<p>ICFP’19</p>\n<li><aside>\n<h2>More Stack Allocation, and Currying for Co-Effect Systems</h2>\n<p>The 1st- and 2nd class model as presented so far is clearly useful, both for stack allocation as optimization and as a general programming model with strong guarantees.</p>\n<p>However, there are some limitations: since function types are restricted to always return 1st-class (heap) values, a function that takes a 2nd-class (stack) value as argument cannot be curried. It is not permitted to return a function that would close over this argument, as that function would need to be typed as 2nd-class as well!</p>\n<p>What would happen if we relax this constraint and just permit arbitrary qualifiers for function return types?</p>\n<p>Nothing bad happens at the type level, but clearly we can’t perform actual stack allocation anymore. And moreover, it is not really clear anymore in a formal sense what precise guarantees the type sytems provides - so what is the right soundness theorem to prove?</p>\n<p>In practice, we found ourselves often converting pieces of code to CPS when we wanted to “return” 2nd-class values, which allowed us to keep growing the stack.</p>\n<p>This lead to a very interesting new idea: what if - in direct style - we just don’t pop the stack? Let’s keep allocating 2nd-class values on the stack, and if a function returns a 2nd-class value, then we simply don’t pop the stack frame. We keep growing the stack, until we reach a caller that returns a 1st-class value. At that point we pop the stack, potentially discarding multiple stack frames at once.</p>\n<p>With that insight, we keep a precise and useful safety guarantee (stack allocation, non-escape behavior subject to qualifiers). And moreover, we obtain a more flexible and powerful stack allocation strategy: now that we have a mechanism to return freshly stack-allocated values up the call chain, we can allocate many more values on the stack!</p>\n<p>And of course we now support currying of 2nd-class functions.\nAnother interesting observation is that we can now eta-expand an equivalent of C’s <code class=\"language-text\">alloca</code> primitive into a proper function.</p>\n<p><strong>Exercise</strong>: adapt proofs from OOPSLA’16 paper to support “lazy-popping” strategy.</p>\n<p><strong>Exercise</strong>: prove lockstep-equivalence with CPS transform (ICFP’19 paper).</p>\n<p><strong>Exercise</strong>: experimentally evaluate the benefits (time, space) of extended stack allocation on a range of benchmarks, using a runtime that supports both stack allocation and GC (e.g., Scala Offheap, Go, Swift, C++ Boehm GC).</p>\n<p><strong>Exercise</strong>: there are good reasons why allocating large amounts of data on the actual call stack might not be the best idea. An alternative is to use a shadow stack, and for some (uncooperative) environments this is in fact the only choice (e.g., Scala Offheap). Compare using the physical call stack with using a shadow stack in suitable environments.</p>\n<p><strong>Exercise</strong>: what is the operational model if we add (potentially an unbounded number of) qualifiers beyond “stack” and “heap”? Many (nested?) regions that each operate as a stack?</p>\n<p><strong>Exercise</strong>: under what conditions can we support storing stack-allocated values in mutable stack-allocated variables? Variables further down the stack appear to be OK, but what about variables further up in situations where we don’t pop the stack right away?</p>\n</aside>\n<p>NEW! “What if we don’t Pop the Stack?”</p>\n<li><aside>\n<h2>Isolating Nonterminating Fragments in Dependently-Typed Programs</h2>\n<p>Based on the observation that non-termination is a side effect, why don’t we guard potential non-termination by a 2nd-class capability, just like other effects (exceptions, IO)?</p>\n<p>A key use case where non-termination must be ruled out is in dependently-typed languages, where computations may forms parts of types but these computations are required to be pure (= terminating) for logical consistency.</p>\n<p>At the same time, it is attractive to support non-termination and potentially other side effects in parts of the program that are <em>not</em> executed at type-checking time.</p>\n<p>The simplest proof-of-concept model provides recursive functions, where the recursive binding is wrapped in a type <code class=\"language-text\">Rec</code> which needs to be explicitly unwrapped (using <code class=\"language-text\">unrec</code>) with a “Turing Capability” (<code class=\"language-text\">CanDiverge</code>) as parameter. The result of <code class=\"language-text\">unrec</code> is a 2nd-class value (can’t escape, can’t be stored).</p>\n<pre>\nTerms\n  e ::= n | x | λf(x).e | e e | unrec e e\n\nTypes\n  T ::= Nat | T1^α -> T2^β | Rec T | CanDiverge\n\nType qualifiers\n  α,β,γ ::= 1 | 2\n\nType assigment:\n\n  Γ^γ, f: Rec(T1^α -> T2^β)^γ, x:T1^α ⊢ e: T2^β\n  --------------------------------------------- (abs)\n  Γ ⊢ λf(x).e: (T1^α)^γ\n\n\n  Γ ⊢ e1: Rec(T)^α  Γ ⊢ e2: CanDiverge^2\n  --------------------------------------- (unrec)\n  Γ ⊢ unrec e1 e2: T^2\n</pre>\n<p><strong>Exercise</strong>: write a few simple recursive programs (e.g., fac, fib) as examples. Assume that the main program gets passed a Turing capability as 2nd-class argument.</p>\n<p><strong>Exercise</strong>: complete the proof for a combined soundness/termination theorem, depending on whether a Turing capability is present in the environment. Proof setup based on combined logical relation and step-indexed logical relation, as described in the Zombie paper (Casinghino et al. POPL’14).</p>\n<p><strong>Exercise</strong>: extend a full dependently-typed language with Turing capabilities, and potentially other side effects. Perhaps based directly on the Zombie artifacts (Casinghino et al. POPL’14).</p>\n<p><strong>Exercise</strong>: extend DOT / Scala with full dependent types, using Turing capabilities to ensure termination of path expressions in type selections (<code class=\"language-text\">e.T</code>) which is necessary for type soundness.</p>\n</aside>\n<p>NEW! “Turing Capabilities - Non-Termination as a Co-Effect”</p>\n<li><aside>\n<h2>Tracking Aliasing and Separation</h2>\n<p>Knowing that two values must be <em>separate</em>, i.e., that they may not <em>alias</em>, enables powerful optimizations. In particular, the two values can be modified independently, without synchronization, and potentially in parallel.</p>\n<p>Regions can provide a (fine-grained) approximation: if values belong to regions that are separate, the values must be separate.</p>\n<p>In a region-monmorphic system this is straightforward. But what if regions can be abstracted over?</p>\n<!-- **XXX:** closures and self types as second ingredient? relate to Tofte and Talpin? -->\n<h3>Key Idea: A “For All Separate Regions” Quantifier</h3>\n<p>We introduce a quantifer that can only be instantiated with regions that are separate from the regions used by the epression quantified over.</p>\n<p>This is enabled crucially by the fact that the region assigned to an abstraction subsumes all the regions it accesses from the definition-site environment.</p>\n<p>Hence, checking separation of the argument from the region of the abstraction is enough to guarantee separation from everything used at the definition site.</p>\n<h3>Formalization</h3>\n<pre>\nTerms\n  e ::= n | x | λf(x).e | e e\n\n              | Λα.e | e[α]\n\nTypes\n  T ::= Nat | T1^α -> T2^β\n\n            | ∀α.T^β\n\nType assigment:\n\n  Function abstraction (standard):\n\n  Γ^γ, x:T1^α ⊢ e: T2^β\n  -------------------------------- (abs)\n  Γ ⊢ λf(x).e: (T1^α -> T2^β)^γ\n\n  Γ ⊢ e1: (T1^α -> T2^β)^γ    Γ ⊢ e1: T1^α\n  ------------------------------------------- (app)\n  Γ ⊢ e1 e2: T2^β\n\n  Region abstraction (new):\n\n  Γ^γ, α::Region ⊢ e: T^β\n  ------------------------ (rabs)\n  Γ ⊢ Λα.e: (∀α.T^β)^γ\n\n  Γ ⊢ e: (∀(α≤α').T^β)^γ    δ⨅γ = α'\n  ------------------------------------- (rapp)\n  Γ ⊢ e[δ]: [δ/α]T^β\n\n</pre>\n<p>Bounded quantification can be added to enable partial overlap. With this extension the last two rules become the following:</p>\n<pre>\n  Γ, α≤α' ⊢ e: T^β\n  ------------------------ (rabs)\n  Γ ⊢ Λα≤α'.e: (∀α.T)^β\n\n  Γ ⊢ e: ∀α≤α'.T^β    δ⨅β ≤ α'\n  ------------------------------- (rapp)\n  Γ ⊢ e[δ]: [δ/α]T^β\n</pre>\n<p>Typically we want to be able to create new regions as well.\nIt is straightforward to add a <code class=\"language-text\">letregion</code> construct in the\nstyle of Milner &#x26; Tofte:</p>\n<pre>\n  Γ, α::Region ⊢ e: T^β   α not in FV(β)\n  ---------------------------------------- (rapp)\n  Γ ⊢ letregion α in e: T^β\n</pre>\n<p><strong>Exercise:</strong> work through some examples.</p>\n<p><strong>Exercise:</strong> establish metatheory.</p>\n<!--\n\n### Example\n\n<pre>\n  let x = e1 in e2\n  (λx.e2)e1\n\n\nMotivation:\n\n<pre>\n  let f = (λ().\n    let c = alloc()\n    λ().c)\n  let g = f()\n  let h = g()\n</pre>\n\nTyping:\n\n<pre>\n  alloc\n     : ∀α.()->R^α\n  c' = Λα.λc.λ().c\n     : ∀α.R^α -> (() -> R^α)^α\n  f  = Λα.λ().c'[α](alloc[α]())\n     : ∀α.() -> (() -> R^α)^α\n  f' = Λα.λf.g'[α](f[α]()\n  g  : ∀α.(() -> R^α)^α  // can't be ∀α.(() -> R^α)^α !!\n  h  :\n</pre>\n\n\n<pre>\n  λf:(∀α.R^α).\n   f[α](alloc[α]())\n</pre>\n\n-->\n</aside>\n<p>NEW! A quantifier for regions that are separate</p>\n<li><aside>\n<h2>Dependency Tracking for Graph IRs</h2>\n<p>Graph IRs are powerful because program expressions can float around freely (code motion), be easily merged together with equivalent ones (CSE), dropped when never used (DCE), or replaced with a cheaper implementation (rewriting, strength reduction).</p>\n<p>This works really well for functional programs, but things get more complicated when side effects need to be supported. Tracking dependencies between side-effecting statements accurately is a challenge. Modeling affected state too coarsely (in the limit, distinguishing only between yes/no effects) means one won’t be able to move stuff around anymore. Modeling state too finely imposes heavy computational demands on the dependency analysis and risks overlooking some dependencies which may lead to incorrect transformations.</p>\n<p>The goal of this work is to develop a new foundation for effects and dependency analysis in the LMS compiler framework.\nLMS is built around a sophisticated Graph IR that includes pure and effectful statements as well as structured expressions such as lambdas which pose additional challenges. Building dependency analysis on a type system based on lambda calculus immediately extends the Graph IR model from first-order to higher-order programs.</p>\n<!-- Our first thrust is to infer precise dependencies between side-effecting statements, given a model of 2nd-class mutable variables. Variables can be created and passed around freely in a program, but there are no indirect references, i.e., variables cannot contain other variables. This is a reasonable model for many AI and HPC workloads based on flat tensors or arrays. -->\n<p>See also: <a href=\"/Public/Generic/graph-ir\">Prototype Implementation</a></p>\n<h3>One Variable, One Region</h3>\n<p>Our solution is to use sets of program variables as type qualifiers.</p>\n<p>A type <code class=\"language-text\">T^{}</code> means the value may not (directly or indirectly) refer to any tracked variable in context, <code class=\"language-text\">T^{x,y}</code> means it may refer to tracked variables <code class=\"language-text\">x</code> or <code class=\"language-text\">y</code>. We use the standard subset relation as partial order.</p>\n<!-- TODO: Example here? -->\n<p>We first consider a model where all variables are tracked. It is straightforward to add a distinction that also supports non-tracked values, with a separate qualifer <code class=\"language-text\">T^0</code> and taking either <code class=\"language-text\">0 &lt; {}</code> or <code class=\"language-text\">0 ≠ {}</code> (allowing non-tracked values to become temporarily tracked or not). We consider this extension at the bottom of this note.</p>\n<p>Type assignment: let us consider the <code class=\"language-text\">let</code>-rule first.</p>\n<pre>\n  Γ ⊢ e1: T1^α\n  Γ, x:T1^(α,x) ⊢ e: T2^β\n  -------------------------------- (let)\n  Γ ⊢ let x = e1 in e2: T2^(β\\{x})\n</pre>\n<p>When binding an expression to a name, the name is added to the type qualifer. When a variable goes out of scope, the name is removed from the qualifier of the result expression.</p>\n<p>Example:</p>\n<pre>\n(let x = e in  // e: T^{}\n ...           // x: T^{x}\n )             // result: T^{}\n</pre>\n<p>For functions, the same idea applies to the argument type, but we allow the return expression to depend on the argument name (possible extension: add the function name to the type, and allow both argument and result types to refer to it). This means that we’re dealing with dependent function types, and need to perform a corresponding substitution in the application case.</p>\n<p>A first cut would be this:</p>\n<pre>\n  Γ^γ, x:T1^(α,x) ⊢ e: T2^β\n  ---------------------------- (abs)\n  Γ ⊢ λx.e: (x:T1^α -> T2^β)^γ\n\n  Γ ⊢ e1: (x:T1^α -> T2^β)^γ   Γ ⊢ e2: T1^α\n  ------------------------------------------ (app)\n  Γ ⊢ e1 e2: [α/x]T2^β\n</pre>\n<p>However the app rule isn’t quite right: first, the substitution doesn’t appear to make a lot of sense (why not include <code class=\"language-text\">α</code> right away in <code class=\"language-text\">β</code>?) and second, we can’t expect <code class=\"language-text\">e2</code> to have the same or a smaller <code class=\"language-text\">α</code> as the one expected by the parameter type. If the argument type is <code class=\"language-text\">T1^{}</code>, we wouldn’t be able to pass anything bound to a variable at the call site - but what we’re actually concerned about is the definition site!</p>\n<p>The key insight is that what we <em>really</em> want in this case is that the argument is different from any variable the function <em>closes over</em>. And these are precisely the names tracked by the qualifer of the function type, <code class=\"language-text\">γ</code>!</p>\n<p>So in our new rule, we demand that the argument may only overlap with the function in the names mentioned explicitly in <code class=\"language-text\">α</code>:</p>\n<pre>\n  Γ ⊢ e1: (x:T1^α -> T2^β)^γ   Γ ⊢ e2: T1^δ    γ∩δ = α\n  ---------------------------------------------------- (app)\n  Γ ⊢ e1 e2: [δ/x]T2^β\n</pre>\n<p><strong>Exercise:</strong> show that this derives let rule</p>\n<p>Note how closely the typing rules mirror those in the “Tracking Aliasing and Separation” section on more traditional regions.</p>\n<h3>Example 1: Function Argument Separation</h3>\n<p>We assume a primitive operation <code class=\"language-text\">alloc(): V^{}</code> that produces a new reference cell (type <code class=\"language-text\">V</code>). We only consider a single side-effecting operation on variables, <code class=\"language-text\">inc: V^{} -&gt; I^{}</code>, which returns an integer (type <code class=\"language-text\">I</code>).</p>\n<p>We further assume that all intermediate expressions are let-bound (this is a given in a graph IR).</p>\n<p>Let’s consider our first example:</p>\n<pre>\nfunction test(s) {   // s: placeholder for block start\n  let v1 = alloc()     // V^{v1}  dep {s: s}\n  let v2 = alloc()     // V^{v2}  dep {s: s}\n  let i1 = inc(v1)     //         dep {v1: v1}\n  let i2 = inc(v2)     //         dep {v2: v2}\n  let f1 = fun(v => {  // v: V^{v}\n    let i3 = inc(v)      //         dep {v: v}\n    let i4 = inc(v1)     //         dep {v1: v} // dep on v as start of block\n    return 1             //         dep {v: i3, v1: i4}\n  })                   // f1: ( (v:V^{}) -> I{} )^{f1,v1}\n  let a1 = f1(v1)      // error:  {f1,v1}∩{v1} = {v1} ≠ {}\n  let a2 = f1(v2)      // ok:     {f1,v1}∩{v2} = {}\n  let i5 = inc(v1)     //         dep {v1: a2}\n  let i6 = inc(v2)     //         dep {v2: a2}\n  return 1\n}\n</pre>\n<p>We can make two key observations:</p>\n<ul>\n<li>Type system successfully prevents calling f1(v1), since f1 uses v1 internally and didn’t declare that v may alias v1. On the other hand, calling f1(v2) is fine, since f1 doesn’t use v2.</li>\n<li>The assigned types enable us to infer precise dependencies between statements in a given block (shown on the right).</li>\n</ul>\n<p>Another example:</p>\n<pre>\nfunction counter() {\n  let v1 = alloc()         // v1: V^{v1}\n  let f1 = fun(() => {     // f1: (U^{} -> I^{})^{v1}\n    let i1 = inc(v1)\n    return 1\n  })\n  return f1\n}\nlet g1 = counter()       // g1: ( U^{} -> I^{} )^{g1}\nlet h1 = g1()            // dep {g1: g1}\nlet h2 = g1()            // dep {g1: h1}\n                         // dep {g1: h2} // block end\n</pre>\n<p>When calling <code class=\"language-text\">counter</code>, we must make sure that the result remains being tracked, and indeed we do - because everything is tracked!</p>\n<h3>Example 2: Escaping Tracked Variables</h3>\n<p>When a function creates a mutable variable that escapes\n(directly or indirectly via another function), the identity\nof that variable is tracked, even though it does not have\nany externally visible identifier.</p>\n<p>The mechanism to achieve this is by logically subsuming\nthe escaping variable into the function via which it\nescapes, and tracking the identity of that function\nwith a self-type (just like in DOT).</p>\n<pre>\ndef f(a: Int) = {\n  let c = alloc()\n                      // f(b:Int) -> Ref^{c}\n  (fun(b: Int) => c)  //     --close-->\n                      // f(b:Int) -> Ref^{f}\n}\nlet h0 = f(0)\nlet h1 = f(1)\nlet c0 = h0(0)\nlet c1 = h0(1) // same as c0\nlet c3 = h1(0)\nlet c4 = h1(1) // same as c3\ninc(c0)\ninc(c1) // serialize with prev\ninc(c3)\ninc(c4) // serialize with prev\nget(c0)\n// expected result:\n// - ops on c0 and c1 are serialized\n// - c3 and c4 are never read and hence\n//   dce'd along with all their ops\n</pre>\n<h3>Extension 1: Tracked and Untracked Variables</h3>\n<p>In practice, the base model induces too many dependencies in realistic programs.</p>\n<p>Hence, we add a type qualifer that permits non-tracked variables, <code class=\"language-text\">T^0</code>.</p>\n<p>It is important that tracked values never become untracked. So <code class=\"language-text\">counter</code> above must remain typed as it is.</p>\n<p>But in other cases, we can gain considerable flexibility for code motion and other optimizations. In the example below we return a pure function, and we can correctly deduce that no dependencies need to be inserted between calls:</p>\n<pre>\nfunction pure() {\n  let f1 = fun(() => {     // f1: (U^0 -> I^0)^0\n    let v1 = alloc(s)        // v1: V{v1}\n    // can use local side effects here\n    return 1\n  })\n  return f1\n}\nlet g1 = counter()       // g1: ( U^0 -> I^0 )^0\nlet h1 = g1()            // dep {}\nlet h2 = g1()            // dep {}\n                         // dep {} // block end\n</pre>\n<p>This model allows us to effectively combine pure functional and side-effecting expressions in a graph IR based on dependencies.</p>\n<h3>Extension 2: Read and Write Effects, Soft and Hard Dependencies</h3>\n<p>Keep track of the last write and the set of reads after the last write.</p>\n<p>Write-after-read and write-after-write dependencies are anti-dependencies or <em>soft</em> dependencies: the subsequent write does not prevent any of the earlier statements from being DCE’d. But if the earlier statements are not DCE’d, they must “happen-before” the following write.</p>\n<p>Most reads can be subject to CSE, and some of the writes as well (overwriting a variable with its current value is a no-op). However, some reads are not idempotent and hence should not be subjected to CSE: reading a random number generator, or reading the next allocation address, if an <code class=\"language-text\">alloc</code> operation is modeled as a read on a global store variable. So an additional flag is needed for reads to mark non-idempotent ones, and writes require further analysis for CSE.</p>\n<h3>Extension 3: Consume Effects, Flow-Sensitivity</h3>\n<p>Tracking effects in a flow-sensitive way enables us to observe state changes of tracked variables in the type system (“sequential effects”, “typestate”).</p>\n<p>A simple but powerful flow-sensitive effect is freeing a variable, or otherwise consuming or destroying it. Such an operation may typically be used no more than once (“affine”) on any given value and generally renders the value inaccessible to any other operations that follow.</p>\n<p>Ownership transfer for nested mutable variables is another potential consume effect.</p>\n<h3>Discussion</h3>\n<p>Key points:</p>\n<ul>\n<li>Tracked expressions remain tracked, even though they may be returned from a function or passed through a let that removes the name from the type qualifier</li>\n<li>Unless otherwise noted, function arguments are guaranteed to be physically separate from any other value reachable from the function. This enables fine-grained dependency tracking inside the function.</li>\n</ul>\n<p>Some questions:</p>\n<ul>\n<li>\n<p>What is the right safety theorem to prove?</p>\n<ul>\n<li>What would an instrumented semantics look like against which we could prove a type soundness theorem?</li>\n<li>Or is it interesting enough to give a soundness proof with respect to the standard STLC reduction semantics?</li>\n<li>It is most likely more interesting to directly show a correctness preservation theorem for graph modifications subject to dependency constraints: reordering, eliminating, etc. does not change result as long as dependencies are preserved. This sounds like a syntactic confluence property.</li>\n</ul>\n</li>\n<li>\n<p>How to support reference cells that can hold other (tracked) reference cells?</p>\n<ul>\n<li>It seems relatively straightforward to prevent merging of separate heap regions, but supporting such merging (or ownership transfer) may be more interesting</li>\n<li>A useful starting point may be thinking about what restrictions are necessary between α and β in <code class=\"language-text\">(Ref T^α)^β</code>. Is α ≤ β the right model?</li>\n<li>Or a notion of ownership transfer (or “capture”) that disables all aliases of x when x is to be stored in a ref cell (how to do that across parent scopes)? It seems that “consume” effects are the right way to think about this.</li>\n</ul>\n</li>\n<li>How to support control effects (delimited continuations)?</li>\n</ul>\n<h3>Formalization</h3>\n<p>Type system:</p>\n<ol>\n<li>Type assignment for direct-style terms.</li>\n<li>Type assignment for ANF expressions extended with effect dependencies. Typing rules ensure that dependencies are sufficient.</li>\n</ol>\n<p>Operational semantics:</p>\n<p>Conceptually, represent values (functions and variables) uniformly as store locations. Represent the store as a sequence of let binding on the “outside” of the program and use variables to denote store locations (typical context formulation, see e.g. Call by Need Lambda Calculus and Wadlerfest DOT).\nTechnically, we maintain the syntactic ANF/graph representation.</p>\n<p>In addition to standard reduction rules, provide a list of equality-preserving rewrites that can be read directionally as optimization rules.</p>\n<p>Metatheory: preservation, progress, confluence for typed terms.</p>\n<p>Corollary: compiler safety for optimizations subject to dependencies.</p>\n<!--\n### Semantics and Soundness\n\nOperational semantics: represent values (functions and variables) uniformly as store locations. Represent the store as a sequence of let binding on the \"outside\" of the program and use variables to denote store locations (typical context formulation, see e.g. Call by Need Lambda Calculus and Wadlerfest DOT paper).\n\nEvaluation rules:\n\n<pre>\nlet x = λz.e in E[x y] - -> let x = λz.e in E[[y/z]e]\nlet x = y in e - -> [y/x]e\nlet x = (let y = e1 in e2) in e3 - -> let y = e1 in let x = e2 in e3\nE[e1] - -> E[e2] if e1 - -> e2\n\nE ::= [] | let x = [] in e | let x = nf in e\n\nnf ::= λz.e | alloc() | inc(x)\n</pre>\n\nSubstitution lemma (may need some tweaks):\n<pre>\nIf Γ,x:S^(α∪{x}) ⊢ e: T^β and Γ ⊢ y: S^α then Γ ⊢ [y/x]e: [y/x]T^β\n</pre>\n\nSoundness theorem:\n<pre>\nIf Γ ⊢ E[e]: T^α then either e is an answer (e = x) or\nthere exists Γ', E', e' such that E[e] - -> E'[e'] and\nΓ,Γ' ⊢ E'[e']: T^α\n</pre>\n\nNote the concatenation of Γ,Γ' (we're adding store bindings but do not change types in the store).\n\nThe standard progress and preservation lemmas follow as corollaries.\n\n-->\n</aside>\n<p>NEW! LMS effect &#x26; mutation tracking</p>\n<li> <aside>\n<h2>More ideas</h2>\n<p>Potential other use cases:</p>\n<ul>\n<li>constexpr/macros/staging: result of a function call is constant only if the function is constant and arg is constant (belong to a “known at compile time” region)</li>\n<li>noninterference: restrict information flow from “high-security” to “low-security” values/regions</li>\n<li>program slicing: split a complex program into specific parts, delineated by region assignment</li>\n</ul>\n</aside>\n</ul>\n<h3>General Formulation</h3>\n<p>Type judgements take the form <code class=\"language-text\">Γ ⊢ x: T^α</code> for a type qualifier <code class=\"language-text\">α</code>. Function types take the form <code class=\"language-text\">T1^α -&gt; T2^β</code>. The type assignment rule for functions is the following, with <code class=\"language-text\">Γ^γ</code> denoting an environment restricted to bindings qualified with <code class=\"language-text\">γ</code>.</p>\n<pre>\nΓ^γ, x:T1^α ⊢ e: T2^β\n---------------------\nΓ ⊢ λx.e: (T1^α)^γ\n</pre>\n<p>It is often useful to assume a partial order <code class=\"language-text\">≤</code> on type qualifiers. Sometimes it is also useful to assume a smallest element <code class=\"language-text\">⊥</code>, which typically means “no restrictions”, i.e., denotes 1st-class values.</p>\n<aside>\n<p>General Formalization - Details</p>\n<p>We use a variant of simply-typed λ-calculus as a basis. The core idea extends naturally to System F and beyond (the OOPSLA’16 paper presents a model based on System D&#x3C;:>).</p>\n<!-- αβγ -->\n<p>Syntax:</p>\n<pre>\nTerms\n  e ::= n | x | λx.e | e e\n\nTypes\n  T ::= Nat | T1^α -> T2^β\n\nType qualifiers\n  α,β,γ ::= ...\n\nEnvironments\n  Γ ::= x:T^α, ...\n</pre>\n<p>Type assigment: <code class=\"language-text\">Γ ⊢ x: T^α</code></p>\n<pre>\n  Γ(x) = T^α\n  ---------- (var)\n  Γ ⊢ x:T^α\n\n  Γ^γ, x:T1^α ⊢ e: T2^β\n  -------------------------- (abs)\n  Γ ⊢ λx.e: (T1^α -> T2^β)^γ\n\n  Γ ⊢ e1: (T1^α -> T2^β)^γ   Γ ⊢ e2: T1^α\n  ---------------------------------------- (app)\n  Γ ⊢ e1 e2: T2^β\n</pre>\n<p>Notes:</p>\n<ul>\n<li>\n<p>Restricted environment in rule (abs): restricting the environment removes all non-matching bindings, so we obtain a guarantee that the function can only access <code class=\"language-text\">γ</code>-qualified bindings from the outer scope.</p>\n<ul>\n<li>Of course, non-<code class=\"language-text\">γ</code>-qualified bindings can still be added in an inner scope.</li>\n<li>An alternative to express this would relate <code class=\"language-text\">γ</code> to the qualifiers of <code class=\"language-text\">e</code>’s free variables explicitly.</li>\n</ul>\n</li>\n<li>\n<p>Qualifier for functions in rule (app): as stated, rule (app) ignores the qualifier of the function, <code class=\"language-text\">γ</code>, and does not constrain it in any way. This is consistent with the expectation that even 2nd-class functions can be called without restrictions. However, several instantiations of the system require certain refinements:</p>\n<ul>\n<li>Recursive functions: may impose restrictions on function itself, e.g., preventing the function itself from escaping during the call</li>\n<li>Separation: may require that the function argument is separate from (i.e., does not alias) the function itself (and anything the function closes over)</li>\n<li>Information flow, staging: certain function may not be called with tainted/high-security or not-yet-available values</li>\n</ul>\n</li>\n</ul>\n<p>Extensions:</p>\n<ul>\n<li>\n<p>Subtyping (qualifier equivalence vs. inclusion): as stated, qualifiers need to match exactly.</p>\n<ul>\n<li>It is often useful to relax this, and assume a partial ordering among qualifiers, which extends the system to a subtyping system in a straightforward way.</li>\n<li>A unique smallest qualifier <code class=\"language-text\">⊥</code> is useful to denote 1st-class, i.e., unrestricted values.</li>\n<li>Depending on the instantiation, it can be desirable to require least-upper-bounds <code class=\"language-text\">⨆</code> on qualifiers, so that it is always possible for a function to close over different qualifiers. In other cases, this may not be desirable.</li>\n</ul>\n</li>\n<li>Parametricity: qualifier abstraction can be added in a straightforward way. It is especially useful to support bounded qualifier abstraction, assuming qualifiers are partially ordered.</li>\n<li>Dependent function types: if qualifiers can refer to program variables, the application rule needs to be extended to support dependent application. This comes up, e.g., when qualifiers track aliasing/separation of program variables.</li>\n</ul>\n<p>As a concrete example of such extensions, the OOPSLA’16 Scala implementation uses standard Scala types as qualifiers, and hence the subtyping lattice as qualifier lattice, providing bounded quantification, functional dependencies, etc.</p>\n</aside>","fields":{"slug":"/Public/Generic/regions-borrowing-coeffects/"},"frontmatter":{"date":"September 27, 2020","title":"Regions, Separation, Stackability, Borrowing, Effect Capabilities, etc","description":"","keywords":"Regions, region-based memory, ownership, borrowing, stack allocation, effects, co-effects, algebraic effects, capabilities, dependent types, graph IR, sea of nodes","tags":null}}},{"node":{"excerpt":"This is a protoype implementation of a program optimizer for a higher-order impure functional language based on a novel expressive graph IR…","html":"<!-- editor definition -->\n<code class=\"runScript\">\ninitArticleEditorSupport()\n</code>\n<p>This is a protoype implementation of a program optimizer for a higher-order impure functional language based on a novel expressive graph IR.</p>\n<p>Graph IRs are ideally suited for purely functional code (no ordering, just dependencies!) and also widely used intra-procedurally for imperative code.\nHowever, the combination of state and higher-order control flow makes it extremely difficult to infer and manage useful dependency information, at a granularity that enables aggressive optimization.</p>\n<p>Our IR supports structured and scoped expressions (functions, loops, conditionals), soft and hard dependencies, nested mutable state, and various forms of effects (e.g., read/write/kill). The basis is a <a href=\"/Public/Generic/regions-borrowing-coeffects\">novel type and effect system</a> that tracks aliasing and separation properties of program values, with degrees of flow-sensitivity.</p>\n<p><strong>Note:</strong> this article is work in progress and will be updated every now and then (see below for missing features and roadmap).</p>\n<h3>Staged graph construction API</h3>\n<aside>\n<p>Implementation code</p>\n<h3>Graph State</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Internals\n// ------------------------------------------------------------\nlet nVars = 0\nlet code = []\nlet nameHint = {}\nlet symToDef = {}\nlet symToTpe = {}\nlet errorLog = {} // indexed by sym\nlet infoLog  = {} // indexed by sym\nlet hm = {} // the bound syms each node depends on\nlet alias = {} // the tracked syms each sym may refer to\nlet state = {} // last effect node for each tracked sym\nlet effects = [] // record effects in current block\nlet blockStart // symbol representing current block start\nfunction fresh() {\n  return nVars++\n}\nfunction reset() {\n  nVars = 0\n  code = []\n  nameHint = {}\n  symToDef = {}\n  symToTpe = {}\n  errorLog = {} // indexed by sym\n  infoLog  = {} // indexed by sym\n  hm = {} // the bound syms each node depends on\n  alias = {} // the tracked syms each sym may refer to\n  state = {} // last effect node for each tracked sym\n  effects = [] // record effects in current block\n  blockStart // symbol representing current block start\n}\n</code>\n<h3>Node Construction</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction reflect(...ss) {\n  if (ss.length == 1 && typeof(ss[0]) == \"number\") {\n    let r = reflect0(fresh(), ss)\n    symToTpe[r] = \"Int\"\n    return r\n  }\n  return reflect0(fresh(), ss)\n}\nfunction reflect0(x,exp,extra) {\n  // options\n  let bound = []\n  let syms = exp.slice(1)\n  let als = \"-\" // untracked by default\n  let read = []\n  let write = []\n  let kill = []\n  let self = [] // latent call effects\n  let tpe = []\n  let areWeCallingAnArgumentSym\n  if (extra) {\n    if (extra.bound) bound = extra.bound\n    if (extra.syms) syms = extra.syms\n    if (extra.alias) als = extra.alias\n    if (extra.effect) {\n      if (extra.effect.write) write = extra.effect.write\n      if (extra.effect.read) read = extra.effect.read\n      if (extra.effect.kill) kill = extra.effect.kill\n      if (extra.effect.self) self = extra.effect.self\n    }\n    if (extra.write) write = extra.write\n    if (extra.read) read = extra.read\n    if (extra.kill) kill = extra.kill\n    if (extra.tpe) tpe = extra.tpe\n    if (extra.areWeCallingAnArgumentSym) areWeCallingAnArgumentSym = extra.areWeCallingAnArgumentSym\n  }\n  //\n  // record info/error\n  //\n  if (!errorLog[x]) errorLog[x] = []\n  if (!infoLog[x]) infoLog[x] = []\n  //\n  // alias info\n  //\n  alias[x] = als == \"-\" ? \"-\" : [x,...als.map(x => [...transitiveAliases(x)]).flat()]  //\n  //\n  // effects: first record effects as declared\n  // (previously: with aliases resolved)\n  //\n  if (!effects.read) effects.read = []\n  if (!effects.write) effects.write = []\n  if (!effects.kill) effects.kill = []\n  if (!effects.self) effects.self = []\n  effects.read.push(...read) // was: allread, etc\n  effects.write.push(...write)\n  effects.kill.push(...kill)\n  effects.self.push(...self)\n  //\n  // effects: resolve latent call effects\n  //\n  // basic logic: for a call\n  // - for dependencies: resolve into actual r/w/k\n  // - for recording what happened: leave as call\n  // - (currently: effects on arg are always resolved)\n  //\n  for (let s of self) {\n    let es = resolveLatentEffect(s)\n    if (es.read) read = [...read,...es.read]\n    if (es.write) write = [...write,...es.write]\n    if (es.kill) kill = [...kill,...es.kill]\n  }\n  //\n  // effects: resolve aliases\n  //\n  let allreads = read.map(x => [...transitiveAliases(x)]).flat()\n  let allwrites = write.map(x => [...transitiveAliases(x)]).flat()\n  let allkills = kill.map(x => [...transitiveAliases(x)]).flat()\n  //\n  // now record dependencies\n  //\n  let deps = {}\n  for (let e of allwrites)\n    deps[e] = state[e] ? state[e] : blockStart\n  let hdeps = {}\n  let sdeps = {}\n  for (let e of allreads) {\n    if (!hdeps[e]) hdeps[e] = []\n    if (!sdeps[e]) sdeps[e] = []\n    if (!state[e]) state[e] = { write: blockStart, reads: [] }\n    if (state[e].kill) logError(x, \"can't read dead object: \"+prettySym(e))\n    hdeps[e].push(state[e].write)\n    state[e].reads.push(x)\n  }\n  for (let e of allwrites) {\n    if (!hdeps[e]) hdeps[e] = []\n    if (!sdeps[e]) sdeps[e] = []\n    if (!state[e]) state[e] = { write: blockStart, reads: [] }\n    // design choice: write could resurrect\n    if (state[e].kill) logError(x, \"can't write dead object: \"+prettySym(e))\n    sdeps[e].push(state[e].write)\n    for (let r of state[e].reads) if (r != x) sdeps[e].push(r)\n    state[e] = { write: x, reads: [] }\n  }\n  for (let e of allkills) {\n    if (!hdeps[e]) hdeps[e] = []\n    if (!sdeps[e]) sdeps[e] = []\n    if (!state[e]) state[e] = { write: blockStart, reads: [] }\n    // design choice: kill could be idempotent\n    if (state[e].kill) logError(x, \"can't kill dead object: \"+prettySym(e))\n    if (state[e].write != x) sdeps[e].push(state[e].write)\n    for (let r of state[e].reads) if (r != x) sdeps[e].push(r)\n    state[e] = { write: x, reads: [], kill: x }\n  }\n  if (alias[x] != \"-\") // every tracked value should have an entry\n    state[x] = { write: x, reads: [] }\n  //\n  // bound info (include effect deps)\n  //\n  let allsyms = [...syms]\n  for (let e in hdeps) allsyms.push(...hdeps[e])\n  for (let e in sdeps) allsyms.push(...sdeps[e]) // nothing special about soft deps -- TODO: \"soft bound\"??? not sure how...\n  let bs = new Set(bound)\n  hm[x] = new Set()\n  for (let s of allsyms) {\n    for (let b of hm[s])\n      if (!bs.has(b)) // lambda should not dep on its own bound var\n        hm[x].add(b)\n  }\n  //\n  // create node\n  //\n  let ss = [\"let\", x, exp, [hdeps,sdeps]]\n  //if (extra) print(\"reflect: \" + JSON.stringify(ss) + \", \"+JSON.stringify(extra))\n  //else print(\"reflect: \" + JSON.stringify(ss))\n  code.push(ss)\n  symToDef[x] = ss\n  //\n  // set type\n  //\n  if (tpe) symToTpe[x] = tpe\n  return x\n}\nfunction transitiveAliases(x) {\n  let res = new Set()\n  function rec(x) {\n    if (res.has(x)) return\n    if (!(alias[x] instanceof Array)) return\n    res.add(x)\n    alias[x].forEach(rec)\n  }\n  if (alias[x] instanceof Array)\n    rec(x)\n  return res\n}\n// the effect a function has on the\n// environment (not its arg, may incl self)\n// Q: do we need to resolve aliases?\n//    before and/or after lookup?\nfunction resolveLatentEffect(f) {\n  let [argInfo, frtp] = extractFunTypeFlat(symToTpe[f])\n  let resInfo = frtp(f,nVars) // fresh var without consumption\n  // TODO: need transitive??\n  let es = filterEffect(resInfo.effect, y => y != nVars)\n  if (es.self)\n    print(\"WARNING: transitive 'self' effects currently not handled (at x\"+f+\")\")\n  return es\n}\nfunction filterEffect(es,f) {\n  let res = {}\n  for (let k in es) {\n    let e = es[k].filter(f)\n    if (e.length > 0)\n      res[k] = e\n  }\n  return res\n}\nfunction logError(x,...es) {\n  print(\"[ERROR \" + prettySym(x) + \"] \" + es.join(\" \"))\n  if (!errorLog[x]) errorLog[x] = []\n  errorLog[x].push(es)\n  highlightSymError(x)\n}\n</code>\n<h3>Basic Expressions</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Expression API (without lambda/app)\n// ------------------------------------------------------------\nfunction plus(a,b) {\n  typeCheckUnflat(a, \"Int\"); typeCheckUnflat(b, \"Int\")\n  return reflect0(fresh(),[\"+\", a, b], {tpe:\"Int\"})\n}\nfunction minus(a,b) {\n  typeCheckUnflat(a, \"Int\"); typeCheckUnflat(b, \"Int\")\n  return reflect0(fresh(),[\"-\", a, b], {tpe:\"Int\"})\n}\nfunction times(a,b) {\n  typeCheckUnflat(a, \"Int\"); typeCheckUnflat(b, \"Int\")\n  return reflect0(fresh(),[\"*\", a, b], {tpe:\"Int\"})\n}\nfunction println(a,b) {\n  //typeCheckUnflat(a, track(\"IO\")); typeCheckUnflat(b, \"?\")\n  typeCheck(a, \"IO\"); typeCheck(b, \"?\")\n  let res = reflect0(fresh(), [\"print\", a, b], {\n    alias: \"-\",\n    read: [a],\n    write: [a], // XXX question -- b ?\n    tpe: \"Unit\"\n  })\n  nameHint[res] = \"p\"\n  return res\n}\nfunction alloc(a) {\n  typeCheck(a, \"IO\")\n  let res = reflect0(fresh(), [\"alloc\", a], {\n    alias: [],\n    read: [a],\n    tpe: \"Ref\"\n  })\n  nameHint[res] = \"c\"\n  return res\n}\nfunction get(a) {\n  typeCheck(a, \"Ref\")\n  // check that input has associated state (= is mutable)\n  // (disabled: we don't have local state when e declared outside)\n  //if (!state[a]) print(\"WARN: no state for W (may be fresh!),\"+a)\n  let res = reflect0(fresh(), [\"get\", a], {\n    alias: \"-\", read: [a], write: [], tpe: \"Int\"\n  })\n  return res\n}\nfunction set(a,b) {\n  typeCheck(a, \"Ref\")\n  typeCheck(b, \"Int\")\n  // check that input has associated state (= is mutable)\n  // (disabled: we don't have local state when e declared outside)\n  //if (!state[a]) print(\"WARN: no state for W (may be fresh!),\"+a)\n  let res = reflect0(fresh(), [\"set\", a, b], {\n    alias: \"-\", read: [], write: [a], tpe: \"Unit\"\n  })\n  return res\n}\nfunction inc(a) {\n  typeCheck(a, \"Ref\")\n  // check that input has associated state (= is mutable)\n  // (disabled: we don't have local state when e declared outside)\n  //if (!state[a]) print(\"WARN: no state for W (may be fresh!),\"+a)\n  let res = reflect0(fresh(), [\"inc\", a], {\n    alias: \"-\", read: [a], write: [a], tpe: \"Int\"\n  })\n  return res\n}\nfunction free(a) {\n  typeCheck(a, \"Ref\")\n  // check that input has associated state (= is mutable)\n  // (disabled: we don't have local state when e declared outside)\n  //if (!state[a]) print(\"WARN: no state for W (may be fresh!),\"+a)\n  let res = reflect0(fresh(), [\"free\", a], {\n    alias: \"-\", read: [], write: [], kill: [a], tpe: \"Unit\"\n  })\n  return res\n}\n</code>\n<h3>Function Expressions (fun &#x26; app)</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Public API for app & fun\n// ------------------------------------------------------------\nfunction app(fun, arg) {\n  assert(symToTpe[fun], \"fun doesn't have type\")\n  let [argInfo, frtp] = extractFunTypeFlat(symToTpe[fun])\n  let resInfo = frtp(fun,arg)\n  //let [[argTpe, argAlias], frtp] = extractFunType(symToTpe[fun])\n  //let [resTpe, resAlias, resEffect] = frtp(fun,arg)\n  //\n  // check arg tpe\n  // XXX: may want to add sanity checks for alias/effects\n  //\n  typeCheckBase(arg,argInfo.base)\n  //\n  // check fun and arg are separate\n  // TODO: pull out into a method\n  //\n  let ala = transitiveAliases(fun)\n  let alb = transitiveAliases(arg)\n  for (let aa of ala) {\n    if (alb.has(aa))\n      print(\"ERROR: \"+fun+\" and \"+arg+\" overlap with \"+aa) // XXX\n  }\n  //\n  // Effect polymorphism\n  // - any calls to a function arg should record\n  //   effect @self(arg) instead of the effects\n  //   from the type. Exception: effects of arg on\n  //   its own arg - we can't in general\n  // - if res effect includes @self(arg), replace\n  //   with actual latent self effect of arg\n  //\n  // Alternative design:\n  // - result effect is always @call(f,arg)\n  // - resolve it during subtype checking and\n  //   when converting to self type (minEligible)\n  let resEffect = resInfo.effect\n  if (!symToDef[fun]) { // calling a bound sym (a fun arg)\n    // only count effects on the argument\n    resEffect = filterEffect(resEffect, y => y == arg)\n    if (!resEffect.self) resEffect.self = []\n    resEffect.self.push(fun)\n  }\n  //\n  // create node and set result type/alias info\n  //\n  let res = reflect0(fresh(), [\"@\", fun, arg], {\n    alias: resInfo.track.alias ? resInfo.track.alias : \"-\",\n    effect: resEffect,\n    tpe: resInfo.base\n  })\n  //symToTpe[res] = resTpe\n  return res\n}\nfunction fun(ftp,f) {\n  let [argInfo, frtp] = extractFunTypeFlat(ftp)\n  let argTpe = argInfo.base\n  let argAlias = argInfo.track.alias\n  //\n  // initialize arg and self ref\n  //\n  let ff = fresh()\n  let xx = fresh()\n  // expected type components (may be wildcards \"?\")\n  let expectedResInfo = frtp(ff,xx)\n  let [expectedResTpe, expectedResAlias, expectedResEffect] =\n    [expectedResInfo.base, expectedResInfo.track.alias, expectedResInfo.effect]\n  symToTpe[ff] = ftp\n  symToTpe[xx] = argTpe\n  nameHint[ff] = \"fun\"\n  nameHint[xx] = \"arg\"\n  hm[ff] = new Set() // mark fun? XXX\n  hm[xx] = new Set([xx]) // mark arg as bound\n  alias[xx] = argAlias ? [... argAlias,xx] : \"-\" // mark arg as tracked\n  //\n  // execute body in fresh state, mapping all entries to arg symbol\n  //\n  let save = {state,effects,blockStart}\n  state = {} // will pick up blockStart as default\n  effects = { }\n  state[xx] = { write: xx, reads: [] } // must be in as marker that it belongs to this block\n  blockStart = xx\n  let yy = f(ff,xx)\n  let localState = state\n  let localEffects = effects\n  state = save.state\n  effects = save.effects\n  blockStart = save.blockStart\n  //\n  // collect internal effect dependencies\n  //\n  let deps = {} // \"dependency\" (last write)\n  let sdeps = {} // soft deps\n  let accs = {read:[],write:[],kill:[]}\n  // XXX we see only last reads and write -- don't know\n  // for sure if sth was read or not if we only see a write\n  // (could maintain a flag)\n  for (let e in localState) { // e is a string!\n    let nonlocal = (e == ff || e == xx || e in state)\n    if (localState[e].write != e && localState[e].write != xx && localState[e].write != ff) {// proper write\n      // right now we assume write implies read (see above)\n      accs.write.push(Number(e))\n      accs.read.push(Number(e))\n      if (!deps[e]) deps[e] = []\n      if (!sdeps[e]) sdeps[e] = []\n      if (nonlocal) deps[e].push(localState[e].write)\n      else sdeps[e].push(localState[e].write)\n    }\n    if (localState[e].kill) {\n      accs.kill.push(Number(e))\n      if (!deps[e]) deps[e] = []\n      if (!sdeps[e]) sdeps[e] = []\n      if (nonlocal) deps[e].push(localState[e].kill)\n      else sdeps[e].push(localState[e].kill)\n    }\n    if (localState[e].reads.length > 0) {\n      accs.read.push(Number(e))\n      if (!sdeps[e]) sdeps[e] = []\n      for (let r of localState[e].reads)\n        sdeps[e].push(r)\n    }\n  }\n  // XXX New: recompute accs more explicitly\n  function nonlocal(e) { return (e == ff || e == xx || e in state) }\n  accs = {}\n  for (let k in localEffects) {\n    accs[k] = [...new Set(localEffects[k].filter(nonlocal))]\n  }\n  // XXXX TODO: don't do this! let minEligible take care of it\n  //\n  //\n  // type check block result (if given expected type)\n  //\n  let newResTpe = symToTpe[yy]\n  let newResAlias = alias[yy]\n  let newResEffect = accs\n  checkSubType(newResTpe, expectedResTpe, {sym:yy})\n  if (expectedResTpe != \"?\") {\n    checkSubAlias(newResAlias, expectedResAlias, {sym:yy})\n    checkSubEffect(newResEffect, expectedResEffect, {sym:yy})\n  }\n  //\n  // compute new type\n  //\n  let newResInfo = { base: newResTpe }\n  newResInfo.track = newResAlias == \"-\" ? {} : { alias: newResAlias }\n  newResInfo.effect = newResEffect\n  let newResInfo1 = minTypeEligibleInParentEnvFlat(newResInfo,[ff,xx])\n  let newArgTpe = tpeUnflatten(argInfo)\n  let newResTpe1 = tpeUnflatten(newResInfo1)\n  //let newFunTpe = funtype(newArgTpe, (f,x) => subst(subst(newResTpe1,xx,x),ff,f) )\n  let newFunTpe = [\"=>\", newArgTpe, ff, xx, newResTpe1]\n  //\n  // compute aliases: alias or effect of result expression\n  //\n  let used = new Set()\n  for (let k in newResInfo1.track)\n    newResInfo1.track[k].forEach(x => used.add(x))\n  for (let k in newResInfo1.effect)\n    newResInfo1.effect[k].forEach(x => used.add(x))\n  used.delete(ff); used.delete(xx)\n  used = [...used]\n  if (used.length == 0) used = \"-\"\n  //\n  // create graph node\n  //\n  let ret = reflect0(ff, [\"λ\", xx, yy, [deps,sdeps], localState], {\n    bound:[xx],\n    syms:[yy,...Object.values(deps).flat()],\n    alias:used,\n    tpe:newFunTpe\n  })\n  return ret\n}\n</code>\n<h3>Type Internals</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Type Internals\n// ------------------------------------------------------------\nfunction tpeFlatten(tpe) {\n  let res = { track: {}, effect: {} }\n  function iter(tpe) {\n    if (tpe instanceof Array) {\n      if (tpe[0] == \"track\") {\n        assert(tpe[2] instanceof Array)\n        if (!res.track.alias) res.track.alias = []\n        res.track.alias.push(...tpe[2])\n        return iter(tpe[1])\n      } else if (tpe[0] == \"effect\") {\n        assert(tpe[3] instanceof Array)\n        let key = tpe[2]\n        if (!res.effect[key]) res.effect[key] = []\n        res.effect[key].push(...tpe[3])\n        return iter(tpe[1])\n      }\n    }\n    res.base = tpe\n  }\n  iter(tpe)\n  return res\n}\nfunction tpeUnflatten(tpe) {\n  assert(tpe.base); assert(tpe.track); assert(tpe.effect)\n  let res = tpe.base\n  if (tpe.track.alias)\n    res = track(res, ...tpe.track.alias)\n  for (let k in tpe.effect)\n    res = effect(res, k, ...tpe.effect[k])\n  return res\n}\nfunction tpeBaseType(tpe) {\n  if (tpe instanceof Array && (tpe[0] == \"track\" || tpe[0] == \"effect\")) {\n    return tpeBaseType(tpe[1])\n  }\n  return tpe // untracked\n}\nfunction tpeAlias(tpe) {\n  if (tpe instanceof Array) {\n    // TODO: accumulate aliases\n    if (tpe[0] == \"track\") return tpe[2]\n    else return tpeAlias(tpe[1])\n  }\n  return \"-\" // untracked\n}\nfunction tpeEffect(tpe) {\n  if (tpe instanceof Array) {\n    // TODO: accumulate effects\n    // ignoring key right now\n    if (tpe[0] == \"effect\") {\n      let res = {}\n      res[tpe[2]] = tpe[3]\n      return res\n    } else return tpeEffect(tpe[1])\n  }\n  return \"-\" // untracked\n}\nfunction extractFunType(ftp) {\n  let [tc_, atp, ff_, xx_, yy_, frtp] = ftp\n  assert(tc_ == \"=>\", \"not a function type: \"+ftp)\n  let argTpe = tpeBaseType(atp)\n  let argAlias = tpeAlias(atp)\n  let frtp1 = (f,b) => {\n    let rtp = subst(subst(yy_,xx_,b),ff_,f) //frtp(f,b)\n    let resTpe = tpeBaseType(rtp)\n    let resAlias = tpeAlias(rtp)\n    let resEffect = tpeEffect(rtp)\n    return [resTpe, resAlias, resEffect]\n  }\n  return [[argTpe, argAlias], frtp1]\n}\nfunction extractFunTypeFlat(ftp) {\n  let [tc_, atp, ff_, xx_, yy_] = ftp\n  assert(tc_ == \"=>\", \"not a function type: \"+ftp)\n  let atpFlat = tpeFlatten(atp)\n  let frtp = (f,b) => {\n    let rtp = subst(subst(yy_,xx_,b),ff_,f) //frtp(f,b)\n    let rtpFlat = tpeFlatten(rtp)\n    return rtpFlat\n  }\n  return [atpFlat, frtp]\n}\nfunction extractFunTypeUnflat(ftp) {\n  let [tc_, atp, ff_, xx_, yy_] = ftp\n  assert(tc_ == \"=>\", \"not a function type: \"+ftp)\n  let frtp = (f,b) => {\n    let rtp = subst(subst(yy_,xx_,b),ff_,f) //frtp(f,b)\n    return rtp\n  }\n  return [atp, frtp]\n}\nfunction subst(e,a,b) {\n  if (e instanceof Array) return e.map(g => subst(g,a,b))\n  if (e == a) return b\n  return e\n}\n// ------------------------------------------------------------\n// Subtype checks (mostly stubs, much of it left TODO)\n// ------------------------------------------------------------\nfunction symToTpeFlat(s) {\n  return {\n    base: symToTpe[s],\n    track: alias[s] == \"-\" ? {} : { alias: alias[s] },\n    effect: {} // XXX: no way to recover!\n  }\n}\nfunction typeCheckFlat(e,tpe2) {\n  let tpe1 = symToTpeFlat(e)\n  return checkSubTypeFlat(tpe1,tpe2,{sym:e,isValue:true}) // TODO: mayWildcard?\n}\nfunction typeCheckBase(e,tpe2) {\n  let tpe1 = symToTpe[e]\n  return checkSubBase(tpe1,tpe2,{sym:e,isValue:true}) // TODO: mayWildcard?\n}\nfunction checkSubTypeFlat(tpe1, tpe2, extra) {\n  checkSubBase(tpe1.base, tpe2.base, extra)\n  // XXX: alias & effects is pretty generic right now. OK?\n  if (tpe2.base != \"?\") {\n    checkSubAnnotation(tpe1.track, tpe2.track, extra)\n    checkSubAnnotation(tpe1.effect, tpe2.effect, extra)\n  }\n}\nfunction checkSubBase(tpe1, tpe2, extra) {\n  if (tpe1 == tpe2) return\n  if (tpe2 == \"?\") return // type well formed?\n  if (tpe1 instanceof Array && tpe2 instanceof Array) {\n    if (tpe1[0] == \"=>\" && tpe2[0] == \"=>\") {\n      //let [atp1,frtp1] = extractFunTypeUnflat(tpe1)\n      //let [atp2,frtp2] = extractFunTypeUnflat(tpe2)\n      // ???\n      let [, atp1, ff1, xx1, rtp1] = tpe1\n      let [, atp2, ff2, xx2, rtp2] = tpe2\n      // TODO/FIXME: names!!! subst with fresh (?)\n      checkSubTypeUnflat(atp2,atp1,extra) // contravariant\n      checkSubTypeUnflat(rtp1,subst(subst(rtp2,xx2,xx1),ff2,ff1),extra) // OK?\n      return\n    }\n  }\n  logError(extra.sym, \"type check failed: \"+tpe1+\" <: \"+tpe2)\n}\nfunction checkSubAnnotation(ls1, ls2, extra) {\n  function sub(k) {\n    return checkSubList(ls1[k],ls2[k],{...extra,key:k})\n  }\n  sub(\"alias\")\n  sub(\"read\")\n  sub(\"write\")\n  sub(\"kill\")\n}\nfunction checkSubList(ls1,ls2, extra) {\n  if (!ls1) return true\n  //if (!ls2) return false\n  if (!ls2) {\n    let s1 = JSON.stringify(ls1)\n    logError(extra.sym, extra.key+\" qualifier check failed: \"+s1+\" <: none\")\n    return\n  }\n  // TODO: good enough? can we use 'transitiveAliases'?\n  // (subtly different until we add extra env...)\n  function trans(xs) {\n    let res = new Set()\n    for (let x of xs) {\n     res.add(x)\n     if (alias[x] instanceof Array)\n       for (let a of alias[x]) res.add(a)\n    }\n    return res\n  }\n  // TODO:\n  // - may need to be more precise w.r.t aliasing on either side\n  // - right now we only check the global alias table: this works\n  //   when a function is passed as argument with an expected function\n  //   self type\n  // - probably need an environment of some sorts to track bindings\n  //   introduced as part of the comparison\n  let ala = trans(ls1)\n  let alb = trans(ls1)\n  let ok = true\n  for (let a of ala) {\n    if (!alb.has(a)) {\n      ok = false; break\n    }\n  }\n  //let s1 = JSON.stringify(ls1)\n  //let s2 = JSON.stringify(ls2)\n  //if (s1 == s2) return ls1\n  if (!ok) {\n    let s1 = JSON.stringify(ls1)\n    let s2 = JSON.stringify(ls2)\n    logError(extra.sym, extra.key+\" qualifier check failed: \"+s1+\" <: \"+s2)\n  }\n}\nfunction symToTpeUnflat(s) {\n  return tpeFlatten(symToTpeFlat(s))\n}\nfunction typeCheckUnflat(e,tpe2) {\n  return typeCheckFlat(e,tpeFlatten(tpe2))\n}\nfunction checkSubTypeUnflat(tpe1,tpe2,extra) {\n  return checkSubTypeFlat(tpeFlatten(tpe1),tpeFlatten(tpe2),extra)\n}\nfunction typeCheck(e,tpe) {\n  if (symToTpe[e] != tpe && tpe != \"?\")\n    print(\"---- CHECK TYPE \"+e+\": \"+symToTpe[e]+\" <: \"+tpe)\n}\nfunction checkSubType(tpe1,tpe2) {\n  if (tpe1 != tpe2 && tpe2 != \"?\")\n    print(\"---- CHECK TYPE \"+tpe1+\" <: \"+tpe2)\n}\nfunction checkSubAlias(al1,al2,extra) {\n  if (al1 != al2 && al2 != \"?\")\n    print(\"---- CHECK ALIAS \"+al1+\" <: \"+al2)\n}\nfunction checkSubEffect(al1,al2,extra) {\n  checkSubAnnotation(al1, al2, extra) // XXX need sym\n  //if (al1 != al2 && al2 != \"?\")\n  //  print(\"---- CHECK EFFECT \"+al1+\" <: \"+al2)\n}\n// ------------------------------------------------------------\n// Close off function result type (by introducing self refs)\n// ------------------------------------------------------------\nfunction minTypeEligibleInParentEnvFlat(tpe,extra) {\n  // Close off a function result:\n  // (f(x:T1) -> T2^a)^a  -->  (f(x:T1) -> T2^f)\n  //\n  let env = {}\n  for (let e in state) env[e] = alias[e]\n  for (let e of extra) env[e] = alias[e]\n  let topSelf\n  let topSelfAls\n  function drop(als) {\n      let als1 = []\n      for (let e of als)\n        if (!env[e]) {\n           // ignore\n        } else\n          als1.push(e)\n      return als1\n  }\n  function check(als) {\n      let als1 = []\n      for (let e of als)\n        if (!env[e]) {\n          print(\"ERROR: alias not in env: \"+e)\n        } else\n          als1.push(e)\n      return als1\n  }\n  function replace(als) {\n      let als1 = []\n      for (let e of als)\n        if (!env[e]) {\n          if (topSelf && topSelfAls.indexOf(e) >= 0)\n            als1.push(topSelf)\n          else\n            print(\"ERROR: alias not in env or self type: \"+e)\n        } else\n          als1.push(e)\n      return als1\n  }\n  function mapTpe(tpe,f) {\n    let res = { base: tpe.base, track:{}, effect:{}}\n    for (let k in tpe.track)\n      res.track[k] = f(tpe.track[k])\n    for (let k in tpe.effect)\n      res.effect[k] = f(tpe.effect[k])\n    return res\n  }\n  function maxEligible(tpe) {\n    let tpe1 = {...tpe}\n    if (tpe.base instanceof Array) {\n      let [hd, atp, ff, xx, yy] = tpe.base\n      assert(hd == \"=>\")\n      let atp1 = tpeUnflatten(minEligible(tpeFlatten(atp)))\n      env[ff] = 1; env[xx] = 1 // could add aliases but don't really need\n      let yy1 = tpeUnflatten(maxEligible(tpeFlatten(yy)))\n      env[ff] = null; env[xx] = null\n      tpe1.base = [hd,atp,ff,xx,yy1]\n    }\n    return mapTpe(tpe1,check) // drop? contravariant position\n  }\n  function minEligible(tpe,als,efs) {\n    let tpe1 = {...tpe}\n    if (tpe instanceof Array) {\n      let [hd, atp, ff, xx, yy] = tpe\n      assert(hd == \"=>\")\n      let atp1 = tpeUnflatten(maxEligible(tpeFlatten(atp)))\n      env[ff] = 1; env[xx] = 1 // could add aliases but don't really need\n      let yy1 = tpeUnflatten(minEligible(tpeFlatten(yy)))\n      env[ff] = null; env[xx] = null\n      tpe1.base = [hd,atp,ff,xx,yy1]\n    }\n    return mapTpe(tpe1,replace)\n  }\n  // top level!\n  let tpe1 = tpe\n  if (tpe.base instanceof Array) {\n    let [hd, atp, ff, xx, yy] = tpe.base\n    assert(hd == \"=>\")\n    if (tpe.track.alias)\n      topSelf = ff; topSelfAls = tpe.track.alias\n    let atp1 = tpeUnflatten(maxEligible(tpeFlatten(atp)))\n    env[ff] = 1; env[xx] = 1 // could add aliases but don't really need\n    let yy1 = tpeUnflatten(minEligible(tpeFlatten(yy)))\n    env[ff] = null; env[xx] = null\n    tpe1.base = [hd,atp,ff,xx,yy1]\n  }\n  return mapTpe(tpe1,drop)\n}\n</code>\n<h3>Type API</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Type API\n// ------------------------------------------------------------\n/*\nexamples:\n- base types: \"Int\", \"Ref\"\n- unknown type (to-be-inferred): \"?\"\n- function types: funtype(arg, (f,x) => res)\n- annotated types: track(tpe, \"x\", \"y\"), effect(tpe, \"write\", x\", \"y\")\n*/\nfunction track(tpe, ...xs) {\n  return [\"track\", tpe, xs]\n}\nfunction effect(tpe, key, ...xs) {\n  if (!xs.length) return tpe\n  return [\"effect\", tpe, key, xs]\n}\nfunction funtype(atp,f) {\n  let ff = fresh()\n  let xx = fresh()\n  nameHint[ff] = \"f\"\n  nameHint[xx] = \"a\"\n  let yy = f(ff,xx)\n  return [\"=>\", atp, ff, xx, yy]\n}\nfunction argtype(atp) {\n  // create a function type with a wildcard result\n  return funtype(atp, (f,x) => \"?\")\n}\n</code>\n<h3>Traversal / Codegen</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Traversal / codegen:\n// ------------------------------------------------------------\nlet path = new Set([])\nlet inner = [] // code\nfunction withScope(p,ns,b) {\n  let [path0, inner0] = [path, inner]\n  path = p; inner = ns\n  try { return b() } finally { path = path0; inner = inner0 }\n}\nfunction traverseBlock(inp, outp) {\n  let path1 = new Set([...inp,...path])\n  withScope(path1, inner, () => {\n    traverseBlock1(outp)})\n}\nfunction traverseBlock1(res) {\n  function available(c) {\n    let [_let, sym, rhs] = c\n    for (let b of hm[sym])\n      if (!path.has(b))\n        return false\n    return true\n  }\n  // this version does not:\n  // - prune by reach(res)\n  // - treat soft deps softly\n  let outer1 = []\n  let inner1 = []\n  for (let c of inner) {\n    if (available(c))\n      outer1.push(c)\n    else\n      inner1.push(c)\n  }\n  withScope(path, inner1, () => {\n    traverseList(outer1, res)})\n}\n</code>\n<h3>Core DOM Utils</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// core dom utils\n// ------------------------------------------------------------\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\nfunction dom(...es) {\n  return e(\"span\",{},...es)\n}\n</code>\n<h3>Pretty printing / DOM interaction</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// ------------------------------------------------------------\n// Pretty printing / DOM interaction\n// ------------------------------------------------------------\nfunction prettySym(n) {\n  if (n in nameHint) return nameHint[n]+n\n  return \"x\"+n\n}\nfunction prettyTypeAtom(e) {\n  if (e instanceof Array)\n    return \"(\"+prettyType(e)+\")\"\n  return prettyType(e)\n}\nfunction prettyType(e) {\n  if (e instanceof Array) {\n    if (e[0] == \"track\")\n      return prettyTypeAtom(e[1])+\"^{\"+e[2].map(prettySym)+\"}\"\n    if (e[0] == \"effect\")\n      return prettyTypeAtom(e[1])+\"^^{\"+e[2].map(prettySym)+\"}\"\n    if (e[0] == \"=>\")\n      return prettySym(e[2])+\"(\"+prettySym(e[3])+\":\"+prettyType(e[1]) + \") => \" +\n        prettyType(e[4])\n  }\n  return String(e)\n}\nfunction prettyExpr(e) {\n  let [op, args] = e\n  if (!args.length) return op; else\n  return op+\"(\"+args.map(prettySym)+\")\"\n}\nfunction prettyAliases(es) {\n  if (es instanceof Array) return \"[\"+es.map(prettySym)+\"]\"\n  else return String(es)\n}\nfunction prettyDeps(es) {\n  return JSON.stringify(Object.values(es))\n    .replaceAll(\",\",\"\\n\").replaceAll('\"',\"\")\n    .replaceAll(\"write\",\"w\")\n    .replaceAll(\"read\",\"r\")\n  function prettySummary(e) {\n    if (typeof(e) == \"number\") return prettySym(e)\n    return \"{\"+Object.entries(e).map(([k,v]) =>(k[0]) + \": \" + prettyAliases(v))+\"}\"}  return \"{\"+Object.entries(es).map(([k,v]) => prettySym(k) + \": \" + prettySummary(v)).join(\"\\n\")+\"}\"\n}\nlet seq\nlet nest = 0\nlet symRefs = []\nfunction prettyNode(c) {\n    let [_let, sym, [op,...args], deps] = c\n    if (op == \"λ\") {\n      let [arg,res,eff] = args\n      let pa = prettySym(arg)+\": \"+prettyType(symToTpe[arg])\n      emit(\"def \"+prettySym(sym)+\"(\"+pa+\") {\",prettyAliases(alias[arg]))\n      let save = seq\n      seq = []; ++nest\n      try { traverseBlock([arg,sym], [res]) }\n      catch (ex) { emit(ex) }\n      emit(\"return \" + prettySym(res), prettyAliases(alias[res]), prettyDeps(eff))\n      let r = e(\"div\", {}, ...seq)\n      //r.style[\"margin-left\"] = \"15px\"\n      seq = save; --nest\n      emit(r)\n      emit(\"} // \"+prettyType(symToTpe[sym]), prettyAliases(alias[sym]), prettyDeps(deps))\n    } else {\n      emit(\"let \"+prettySym(sym)+\" = \"+prettyExpr([op,args]), prettyAliases(alias[sym]), prettyDeps(deps))\n    }\n}\nlet currentHighlight\nfunction highlightSym(n) {\n  if (currentHighlight) {\n    for (let e of symRefs[currentHighlight]) {\n      if (errorLog[currentHighlight] && errorLog[currentHighlight].length)\n        e.style[\"background\"] = \"lightpink\"\n      else\n        e.style[\"background\"] = \"none\"\n    }\n  }\n  if (n && n != currentHighlight) {\n    for (let e of symRefs[n]||[]) {\n      e.style[\"background\"] = \"lightgreen\"\n    }\n    currentHighlight = n\n  } else\n    currentHighlight = undefined\n}\nfunction highlightSymError(n) {\n  if (n == currentHighlight) return\n  for (let e of symRefs[n]||[]) {\n    e.style[\"background\"] = \"lightpink\"\n  }\n}\nfunction registerSymRef(n,d,clickable) {\n  if (!symRefs[n])\n    symRefs[n] = []\n  symRefs[n].push(d)\n  if (errorLog[n] && errorLog[n].length)\n    d.style[\"background\"] = \"lightpink\"\n  if (clickable) {\n    d.style[\"cursor\"] = \"pointer\"\n    d.addEventListener(\"click\", catchAll(e => {\n      highlightSym(n, true)\n      e.stopPropagation()\n    }))\n  }\n  if (d.src)\n    registerSymRef(n,d.src,clickable)\n}\nfunction catchAll(f) {\n  function g(e) {\n    try { return f(e) } catch(ex) { print(ex); throw ex }\n  }\n  return g\n}\nfunction prettyDomSym(n) {\n  let s = n in nameHint ? nameHint[n]+n : \"x\"+n\n  let d = dom(s)\n  registerSymRef(n,d)\n  d.style[\"color\"] = \"navy\"\n  d.style[\"cursor\"] = \"pointer\"\n  d.addEventListener(\"click\", catchAll(e => {\n    highlightSym(n, true)\n  }))\n  return d\n}\nfunction prettyDomCommaList(es,f) {\n  if (!es.length) return dom()\n  let as = [f(es[0])]\n  for (let a of es.slice(1))\n    as.push(\",\",\" \",f(a))\n  return dom(...as)\n}\nfunction prettyDomExpr(e) {\n  let [op, args] = e\n  if (!args.length) return op\n  let as = [prettyDomSym(args[0])]\n  for (let a of args.slice(1))\n    as.push(\",\",\" \",prettyDomSym(a))\n  return dom(op,\"(\",...as,\")\")\n}\nfunction prettyDomTypeAtom(e) {\n  if (e instanceof Array)\n    return dom(\"(\",prettyDomType(e),\")\")\n  return prettyDomType(e)\n}\nfunction prettyDomType(e) {\n  // TODO: call prettyAlias/Effect methods?\n  if (e instanceof Array) {\n    if (e[0] == \"track\")\n      return dom(prettyDomTypeAtom(e[1]),\"^{\",prettyDomCommaList(e[2],prettyDomSym),\"}\")\n    if (e[0] == \"effect\")\n      return dom(prettyDomTypeAtom(e[1]),\"^^\",e[2],\"{\",prettyDomCommaList(e[3],prettyDomSym),\"}\")\n    if (e[0] == \"=>\")\n      return dom(prettyDomSym(e[2]),\"(\",prettyDomSym(e[3]),\":\",prettyDomType(e[1]),\")\",\" \",\"=>\",\" \", prettyDomType(e[4]))\n  }\n  return String(e)\n}\nfunction prettyDomAliases(es) {\n  if (es instanceof Array) return prettyDomCommaList(es,prettyDomSym)\n  else return String(es)\n}\nfunction prettyDomEffects(es) {\n  function prettySummary(es) {\n    let as = []\n    for (let k in es) {\n      as.push(prettyDomSym(k))\n      as.push(\":{\")\n      if (es[k].kill) {\n        as.push(\"k:\")\n        as.push(prettyDomSym(es[k].kill))\n      }\n      as.push(\"w:\")\n      as.push(prettyDomSym(es[k].write))\n      as.push(\" \")\n      as.push(\"r:\")\n      as.push(prettyDomCommaList(es[k].reads, prettyDomSym))\n      as.push(\"} \")\n    }\n    return dom(...as)\n  }\n  return dom(prettySummary(es))\n}\nfunction prettyDomDeps(es) {\n  function prettySummary(es) {\n    let as = []\n    for (let k in es) {\n      as.push(prettyDomSym(k))\n      as.push(\":[\")\n      as.push(prettyDomCommaList(es[k], prettyDomSym))\n      as.push(\"] \")\n    }\n    return dom(...as)\n  }\n  let [h,s] = es\n  return dom(\"hard: {\",prettySummary(h),\"} soft: {\",prettySummary(s),\"}\")\n}\nfunction emitLine(d) {\n  d.style[\"display\"] = \"block\"\n  d.style[\"border-radius\"] = \"10px\"\n  d.style[\"padding\"] = \"5px\"\n  d.style[\"padding-left\"] = \"10px\"\n  d.style[\"background-color\"] = \"#F2F2F2\"\n  d.style[\"font-weight\"] = \"bold\"\n  seq.push(d)\n}\nfunction emitIndent(d) {\n  d.style[\"display\"] = \"block\"\n  d.style[\"margin-left\"] = \"10px\"\n  seq.push(d)\n}\nfunction emitBox(box) {\n  box.style[\"display\"] = \"block\"\n  //box.style[\"padding\"] = \"5px\"\n  box.style[\"margin-left\"] = \"20px\"\n  box.style[\"font-size\"] = \"10px\"\n  seq.push(box)\n}\nfunction prettyDomNode(c) {\n    let [_let, sym, [op,...args], deps] = c\n    if (op == \"λ\") {\n      let [arg,res,d,eff] = args\n      let pa = dom(prettyDomSym(arg),\": \",prettyDomType(symToTpe[arg]))\n      emitLine(dom(\"def \",prettyDomSym(sym),\"(\",pa,\") {\"))\n      let save = seq\n      seq = []; ++nest\n      emitBox(dom(\"arg \",prettyDomSym(arg),\":\"))\n      emitBox(dom(\"  aliases:\",\" \",prettyDomAliases(alias[arg])))\n    for (let er of errorLog[arg]||[]) {\n      let d = e(\"div\",{},\"ERROR:  \",\" \",...er) // TODO: map prettyDomSym\n      d.style[\"background-color\"] = \"red\"\n      d.style[\"font-weight\"] = \"bold\"\n      emitBox(d)\n    }\n      try { traverseBlock([arg,sym], [res]) }\n      catch (ex) { emit(ex) }\n      emitLine(dom(\"return \",prettyDomSym(res)))\n      emitBox(dom(\"aliases: \",prettyDomAliases(alias[res])))\n      emitBox(dom(\"effects: \",prettyDomEffects(eff)))\n      emitBox(dom(\"deps:    \",prettyDomDeps(d)))\n      let r = e(\"span\", {}, ...seq)\n      //r.style[\"margin-left\"] = \"15px\"\n      seq = save; --nest\n      emitIndent(r)\n      emitLine(dom(\"}\"))\n    } else {\n      let line = e(\"div\", {}, \"let\",\" \",prettyDomSym(sym), \" \", \"=\", \" \", prettyDomExpr([op,args]))\n      emitLine(line)\n    }\n    let as = []\n    as.push(e(\"div\",{},\"type:   \",\" \",prettyDomType(symToTpe[sym])))\n    as.push(e(\"div\",{},\"aliases:\",\" \",prettyDomAliases(alias[sym])))\n    as.push(e(\"div\",{},\"deps:   \",\" \",prettyDomDeps(deps)))\n    for (let er of errorLog[sym]||[]) {\n      let d = e(\"div\",{},\"ERROR:  \",\" \",...er) // TODO: map prettyDomSym\n      d.style[\"background-color\"] = \"red\"\n      d.style[\"font-weight\"] = \"bold\"\n      as.push(d)\n    }\n    let box = e(\"div\",{}, ...as)\n    emitBox(box)\n}\nfunction traverseList(nodes, res) {\n  for (let c of nodes) {\n    prettyDomNode(c)\n  }\n}\n</code>\n<h3>Main Program</h3>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction run(test) {\n  // may want to explicitly reset state\n  print(\"--- Staging:\")\n  let tpe = funtype(track(\"IO\"),(f,x) => effect(effect(effect(\"Int\",\"read\",x),\"write\",x),\"kill\",x))\n//  let tpe = funtype(track(\"IO\"),(f,x) => effect(\"Int\",\"write\",x))\n  let res = fun(tpe,test) // assume 1 tracked arg\n  print(\"--- Traversal / codegen:\")\n  seq = []\n  path = new Set([])\n  inner = code\n  traverseBlock1(res)\n  //emitLine(prettyDomSym(res))\n  //, prettyAliases(alias[res]), prettyDeps(state))\n  o.appendChild(e(\"pre\",{},...seq))\n}\n</code>\n</aside>\n</aside>\n<p>Examples / test cases:</p>\n<ul>\n<li><aside>\n<p>Basic println</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test2(f,stdout) {\n  let _0 = reflect(0)\n  let _1 = reflect(1)\n  let _2 = reflect(2)\n  println(stdout, _1)\n  println(stdout, _2)\n  return _0\n}\nrun(test2)\n</code>\n</aside></li>\n<li><aside>\n<p>Argument separation failure</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test1(f,store) {\n  let _1 = reflect(1)\n  let c1 = alloc(store)\n  let c2 = alloc(store)\n  inc(c1)\n  inc(c2)\n  let f1 = fun(argtype(track(\"Ref\")), (f1,c) => {\n    inc(c)\n    inc(c1)\n    return _1\n  })\n  app(f1,c1) // error\n  app(f1,c2) // ok\n  inc(c1) // dep on apps\n  inc(c2) // dep on apps\n  return _1\n}\nrun(test1)\n</code>\n</aside></li>\n<li><aside>\n<p>Escaping ref</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction test3(f,store) {\n  let _0 = reflect(0)\n  let _1 = reflect(1)\n  let _2 = reflect(2)\n  let f1 = fun(argtype(\"Int\"), (f1,a) => {\n    let c1 = alloc(store)\n    return fun(argtype(\"Int\"), (f2,b) => {\n      return c1\n    })\n  })\n  let f2 = app(f1, _0)\n  let f3 = app(f1, _1)\n  let c3 = app(f2, _0)\n  let c4 = app(f2, _1)\n  inc(c3)\n  inc(c4)\n  return _0\n}\nrun(test3)\n</code>\n</aside></li>\n</ul>\n<p>Interaction: click “code>>” to show source, click on any identifier to highlight references.</p>\n<h3>Complete pipeline (with parser and codegen)</h3>\n<aside>\n<p>Implementation code</p>\n<p>Parser</p>\n<p>Core DOM and text editor</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// text selection utils\n//\nfunction findOffsetInParent(node, pos, top) {\n  if (node == top)\n    return pos;\n  while (node.previousSibling) {\n    node = node.previousSibling;\n    var len = node.nodeType == 3 ? node.length : node.innerText.length;\n    pos = len + pos;\n  }\n  return findOffsetInParent(node.parentNode, pos, top);\n}\nfunction findChildForOffset(node, pos) {\n  var len = node.nodeType == 3 ? node.length : node.innerText.length;\n  if (pos > len)\n    return findChildForOffset(node.nextSibling, pos - len);\n  if (node.firstChild)\n    return findChildForOffset(node.firstChild, pos);\n  return {node: node, pos: pos};\n}\n//\n// text editor\n//\nlet text\nlet p = document.createElement(\"pre\")\nlet d = document.createElement(\"pre\")\nlet row = document.createElement(\"div\")\nrow.style[\"display\"] = \"flex\"\nrow.appendChild(p)\nrow.appendChild(d)\no.appendChild(row)\np.setAttribute(\"contenteditable\", false)\np.setAttribute(\"spellcheck\", false)\np.style[\"-webkit-user-modify\"] = \"read-write-plaintext-only\"\np.style[\"border\"] = \"1px solid grey\"\np.style[\"padding\"] = \"3px\"\n//p.style[\"width\"] = \"250px\"\np.style[\"min-height\"] = \"200px\"\np.style[\"outline\"] = \"none\"\np.style[\"overflow\"] = \"scroll\"\nd.style[\"border\"] = \"1px solid grey\"\nd.style[\"padding\"] = \"3px\"\n//d.style[\"width\"] = \"250px\"\n//d.style[\"height\"] = \"200px\"\nd.style[\"overflow\"] = \"scroll\"\np.addEventListener(\"beforeinput\", ev => {\n  ev.preventDefault()\n  let data = ev.data || ev.dataTransfer?.getData(\"text/plain\") || \"\"\n  if (ev.inputType == \"insertLineBreak\")\n    data = \"\\n\"\n  let range = ev.getTargetRanges()[0]\n  // CHROME WORKAROUND!\n  let startOffset = 0\n  if (!range) {\n    range = window.getSelection().getRangeAt(0)\n    if (ev.inputType==\"deleteContentBackward\" && range.startContainer == range.endContainer && range.startOffset == range.endOffset)\n      startOffset = 1\n  }\n  let start = findOffsetInParent(range.startContainer, range.startOffset, p)\n  let end = findOffsetInParent(range.endContainer, range.endOffset, p)\n  if (start > 0) start -= startOffset\n  edit(start, end, data)\n  select(start + data.length, start + data.length)\n})\nlet onEdit = () => p.innerText = text\nfunction edit(start, end, data) {\n  text = text.substring(0, start) + data + text.substring(end, text.length)\n  try {\n    onEdit()\n  } catch(ex) {\n    print(\"[Editor Callback] \"+ex)\n  }\n  /*p.innerText = \"\"\n  d.innerText = \"\"\n  try {\n    let txt = parse(text)\n    let ast = walk(txt)\n    p.appendChild(txt)\n    d.appendChild(ast)\n  } catch(ex) {\n    print(ex)\n  }*/\n}\nfunction select(start, end) {\n  let sel = window.getSelection()\n  let base = findChildForOffset(p, start)\n  let extent = findChildForOffset(p, end)\n  sel.setBaseAndExtent(base.node, base.pos, extent.node, extent.pos)\n}\n</code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n<p>Parser</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// parser state & lexer\n//\nlet pos, peek\nlet gap, skippedNL, pastGap\nlet str\n//let seq\nfunction init(s) {\n  seq = []\n  input = s;\n  pos = 0;\n  whitespace()\n  read()\n}\nfunction processGap() {\n  if (!pastGap) {\n    if (gap.trim()) {\n      seq.push(dom1(\"comment\", \"\", gap))\n    } else {\n      seq.push(gap)\n    }\n    pastGap = true\n  }\n}\nfunction next() {\n  processGap()\n  if (peek != str)\n    seq.push(dom1(peek, \"\", str))\n  else\n    seq.push(str)\n  let c = peek;\n  whitespace()\n  read()\n  return c\n}\nfunction read() {\n  let isdigit = () => '0' <= input[pos] && input[pos] <= '9'\n  let isletter = () => 'a' <= input[pos] && input[pos] <= 'z' || 'A' <= input[pos] && input[pos] <= 'Z'\n  let isopr = () => input[pos] in {'+':1,'-':1,'*':1,'/':1,'%':1,'<':1,'>':1,'=':1}\n  let start = pos\n  if (isdigit()) {\n    while (isdigit()) pos++\n    peek = \"num\"\n  } else if (isletter()) {\n    while (isletter() || isdigit()) pos++\n    peek = \"ident\"\n  } else if (isopr()) {\n    while (isopr()) pos++\n    peek = input.substring(start,pos)\n  } else {\n    peek = input[pos++]\n  }\n  str = input.substring(start,pos)\n}\nfunction whitespace() {\n  let start = pos\n  for (;;) {\n    if (input[pos] == '/' && input[pos+1] == '/') {\n      pos += 2\n      while (input[pos] && input[pos] != '\\n') ++pos\n    } else if (input[pos] == ' ') {\n      pos++\n    } else if (input[pos] == '\\n') {\n      pos++\n    } else {\n      break\n    }\n  }\n  gap = input.substring(start,pos)\n  pastGap = false\n}\n//\n// parser aux\n//\nfunction dom1(key, info, children) {\n  let d = e(\"span\",{key,info},...children)\n  if (key == \"error\") {\n    d.style[\"padding\"] = \"1px\"\n    d.style[\"background\"] = \"red\"\n  } else if (key == \"skip\") {\n    d.style[\"background\"] = \"lightpink\"\n  } else if (key == \"comment\") {\n    d.style[\"font-style\"] = \"italic\"\n    d.style[\"color\"] = \"grey\"\n  } else if (key == \"ident\") {\n    d.style[\"color\"] = \"navy\"\n  } else {\n    d.style[\"color\"] = \"sienna\"\n  }\n  return d\n}\nfunction collectPT(k,f) {\n  processGap()\n  let save = seq\n  let res = []\n  seq = res\n  try { f() } finally {\n  seq = save\n  let d = dom1(k,\"\",res)\n  seq.push(d)\n  }\n  return res\n}\nfunction error(msg) {\n  processGap()\n  print(\"Parse error: \"+msg)\n  // alternative logic:\n  // - call markError on skip node\n  seq.push(dom1(\"error\", msg, []))\n  collectPT(\"skip\", () => {\n    while (peek && peek != '\\n' && !(gap.includes('\\n')) &&\n           peek != '*' && peek != '+' && peek != '=>' &&\n           (!(nparens > 0 && peek == ')')) &&\n           (!(nbraces > 0 && peek == '}'))\n    ) {\n      next()\n    }\n  })\n  throw new Error(msg)\n}\nfunction expect(d,s) {\n  if (peek == d && (!s || str == s)) {\n    next()\n  } else {\n    try { error(d+\" expected\") }\n    catch (ex) {\n      if (peek == d && (!s || str == s)) next(); else throw ex\n    }\n  }\n}\n//\n// main parser logic\n//\nfunction split(d,f) {\n  collectPT(d, () => {\n    if (d == ';')\n      for (;;) {\n        let last = pos\n        try { f(); } catch (ex) {\n          println(\"Trying to back up!\")\n          println(\"peek '\"+String(peek)+\"' gap: '\"+gap+\"' \"+gap.includes('\\n')+\"  \"+last+\"/\"+pos)\n        };\n        if (peek == d) next(); else if (pos > last && gap.includes('\\n')); else break\n      }\n    else\n      for (;;) {\n        try { f(); } catch (ex) {\n          /*if (peek == \")\") { // extra closing paren - recover by skipping\n            collectPT(\"skipped\", () => next())\n          }*/\n        };\n        if (peek == d && !gap.includes('\\n')) next(); else break\n      }\n  })\n}\nlet nparens = 0\nfunction parens(f) {\n  collectPT('()', () => {\n    expect('(')\n    nparens++\n    try { f() } catch(ex) {} // could rethrow if no match\n    expect(')')\n    nparens--\n  })\n}\nlet nbraces = 0\nfunction braces(f) { // could unify\n  collectPT('{}', () => {\n    expect('{')\n    nbraces++\n    try { f() } catch(ex) {} // could rethrow if no match\n    expect('}')\n    nbraces--\n  })\n}\nfunction expr() {\n  split(':', () => {\n  split('=>', () => {\n  split('@', () => {\n  split('+', () => {\n    split('*', () => {\n      if (peek == '{') {\n        braces(block)\n      } else if (peek == '(') {\n        parens(expr)\n      } else if (peek == \"num\" || peek == \"ident\") {\n        collectPT('@@', () => {\n          next()\n          while (peek == '(')\n            parens(() => split(',', expr))\n        })\n      } else {\n        error(\"atom expected\")\n      }\n    })\n  })\n  })\n  })\n  })\n}\nfunction block() {\n  split(';', () => {\n    if (peek == \"ident\" && str == \"def\") {\n      collectPT(\"D\", () => {\n        expect(\"ident\", \"def\")\n        applyTokenStyle(\"keyword\")\n        expect(\"ident\")\n        applyTokenStyle(\"bound\")\n        parens(() => split(',', () => {\n          expect(\"ident\"); expect(\":\"); expr()\n        }))\n        // do not expect res types atm\n        //expect(\":\")\n        //expr()\n        expect(\"=\")\n        expr()\n      })\n    } else if (peek == \"ident\" && str == \"let\") {\n      collectPT(\"L\", () => {\n        expect(\"ident\", \"let\")\n        applyTokenStyle(\"keyword\")\n        //expect(\"ident\")\n        expr()\n        applyTokenStyle(\"bound\")\n        expect(\"=\")\n        expr()\n      })\n    } else if (peek && peek != '}') {\n      expr()\n    }\n  })\n}\n// more formatting\nfunction applyTokenStyle(key) {\n  let d = seq[seq.length-1]\n  if (key == \"keyword\")\n    d.style[\"color\"] = \"purple\"\n  else if (key == \"bound\")\n    d.style[\"color\"] = \"navy\"\n}\n//\n// string -> cst (concrete syntax tree: structured text as html dom)\n//\nfunction parse(text) {\n  try {\n    init(text)\n    block()\n    let max = 20\n    while (peek && max--) {\n      let last = pos\n      try { error(\"unexpected \"+peek,true) } catch(ex) {}\n      if (last == pos)\n        next()\n      block()\n    }\n    if (peek) error(\"unexpected \"+peek)\n    // Q: need to emit last gap?\n  } catch (ex) {}\n  if (pos-1 < text.length) {\n    seq.push(dom1(\"skipped\",\"\",[text.substring(pos-1,text.length)]))\n  } else seq.push(gap)\n  return dom1(\"P\",\"\",seq)\n}\n//\n// cst -> ast (abstract syntax tree: html dom formatted as tree)\n//\n// (trivial version, not used)\n//\nfunction walk(a) {\n  let ch = []\n  for (let c of a.children) ch.push(walk(c))\n  //if (a.key in {'+':0,'*':0,'⏎':0,'=':0,'T':0} && ch.length == 1) return ch[0]\n  if (ch.length == 1) return ch[0]\n  let l = (a.key + \" \\\"\"+ (a.info||a.textContent) + \"\\\"\").substring(0,30).replaceAll(\"\\n\",\"⏎\");\n  let d = e(\"div\", {}, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  return d\n}\n</code>\n<p>AST to IR converter</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//\n// convert cat -> ast (throw away some empty grouping)\n//\n// TODO: could nest operators based on associativity\n//\nfunction convertCstToAst(a) {\n  if (a.key == \"comment\") return\n  let ch = []\n  for (let c of a.children) {\n    let c1 = convertCstToAst(c)\n    if (c1) ch.push(c1)\n  }\n  if (ch.length == 1 && a.key != ';' && a.key != ',') return ch[0]\n  let l = a.key\n  let info = \"\"\n  if (a.key == \"ident\" || a.key == \"num\") {\n    l += \" \\\"\"+ a.textContent + \"\\\"\"\n    info = a.textContent\n  } else if (a.info) { // e.g. errors!\n    l += \" \\\"\"+ a.info + \"\\\"\"\n    info = a.info\n  }\n  let d = e(\"div\", {key: a.key, info: info, src: a }, l, ...ch)\n  d.style[\"margin-left\"] = \"2ch\"\n  if (a.key == \"error\")\n    d.style[\"background-color\"] = \"red\"\n  if (a.key == \"skip\")\n    d.style[\"background-color\"] = \"lightpink\"\n  return d\n}\n//\n// convert ast -> graph IR via staging\n//\nlet env = {}\nfunction walkExpr(expr) {\n  if (expr.key == \"num\") {\n    expr.sym = reflect(Number(expr.info))\n  } else if (expr.key == \"ident\") {\n    if (expr.info in env)\n      expr.sym = env[expr.info]\n    else\n      print(\"Error: Ident not found: \"+expr.info)\n  } else if (expr.key == \"+\") {\n    if (expr.children.length != 2) {\n      print(\"Error: only binary + supported (for now)\")\n    }\n    for (let e of expr.children) {\n      walkExpr(e)\n    }\n    expr.sym = plus(...[...expr.children].map(e=>e.sym))\n  } else if (expr.key == \";\") {\n    walkBlock(expr)\n  } else if (expr.key == \"@@\") {\n    assert(expr.children.length == 2)\n    let [fun,args] = expr.children\n    if (fun.key == \"ident\" && fun.info == \"println\") {\n      // TODO: check n args?\n      expr.sym = println(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"alloc\") {\n      expr.sym = alloc(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"set\") {\n      expr.sym = set(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"get\") {\n      expr.sym = get(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"inc\") {\n      expr.sym = inc(...[...args.children].map(walkExpr))\n    } else if (fun.key == \"ident\" && fun.info == \"free\") {\n      expr.sym = free(...[...args.children].map(walkExpr))\n    } else {\n      // TODO: check stuff?\n      walkExpr(fun);\n      // TODO: extract expected arg types from fun!!\n      expr.sym = app(fun.sym, ...[...args.children].map(walkExpr))\n    }\n  } else if (expr.key == \"=>\") {\n    // see DEF case in walkStm for comparison\n    assert(expr.children.length > 1)\n    function rec(es,ept) {\n      if (es.length == 1) { es[0].ept = ept; return walkExpr(es[0]) }\n      let [arg,...rest] = es\n      let [fn,xn,atp0] = walkArgExpr(arg)\n      // TODO: relate given and expected types\n      if (ept == \"?\" && atp0 == \"?\") {\n        assert(false, \"lambda needs expected type or provided argument type\")\n      }\n      // ignore expected type if arg type given (for now!)\n      let [atp, frtp] = atp0 != \"?\" ? [atp0, (f,x) => \"?\"] : extractFunTypeUnflat(ept)\n      return fun(argtype(atp), (ff,xx) => {\n        let save = env\n        env = {...save}\n        if (fn != \"?\") {\n          env[fn.info] = ff\n          nameHint[ff] = fn.info\n          registerSymRef(ff,fn)\n        }\n        env[xn.info] = xx\n        nameHint[xx] = xn.info\n        registerSymRef(xx,xn)\n        let res = rec(rest, frtp(ff,xx))\n        env = save\n        return res\n      })\n    }\n    expr.sym = rec(expr.children,expr.ept || \"?\")\n  } else {\n    print(\"Unknown expr: \"+expr.key)\n  }\n  registerSymRef(expr.sym,expr)\n  if (expr.ept)\n    typeCheckUnflat(expr.sym, expr.ept)\n  return expr.sym\n}\nfunction walkArgExpr(expr) {\n  function walkArg(expr) {\n    if (expr.key == \":\") {\n      assert(expr.children.length == 2)\n      let [name,tpe] = expr.children\n      walkIdent(name)\n      return [name, walkTypeExpr(tpe)]\n    } else {\n      walkIdent(expr)\n      return [expr,\"?\"]\n    }\n  }\n  if (expr.key == \"@@\") {\n    assert(expr.children.length == 2)\n    let [fun,arg] = expr.children\n    walkIdent(fun)\n    assert(arg.key == \",\")\n    if (arg.children.length != 1) {\n      print(\"Error: expected exactly one function parameter\")\n      print(\"at \" + arg.textContent)\n    }\n    return [fun, ...walkArg(arg.children[0])]\n  } else {\n    return [\"?\",walkArg(expr)]\n  }\n}\nfunction walkArgTypeExpr(expr) {\n  // cases:\n  // - named fun & arg: f(x:Int)\n  // - named fun:       f(Int)\n  // - named arg:       x:Int\n  // - type only:       Int\n  // TODO: multiple args, without or without arg/fun name(s)\n  function walkArg(expr) {\n    if (expr.key == \":\") {\n      assert(expr.children.length == 2)\n      let [name,tpe] = expr.children\n      walkIdent(name)\n      return [name.info, walkTypeExpr(tpe)]\n    } else {\n      return [\"?\",walkTypeExpr(expr)]\n    }\n  }\n  if (expr.key == \"@@\") {\n    assert(expr.children.length == 2)\n    let [fun,arg] = expr.children\n    // TODO: support multiple parameters (via arg.key == \",\" ?)\n    walkIdent(fun)\n    assert(arg.key == \",\")\n    if (arg.children.length != 1) {\n      print(\"Error: expected exactly one function parameter\")\n      print(\"at \" + arg.textContent)\n    }\n    return [fun.info, ...walkArg(arg.children[0])]\n  } else\n    return [\"?\",...walkArg(expr)]\n}\nfunction walkTypeExpr(expr) {\n  if (expr.key == \"ident\") {\n    return expr.info\n  } else if (expr.key == \"@\") {\n    let [base,...rest] = expr.children\n    let tpe = walkTypeExpr(base)\n    for (let e of rest)\n      tpe = walkTypeAnnot(tpe,e)\n    return tpe\n  } else if (expr.key == \"=>\") {\n    assert(expr.children.length > 1)\n    function rec(es) {\n      if (es.length == 1) return walkTypeExpr(es[0])\n      let [arg,...rest] = es\n      let [fn,xn,atp] = walkArgTypeExpr(arg)\n      let env1 = env\n      return funtype(atp, (f,x) => {\n        let save = env\n        env = {...env1,[fn]:f,[xn]:x} // XXX do not add \"?\"\n        try { return rec(rest) } finally {\n          env = save\n        }\n      })\n    }\n    return rec(expr.children)\n  } else {\n    print(\"Unknown type expr: \"+expr.key)\n    print(\"at \" + expr.textContent)\n  }\n}\nfunction walkTypeAnnot(base,expr) {\n  if (expr.key == \"ident\" && expr.info == \"track\") {\n    return track(base)\n  } else if (expr.key == \"@@\") {\n    assert (expr.children.length == 2)\n    let fun = expr.children[0]\n    let args = expr.children[1]\n    walkIdent(fun)\n    let args1 = walkIdentList(args)\n    if (fun.info == \"track\") {\n      return track(base, ...args1)\n    } else if (fun.info == \"read\") {\n      return effect(base, \"read\", ...args1)\n    } else if (fun.info == \"write\") {\n      return effect(base, \"write\", ...args1)\n    } else if (fun.info == \"kill\") {\n      return effect(base, \"kill\", ...args1)\n    // shorthands...\n    } else if (fun.info == \"r\") {\n      return effect(base, \"read\", ...args1)\n    } else if (fun.info == \"w\") {\n      return effect(base, \"write\", ...args1)\n    } else if (fun.info == \"k\") {\n      return effect(base, \"kill\", ...args1)\n    } else if (fun.info == \"rw\") {\n      return effect(effect(base, \"read\", ...args1), \"write\", ...args1)\n    } else if (fun.info == \"wk\") {\n      return effect(effect(base, \"write\", ...args1), \"kill\", ...args1)\n    } else if (fun.info == \"rwk\") {\n      return effect(effect(effect(base, \"read\", ...args1), \"write\", ...args1), \"kill\", ...args1)\n    }\n  }\n  print(\"Unknown type annotation: \"+expr.key)\n  print(\"at \" + expr.textContent)\n  // TODO: register error\n  return base\n}\nfunction walkIdentList(es) {\n  assert(es.key == \",\")\n  let as = []\n  for (let a of es.children) {\n    walkIdent(a)\n    if (a.info in env)\n      as.push(env[a.info])\n    else\n      print(\"Error: Ident not found: \"+a.info)\n  }\n  return as\n}\nfunction walkParamList(params) {\n  assert(params.key == \",\")\n  if (params.children.length != 2) {\n    print(\"Error: expected exactly one declared function parameter \" + params.textContent)\n  }\n  //assert(params.children.length == 2,\"X\")\n  let [p,ptp] = params.children\n  walkIdent(p)\n  let ptp1 = walkTypeExpr(ptp)\n  return [p.info,ptp1]\n}\nfunction walkKeyword(k,s) {\n  assert(k.key == \"ident\" && k.info == s, \"expected '\"+s+\"'\")\n}\nfunction walkIdent(k) {\n  assert(k.key == \"ident\", \"expected identifier\")\n}\nfunction walkLhs(expr) {\n  if (expr.key == \"ident\") {\n    walkIdent(expr)\n    return [expr, \"?\"]\n  } else if (expr.key == \":\") {\n    assert(expr.children.length == 2)\n    let [name,tpe] = expr.children\n    walkIdent(name)\n    return [name, walkTypeExpr(tpe)]\n  } else {\n    assert(false, \"malformed lhs\")\n  }\n}\nfunction walkStm(stm) {\n  if (stm.key == \"D\") {\n    //print(\"DEF\");\n    assert(stm.children.length == 4)\n    let [kw, name, params, /*rtp, */body] = stm.children\n    walkKeyword(kw, \"def\")\n    let save = env\n    env = {...save}\n    walkIdent(name)\n    let [x,ptp1] = walkParamList(params)\n    //let rtp1 = walkTypeExpr(rtp) // TODO: used?\n    let ftp = argtype(ptp1)\n    stm.sym = fun(ftp, (ff,xx) => {\n      env[name.info] = ff\n      env[x] = xx\n      nameHint[ff] = name.info\n      nameHint[xx] = x\n      walkExpr(body)\n      env = save\n      return body.sym\n    })\n    env[name.info] = stm.sym\n    nameHint[stm.sym] = name.info\n    registerSymRef(stm.sym,name)\n } else if (stm.key == \"L\") {\n    //print(\"LET\")\n    assert(stm.children.length == 3)\n    let [kw, lhs, rhs] = stm.children\n    walkKeyword(kw, \"let\")\n    let [name,tpe] = walkLhs(lhs)\n    rhs.ept = tpe // expected type!!\n    walkExpr(rhs)\n    stm.sym = rhs.sym // needed?\n    env[name.info] = rhs.sym\n    nameHint[rhs.sym] = name.info\n    registerSymRef(rhs.sym,name)\n  } else {\n    walkExpr(stm)\n  }\n}\nfunction walkBlock(block) {\n  assert(block.key == \";\")\n  for (let s of block.children)\n    walkStm(s)\n  let len = block.children.length\n  if (len)\n    block.sym = block.children[len-1].sym\n  // TODO: empty block!\n  //else\n  //  block.sym = UnitType\n}\nfunction walk(a) {\n  let stms = convertCstToAst(a)\n  try { walkBlock(stms) } catch (ex) { print(\"EX \"+ex) }\n  return stms\n}\n</code>\n<p>Compact codegen</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// NOTE: shouldInline itself isn't tight enough\n// to prevent reordering of effectful exprs that also\n// return a value (e.g. var reads).\n//   let c = alloc(1)\n//   let r = get(c)\n//   set(c,2)\n//   println(r) // can't inline r here!\n//              // but could if set/println reordered\n// That's why there's an additional pass to fix it up.\n//\n//let path = new Set([])\n//let inner = code // []\nlet shouldInline\nlet needSymbol\n//function withScope(p,ns,b) {\n//  let [path0, inner0] = [path, inner]\n//  path = p; inner = ns\n//  try { return b() } finally { path = path0; inner = inner0 }\n//}\nfunction symsRec(c) {\n  if (typeof(c) === \"number\") return [c]\n  return Object.values(c).map(symsRec).flat()\n}\nfunction syms(c) {\n  let [_, sym, [op,...args], [hdeps,sdeps]] = c\n  return {v: symsRec(args), h: symsRec(hdeps), s: symsRec(sdeps)}\n}\nfunction symsFreq(c) {\n  let [_, sym, [op,...args], deps] = c\n  if (op == \"λ\") {\n    let [xx, yy, [hdeps,sdeps], eff] = args\n    return {v: [[yy,100.0]],\n            h: symsRec(hdeps).map(x => [x,100.00]),\n            s: symsRec(sdeps).map(x => [x,100.00])}\n    // XXX ignoring stm deps -- ok???\n  } else if (op == \"?\") {\n    // TODO/FIXME!\n    let [c,xa,[a,yan],xb,[b,ybn]] = args\n    return [[yan,0.5], [ybn,0.5]]\n  } else {\n    let {v,h,s} = syms(c)\n    return {v: v.map(x => [x,1.0]),\n            h: h.map(x => [x,1.0]),\n            s: s.map(x => [x,1.0])}\n  }\n}\nfunction traverseBlockCompact(inp, outp) {\n  let path1 = new Set([...inp,...path])\n  withScope(path1, inner, () => {\n    traverseBlockCompact1(outp)})\n}\nfunction traverseBlockCompact1(res) {\n  function available(c) {\n    let [_let, sym, rhs] = c\n    for (let b of hm[sym])\n      if (!path.has(b))\n        return false\n    return true\n  }\n  // todo: prune harder by reach(res)\n  // todo: soft/hard\n  let reach = new Set()\n  let df = [] // local definitions\n  let hmo = [] // how many times used outer (as proper val)\n  let hmi = [] // how many times used inner (as proper val)\n  for (let s of res)\n    reach.add(s)\n  hmo[res[0]] = 1 // only first is used as proper val\n  let outer1 = []\n  let inner1 = []\n  inner.reverse()\n  for (let c of inner) {\n    if (reach.has(c[1])) {\n      let sfs = symsFreq(c)\n      if (available(c)) {\n      // XXX careful with successor computation:\n      // XXX we're going bottom up!\n        outer1.push(c)\n        df[c[1]] = c\n        for (let [s,f] of sfs.v) { // value deps\n          if (f > 0.5) reach.add(s)\n          if (f == 1.0) hmo[s] = (hmo[s]||0)+1 // direct syms, no blocks!\n          else hmi[s] = (hmi[s]||0)+1\n        }\n        for (let [s,f] of sfs.h) { // hard effect deps\n          if (f > 0.5) reach.add(s)\n        }\n        // soft effect deps: do nothing\n      } else {\n        inner1.push(c)\n        for (let [s,f] of sfs.v) { // value deps\n          reach.add(s)\n          hmi[s] = (hmi[s]||0)+1\n        }\n        for (let [s,f] of sfs.h) { // hard effect deps\n          reach.add(s)\n        }\n      }\n    } else {\n      // XXX it may be cold-only reachable, but\n      // XXX what if not reachable at all?\n      // XXX can we prune more, based on 'reach'??\n      inner1.push(c)\n      for (let [s,f] of symsFreq(c).v) {\n        hmi[s] = (hmi[s]||0)+1\n      }\n    }\n  }\n  inner.reverse()\n  outer1.reverse()\n  inner1.reverse()\n  let save = {shouldInline,needSymbol}\n  shouldInline = (s) => {\n    // must not have errors (want to print them)\n    if (errorLog[s] && errorLog[s].length > 0)\n      return null\n    // defined as an atom\n    if (symToDef[s] && typeof(symToDef[s][2][0]) === \"number\")\n      return symToDef[s]\n    // locally defined, locally used (as value) exactly once,\n    // not used in nested scopes\n    if (df[s] && hmo[s] == 1 && !hmi[s])\n      return df[s]\n  }\n  needSymbol = (s) => {\n    return hmi[s] || hmo[s] // used as value\n  }\n  // --- Check dependencies for inlined expressions ---\n  // Additional traversals to figure out which exprs\n  // can be safely inlined wrt successor dependencies.\n  //\n  // TODO: can this be optimized? (fewer traversals)\n  // TODO: some tweaks/checks will likely be necessary:\n  //       - do we deal with effect deps correctly?\n  //       - especially, what about soft deps?\n  //\n  // 1. compute local successors (fwd)\n  succ = {}\n  for (let c of outer1) {\n      let sfs = symsFreq(c)\n      let ss = [...sfs.v,...sfs.h,...sfs.s]\n      succ[c[1]] = []\n      for (let [s,f] of ss) {\n        if (df[s]) succ[s].push(c[1])\n      }\n  }\n  // 2. check if all successors are emitted after the point\n  //    considered for inlining, if not disable inlining\n  //    for this node (bwd)\n  outer1.reverse()\n  let seen = {}\n  function processNodeHere(c) {\n    seen[c[1]] = true\n    let sfs = symsFreq(c)\n    let ss = [...sfs.v].reverse() // bwd\n    for (let [s,f] of ss) {\n      if (f == 1.0) // direct\n        checkInline(s)\n    }\n  }\n  function checkInline(s) {\n    let c = shouldInline(s)\n    if (c) {\n      // Note: all local defs have succ[s] defined,\n      // but we also inline global constants. These\n      // don't have effects, so we don't need succs.\n      for (let s1 of succ[s]||[]) {\n        if (!seen[s1]) {// a successor hasn't been seen:\n          delete df[s] // disable inlining (somewhat crude)\n          return\n        }\n      }\n      processNodeHere(c)\n    }\n  }\n  //res.forEach(checkInline)\n  checkInline(res[0]) // only value result, not effects!\n  for (let c of outer1) {\n    if (!shouldInline(c[1]))\n      processNodeHere(c)\n  }\n  outer1.reverse()\n  // 3. actual codegen (fwd)\n  withScope(path, inner1, () => {\n    traverseListCompact(outer1, res)})\n  shouldInline = save.shouldInline\n  needSymbol = save.needSymbol\n}\nlet buf = []\nfunction collectOT(f) {\n  let save = buf\n  buf = []\n  nest++\n  f()\n  nest--\n  let res = buf\n  buf = save\n  return res\n}\nfunction dom2(tag, ...children) {\n  let toDom = x => x instanceof Node ? x : document.createTextNode(String(x))\n  let d = document.createElement(tag)\n  for (let e of children)\n    d.appendChild(toDom(e))\n  return d\n}\nfunction emit(s) {\n  let toDom = x => x instanceof Node ? x : document.createTextNode(String(x))\n  buf.push(toDom(s))\n}\nfunction formatNode(...e) {\n  let d = dom2(\"div\", ...e)\n  return d\n}\nfunction newline(indent) {\n  return \"\\n\"+\"\".padStart(2*(indent-1), \" \")\n}\nfunction emitLine1(...e) {\n   if (buf.length > 0) emit(newline(nest))\n   emit(dom2(\"span\",...e))\n}\nfunction formatBlockCompact(f) {\n  let d = collectOT(f)\n  if (d.length > 1) {\n    d = dom2(\"span\", newline(nest+1), ...d, newline(nest))\n    // d.style[\"border\"] = \"1px solid lightgrey\"\n    // d.style[\"padding-left\"] = \"10px\"\n    // d.style[\"padding-right\"] = \"10px\"\n    return d\n  } else return d[0]\n}\nfunction formatSym(n) {\n  let s = n in nameHint ? nameHint[n] : \"x\"\n  let superscript = dom(n)\n  // superscript.style[\"color\"] = \"grey\"\n  superscript.style[\"vertical-align\"] = \"super\"\n  superscript.style[\"font-size\"] = \"50%\"\n  let d = dom(s,superscript)\n  d.style[\"color\"] = \"navy\"\n  registerSymRef(n,d,true)\n  return d\n}\nfunction walkSym(e) {\n  let de = shouldInline(e)\n  if (de)\n    return walkExpr2(de)\n  else\n    return formatSym(e)\n}\nfunction formatCommaList(es,f) {\n  return prettyDomCommaList(es, f)\n}\nfunction walkExpr2(c) {\n    let [_let, sym, rhs] = c\n    let [op,...args] = rhs\n    let d = []\n    if (op == \"λ\") {\n      let [arg,res,[hdeps,sdeps],eff] = args\n      let body = formatBlockCompact(() => {\n        // emit any errors attached to argument\n        if (errorLog[arg] && errorLog[arg].length > 0) {\n          let aux = []\n          aux.push(\"// error: \")\n          for (let er of errorLog[arg])\n            aux.push(dom(...er))\n          emitLine1(...aux)\n        }\n        return traverseBlockCompact([arg,sym], symsRec([res,hdeps]))\n      })\n      d = dom2(\"span\", formatSym(sym), \"(\", formatSym(arg),\")\",\" \", \"=> {\",\n      body, \"}\")\n    } else if (op == \"?\") {// TODO\n      let [c,xa,ya,xb,yb] = args\n      let thenp = formatBlockCompact(() => { traverseBlockCompact([xa], [ya]) })\n      let elsep = formatBlockCompact(() => { traverseBlockCompact([xb], [yb]) })\n      d = dom2(\"span\", \"if\", \" (\", walkSym(c), \") {\", thenp, \"} else {\", elsep, \"}\")\n    } else if (args.length) {\n      d = dom2(\"span\", op, \"(\", formatCommaList(args,walkSym), \")\")\n    } else\n      d = dom2(\"span\", op)\n    //d.style[\"display\"] = \"inline-block\"\n    //d.style[\"border\"] = \"1px solid lightgrey\"\n    //d.style[\"padding\"] = \"1px\"\n    registerSymRef(sym,d,true)\n    return d\n}\nfunction prettyNodeCompact(c) {\n  let [_let, x, rhs] = c\n  // TODO: special case for functions?\n  let aux = []\n  if (errorLog[x] && errorLog[x].length > 0) {\n    aux.push(\" // error: \")\n    for (let er of errorLog[x])\n      aux.push(dom(...er))\n  }\n  if (needSymbol(x)) {\n    let kw = dom(\"let\")\n    kw.style[\"color\"] = \"purple\"\n    emitLine1(kw,\" \",formatSym(x),\" \",\"=\",\" \",walkExpr2(c),...aux)\n  }\n  else\n    emitLine1(walkExpr2(c),...aux)\n}\nfunction traverseListCompact(nodes, res) {\n  for (let c of nodes) {\n    let [_let, sym, [op,...args]] = c\n    if (shouldInline(sym)) continue\n    prettyNodeCompact(c)\n  }\n  emitLine1(walkSym(res[0])) // 0 is value, rest is eff\n}\n//o.appendChild(formatBlock(() => {\n//traverseBlock1([res[1]])\n//}))\n;\n</code>\n<p>Augmented Editor Component</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet oo = e(\"div\",{})\no.appendChild(oo)\nfunction panel(str,d,open) {\n  let sum = e(\"summary\",{},str)\n  sum.style[\"outline\"] = \"none\"\n  let det = e(\"details\",{},sum,d)\n  det.open = open\n  oo.appendChild(det)\n}\nfunction print(...es) {\n  oo.appendChild(e(\"div\",{},...es))\n}\nfunction run(src,dst) {\n  p.style.width = \"100%\"\n  d.style.width = \"100%\"\n  onEdit = () => {\n    // reset state\n    reset()\n    // reset output\n    p.innerText = \"\"\n    d.innerText = \"\"\n    oo.innerText = \"\"\n    // parse\n    let txt = parse(text)\n    let ast = walk(txt)\n    p.appendChild(txt)\n    d.appendChild(ast)\n    panel(\"AST\", d)\n    res = env[\"main\"]\n    //print(\"--- Traversal / codegen:\")\n    seq = []\n    path = new Set([])\n    inner = code\n    traverseBlock1(res)\n    //emitLine(prettyDomSym(res))\n    //, prettyAliases(alias[res]), prettyDeps(state))\n    panel(\"Graph IR\", pre = e(\"pre\",{},...seq))\n    //print(\"--- Compact Traversal / codegen:\")\n    seq = []\n    path = new Set([])\n    inner = code\n    let out = formatBlockCompact(() => {\n      traverseBlockCompact1([res])\n    })\n    let q = e(\"pre\",{},out)\n    q.style[\"border\"] = \"1px solid grey\"\n    q.style[\"padding\"] = \"3px\"\n    panel(\"Target Code\", q, true)\n    if (out.textContent.trim() != dst.trim()) {\n      panel(\"Test FAILED\",e(\"pre\", {},\n        \"// ACTUAL:\\n\", out.textContent.trim(), \"\\n\",\n        \"// EXPECTED:\\n\", dst.trim()), true)\n    } else {\n      print(\"Test passed\")\n    }\n  }\n  text = src\n  onEdit()\n}\n</code>\n</aside>\n<p>Examples / test cases:</p>\n<ul>\n<li><aside>\n<p>Basic println</p>\n<p>Effect dependencies ensure that side-effecting statements\nare not accidentally removed from the graph or reordered, even though\ntheir result values may never be used (and hence, there is no\ndependency on their result).</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(stdout: IO @track) = {\n  println(stdout,1)\n  println(stdout,2)\n  0\n}\n`,`main2(stdout3) => {\n  print(stdout3, 1)\n  print(stdout3, 2)\n  0\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Basic dce 1</p>\n<p>Pieces of mutable state that are never <em>actually</em> used, i.e.,\nthat do not contribute to any actual value computation are\nremoved.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  let d = alloc(store) // dce\n  get(d) // dce\n  get(c)\n}\n`,`main2(store3) => {get(alloc(store3))}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Basic dce 2</p>\n<p>Pieces of mutable state that are never <em>actually</em> used, i.e.,\nthat do not contribute to any actual value computation are\nremoved.</p>\n<p>This holds even for stateful variables that are modified.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  set(c, 0) // dce\n  get(c)    // dce\n  set(c, 1)\n  get(c)    // dce\n  get(c)\n}\n`,`main2(store3) => {\n  let c4 = alloc(store3)\n  set(c4, 1)\n  get(c4)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Escaping ref</p>\n<p>When a function creates a mutable variable that escapes\n(directly or indirectly via another function), the identity\nof that variable is tracked, even though it does not have\nany externally visible identifier.</p>\n<p>The mechanism to achieve this is by logically subsuming\nthe escaping variable into the function via which it\nescapes, and tracking the identity of that function\nwith a self-type (just like in DOT).</p>\n<p>(See the Graph IR pane below for detailed type assignments)</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def f(a: Int) = {\n    let c = alloc(store)\n    def g(b: Int) = c\n    g\n  }\n  let h0 = f(0)\n  let h1 = f(1)\n  let c0 = h0(0)\n  let c1 = h0(1) // same as c0\n  let c3 = h1(0)\n  let c4 = h1(1) // same as c3\n  inc(c0)\n  inc(c1)\n  inc(c3)\n  inc(c4)\n  get(c0)\n  // expected result:\n  // - ops on c0 and c1 are serialized\n  // - c3 and c4 are never read and hence\n  //   dce'd along with all their ops\n}\n`,`main2(store3) => {\n  let f6 = f6(a7) => {\n    let c8 = alloc(store3)\n    g11(b12) => {c8}\n  }\n  let h014 = @(f6, 0)\n  let c018 = @(h014, 0)\n  inc(c018)\n  inc(@(h014, 1))\n  get(c018)\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Compact codegen soft deps</p>\n<p>Soft dependencies are honored when inlining an expression.\nWithout further checks, the first read <code class=\"language-text\">r</code> would be inlined as the\nblock result, incorrectly moving it after the <code class=\"language-text\">inc(c)</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  let r = get(c) // may not move after inc\n  inc(c)\n  println(store, get(c))\n  r // tempting to inline r here\n}\n`,`main2(store3) => {\n  let c4 = alloc(store3)\n  let r5 = get(c4)\n  inc(c4)\n  print(store3, get(c4))\n  r5\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Consume effects 1</p>\n<p>Effects can be flow-sensitive, implementing a form of typestate tracking.\nA simple but important use case are “comsume” or “kill” effects that\nmake a value unusable.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  inc(c)\n  println(store, get(c))\n  free(c)\n  get(c) // error\n}\n`,`main2(store3) => {\n  let c4 = alloc(store3)\n  inc(c4)\n  print(store3, get(c4))\n  free(c4)\n  let x9 = get(c4) // error: can't read dead object: c4\n  x9\n}\n`)\n</code>\n</aside>\n</li>\n<li><aside>\n<p>Consume effects 2</p>\n<p>Effects can be flow-sensitive, implementing a form of typestate tracking.\nA simple but important use case are “comsume” or “kill” effects that\nmake a value unusable.</p>\n<p>Of course this also works for user-defined functions, not just primitives.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def myfree(c: Ref @track) = {\n    free(c)\n  }\n  let c = alloc(store)\n  inc(c)\n  println(store, get(c))\n  myfree(c)\n  get(c) // error\n}\n`,`let myfree6 = myfree6(c7) => {free(c7)}\nmain2(store3) => {\n  let c9 = alloc(store3)\n  inc(c9)\n  print(store3, get(c9))\n  @(myfree6, c9)\n  let x14 = get(c9) // error: can't read dead object: c9\n  x14\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Extended parser / type checker</p>\n<p>Note how clicking symbols in the IR highlights program fragments in both the source and target code.</p>\n<p>We may want to resolve associativity earlier in the parser and re-nest the concrete syntax tree for better syntax highlighting (TODO?)</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Int => Int = g(x) => h(y) => x+y\n`,`main6(x7) => {h10(y11) => {+(x7, y11)}}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Expected type failure</p>\n<p>TODO:</p>\n<ul>\n<li><del>invisible output in test 2</del></li>\n<li>\n<p>double error in test 1</p>\n<ul>\n<li>checkSub: currently reporting innermost comparison on error - show outermost instead?</li>\n</ul>\n</li>\n<li>fix internal checks (base,alias,effect) (12/10 done?)</li>\n<li>fix substitution for function type  (12/10 done?)</li>\n</ul>\n<h3>Test 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Int => Unit = g(x) => h(y) => x+y\n`,`let main6 = main6(x7) => {h10(y11) => {\n    let x12 = +(x7, y11) // error: type check failed: Int <: Unit\n    x12\n  }} // error: type check failed: Int <: Unit\nmain6\n`)\n</code>\n<h3>Test 2</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Unit => Int = g(x) => h(y) => x+y\n`,`main6(x7) => {h10(y11) => {\n    // error: type check failed: Unit <: Int\n    +(x7, y11)\n  }}\n`)\n</code>\n<h3>Test 3</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\nlet main: f(x:Int) => Unit => Int = g(x) => h(y:Int) => x+y\n`,`let main6 = main6(x7) => {h10(y11) => {+(x7, y11)}} // error: type check failed: Unit <: Int\nmain6\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Effect Polymorphism 1</p>\n<p>We support lightweight bounded effect polymorphism\nfor higher order functions using a special <code class=\"language-text\">@call</code>\neffect that is resolved at the call site of the\nhigher order function to the latent effect of\nits argument.</p>\n<p>TODO:</p>\n<ul>\n<li><del>use latent function effect in app</del></li>\n<li><del>subtype checking for self types (via aliasing)</del></li>\n<li><del>record effects explicitly in reflect0</del></li>\n<li><del>track and resolve latent self effect</del></li>\n<li>parse <code class=\"language-text\">@call</code> qualifier</li>\n</ul>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  // rwk is an abbreviation for read, write, kill\n  // result type: Int @call(f)\n  def gen(f: (f(x:Int) => Int @rwk(f)) @track) = {\n    f(1)\n  }\n  def g(x: Int) = {\n    println(store, x)\n    x\n  }\n  let res = gen(g) // effect: @call(g), doesn't really kill g or store!\n  println(store,1)\n}\n`,`let gen8 = gen8(f9) => {@(f9, 1)}\nmain2(store3) => {\n  @(gen8, g14(x15) => {\n    print(store3, x15)\n    x15\n  })\n  print(store3, 1)\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited continuation</p>\n<p>TODO/FIXME:</p>\n<ul>\n<li><del>parse function type and type check</del></li>\n<li><del>parse lambda expr and type check bidirectionally with expected type</del></li>\n<li><del>parse and check effect annotations</del></li>\n<li><del>close type and do self type comparison</del></li>\n</ul>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  def gen(f: (f(Int) => Int @rw(f)) @track) = {\n    f(1) + f(2)\n  }\n  def g(x: Int) = {\n     println(store, x)\n     x // could do 2*x\n  }\n  let res = gen(g)\n  println(store,res)\n}\n`,`let gen8 = gen8(f9) => {+(@(f9, 1), @(f9, 2))}\nmain2(store3) => {print(store3, @(gen8, g17(x18) => {\n    print(store3, x18)\n    x18\n  }))}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited one-shot continuation 1</p>\n<p>Negative case 1</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(Int) => Int @rw(f)) @track) = {\n    f(1) + f(2)\n  }\n  def g(x: Int) = {\n     println(store, x)\n     free(c)\n     x\n  }\n  println(store,gen(g)) // error: type mismatch of g\n}\n`,`let gen9 = gen9(f10) => {+(@(f10, 1), @(f10, 2))}\nmain2(store3) => {\n  let c4 = alloc(store3)\n  let g18 = g18(x19) => {\n    print(store3, x19)\n    free(c4)\n    x19\n  } // error: kill qualifier check failed: [4] <: none\n  print(store3, @(gen9, g18))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited one-shot continuation 2</p>\n<p>Negative case 2</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(x:Int) => Int @rwk(f)) @track) = {\n    f(1) + f(2)  // error: f already killed\n  }\n  def g(x: Int) = {\n     println(store, x)\n     free(c)\n     x\n  }\n  println(store,gen(g))\n}\n`,`let gen9 = gen9(f10) => {\n  let x12 = @(f10, 1)\n  let x14 = @(f10, 2) // error: can't read dead object: f10can't write dead object: f10\n  +(x12, x14)\n}\nmain2(store3) => {\n  let c4 = alloc(store3)\n  print(store3, @(gen9, g18(x19) => {\n    print(store3, x19)\n    free(c4)\n    x19\n  }))\n}\n`)\n</code>\n</aside></li>\n<li><aside>\n<p>Delimited one-shot continuation 3</p>\n<p>Positive case. Relies on effect polymorphism.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nrun(`// source program\ndef main(store: IO @track) = {\n  let c = alloc(store)\n  def gen(f: (f(x:Int) => Int @rwk(f)) @track) = {\n    f(1)\n  }\n  def g(x: Int) = {\n    println(store, x)\n    free(c)\n    x\n  }\n  println(store,gen(g))\n}\n`,`let gen9 = gen9(f10) => {@(f10, 1)}\nmain2(store3) => {\n  let c4 = alloc(store3)\n  print(store3, @(gen9, g15(x16) => {\n    print(store3, x16)\n    free(c4)\n    x16\n  }))\n}\n`)\n</code>\n</aside></li>\n</ul>\n<p>Currently failing / to be done:</p>\n<ul>\n<li>currently none...</li>\n</ul>\n<aside>\n<p>TODO</p>\n<p>Tests:</p>\n<ul>\n<li><del>test compact codegen sequencing</del></li>\n<li><del>test kill effects (“free”)</del></li>\n<li><del>test effect polymorphism</del></li>\n<li>new effect recording method: what happens if a local\nvalue aliases an outer one and is modified. Do we drop\nthe effect when exiting the scope? (Would be wrong!)</li>\n</ul>\n<p>Fixes:</p>\n<ul>\n<li><del>make alloc a read effect on store</del></li>\n<li><del>track read effects in types</del></li>\n<li><del>impl &#x26; test proper soft deps dce</del></li>\n<li>preserve type ascriptions in let/def (add cast node?)</li>\n</ul>\n<p>Features (S):</p>\n<ul>\n<li><del>attach errors to graph nodes</del> (todo: other output)</li>\n<li><del>impl proper type comparisons</del></li>\n<li>effect polymorphism (lightweight)</li>\n<li>support multi-arg functions</li>\n<li>cse, rewriting, other opts</li>\n</ul>\n<p>Features (M):</p>\n<ul>\n<li><del>graph ir dom interaction</del></li>\n<li><del>parser</del></li>\n<li><del>compact codegen</del></li>\n<li>if, loops, recursion</li>\n<li>lowering passes</li>\n<li>macros / must-inline functions</li>\n<li>nested refs, ownership transfer</li>\n</ul>\n<!-- Features (medium):\n- tensors, arrays, loops, if\n- lowering phases, loop fusion-->\n<p>Features (L):</p>\n<ul>\n<li>continuations</li>\n<li>dependent types</li>\n</ul>\n</aside>","fields":{"slug":"/Public/Generic/graph-ir/"},"frontmatter":{"date":"September 25, 2020","title":"Graph IRs and Dependencies","description":"The unreasonable effectiveness of Graph IRs for optimization","keywords":null,"tags":null}}},{"node":{"excerpt":"Delimited continuations are a powerful and generic control abstraction. Fully-general implementations tend to be heavyweight (full CPS…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        invokeOnClear()\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nlet clearHook = null\nfunction onclear(f) {\n  clearHook = f\n}\nfunction invokeOnClear() {\n  if (clearHook) {\n    clearHook()\n    clearHook = null\n  }\n}\nfunction clear() {\n    invokeOnClear()\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Delimited continuations are a powerful and generic control abstraction. Fully-general implementations tend to be heavyweight (full CPS: runtime overhead; selective CPS: type/syntax overhead; stack copying: different kind of runtime overhead). But often, restricted models are sufficient, and can be implemented more efficiently.</p>\n<p>Here we consider delimited continuations restricted to affine and non-escaping use: we assume a control operator <code class=\"language-text\">shift(k =&gt; ...)</code> that permits invocation of k once or not at all, and only within the operator’s dynamic extent.</p>\n<p>We will show that we can implement this operator efficiently, using a single auxiliary stack in addition to the standard call stack.</p>\n<p>Our implementation is in JavaScript, so the restrictions aren’t enforced, but type systems exist that could provide corresponding static guarantees.</p>\n<p>Use cases:</p>\n<ul>\n<li><a href=\"/Public/Generic/differentiable-programming-in-js\">AutoDiff</a> (backward pass to propagate gradient updates)</li>\n<li>Automatic resource management (clean up resource after use)</li>\n<li>Algebraic effects (certain classes)</li>\n</ul>\n<p>Restriction:</p>\n<pre>\nshift(k => k() * 2)         // ok: linear (1 use)\nshift(k => 2)               // ok: not linear but still affine (0 uses)\n// shift(k => k() + k())    // not affine (2 uses)\n// shift(k => outer = k)    // not affine (k escapes)\n</pre>\n<p>Running Example:</p>\n<pre>\nreset(() => {\n    4 + shift(k => k(3) * 2)\n})\n// result: (4 + 3) * 2 = 14\n</pre>\n<h2>Key Idea</h2>\n<aside>\n<h2>Recall the general implementation using CPS</h2>\n<p>The original semantics for shift/reset is expressed in terms of whole-program CPS transformation. In that case, there is an implicit reset around the shift body. This is useful for uniformity, but not strictly necessary.</p>\n<p>It is often useful to implement a selective CPS transform. In this case we have distinct CPS and non-CPS code paths in the same program. We can keep the two worlds apart using a type system (as in Scala) or using syntax annotations (monadic do, async/await). In either case, we can leave the shift body in direct style.</p>\n<p>Example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// result: (4 + 3) * 2 = 14\nlet res = (k1 => {\n    let k = (r => k1(4 + r));\n    return (k => k(3) * 2)(k)\n})(r1 => r1)\nprint(res)\n</code>\n<p>Transformation rules (selective cps, excerpt):</p>\n<pre>\n[[ reset(f) ]]    = [[ f ]](r => r)\n[[ shift(f) ]](k) = f(k)\n</pre>\n</aside>\n<p>Here’s what’s different:</p>\n<ul>\n<li>\n<p>Standard shift/reset</p>\n<ul>\n<li>Materialize the continuation (the return path) of shift</li>\n<li>Selectively CPS-transform the code outside of shift (up to enclosing reset)</li>\n<li>Code inside shift is in direct style</li>\n<li>Shift body invokes k as desired, metacontinuation (what happens after calling k) is implicit</li>\n<li>Reset applies identity continuation to extract result</li>\n</ul>\n</li>\n<li>\n<p>Affine, non-escaping shift/reset</p>\n<ul>\n<li>Materialize the metacontinuation (the “cleanup” code, what to do after returning)</li>\n<li>Selectively CPS-transform the code inside of shift</li>\n<li>Code outside shift is in direct style</li>\n<li>Shift returns normally, but pushes explicit metacontinuation (continuation of calling k) on a stack</li>\n<li>Reset empties the stack to execute metacontinuation and extract result</li>\n</ul>\n</li>\n</ul>\n<h2>Technical Details</h2>\n<p>Recall running Example:</p>\n<pre>\nreset(() => {\n    4 + shift(k => k(3) * 2)\n})\n// result: (4 + 3) * 2 = 14\n</pre>\n<p>Proposed implementation (example):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet stack = []\nstack.push(r => r * 2)\nlet r = 4 + 3\nstack.pop()(r)\n</code>\n<p>Proposed implementation (generic, linear case):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet stack = []\nfunction shift(f) {\n  let rval\n  f((z,k2) => { rval = z; stack.push(k2) })\n  return rval\n}\nfunction reset(f) {\n  let save = stack.length\n  let r = f()\n  // exception handling elided\n  while (stack.length > save)\n    r = stack.pop()(r)\n  return r\n}\n</code>\n<p>Let’s try it on our example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nprint(reset(() => 4 + shift(k => k(3, r => r*2))))\n</code>\n<p>Another example (multiple shifts):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction foo() {\n    let x1 = shift(k => k(\"1\", r => r + \"A\"))\n    let x2 = shift(k => k(\"2\", r => r + \"B\"))\n    let x3 = shift(k => k(\"3\", r => r + \"C\"))\n    return (x1+x2+x3)\n}\nprint(reset(foo))\n</code>\n<h3>Linear to Affine</h3>\n<p>The code shown above only implements the linear case (exactly 1 use of k). To deal with the affine case (k not used at all), we can throw an exception when we detect that the function passed to shift returns without having invoked k. This exception can communicate the result value outward until caught by reset.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h3>Sync to Async, Non-Escaping to Escaping</h3>\n<p>Since our implementation returns normally (using the regular call stack) we cannot use our version of shift to actually interrupt the program, and, say, continue later by calling k from an event handler.</p>\n<p>Many languages these days implement async/await or generators with <code class=\"language-text\">yield</code>. Essentially, these are one-shot <em>undelimited</em> continuations. This differs from our non-escaping model in that asynchronous interruption is supported, using some variant of CPS underneath the covers (typically chaining futures and promises).</p>\n<p>Using the auxiliary stack technique shown above, we can extend these existing facilities to (potentially escaping) one-shot <em>delimited</em> continuations.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h3>The CPS Hierarchy</h3>\n<p>How to support nested continuations (e.g. for higher-order derivatives in AD)? Maintain a separate stack for each level of nesting, so that shift-n can push to the level-n stack anywhere.</p>\n<p><strong>Exercise:</strong> implement!</p>\n<h2>Discussion</h2>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://dev.to/yelouafi/algebraic-effects-in-javascript-part-3---delimited-continuations-42hj\">https://dev.to/yelouafi/algebraic-effects-in-javascript-part-3---delimited-continuations-42hj</a></li>\n<li><a href=\"https://gist.github.com/yelouafi/44f5ed9bcdd1100b1902bcdb80aa32da\">https://gist.github.com/yelouafi/44f5ed9bcdd1100b1902bcdb80aa32da</a></li>\n</ul>","fields":{"slug":"/Public/Generic/affine-continuations/"},"frontmatter":{"date":"July 14, 2020","title":"Implementing Affine Non-Escaping Delimited Continuations with a Single Auxiliary Stack","description":"Instead of materializing the continuation (the return path) of 'shift', we materialize the metacontinuation (the 'cleanup' code) on a stack that is drained by 'reset'.","keywords":"Delimited Continuations, Shift/Reset, Async","tags":null}}},{"node":{"excerpt":"Differentiable programming enables a form of backwards execution of programs: specify a computation based on tunable parameters, provide a…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        invokeOnClear()\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nlet clearHook = null\nfunction onclear(f) {\n  clearHook = f\n}\nfunction invokeOnClear() {\n  if (clearHook) {\n    clearHook()\n    clearHook = null\n  }\n}\nfunction clear() {\n    invokeOnClear()\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Differentiable programming enables a form of backwards execution of programs: specify a computation based on tunable parameters, provide a desired result, and then use gradient descent to derive the correct parameter values that match the computation to the desired output.</p>\n<p>Let’s explore this idea in the context of interative graphics. We’ll implement just the drawing logic, and obtain an interactive environment that enables interaction with the drawn shapes, subject to constraints inherent in the program structure.</p>\n<p>The code is based on the <a href=\"/Public/Generic/differentiable-programming-in-js\">minimal AD toolkit presented in a companion note</a>.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// stack to remember backward operations\nlet tape = []\n// dual number api\nfunction num(x) {\n    return { val: x, grad: 0 }\n}\nfunction plus(x,y) {\n    let z = num(x.val + y.val)\n    tape.push(() => { x.grad += z.grad; y.grad += z.grad })\n    return z\n}\nfunction minus(x,y) {\n    let z = num(x.val - y.val)\n    tape.push(() => { x.grad += z.grad; y.grad -= z.grad })\n    return z\n}\nfunction times(x,y) {\n    let z = num(x.val * y.val)\n    tape.push(() => { x.grad += y.val * z.grad; y.grad += x.val * z.grad })\n    return z\n}\nfunction sin(x) {\n    let z = num(Math.sin(x.val))\n    tape.push(() => { x.grad += z.grad * Math.cos(x.val) })\n    return z\n}\nfunction cos(x) {\n    let z = num(Math.cos(x.val))\n    tape.push(() => { x.grad += -z.grad * Math.sin(x.val) })\n    return z\n}\n// derivative api\nfunction deriv(f) {\n    function d(x) {\n        // forward pass\n        let dx = num(x)\n        let dz = f(dx)\n        dz.grad = 1\n        // backward pass\n        for (b of tape.reverse()) b()\n        tape = []\n        return dx.grad\n    }\n    return d\n}\n// optimizable parameters\nlet params = []\nfunction param(x) {\n    const dx = num(x)\n    params.push(dx)\n    return dx\n}\n// compute primal and gradient\nfunction compute(loss) {\n    tape = []\n    // forward\n    const d = loss()\n    // backprop\n    d.grad = 1\n    for (const b of tape.reverse()) b()\n    return d\n}\n// one optimization step\nlet lr = 0.0001 // learning rate\nfunction optimize(loss) {\n    const d = compute(loss)\n    // gradient descent\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        p.val -= lr * p.grad\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// basic drawing code\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 300\ncvs.height = 150\nlet ctx = cvs.getContext(\"2d\")\no.appendChild(cvs)\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n}\n</code>\n<p>Let’s define a parameterized drawing. We pick an example from the <a href=\"https://ravichugh.github.io/sketch-n-sketch/\">Sketch-n-Sketch</a> bidirectional programming environment):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet y = param(10)\nlet w = param(20)\nlet h = param(100)\nlet d = param(40)\nfunction draw() {\n    drawRect(times(num(1), d), y, w, h)\n    drawRect(times(num(2), d), y, w, h)\n    drawRect(times(num(3), d), y, w, h)\n    drawRect(times(num(4), d), y, w, h)\n}\n</code>\n<p>Regular forward computation will plot it to the screen:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndraw()\n</code>\n<h2>Interactivity</h2>\n<p>Now let’s make it interactive. We do this by introducing a set of “active” (draggable) points, that are coupled to differentiable coordinates.</p>\n<p>Whenever we move such a point, we set its gradient to the delta between the last drawn position and the current mouse position, and then run gradient descent to adjust the parameters of the drawing.</p>\n<p>This will tweak as many parametric aspects of the drawing as necessary to move the desired point to its new position.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet active = []\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n  active.push({x,y})\n  active.push({x: plus(x,w), y: plus(y,h)})\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawActive() {\n  ctx.strokeStyle = \"#aaaaaa\"\n  ctx.lineWidth = 2\n  for (let {x,y} of active) {\n    ctx.beginPath()\n    ctx.arc(x.val, y.val, 5, 0, 2*Math.PI)\n    ctx.stroke()\n  }\n  ctx.strokeStyle = \"black\"\n}\nfunction drawAll() {\n  tape = []\n  active = []\n  ctx.clearRect(0,0,300,150)\n  draw()\n  drawActive()\n}\nfunction findActivePoint(offsetX,offsetY) {\n  for (let i in active) {\n    let {x,y} = active[i]\n    const dx = x.val - offsetX\n    const dy = y.val - offsetY\n    if (Math.sqrt(dx*dx + dy*dy) < 5)\n      return i\n  }\n  return -1\n}\nfunction dragActivePoint(dragging,offsetX,offsetY) {\n  for (let i = 0; i<200; i++){\n    let {x,y} = active[dragging]\n    x.grad += offsetX - x.val\n    y.grad += offsetY - y.val\n    optimize()\n    drawAll()\n  }\n}\nlr = 0.01\nfunction optimize() {\n  // backprop\n  for (b of tape.reverse()) b()\n  tape = []\n  // gradient descent\n  let totaldiff = 0\n  for (let p of params) {\n    totaldiff += p.grad*p.grad\n    p.val += lr * p.grad\n    p.grad = 0\n  }\n}\ncvs.addEventListener(\"mousedown\", ev => {\n  let dragging = findActivePoint(ev.offsetX, ev.offsetY)\n  if (dragging >= 0) {\n    let drag = ev => dragActivePoint(dragging,ev.offsetX,ev.offsetY)\n    document.addEventListener(\"mousemove\", drag)\n    document.addEventListener(\"mouseup\", ev => {\n      document.removeEventListener(\"mousemove\", drag)\n    })\n  }\n})\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawAll()\n</code>\n<p>Note how dragging the top left corners only moves the rectangles, while dragging the bottom right corners also resizes them. This is because the bottom right corners create gradient updates for <code class=\"language-text\">x</code>,<code class=\"language-text\">y</code> and <code class=\"language-text\">w</code>,<code class=\"language-text\">h</code> to equals parts, instead of just <code class=\"language-text\">x</code>,<code class=\"language-text\">y</code>.</p>\n<h2>More Constraints</h2>\n<p>What if we want to have more control, such as a control handle that <em>only</em> resizes, without moving?</p>\n<p>Fortunately, we can achieve this with a relatively small change. We allow each active point to specify others that should <em>not</em> move, e.g., opposite corners of a rectangle.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction drawRect(x,y,w,h) {\n  ctx.fillRect(x.val, y.val, w.val, h.val)\n  // center\n  active.push({x: plus(x, times(w, num(0.5))),\n               y: plus(y, times(h, num(0.5))),\n               constraint: [w,h]})\n  // top left\n  active.push({x: x, y: y, constraint: [plus(x,w),plus(y,h)]})\n  // top right\n  active.push({x: plus(x,w), y: y, constraint: [x,plus(y,h)]})\n  // bottom left\n  active.push({x: x, y: plus(y,h), constraint: [plus(x,w),y]})\n  // bottom right\n  active.push({x: plus(x,w), y: plus(y,h), constraint: [x,y]})\n}\n</code>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet constraint = []\nfunction findActivePoint(offsetX,offsetY) {\n  for (let i in active) {\n    let p = active[i]\n    const dx = p.x.val - offsetX\n    const dy = p.y.val - offsetY\n    if (Math.sqrt(dx*dx + dy*dy) < 5) {\n      constraint = (p.constraint || []).map(x => x.val)\n      return i\n    }\n  }\n  return -1\n}\nfunction dragActivePoint(dragging,offsetX,offsetY) {\n  for (let i = 0; i<200; i++){\n    let p = active[dragging]\n    p.x.grad += offsetX - p.x.val\n    p.y.grad += offsetY - p.y.val\n    for (let i in p.constraint) {\n      p.constraint[i].grad += constraint[i] - p.constraint[i].val\n    }\n    optimize()\n    drawAll()\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawAll()\n</code>\n<p>This is just another form of constraints. Active points are constrained to follow the mouse pointer when dragged (by setting their gradient to the delta between current and desired position), and stationary points are constrained to stay fixed by adjusting their gradient to the delta between their current position (which may have shifted) and the position at the start of the drag, effectively keeping them in place.</p>\n<p>Other forms of constraints are of course possible as well, e.g., to keep shapes non-overlapping, or a certain distance apart.</p>\n<h2>More Examples</h2>\n<h3>Sine Wave</h3>\n<p>Here is another example from Sketch-n-Sketch. We fix the starting x,y coordinate so dragging will be directed to only change the amplitude, not the overall position of the curve:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet [x0,y0] = [10,50]\nlet [pw,ph,psep,pamp] = [15,50,20,40].map(param)\nlet n = 14\nfunction draw() {\n  function box(i) {\n   let x = plus(num(x0), times(num(i), psep))\n   let y = minus(num(y0), times(pamp, sin(num(i*2*Math.PI/n))))\n   drawRect(x,y,pw,ph)\n  }\n  for (let i = 0; i < n; i++) box(i)\n}\ndrawAll()\n</code>\n<h3>Sliders</h3>\n<p>We can create UI elements such as interconnected sliders:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet p1 = param(20)\nlet p2 = param(20)\nfunction draw() {\n  let [x0,y0,] = [10,20]\n  function slider(p,min,max,label) {\n    ctx.fillText(label,x0+110,y0+3)\n    ctx.fillRect(x0,y0-2,100,4)\n    if (p.val < min) p.val = min\n    if (p.val > max) p.val = max\n    active.push({x:plus(num(x0),times(p,num(100/(max-min)))),y:num(y0)})\n    y0 += 20\n  }\n  slider(p1,0,100,\"p1\")\n  slider(p2,0,100,\"p2\")\n  slider(plus(p1,p2),0,200,\"p1+p2\")\n  slider(times(p1,p2),0,10000,\"p1*p2\")\n  slider(minus(num(200),plus(p1,p2)),0,200,\"200-p1-p2\")\n  slider(minus(num(100),p1),0,100,\"100-p1\")\n  slider(minus(num(100),p2),0,100,\"100-p2\")\n}\ndrawAll()\n</code>\n<p>Note how dragging the <code class=\"language-text\">p1+p2</code> or <code class=\"language-text\">p1*p2</code> will update <code class=\"language-text\">p1</code> and <code class=\"language-text\">p2</code> without any explicit backward calculation. Note also the clamping to <code class=\"language-text\">min</code> and <code class=\"language-text\">max</code> using regular control flow (an alternative would be soft clamping via gradients, or we could do both).</p>\n<h3>Connected Points and Circles</h3>\n<p>Some more examples, this time from <a href=\"http://omrelli.ug/g9/gallery/\">g9.js</a>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet px = param(80)\nlet py = param(70)\nfunction draw() {\n  active.push({x:px,y:py})\n  active.push({x:py,y:px})\n}\ndrawAll()\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet pradius = param(50)\nlet pangle = param(0)\nfunction draw() {\nlr = 0.0001\n    let [mx,my] = [num(75),num(75)]\n    let sides = 10\n    for (var i=0; i < sides; i++) {\n        let a = plus(pangle, num(i/sides * Math.PI * 2))\n        let a1 = times(num(-1),a)\n        let r1 = pradius\n        let r2 = times(r1, num(0.5))\n        active.push({x: plus(mx, times(r1, cos( a))), y: plus(my, times(r1, sin( a))) })\n        active.push({x: plus(mx, times(r2, cos(a1))), y: plus(my, times(r2, sin(a1))) })\n    }\n}\ndrawAll()\n</code>\n<p>The last example is interesting as it computes derivates for <code class=\"language-text\">sin</code> and <code class=\"language-text\">cos</code>. This requires a smaller learning rate. <a href=\"/gradient-descent-with-adam\">Adaptive optimizers such as Adam</a> might perform better on this example than the plain vanilla gradient descent we’re currently using.</p>\n<h3>Turtle Graphics</h3>\n<p>A classic example of LOGO-style turtle graphics: here is a simple spiral drawn using forward, turn, etc. commands. Varying the radius, angle, and scale leads to many different shapes. Drag the control points to explore!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet pradius = param(10)\nlet pangle = param(60)\nlet pscale = num(1.2)\nfunction draw() {\n  // turtle API\n  let [mx,my,ma] = [num(75),num(75),num(-Math.PI)]\n  active.push({x: mx, y: my })\n  ctx.beginPath()\n  ctx.moveTo(mx.val, my.val)\n  function forward(n) {\n    mx = plus(mx,times(sin(ma), n))\n    my = plus(my,times(cos(ma), n))\n    active.push({x: mx, y: my })\n    ctx.lineTo(mx.val, my.val)\n  }\n  function turn(n) {\n    ma = minus(ma, times(n, num(Math.PI/180)))\n  }\n  // turtle program: draw spiral\n  let [r,a,s] = [pradius, pangle, pscale]\n  for (let i = 0; i < 10; i++) {\n    forward(r)\n    turn(a)\n    r = times(r, s)\n  }\n  // finish up\n  ctx.stroke()\n}\ndrawAll()\n</code>\n<h2>Discussion</h2>\n<p>Related:</p>\n<ul>\n<li>G9 <a href=\"http://omrelli.ug/g9/\">http://omrelli.ug/g9/</a></li>\n<li>Basalt <a href=\"https://www.anishathalye.com/2019/12/12/constraint-based-graphic-design/\">https://www.anishathalye.com/2019/12/12/constraint-based-graphic-design/</a></li>\n<li>HN discussion of Basalt, mentions other pieces of related work <a href=\"https://news.ycombinator.com/item?id=21774018\">https://news.ycombinator.com/item?id=21774018</a></li>\n<li>Sketch-n-Sketch <a href=\"https://ravichugh.github.io/sketch-n-sketch/\">https://ravichugh.github.io/sketch-n-sketch/</a></li>\n<li>Apparatus <a href=\"http://aprt.us\">http://aprt.us</a></li>\n</ul>","fields":{"slug":"/Public/Generic/differentiable-graphics/"},"frontmatter":{"date":"July 12, 2020","title":"Differentiable Programming for Interactive Graphics","description":"From parameterized drawings to interactive diagrams with differentiable programming and gradient descent.","keywords":"Gradient Descent, Interactive Graphics, AutoDiff","tags":null}}},{"node":{"excerpt":"React is a JavaScript library for building interactive user interfaces. Contrary to traditional, imperative, approaches to UI programming…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        invokeOnClear()\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nlet clearHook = null\nfunction onclear(f) {\n  clearHook = f\n}\nfunction invokeOnClear() {\n  if (clearHook) {\n    clearHook()\n    clearHook = null\n  }\n}\nfunction clear() {\n    invokeOnClear()\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>React is a JavaScript library for building interactive user interfaces. Contrary to traditional, imperative, approaches to UI programming, React embraces ideas from functional programming.</p>\n<aside>\n<h2>Creating Web UIs Programmatically</h2>\n<p>Traditionally, web pages were largely based on static HTML, perhaps generated by server-side application logic, and maybe with a bit of JavaScript sprinkled in for interactivity.</p>\n<p>React and similar frameworks turn this model upside-down, and generate the entire DOM presentation programmatically from JS.\nClearly, a good API for this is key. The traditional, imperative, DOM API is verbose and cumbersome. Hence, React code is typically written using JSX — JavaScript enriched with quasiquotations to embed HTML syntax — but this layer of syntactic sugar is entirely optional.</p>\n<h3>DOM Trees: Think S-Expressions</h3>\n<p>We’ll use a more direct API as our starting point. Our first version (which we will gradually refine) recomputes the full DOM for every change, which is limiting in several ways. First, it is inefficient. Second, while it supports persistent/global state, it does not support ephemeral/local state.</p>\n<p>The essence of this API is a single function <code class=\"language-text\">createElement</code> (which we’ll alias to <code class=\"language-text\">e</code>) to create DOM nodes with a given set of properties and children.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  const dom = document.createElement(type)\n  // Set properties\n  for (let k in props) {\n    if (isEvent(k))\n      dom.addEventListener(eventName(k), props[k])\n    else\n      dom[k] = props[k]\n  }\n  // Add children\n  for (let child of children) {\n    if (!(child instanceof Node))\n      child = document.createTextNode(child)\n    dom.appendChild(child)\n  }\n  return dom\n}\nfunction isEvent(key) {\n  return key.startsWith(\"on\")\n}\nfunction eventName(key) {\n  return key.toLowerCase().substring(2)\n}\nfunction render(element, container=o) {\n  container.innerHTML = \"\"\n  container.appendChild(element)\n}\nconst e = createElement\n</code>\n<p>Here is a basic example. Note how we’re essentially using s-expression syntax to build DOM trees:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction greet(name) {\n  return e(\"div\",{},\"Hello, \",e(\"i\",{},name),\"!\")\n}\nrender(greet(\"World\"))\n</code>\n<h3>Functions I: Event Listeners for Interactivity</h3>\n<p>Properties may include event listeners, so we can support basic interactivity. True to our goal, we recompute the whole UI on every change:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nconst state = [{label: \"A\", count: 1}, {label: \"B\", count: 1}]\nfunction App() {\n  return e(\"div\", {}, ...state.map(Counter))\n}\nfunction Counter(state) {\n  return e(\"div\",\n    { onClick: () => update(state.count += 1) },\n    state.label, \": \", state.count)\n}\nfunction update() {\n  render(App())\n}\nrender(App())\n</code>\n<h3>Functions II: Abstracting Component Composition</h3>\n<p>Note how we can freely use functional abstraction to build components. In the current implementation, these functions are immediately evaluated to compute UI components, but they do not become part of the computed UI. Thinking about this more formally, the language of UI components does not include a case for function application. Instead, all function applications are fully normalized (beta-reduced) while computing the UI.</p>\n<p>This works OK here because the <em>entire</em> UI state is determined by the global model.</p>\n<h3>Limitation: Recomputation Discards Local State</h3>\n<p>But this is not always the case. Here is an example that doesn’t work so well. Let’s build a temperature converter:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nconst state = { val: 30 }\nfunction App() {\n  return e(\"div\", {},\n    Field(state, \"°F: \", 9/5, 32),\n    Field(state, \"°C: \", 1, 0))\n}\nfunction Field(state, label, factor, offset) {\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state.val*factor+offset),\n      onInput: (e) => update(state.val = (event.target.value-offset)/factor) }))\n}\nfunction update() {\n  render(App())\n}\nrender(App())\n</code>\n<p>Using this interface is quite a pain. Every time we change one of the fields, an input event is triggered that deletes the existing text fields and replaces them with identical ones. And in doing so, we throw away the ephemeral state of the input fields: keyboard focus, cursor position, etc.</p>\n</aside>\n<p>Notably, React is based on a programming model that treats the UI as immutable, which means that (conceptually) the entire UI is regenerated from a data model after every change.</p>\n<aside>\n<h2>Virtual DOM and Diff Algorithm</h2>\n<p>The key idea behind React is to prevent the situation in the previous section by decoupling ephemeral presentation state from persistent application state and to preserve the presentation state for pieces of application state that didn’t change.</p>\n<h3>Virtual DOM</h3>\n<p>React introduces a “virtual DOM” layer, i.e., a shallow representation of UI elements as plain JavaScript objects. How to detect change? Keep the previous version and do a diff! This process is called “reconciliation” in React.</p>\n<p>Here is our revised implementation (much of it inspired by <a href=\"https://pomb.us/build-your-own-react/\">Rodrigo Pombo’s “Build your own React”</a>). Function <code class=\"language-text\">createElement</code> just wraps its parameters in an object for later use:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: props,\n    children: children.map(child =>\n      typeof child === \"object\"\n        ? child\n        : createTextElement(child)\n      )\n  }\n}\n// Special case for plain strings: distinction\n// is not really necessary here, but it allows\n// updating \"nodeValue\" as property without\n// dispatch later\nfunction createTextElement(text) {\n  return {\n    type: \"TEXT_ELEMENT\",\n    props: {\n      nodeValue: String(text),\n    },\n    children: []\n  }\n}\n// Create an actual DOM node\nfunction createDom(type) {\n  const dom = type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(type)\n  return dom\n}\n</code>\n<h3>Diffing Properties and Tree Structure</h3>\n<p>Given a real DOM node and old and new virtual DOM nodes, we can diff and patch object properties including event listeners:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction updateProperties(dom, prevProps, nextProps) {\n  const isNew  = key => prevProps[key] !== nextProps[key]\n  const isGone = key => !(key in nextProps)\n  // Remove old properties and event listeners\n  for (let k in prevProps) {\n    if (isEvent(k)) {\n      if (isGone(k) || isNew(k))\n        dom.removeEventListener(eventName(k), prevProps[k])\n    } else {\n      if (isGone(k))\n        dom[k] = \"\"\n    }\n  }\n  // Remove new/updated properties and event listeners\n  for (let k in nextProps) {\n    if (isEvent(k)) {\n      if (isNew(k))\n        dom.addEventListener(eventName(k), nextProps[k])\n    } else {\n      if (isNew(k) && dom[k] != nextProps[k])\n        dom[k] = nextProps[k]\n    }\n  }\n}\n</code>\n<p>And we proceed recursively to diff and patch DOM children, dealing with newly inserted and removed nodes appropriately:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      newChild.dom = oldChild.dom\n      updateProperties(newChild.dom, oldChild.props, newChild.props)\n      updateChildren(newChild.dom, oldChild.children, newChild.children)\n    } else {\n    if (oldChild) {\n      domParent.removeChild(oldChild.dom)\n    }\n    if (newChild) {\n      newChild.dom = createDom(newChild.type),\n      updateProperties(newChild.dom, {}, newChild.props)\n      updateChildren(newChild.dom, [], newChild.children)\n      domParent.appendChild(newChild.dom)\n    }\n    }\n  }\n}\n</code>\n<h3>Top Level &#x26; Improved Example</h3>\n<p>Finally, the <code class=\"language-text\">render</code> method remembers the previous version\nand triggers reconciliation:\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nlet currentRoot = []\nfunction render(element, container=o) {\nupdateChildren(container, currentRoot, [element])\ncurrentRoot = [element]\n}\n// internal: cleanup on recompile\nonclear(() => updateChildren(o,currentRoot,[]))\n</code></p>\n<p>Here is the temperature converter example again (code is unchanged):</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nconst state = { val: 30 }\nfunction App() {\n  return e(\"div\", {},\n    Field(state, \"°F: \", 9/5, 32),\n    Field(state, \"°C: \", 1, 0))\n}\nfunction Field(state, label, factor, offset) {\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state.val*factor+offset),\n      onInput: (e) => update(state.val = (event.target.value-offset)/factor) }))\n}\nfunction update() {\n  render(App(),o)\n}\nrender(App(),o)\n</code>\n<p>This is much better than before! Since physical DOM nodes are preserved, we no longer lose any ephemeral state.</p>\n<h3>Diff Algorithm Considerations I: How to Compare</h3>\n<p>The diff algorithm used here (also in the real React) is quite simplistic. This is a conscious choice. First, diffs are computed on trees so the natural hierarchy already provides significant structure. Doing a “proper” diff on the sequence of child nodes would be too expensive for many uses, with unclear practical benefits.</p>\n<p>Clearly there are cases where this is too simple, in particular when elements are reordered. For such situations, React provides a facility to diff child nodes by a computed key instead of by numeric index within the parent.</p>\n<p><strong>Exercise:</strong> implement reconciliation by key.</p>\n<p>See also: <a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation</a> chapter of the React.js docs.</p>\n<h3>Diff Algorithm Considerations II: What to Compare</h3>\n<p>Another question is what to diff against, and again there are some choices: in the code above, we diff the freshly computed virtual DOM with the previous virtual DOM. An alternative would be to diff the new virtual DOM against the real mutable DOM (in fact, we’re also looking at the real DOM for property updates, since the real DOM can be changed through user actions). Keeping the previous virtual DOM around becomes necessary once we add additional structure that is not present in the real DOM (virtual components, in the next section).</p>\n<p>Virtual DOM trees are treated by design as immutable. However, we’re taking a little shortcut by mutably adding a reference to the physical DOM node.</p>\n<p>This works fine for most cases, but what if we want to use a single child node in multiple places? Then we have a problem: we’d try add <em>two</em> physical DOM references to the same virtual DOM node. We should be allowed to freely share virtual DOM nodes, but in our implementation this won’t work (not without an explicit copy operation).</p>\n<p>The solution is to create a mutable “augmented DOM” that represents the currently installed state. This is what React does, as part of its Fiber data structure.</p>\n<p><strong>Exercise:</strong> implement mutable augmented DOM.</p>\n</aside>\n<p>A key obstacle to making this approach work in practice is that UIs contain a lot of ephemeral state that is not determined by the data model (selections, cursor and scroll positions, etc). To deal with this, React diffs the new UI from the previous version, and carefully patches underlying mutable UI widgets to preserve local emphemeral state across updates.</p>\n<aside>\n<h2>Components, Life Cycle, State</h2>\n<p>Of course we want to be able to define our own local state in higher-level UI components, in addition to state embedded in DOM nodes. For example, which tab is shown, which items are selected, etc.</p>\n<p>The key idea is to replicate what we did for the physical DOM in the virtual DOM: maintain a mutable component instance that, once created, is shared by all “versions” of the component.</p>\n<p>In addition, we want to support local updates to the tree. Whenever a component changes, only the components below should be recomputed, not the whole tree.</p>\n<p>Finally, we want to suppport lifecycle callbacks. In many cases, a component needs to perform some cleanup once it’s removed from the tree (e.g., close a network connection or deinstall a timer).</p>\n<p>The basics of the implementation remain the same. Only the diff and update code gets some extra cases:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction renderSubTree(newChildInst) {\n  let newSub = [newChildInst.type(newChildInst)]\n  updateChildren(newChildInst.domParent, newChildInst.sub, newSub)\n  newChildInst.sub = newSub\n}\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      if (newChild.type instanceof Function) {\n        let oldSub = oldChild.instance.sub\n        newChild.instance = oldChild.instance\n        newChild.instance.type = newChild.type\n        newChild.instance.props = newChild.props\n        newChild.instance.children = newChild.children\n        newChild.instance.domParent = domParent\n        newChild.instance.sub = [newChild.type(newChild.instance)]\n        updateChildren(domParent, oldSub, newChild.instance.sub)\n      } else {\n        newChild.dom = oldChild.dom\n        updateProperties(newChild.dom, oldChild.props, newChild.props)\n        updateChildren(newChild.dom, oldChild.children, newChild.children)\n      }\n    } else {\n      if (oldChild) {\n        if (oldChild.type instanceof Function) {\n          if (oldChild.instance.componentWillUnmount)\n            oldChild.instance.componentWillUnmount()\n          updateChildren(domParent, oldChild.instance.sub, [])\n        } else {\n          domParent.removeChild(oldChild.dom)\n          // make sure all cleanup handlers are called\n          updateChildren(oldChild.dom, oldChild.children, [])\n        }\n      }\n      if (newChild) {\n        if (newChild.type instanceof Function) {\n          // instance is uninitialized\n          newChild.instance = {}\n          newChild.instance.type = newChild.type\n          newChild.instance.props = newChild.props\n          newChild.instance.children = newChild.children\n          newChild.instance.domParent = domParent\n          newChild.instance.sub = [newChild.type(newChild.instance)]\n          updateChildren(domParent, [], newChild.instance.sub)\n        } else {\n          newChild.dom = createDom(newChild.type),\n          updateProperties(newChild.dom, {}, newChild.props)\n          updateChildren(newChild.dom, [], newChild.children)\n          domParent.appendChild(newChild.dom)\n        }\n      }\n    }\n  }\n}\n</code>\n<h3>Local State</h3>\n<p>Here is the temperature converter again, now using local component state:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example\nfunction App(self) {\n  if (self.state == undefined)\n    self.state = 30\n  const setState = (x => self.state = x)\n  return e(\"div\", {}, \"Foo\",\n    e(Field, { state: self.state, setState: setState, label: \"°F: \", factor: 9/5, offset: 32}),\n    e(Field, { state: self.state, setState: setState, label: \"°C: \", factor: 1, offset: 0}))\n}\nfunction Field(self) {\n  const { state, setState, label, factor, offset } = self.props\n  return e(\"span\",{}, label,\n    e(\"input\", {\n      type: \"text\",\n      value: (state*factor+offset),\n      onInput: (e) => setState((event.target.value-offset)/factor) }))\n}\nrender(e(App,{}),o)\n</code>\n<h3>Nested Local State</h3>\n<p>Nested state work as expected, too:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer(self) {\n  if (self.v == undefined)\n    self.v = 0\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(self) {\n  const [oSt,oSetSt] = self.props.outerState\n  if (self.v == undefined)\n    self.v = oSt\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nrender(e(Outer),o)\n</code>\n<p>Clicking on “Outer” or “Inner” will increment the respective counter.</p>\n<h3>Asynchronicity and Life Cycle Management</h3>\n<p>We can support asynchronous interaction, e.g. using a timer:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer(self) {\n  if (self.v == undefined)\n    self.v = 0\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  return e(Inner,{outerState: [self.v, setState]})\n}\nfunction Inner(self) {\n  const [oSt,oSetSt] = self.props.outerState\n  if (self.v == undefined)\n    self.v = oSt\n  const setState = (f => renderSubTree(self,self.v = f(self.v)))\n  const [iSt,iSetSt] = [self.v, setState]\n  if (self.timer == undefined) {\n    self.timer = setInterval(() => iSetSt(s=>s-1), 1000)\n    console.log(\"start \",self.timer)\n  }\n  self.componentWillUnmount = () => {\n    console.log(\"stop \",self.timer)\n    clearInterval(self.timer)\n  }\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n<p>Once started, the timer will run forever if we don’t shut it down. We can invoke such cleanup logic using <code class=\"language-text\">componentWillUnmount</code>.</p>\n</aside>\n<p>React implements a tree of components, with data flowing unidirectionally from parents to children. The conceptual model of a component is a function from data to UI, with lifecycle callbacks (invoked when added/removed from tree), and optional local state. Whenever a child component wants to update state higher up in the tree, the corresponding subtree will be regenerated based on the new state of the ancestor.</p>\n<aside>\n<h2>State and Effect Hooks API</h2>\n<p>It is useful to encapsulate state and lifecycle management further, using functional abstractions. React provides a “hooks” API, which developers can use to parameterize, compose, and abstracted over component behavior using functional techniques.</p>\n<h3>The useState and useEffect Hooks</h3>\n<p>The use of hooks allows us to hide the mutable component instance from the user-facing API entirely, accessing it only internally in a sort of dynamically scoped way during component evaluation.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet currentInstance = null\nfunction useState(init) {\n  let inst = currentInstance.self\n  let i = currentInstance.hookIndex++\n  if (i < inst.hooks.length)\n    return inst.hooks[i]\n  let update = (f => renderSubTree(inst, inst.hooks[i][0] = f(inst.hooks[i][0])))\n  return inst.hooks[i] = [init, update]\n}\nfunction useEffect(f,watch) {\n  let inst = currentInstance.self\n  let i = currentInstance.effectIndex++\n  if (i < inst.effects.length) {\n    let [g1,w1] = inst.effects[i]\n    if (watch != undefined && arraysMatch(w1,watch))\n      return\n    if (g1) g1()\n  }\n  inst.effects[i] = [f(),watch]\n}\nfunction arraysMatch(arr1, arr2) {\n  if (arr1.length !== arr2.length) return false;\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) return false;\n  }\n  return true;\n}\nfunction renderInstance(instance) {\n  let save = currentInstance\n  currentInstance = { self: instance, hookIndex: 0, effectIndex: 0 }\n  let res = instance.type(instance.props, instance.children)\n  currentInstance = save\n  return res\n}\n</code>\n<p>We refactor <code class=\"language-text\">updateChildren</code> slightly to reduce code duplication between the insert and update cases.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction renderSubTree(instance) {\n  let oldSub = instance.sub\n  instance.sub = [renderInstance(instance)]\n  updateChildren(instance.domParent, oldSub, instance.sub)\n}\nfunction updateInstance(domParent, instance, newChild) {\n  let oldSub = instance.sub\n  newChild.instance = instance\n  instance.type = newChild.type\n  instance.props = newChild.props\n  instance.children = newChild.children\n  instance.domParent = domParent\n  instance.sub = [renderInstance(instance)]\n  updateChildren(domParent, oldSub, instance.sub)\n}\nfunction updateChildren(domParent, oldChildren, newChildren) {\n  let len = Math.max(oldChildren.length, newChildren.length)\n  for (let i = 0; i < len; i++) {\n    const newChild = newChildren[i]\n    const oldChild = oldChildren[i]\n    const sameType =\n      oldChild &&\n      newChild &&\n      newChild.type == oldChild.type\n    if (sameType) {\n      if (newChild.type instanceof Function) {\n        updateInstance(domParent, oldChild.instance, newChild)\n      } else {\n        newChild.dom = oldChild.dom\n        updateProperties(newChild.dom, oldChild.props, newChild.props)\n        updateChildren(newChild.dom, oldChild.children, newChild.children)\n      }\n    } else {\n      if (oldChild) {\n        if (oldChild.type instanceof Function) {\n          for (let [g,w] of oldChild.instance.effects) if (g) g()\n          updateChildren(domParent, oldChild.instance.sub, [])\n        } else {\n          domParent.removeChild(oldChild.dom)\n          // make sure all cleanup handlers are called\n          updateChildren(oldChild.dom, oldChild.children, [])\n        }\n      }\n      if (newChild) {\n        if (newChild.type instanceof Function) {\n          // instance is uninitialized\n          updateInstance(domParent, {sub: [], hooks: [], effects: []}, newChild)\n        } else {\n          newChild.dom = createDom(newChild.type),\n          updateProperties(newChild.dom, {}, newChild.props)\n          updateChildren(newChild.dom, [], newChild.children)\n          domParent.appendChild(newChild.dom)\n        }\n      }\n    }\n  }\n}\n</code>\n<p>Here is the timer example again, using hooks <code class=\"language-text\">useState</code> and <code class=\"language-text\">useEffect</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction Outer() {\n  const [iSt,iSetSt] = useState(0)\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(props) {\n  const [oSt,oSetSt] = props.outerState\n  const [iSt,iSetSt] = useState(oSt)\n  useEffect(() => {\n    let timer = setInterval(() => iSetSt(s=>s-1), 1000)\n    return () => clearInterval(timer)\n  }, [])\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n<h3>Custom Hooks: Reusable Interaction Patterns</h3>\n<p>The <code class=\"language-text\">useEffect</code> hook executes the provided function on\ncomponent insertion, and on updates whenever the second\nargument changes (<code class=\"language-text\">[]</code> in this case, so never).\nThe function returned from the provided one is installed\nas a cleanup callback.</p>\n<p>Based on this definition, we can extract the timer handling\ninto a new custom hook, <code class=\"language-text\">useTimer</code>, which can be reused by\nother components:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet useTimer = (f, n) => useEffect(() => {\n  let timer = setInterval(f, n)\n  return () => clearInterval(timer)\n}, [])\nfunction Outer() {\n  const [iSt,iSetSt] = useState(0)\n  return e(Inner,{outerState: [iSt,iSetSt]})\n}\nfunction Inner(props) {\n  const [oSt,oSetSt] = props.outerState\n  const [iSt,iSetSt] = useState(oSt)\n  useTimer(() => iSetSt(s=>s-1), 1000)\n  return e(\"div\",{},\n    e(\"div\", { onClick: () => oSetSt(s=>s+1) }, \"Outer: \", oSt),\n    e(\"div\", { onClick: () => iSetSt(s=>s+1) }, \"Inner: \", iSt))\n}\nawait buttonClick(\"start\")\nrender(e(Outer),o)\nawait buttonClick(\"stop\")\nrender(e(\"div\",{}),o)\n</code>\n</aside>\n<p>State management and other side effects are defined as “hooks” in React, using a higher-order functional API. This means that component behavior can be parameterized, composed, and abstracted over using functional\ntechniques.</p>\n<aside>\n<h2>Asynchronous Updates</h2>\n<p>Right now we update (re-render) only the relevant subtrees, which is good. But we’re updating them synchronously. If there are two subsequent modifications of the same component, we’ll update it twice. If we modify a child, then the parent, the child gets updated twice.</p>\n<h3>Async Updates</h3>\n<p>Better idea: schedule updates in a work queue, and batch-process them later. When processing, order by distance from the root. This way, parents are processed before children. Maintain a dirty flag on components, so that redundant children can be skipped.</p>\n<h3>Async State Management</h3>\n<p>Directly modifying component state but processing DOM updates asynchronously may lead to some inconsistencies (state is state, so inconsistencies may have other causes as well).</p>\n<p>To reduce inconsistencies, do not modify component state directly, but schedule state updates <code class=\"language-text\">s =&gt; f(s)</code> for batch processing, too (can be done during reconciliation).</p>\n<p>The dirty flag on components becomes a queue of state transitions to apply. If empty, the component is up to date and doesn’t need re-rendering (unless props have changed).</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://github.com/facebook/react/issues/11527\">https://github.com/facebook/react/issues/11527</a></li>\n<li><a href=\"https://github.com/facebook/react/issues/11527#issuecomment-360199710\">https://github.com/facebook/react/issues/11527#issuecomment-360199710</a></li>\n</ul>\n<h3>Incremental Reconciliation</h3>\n<p>Reconciliation may take time, so there are benefits in making it interruptible. This is easy to do at the granularity of a worklist (non-overlapping subtrees), but for large trees it is worth to chunk up traversal of children. Standard methods exist to make a recursive traversal interruptible. React uses a Zipper-like data structure they call a fiber (a tree node with parent and sibling pointers). A simpler option in JS is async/await.</p>\n<p>It is still important that DOM modifications are applied atomically. After all, we don’t want to see a partially updated UI. Hence, React splits processing into a “render” and a “commit” phase. The (interruptible) render phase does all the diffing and determines necessary DOM changes, and the commit phase applies the final changes in a single atomic step.</p>\n<p>There is some overhead associated with maintaining data structures for this phase separation. Presumably these are outweighed by the benefits of incrementality in some cases but not all.</p>\n<h3>Concurrency</h3>\n<p>It is sometimes desirable to not process updates strictly in order, but according to priorities. This way, a response to clicks or key presses may be processed immediately, while, for example, updates due to incoming network data may be batched a little bit to enable processing in larger chunks (to keep the UI responsive to user actions).</p>\n</aside>\n<p>React always keeps the component tree in a consistent state, which provides considerable freedom for asynchronous processing, such as batching or prioritizing updates.</p>\n<aside>\n<h2>Discussion</h2>\n<p>At its core, React is a system for computing incremental updates on conceptually immutable trees. Children are computed from parents, and may contain independent local state. Information flows downward in the tree, from parents to children. Children may request a change further up the tree, which will trigger recomputation of the affected part of the tree.</p>\n<p>The basic design permits several degrees of freedom, including:</p>\n<ul>\n<li>What and how to diff (reconciliation by key, etc.)</li>\n<li>Synchronous and asynchronous processing (decoupling effect logic)</li>\n<li>User-defined functional abstractions (components, hooks, etc.)</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href=\"https://pomb.us/build-your-own-react/\">Build your own React</a> by Rodrigo Pompbo</li>\n<li><a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a></li>\n<li><a href=\"https://reactjs.org/docs/reconciliation.html\">Reconciliation</a> from the React.js docs</li>\n<li>State handling <a href=\"https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key\">broken</a> and <a href=\"https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key\">fixed</a> using keys</li>\n<li><a href=\"http://todomvc.com/examples/react/#/\">TodoMvc</a> example in React</li>\n<li>Dealing with input React Mental Models: Working With <code class=\"language-text\">&lt;input&gt;</code> | Learn React.Design Backstories <a href=\"https://learnreact.design/2020/03/31/react-mental-models-working-with-input\">https://learnreact.design/2020/03/31/react-mental-models-working-with-input</a> HN: React Mental Models: Working with Input | Hacker News <a href=\"https://news.ycombinator.com/item?id=22761622\">https://news.ycombinator.com/item?id=22761622</a></li>\n<li>A visual guide to React Mental models, part 2: useState, useEffect and lifecycles | Obed Parlapiano - JavaScript Engineer &#x26; Writer <a href=\"https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/\">https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/</a></li>\n</ul>\n</aside>","fields":{"slug":"/Public/Generic/deconstructing-react/"},"frontmatter":{"date":"July 07, 2020","title":"Deconstructing React","description":"How does React work? Let's build a React clone from scratch to understand.","keywords":"JavaScript, React, State, Hook, Virtual DOM, Diff, Reconciliation, Async","tags":null}}},{"node":{"excerpt":"Device APIs allow web pages to interface with the physical world, blending the boundary between web and native apps.\nPhones and tablets come…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Device APIs allow web pages to interface with the physical world, blending the boundary between web and native apps.\nPhones and tablets come with a variety of sensors, and web APIs exist for many of them. Below are examples for the most interesting ones.</p>\n<p>References:</p>\n<ul>\n<li><a href=\"https://developers.google.com/web/fundamentals\">Google developer pages</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API\">Mozilla developer’s network (MDN)</a></li>\n</ul>\n<h2>Touch</h2>\n<p>Finger and stylus, sensitive to touch size, pressure, tilt.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!window.PointerEvent)\n  return print(\"PointerEvent not supported\")\nlet cvs = document.createElement(\"canvas\")\ncvs.width = 600\ncvs.height = 300\nlet ctx = cvs.getContext(\"2d\")\nctx.strokeRect(0,0,cvs.width,cvs.height)\no.appendChild(cvs)\nlet msg = document.createElement(\"small\")\no.appendChild(msg)\nfunction show(e) {\n  msg.innerText = e+\"\\n\"\n}\nshow(\"navigator.maxTouchPoints: \"+ navigator.maxTouchPoints)\ncvs.style.touchAction=\"none\" // prevent scrolling\ncvs.addEventListener(\"pointerdown\", ev => {\n  cvs.setPointerCapture(ev.pointerId)\n  ev.preventDefault()\n  ev.stopPropagation()\n  // ev.stopImmediatePropagation() // necessary?\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointermove\", ev => {\n  ev.preventDefault()\n  ev.stopPropagation()\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointerup\", ev => {\n  ev.preventDefault()\n  drawTouch(ev)\n})\ncvs.addEventListener(\"pointercancel\", ev => {\n  ev.preventDefault()\n  drawTouch(ev)\n})\nfunction drawTouch(ev) {\n  show(ev.type + \"/\" + ev.pointerType + \"\\n\"+\n   \"width: \"+ev.width +\", \" +\n   \"height: \"+ev.height +\"\\n\" +\n   \"button: \"+ev.button +\", \" +\n   \"buttons: \"+ev.buttons +\"\\n\" +\n   \"pressure: \"+ev.pressure +\", \" +\n   \"tangentialPressure: \"+ev.tangentialPressure +\", \" +\n   \"webkitForce: \"+ev.webkitForce +\"\\n\" +\n   \"tiltX: \"+ev.tiltX +\", \" +\n   \"tiltY: \"+ev.tiltY\n  )\n  // debug: print all fields\n  // for (k in ev) msg.innerText += (k+\"\\n\")\n  let rect = cvs.getBoundingClientRect()\n  let x = ev.clientX-rect.left\n  let y = ev.clientY-rect.top\n  if (ev.pointerType == \"touch\") {\n    let rx = ev.width\n    let ry = ev.height\n    ctx.fillStyle = \"white\"\n    ctx.fillRect(x-rx/2,y-ry/2,rx,ry)\n    ctx.strokeRect(x-rx/2,y-ry/2,rx,ry)\n  } else if (ev.pointerType == \"pen\") {\n    let r = ev.pressure * 100\n    let tanX = Math.tan(ev.tiltX/180*Math.PI)\n    let tanY = Math.tan(ev.tiltY/180*Math.PI)\n    let azimuth = Math.atan2(tanY,tanX)\n    let altitude =Math.atan2(1, Math.sqrt(tanX*tanX+tanY*tanY))\n    let rx = r+Math.cos(altitude) * r\n    let ry = r\n    ctx.beginPath()\n    ctx.ellipse(x,y,rx,ry,azimuth,0,2*Math.PI)\n    ctx.fillStyle = \"white\"\n    ctx.closePath()\n    ctx.fill()\n    ctx.stroke()\n  } else {\n    let rx = ev.width\n    let ry = ev.height\n    ctx.fillStyle = \"white\"\n    ctx.fillRect(x-rx/2,y-ry/2,rx,ry)\n    ctx.strokeRect(x-rx/2,y-ry/2,rx,ry)\n  }\n}\n</code>\n<p>This example uses ‘pointer events’, which are the new emerging standard for unifying touch and mouse events. Tested on a 2018 iPad Pro with Apple Pencil, running Safari 13.</p>\n<p>Some notes: <code class=\"language-text\">setPointerCapture</code> is necessary to continue receiving <code class=\"language-text\">pointermove</code> events after leaving the canvas, <code class=\"language-text\">touch-action=none</code> is necessary to prevent scrolling. On iPad, finger touches have size but no pressure. The first touch with a pencil appears to register with higher pressure than subsequent ones. Finger and stylus touches are mutually exclusive, presumably to enable hand-resting on the surface while drawing or writing.</p>\n<p>Desktop Safari (13.1) currently doesn’t report trackpad pressure for pointer events. There is a separate and non-standard set of events for this (<code class=\"language-text\">webkitmouseforcewillbegin</code>, <code class=\"language-text\">webkitmouseforcedown</code>,<code class=\"language-text\">webkitmouseforcechanged</code>, <code class=\"language-text\">webkitmouseforceup</code>).</p>\n<p>See also: <a href=\"https://patrickhlauke.github.io/getting-touchy-presentation/\">https://patrickhlauke.github.io/getting-touchy-presentation/</a></p>\n<h2>Motion &#x26; Orientation</h2>\n<p>Accelerometer, Gyroscope, Compass.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!window.DeviceMotionEvent)\n  return print(\"DeviceMotionEvent not supported\")\nsizeX = 300\nsizeY = 150\nlet cvs = document.createElement(\"canvas\")\ncvs.width = sizeX\ncvs.height = sizeY\nlet ctx = cvs.getContext(\"2d\")\no.appendChild(cvs)\nlet msg = document.createElement(\"small\")\no.appendChild(msg)\nfunction show(e) {\n  msg.innerText = e+\"\\n\"\n}\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => { DeviceMotionEvent.requestPermission().then(res => {\n  if (res != 'granted')\n    return print(\"Error: \"+res)\n  window.addEventListener(\"devicemotion\", motion)\n  window.addEventListener(\"deviceorientation\", orientation)\n  let a = document.createElement(\"div\")\n  let b = document.createElement(\"div\")\n  let g = document.createElement(\"div\")\n  let c = document.createElement(\"div\")\n  let x = document.createElement(\"div\")\n  let y = document.createElement(\"div\")\n  let z = document.createElement(\"div\")\n  o.appendChild(x)\n  o.appendChild(y)\n  o.appendChild(z)\n  o.appendChild(a)\n  o.appendChild(b)\n  o.appendChild(g)\n  o.appendChild(c)\n  function motion(ev) {\n    ctx.clearRect(0,0,100,sizeY)\n    ctx.fillRect(10,sizeY/2,20,-10*ev.acceleration.x)\n    ctx.fillRect(40,sizeY/2,20,-10*ev.acceleration.y)\n    ctx.fillRect(70,sizeY/2,20,-10*ev.acceleration.z)\n    x.innerText = \"\"+ev.acceleration.x\n    y.innerText = \"\"+ ev.acceleration.y\n    z.innerText = \"\"+ ev.acceleration.z\n  }\n  function orientation(ev) {\n    ctx.clearRect(100,0,sizeX,sizeY)\n    let r = 15\n    function drawDial(x,angle) {\n      let dx = r * Math.cos(angle/180*Math.PI)\n      let dy = r * Math.sin(angle/180*Math.PI)\n      ctx.beginPath()\n      ctx.moveTo(x,sizeY/2)\n      ctx.lineTo(x+dx,sizeY/2+dy)\n      ctx.stroke()\n      ctx.beginPath()\n      ctx.arc(x,sizeY/2,r,0,2*Math.PI)\n      ctx.stroke()\n    }\n    drawDial(110,ev.alpha)\n    drawDial(140,ev.beta)\n    drawDial(170,ev.gamma)\n    drawDial(210,ev.webkitCompassHeading)\n    a.innerText = \"\"+ev.alpha\n    b.innerText = \"\"+ ev.beta\n    g.innerText = \"\"+ ev.gamma\n    c.innerText = \"\"+ ev.webkitCompassHeading\n  }\n  button(\"stop\", () => {\n    window.removeEventListener(\"devicemotion\", motion)\n    window.removeEventListener(\"deviceorientation\", orientation)\n  })\n})})\n</code>\n<h2>Location</h2>\n<p>Via GPS or Wifi.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nif (!navigator.geolocation)\n  return print(\"geolocation not supported\")\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nbutton(\"start\", ev => {\n  function success(pos) {\n    print(\"Latitude: \" + pos.coords.latitude)\n    print(\"Longitude: \" + pos.coords.longitude)\n  }\n  function error(err) {\n    print(\"Error: \"+err.message)\n  }\n  navigator.geolocation.getCurrentPosition(success, error)\n})\n</code>\n<p>In addition to <code class=\"language-text\">getCurrentPosition</code>, there is also <code class=\"language-text\">watchCurrentPosition</code>, which provides continuous updates (returns a watch id, clean up with <code class=\"language-text\">clearWatch</code>). Both calls support some options (passed as third argument): <code class=\"language-text\">enableHighAccuracy</code>, <code class=\"language-text\">maximumAge</code>, <code class=\"language-text\">timeout</code>.</p>\n<h2>Microphone</h2>\n<p>Capture audio input, do an FFT on the fly, and draw a frequency spectrum.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => {\n  navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(handleSuccess)})\nfunction handleSuccess(stream) {\n    // console.log(stream)\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      // console.log(devices)\n      for (d of devices) print(d.kind,d.label)\n    })\n    // set up canvas\n    let WIDTH = 600\n    let HEIGHT = 100\n    let cvs = document.createElement(\"canvas\")\n    cvs.width = WIDTH\n    cvs.height = HEIGHT\n    let ctx = cvs.getContext(\"2d\")\n    o.appendChild(cvs)\n    print(\"\")\n    let msg = document.createElement(\"small\")\n    o.appendChild(msg)\n    print(\"\")\n    // set up audio\n    if (!window.audioContext)\n      window.audioContext = new (window.webkitAudioContext||AudioContext)();\n    const context = window.audioContext\n    const source = context.createMediaStreamSource(stream);\n    const analyser = context.createAnalyser()\n    analyser.minDecibels = -50;\n    analyser.maxDecibels = -5;\n    analyser.smoothingTimeConstant = 0.85;\n    source.connect(analyser);\n    // analyser.connect(context.destination); // if we want sound output\n    analyser.fftSize = 4096;\n    var bufferLength = analyser.frequencyBinCount;\n    var dataArray = new Float32Array(bufferLength);\n    // stop button\n    button(\"stop\", ev => {\n      stream.getTracks().forEach(track=>track.stop())\n      source.disconnect()\n      analyser.disconnect()\n      cancelAnimationFrame(drawId)\n    })\n    // drawing loop\n    let drawId = requestAnimationFrame(draw)\n    function draw() {\n      analyser.getFloatFrequencyData(dataArray);\n      // compute peak frequency\n      let max = 0\n      let maxi = 0\n      for(let i = 20; i < bufferLength; i++) {\n        if (dataArray[i]+200 > max) {\n          max = dataArray[i]+200\n          maxi = i\n        }\n      }\n/*\nWhat is the frequency at i?\nLinear scale from 0 to window.audioContext.sampleRate/2 (typically 44100/2 = 22050, so each step is 22050/fftSize)\n*/\n// Some note indexes, calibrated by xylophone\n// (these are C6, C7, ...):\n// C  97 194\n// D 109 218\n// E 122 245\n// F 130 259\n// G 146\n// A 163\n// H 183\n      let freq = window.audioContext.sampleRate/2/(bufferLength-1)*maxi\n      msg.innerText = \"peak: \" + Math.round(freq) + \" Hz (index \" + maxi + \")\"\n      // draw spectrum\n      ctx.clearRect(0, 0, WIDTH, HEIGHT)\n      let barCount = bufferLength/2\n      let barWidth = (WIDTH / barCount) * 2.5\n      let barHeight\n      let x = 0\n      for(let i = 0; i < barCount; i++) {\n        barHeight = (dataArray[i] + 100)*2\n        //ctx.fillStyle = 'rgb(' + Math.floor(barHeight+100) + ',50,50)'\n        ctx.fillRect(x,HEIGHT-barHeight/2,barWidth,barHeight/2)\n        x += barWidth + 1\n      }\n      drawId = requestAnimationFrame(draw)\n    }\n}\n/*\n    Alternative to manually process raw audio:\n    const processor = context.createScriptProcessor(1024, 1, 1)\n    source.connect(processor)\n    processor.connect(context.destination)\n    processor.onaudioprocess = function(e) {\n      // Process the data ...\n      //console.log(e.inputBuffer)\n    }\n*/\n</code>\n<p>Given the frequency spectrum data we can detect peaks using a simple threshold scheme. This is almost useable as a guitar tuner, but not quite (resolution of FFT at low frequencies is not high enough, so typical tuner apps use other algorithms, typically based on autocorrelation in the time domain).</p>\n<p>See also: <a href=\"https://mdn.github.io/voice-change-o-matic/\">https://mdn.github.io/voice-change-o-matic/</a></p>\n<h2>Camera</h2>\n<p>Show camera input, and grab frames by drawing to a canvas.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\nprint(\"\")\nbutton(\"start\", () => {\n  navigator.mediaDevices.getUserMedia({ audio: true, video: true }).then(handleSuccess)})\nfunction handleSuccess(stream) {\n    // console.log(stream)\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      // console.log(devices)\n      for (d of devices) print(d.kind,d.label)\n    })\n    // set up canvas\n    let WIDTH = 600\n    let HEIGHT = WIDTH/4*3\n    // msg not used ...\n    // let msg = document.createElement(\"small\")\n    // o.appendChild(msg)\n    print(\"\")\n    // video elem\n    let vid = document.createElement(\"video\")\n    vid.autoplay = true\n    vid.width = WIDTH\n    vid.height = HEIGHT\n    vid.srcObject = stream\n    o.appendChild(vid)\n    print(\"\")\n    // snapshot button\n    button(\"snapshot\", ev => {\n      let cvs = document.createElement(\"canvas\")\n      cvs.width = WIDTH/3\n      cvs.height = HEIGHT/3\n      o.appendChild(cvs)\n      let ctx = cvs.getContext(\"2d\")\n      ctx.drawImage(vid,0,0,cvs.width,cvs.height)\n    })\n    // stop button\n    button(\"stop\", ev => {\n      stream.getTracks().forEach(track=>track.stop())\n      cancelAnimationFrame(drawId)\n    })\n    // drawing loop\n    //let drawId = requestAnimationFrame(draw)\n    //function draw() {\n    //  drawId = requestAnimationFrame(draw)\n    //}\n}\n</code>\n<p>Video DOM elements can be styled using CSS, so it’s possible to add filters or other transformations in that way. Video frames can be drawn to a canvas (like above) or also serve as texture in a WebGL context.</p>\n<p>See also: <a href=\"https://www.html5rocks.com/en/tutorials/getusermedia/intro/\">https://www.html5rocks.com/en/tutorials/getusermedia/intro/</a></p>\n<p>To get access to raw pixel data, first draw a video frame to a canvas, and then read back pixel data from the canvas using <code class=\"language-text\">ctx.getImageData</code>. This enables CPU processing using JS or, potentially, WASM. For GPU processing, once loaded as a WebGL texture, a video frame can be processed using vertex and fragment shaders.</p>\n<p>See also: <a href=\"https://developers.google.com/web/fundamentals/media/manipulating/live-effects\">https://developers.google.com/web/fundamentals/media/manipulating/live-effects</a></p>","fields":{"slug":"/Public/Generic/touch-camera-device-apis/"},"frontmatter":{"date":"July 04, 2020","title":"Touch, Camera, and Other Device APIs","description":"How to enable touch and stylus input, and access the accelerometer, compass, GPS, microphone, and camera in your device from JS.","keywords":"Device API, Touch Events, Pointer Events, Stylus, DeviceMotion Event, Accelerometer, Geolocation, Microphone, Camera, Web, JavaScript","tags":null}}},{"node":{"excerpt":"Graphs are everywhere, and it’s often useful to visualize them. We can use tools like GraphViz to do so, or TikZ, Mathematica, or D3. But…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Graphs are everywhere, and it’s often useful to visualize them. We can use tools like GraphViz to do so, or TikZ, Mathematica, or D3. But how does GraphViz work? And what if we wanted to draw nice-looking graphs ourselves from scratch?</p>\n<p>We can think about drawing graphs as two separate problems. One is determining where to place each node and edge (“Frontend”). The other is to actually draw them once positions are determined (“Backend”). We’ll go bottom-up and start with the backend.</p>\n<aside>\n<h2>Backend</h2>\n<p>In this section we’ll assume we already know where to place graph nodes. We’ll treat ways to automate this below under <a href=\"/graphs-frontend\">Frontend</a>.</p>\n<p>Let’s create a place to draw.</p>\n<code class=\"runScript\" filter=\"setPreamble\" popout=\"true\">\nlet cvs = null\nlet ctx = null\nlet sizeX = 300\nlet sizeY = 100\nfunction createCanvas() {\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.width = sizeX\n  cvs.height = sizeY\n  ctx = cvs.getContext(\"2d\")\n  ctx.lineWidth = 1\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n}\n</code>\n<h3>Boxes</h3>\n<p>Here’s our first graph. Just a single node, i.e., a box and a label:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\nctx.strokeRect(10, 10, 80, 80)\nctx.fillText(\"A\", 50, 50)\n</code>\n<p>We’re going to draw more boxes, so let’s define\na few auxiliaries.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// Fix some parameters\nlet boxX = 20\nlet boxY = 20\n</code>\n<p>Wrap it up in a function that draws labeled boxes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// Draw a box with label n centered around point x,y\nfunction drawBox(n, x, y) {\n  ctx.strokeRect(x-boxX/2, y-boxY/2, boxX, boxY)\n  ctx.fillText(n, x, y, boxX)\n}\n</code>\n<p>Cool. Now this works:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\n</code>\n<h3>Lines</h3>\n<p>Now let’s draw some lines:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nfunction drawLine(x1, y1, x2, y2) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawLine(20, 20, 80, 20)\ndrawLine(20, 20, 80, 80)\n</code>\n<p>That’s not ideal. We want lines to stop at the edges of boxes. An easy way is to adjust by <code class=\"language-text\">boxX/2</code> or <code class=\"language-text\">boxY/2</code>:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawLine(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const skipX = dx < dy  ? 0 : x2 > x1 ? boxX/2 : -boxX/2\n  const skipY = dx >= dy ? 0 : y2 > y1 ? boxY/2 : -boxY/2\n  ctx.beginPath()\n  ctx.moveTo(x1+skipX, y1+skipY)\n  ctx.lineTo(x2-skipX, y2-skipY)\n  ctx.stroke()\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawBox(\"D\", 20, 80)\ndrawLine(20, 20, 80, 20)\ndrawLine(20, 20, 80, 80)\ndrawLine(20, 20, 20, 80)\n</code>\n<p>The result always connects the centerpoints of the opposing faces. Good enough for now, but we’ll consider alternatives below.</p>\n<h3>Arrows</h3>\n<p>Here’s how to draw basic arrow heads:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawArrowHead(x, y, angle) {\n  ctx.save()\n  ctx.translate(x,y)\n  ctx.rotate(angle)\n  ctx.beginPath()\n  ctx.moveTo(0,0)\n  ctx.lineTo(-6,-3)\n  ctx.lineTo(-5,0)\n  ctx.lineTo(-6,3)\n  ctx.lineTo(0,0)\n  ctx.fill()\n  ctx.restore()\n}\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = x2 - x1\n  const dy = y2 - y1\n  const angle = Math.atan2(dy, dx)\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n  drawArrowHead(x2, y2, angle)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawArrow(10,50,40,50)\ndrawArrow(50,40,70,60)\ndrawArrow(90,35,90,65)\ndrawArrow(110,60,140,40)\n</code>\n<p>Now we put it back together with the rest of the line drawing code:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const skipX = dx < dy  ? 0 : x2 > x1 ? boxX/2 : -boxX/2\n  const skipY = dx >= dy ? 0 : y2 > y1 ? boxY/2 : -boxY/2\n  const angle = Math.atan2(dy, dx)\n  ctx.beginPath()\n  ctx.moveTo(x1+skipX, y1+skipY)\n  ctx.lineTo(x2-skipX, y2-skipY)\n  ctx.stroke()\n  drawArrowHead(x2-skipX, y2-skipY, angle)\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 80, 80)\ndrawBox(\"D\", 20, 80)\ndrawArrow(20, 20, 80, 20)\ndrawArrow(20, 20, 80, 80)\ndrawArrow(20, 20, 20, 80)\n</code>\n<p>Pretty neat, huh?</p>\n<h3>Lines: targeting the center</h3>\n<p>This style gets a bit crowded if many arrows point to the same node. All the arrow heads will point to the same exact location and partly overlap there (which doesn’t look nice).</p>\n<p><strong>Exercise:</strong> Try it!</p>\n<p>An alternative is to plan drawing the lines into the center of the box and then cut them short where they cross the box outline:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction drawArrow(x1, y1, x2, y2) {\n  const dx = x2 - x1\n  const dy = y2 - y1\n  if (Math.abs(dx) > Math.abs(dy)) {\n    const slope = dy / dx\n    const angle = Math.atan2(dy, dx)\n    const skip = dx >= 0 ? boxX/2 : -boxX/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skip, y1+skip*slope)\n    ctx.lineTo(x2-skip, y1+(dx-skip)*slope)\n    ctx.stroke()\n    drawArrowHead(x2-skip, y1+(dx-skip)*slope, angle)\n  } else {\n    const slope = dx / dy\n    const angle = Math.atan2(dy, dx)\n    const skip = dy >= 0 ? boxY/2 : -boxY/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skip*slope, y1+skip)\n    ctx.lineTo(x1+(dy-skip)*slope, y2-skip)\n    ctx.stroke()\n    drawArrowHead(x1+(dy-skip)*slope, y2-skip, angle)\n  }\n}\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 80, 20)\ndrawBox(\"C\", 140, 20)\ndrawBox(\"D\", 20, 80)\ndrawBox(\"E\", 80, 80)\ndrawBox(\"F\", 140, 80)\ndrawArrow(20, 20, 80, 80) // A->E right down\ndrawArrow(20, 80, 80, 20) // D->B right up\ndrawArrow(140, 80, 80, 20) // C -> E left down\ndrawArrow(140, 20, 80, 80) // F -> B left up\ndrawArrow(20, 20, 20, 80) // A->D down\ndrawArrow(140, 80, 140, 20) // F->C up\n\"done\"\n</code>\n<p>This approach generalizes pretty well to other node shapes (circles, etc.).</p>\n<p><strong>Exercise</strong>: Try it!</p>\n<h3>Lines: straight segments</h3>\n<p>Sometimes we don’t want to draw lines at arbitrary angles but have something more orthogonal.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawStraightArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  if (dx > dy) {\n    const skipX = x2 > x1 ? boxX/2 : -boxX/2\n    const midX = (x1+skipX+x2-skipX)/2\n    ctx.beginPath()\n    ctx.moveTo(x1+skipX, y1)\n    ctx.lineTo(midX, y1)\n    ctx.lineTo(midX, y2)\n    ctx.lineTo(x2-skipX, y2)\n    ctx.stroke()\n    drawArrowHead(x2-skipX, y2, x2 > x1 ? 0 : Math.PI)\n  } else {\n    const skipY = y2 > y1 ? boxY/2 : -boxY/2\n    const midY = (y1+skipY+y2-skipY)/2\n    ctx.beginPath()\n    ctx.moveTo(x1, y1+skipY)\n    ctx.lineTo(x1, midY)\n    ctx.lineTo(x2, midY)\n    ctx.lineTo(x2, y2-skipY)\n    ctx.stroke()\n    drawArrowHead(x2, y2-skipY, y2 > y1 ? Math.PI/2 : 3*Math.PI/2)\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 120, 20)\ndrawBox(\"C\", 120, 80)\ndrawBox(\"D\", 40, 80)\ndrawStraightArrow(20, 20, 120, 20)\ndrawStraightArrow(20, 20, 120, 80)\ndrawStraightArrow(20, 20, 40, 80)\n</code>\n<h3>Lines: curved segments</h3>\n<p>If these right angles look too rigid, we can also use Bezier curves.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawCurvedArrow(x1, y1, x2, y2) {\n  const dx = Math.abs(x2 - x1)\n  const dy = Math.abs(y2 - y1)\n  const bend = 0.75 // play with this factor!\n  if (dx > dy) {\n    const skipX = x2 > x1 ? boxX/2 : -boxX/2\n    const ctrlX = bend*(x2-x1-2*skipX)\n    ctx.beginPath()\n    ctx.moveTo(x1+skipX, y1)\n    ctx.bezierCurveTo(\n      x1+skipX + ctrlX, y1,\n      x2-skipX - ctrlX, y2,\n      x2-skipX, y2)\n    ctx.stroke()\n    drawArrowHead(x2-skipX, y2, x2 > x1 ? 0 : Math.PI)\n  } else {\n    const skipY = y2 > y1 ? boxY/2 : -boxY/2\n    const ctrlY = bend*(y2-y1-2*skipY)\n    ctx.beginPath()\n    ctx.moveTo(x1, y1+skipY)\n    ctx.bezierCurveTo(\n      x1, y1+skipY+ctrlY,\n      x2, y2-skipY-ctrlY,\n      x2, y2-skipY)\n    ctx.stroke()\n    drawArrowHead(x2, y2-skipY, y2 > y1 ? Math.PI/2 : 3*Math.PI/2)\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ncreateCanvas()\ndrawBox(\"A\", 20, 20)\ndrawBox(\"B\", 120, 20)\ndrawBox(\"C\", 120, 80)\ndrawBox(\"D\", 40, 80)\ndrawCurvedArrow(20, 20, 120, 20)\ndrawCurvedArrow(20, 20, 120, 80)\ndrawCurvedArrow(20, 20, 40, 80)\n</code>\n<p>It’s also possible to draw curves using circle segments or quadratic curves instead of cubic bezier curves.</p>\n<p><strong>Exercise:</strong> Try it!</p>\n<!--\n// Understanding arcto\n\net r = 20\n\nfunction arc(x2,y2,d) {\nlet [x1,y1] = [x2-100,y2-d]\nlet [x3,y3] = [x2-100,y2+d]\nctx.beginPath()\nctx.moveTo(x1,y1)\nctx.arcTo(x2,y2,x3,y3,r)\nctx.lineTo(x3,y3)\nctx.stroke()\n\nctx.beginPath()\nctx.arc(x2,y2,3,0,2*Math.PI)\nctx.fill()\nctx.beginPath()\nctx.arc(x2,y2,r,0,2*Math.PI)\nctx.stroke()\n}\n\n\narc(220,150, 100)\narc(220,150, 90)\narc(220,150, 80)\narc(220,150, 70)\narc(220,150, 60)\narc(220,150, 50)\narc(220,150, 40)\narc(220,150, 30)\narc(220,150, 21)\narc(220,150, 20)\narc(220,150, 19)\narc(220,150, 18)\narc(220,150, 17)\narc(220,150, 16)\narc(220,150, 15)\narc(220,150, 14)\narc(220,150, 13)\narc(220,150, 12)\narc(220,150, 11)\narc(220,150, 10)\n\n\narc(460,150, 60)\narc(460,150, 60)\narc(460,150, 40)\narc(460,150, 20)\narc(460,150, 10)\n\n  -->\n<h3>Lines: specifying connectors and waypoints</h3>\n<p><strong>Exercise:</strong> Let the user specify which side of a box a line should be attached to.</p>\n<p>This may require drawing multiple line segments, for example when node A is above B and we want to connect the top of node A with the bottom of node B.</p>\n<p>As a generalization we provide a function that draws a line through an arbitrary number of waypoints. It’s also useful to introduce a special case for cycles.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet edgeBend = 20\nfunction drawCircle(n, x, y) {\n  ctx.beginPath();\n  ctx.arc(x, y, boxX/2, 0, 2 * Math.PI);\n  ctx.stroke();\n  ctx.fillText(n, x, y, boxX)\n}\nfunction drawArrowHead(x, y, angle) {\n  ctx.save()\n  ctx.translate(x,y)\n  ctx.rotate(angle)\n  ctx.beginPath()\n  ctx.moveTo(0,0)\n  ctx.lineTo(-6,-3)\n  ctx.lineTo(-5,0)\n  ctx.lineTo(-6,3)\n  ctx.lineTo(0,0)\n  ctx.fill()\n  ctx.restore()\n}\nfunction drawArrow(u1, v1, u2, v2) {\n  drawArrowN([u1, v1, u2, v2])\n}\nfunction drawArrowN(points) {\n  let [x1,y1,x2,y2] = points\n  let dx = x2 - x1\n  let dy = y2 - y1\n  let angle = Math.atan2(dy, dx)\n  x1 += Math.cos(angle) * boxX/2\n  y1 += Math.sin(angle) * boxX/2\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  for (let j = 4; j < points.length; j+=2) {\n    let [x3,y3] = [points[j],points[j+1]]\n    ctx.arcTo(x2, y2, x3, y3, edgeBend);\n    x1 = x2; y1 = y2\n    x2 = x3; y2 = y3\n  }\n  dx = x2 - x1\n  dy = y2 - y1\n  angle = Math.atan2(dy, dx)\n  x2 -= Math.cos(angle) * boxX/2\n  y2 -= Math.sin(angle) * boxX/2\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n  drawArrowHead(x2, y2, angle)\n}\nfunction drawCycle(x,y) {\n  ctx.beginPath()\n  let r1 = boxX/2\n  let r2 = 15\n  let a = 2*Math.asin(0.5*r1/r2)\n  ctx.arc(x+r2,y,r2,Math.PI+a,3*Math.PI-a)\n  ctx.stroke()\n  drawArrowHead(x+r2+r2*Math.cos(Math.PI+a),y+r2*Math.sin(Math.PI+a),Math.PI-a)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\ncreateCanvas()\ndrawCircle(\"A\",20,20)\ndrawCircle(\"B\",180,20)\ndrawArrowN([20,20,60,60,140,60,180,20])\ndrawCycle(180,20)\n</code>\n<h3>Lines: avoiding overlap</h3>\n<p><strong>Exercise:</strong> Keep track of where line segments are, and move new ones slightly off to the side. Hint: see <a href=\"/graphs-frontend\">Frontend</a> section below for a variant that does this for back-edges</p>\n<h3>Deferred mode</h3>\n<p>So far, we have drawing functions that produce immediate graphical output at the given coordinates.</p>\n<p>Remembering all these coordinate values is a bit cumbersome, so let’s introduce a layer that allows us to assign node coordinates first, and then draw nodes and edges based on the assigned positions in a second step.</p>\n<p>This model has a number of other advantages. We become independent of a specific drawing backend (e.g., we could use positioned HTML or SVG nodes instead of canvas), and of course we have a better foundation for computing positions programmatically later on.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nlet gridX = 50\nlet gridY = 50\nlet originX = 20\nlet originY = 20\nlet pos = {}\nfunction placeNode(n, u, v) {\n  pos[n] = [u*gridX, v*gridY]\n}\nfunction drawNode(n1) {\n  let [x,y] = pos[n1]\n  drawCircle(n1, originX + x, originY + y)\n}\nfunction drawEdge(n1,n2) { // TODO: N\n  let [x1,y1] = pos[n1]\n  let [x2,y2] = pos[n2]\n  drawArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n}\nfunction createCanvas() {\n  let minX = Number.MAX_VALUE\n  let maxX = Number.MIN_VALUE\n  let minY = Number.MAX_VALUE\n  let maxY = Number.MIN_VALUE\n  for (let n in pos) {\n    let [x,y] = pos[n]\n    minX = Math.min(minX, x-boxX/2)\n    maxX = Math.max(maxX, x+boxX/2)\n    minY = Math.min(minY, y-boxY/2)\n    maxY = Math.max(maxY, y+boxY/2)\n  }\n  minX -= 20\n  maxX += 20\n  minY -= 20\n  maxY += 20\n  originX = -minX\n  originY = -minY\n  sizeX = maxX - minX\n  sizeY = maxY - minY\n  // super.createCanvas\n  cvs = document.createElement(\"canvas\")\n  o.appendChild(cvs)\n  cvs.height = sizeY\n  cvs.width = sizeX\n  ctx = cvs.getContext(\"2d\")\n  ctx.lineWidth = 1\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 1, 0)\nplaceNode(\"C\", 1, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\n</code>\n</aside>\n<p>Now we have tools to draw various forms of lines and boxes:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 1, 0)\nplaceNode(\"C\", 1, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawArrow = drawStraightArrow\ndrawCircle = drawBox\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 2, 0)\nplaceNode(\"C\", 2, 1)\nplaceNode(\"D\", 0.5, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawNode(\"D\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\ndrawEdge(\"A\",\"D\")\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\ndrawArrow = drawCurvedArrow\nplaceNode(\"A\", 0, 0)\nplaceNode(\"B\", 2, 0)\nplaceNode(\"C\", 2, 1)\nplaceNode(\"D\", 0.5, 1)\ncreateCanvas()\ndrawNode(\"A\")\ndrawNode(\"B\")\ndrawNode(\"C\")\ndrawNode(\"D\")\ndrawEdge(\"A\",\"B\")\ndrawEdge(\"A\",\"C\")\ndrawEdge(\"A\",\"D\")\n</code>\n<p>Deciding how exactly to draw connecting edges (between which faces, when to draw an “S” vs “L” shape, etc.) already requires some nontrivial geometry.</p>\n<aside>\n<h2>Frontend - Drawing Trees</h2>\n<p>Before we tackle general graphs, let’s take a look at trees. Trees are of course a very important subclass of graphs, but they are actually quite interesting in their own right.</p>\n<h3>Algorithm 1</h3>\n<p>Preliminaries:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n//let g = {5: {11: {0:{},2:{},4:{}}, 1.3: { 7.9: {6:{}, 8:{}, 10:{} }}}}\nlet g = { 1: { 2: { 3: { 4: {5: {}}, 6: {7:{}, 8:{}, 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\nfunction succ(n) {\n  return Object.entries(n)\n}\nfunction drawForest(g,p) {\n  for (let [k,v] of succ(g)) {\n    drawForest(v, k)\n    drawNode(k)\n    if (p != null) drawEdge(p,k)\n  }\n}\n</code>\n<p>How to place the nodes? Let’s start on one end of\nthe canvas and keep track of how many we’ve drawn at each level:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    placeForest(v, d+1)\n    placeNode(k, d, fringe[d])\n    fringe[d] += 1\n  }\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>Looks like a good start, but obviously not great.</p>\n<h3>Algorithm 2</h3>\n<p>An easy idea to improve the layout is to center nodes at each level. We can do this in two passes:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet extent = []\nfunction layoutForest(g,d) {\n  extent[d] = extent[d] || 0\n  for (let [k,v] of succ(g)) {\n    layoutForest(v, d+1, extent[d])\n    extent[d] += 1\n  }\n}\nlet max = 4\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    const pos = (max-extent[d])/2 + fringe[d]\n    placeForest(v, d+1)\n    placeNode(k, d, pos)\n    fringe[d] += 1\n  }\n}\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This is better, but still not optimal. The placement of parents with respect to children is awkward.</p>\n<h3>Algorithm 3</h3>\n<p>We’d like to place parents in the middle above of their children. We’ll implement a version of an algorithm attributed to Reingold and Tilford.</p>\n<p>First cut:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) { return Object.entries(g).reverse() }\nlet fringe = []\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let childpos = []\n  for (let [k,v] of succ(g)) {\n    const cp = placeForest(v, d+1)\n    let pos = fringe[d]\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid > pos) pos = mid\n    }\n    placeNode(k, d, pos)\n    fringe[d] = pos+1\n    childpos.push(pos)\n  }\n  return childpos\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This is better, but misses the case where a subtree would need to be moved after it has been drawn.</p>\n<p>We switch back to a two-pass process and add a function to move already-positioned subtrees:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\n// annoying: converting between screen and grid pos\nfunction succ(g) { return Object.entries(g).reverse() }\nlet fringe = []\nfunction moveForest(g,d,off) {\n  for (let [k,v] of succ(g)) {\n    moveForest(v,d+1,off)\n    pos[k][1] += off*gridY\n    let scaled = pos[k][1]/gridY\n    if (scaled + 1 > fringe[d])\n      fringe[d] = scaled + 1\n  }\n}\nfunction placeForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  for (let [k,v] of succ(g)) {\n    let p = fringe[d]\n    placeForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => pos[k1][1]/gridY)\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid >= p) {\n        p = mid\n      } else {\n        // move children and adjust fringe below!\n        moveForest(v, d+1, p-mid)\n      }\n    }\n    fringe[d] = p+1\n    placeNode(k,d,p)\n  }\n}\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>This works great! But it’s horribly inefficient. The recursive invocation of <code class=\"language-text\">moveForest</code> makes the implementation exponential (compare recursion pattern to naive Fibonacci).</p>\n<p>We’ll be back to linear performance if we manage to remove recursion from <code class=\"language-text\">moveForest</code>. But how can we do that?</p>\n<p>Function <code class=\"language-text\">moveForest</code> does two things: it updates the position of each node (shifting by <code class=\"language-text\">off</code>), and it updates the fringe accordingly.</p>\n<p>Updating node positions can be done in constant time if we just record the offset, and add it in later while drawing.</p>\n<p>This means that we no longer need to traverse the full subtree to move, but we still need to traverse the fringe (up to the depth of the subtree) to adjust the offset.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    let off = 0\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1.pos)\n    if (cp.length > 0) {\n      const mid = (cp[0] + cp[cp.length-1])/2\n      if (mid >= pos) {\n        pos = mid\n      } else {\n        off = pos-mid\n        // children move lazily, but still need\n        // to update fringe (up to depth of child tree)\n        for (let d1 = 0; d1 < cd; d1++)\n          fringe[d+1+d1] += off\n      }\n    }\n    fringe[d] = pos+1\n    v.pos = pos\n    v.off = off\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,off) {\n  for (let [k,v] of succ(g)) {\n    const pos = v.pos\n    placeForest(v, d+1, off+v.off, pos+off)\n    placeNode(k, d, pos+off)\n  }\n}\nlayoutForest(g,0)\nplaceForest(g,0,0)\ncreateCanvas()\ndrawForest(g)</code>\n<p>This is much better, but still not ideal in terms of performance.</p>\n<p><strong>Exercise:</strong> what is the worst case complexity? Prove it.</p>\n<p>What can we do to make it linear?</p>\n<p>The key idea is to make fringe entries relative to the parent. Then we only need to adjust the value at <code class=\"language-text\">d+1</code> and set it back at <code class=\"language-text\">d+cd+1</code> (where <code class=\"language-text\">cd</code> is the depth of the child tree)!</p>\n<p>This works best when tree positions are also relative to the parent. So we get rid of the relative <code class=\"language-text\">off</code> field and just use the normal <code class=\"language-text\">pos</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1)\n    if (cp.length > 0) {\n      const mid = (cp[0].pos + cp[cp.length-1].pos)/2\n      cp.forEach(v1 => v1.pos -= mid)\n      if (mid >= 0) {\n        pos += mid\n      } else {\n        // children are relative, fringe also relative\n        fringe[d+1] -= mid\n        fringe[d+1+cd] += mid\n      }\n    }\n    fringe[d+1] += fringe[d] - (pos+1)\n    fringe[d] = pos+1\n    v.pos = pos\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,p) {\n  for (let [k,v] of succ(g)) {\n    const pos = (p||0) + v.pos\n    placeForest(v, d+1, pos)\n    placeNode(k, d, pos)\n  }\n}\ng = { 1: {\n2: { 3: { 4: {5: {50:{501:{},502:{}}}}, 6: {7:{71:{},72:{},73:{}}, /*8:{80:{} },*/ 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<p>Now we’re done, and we have a nice and efficient method for drawing trees.</p>\n<p><strong>Exercise:</strong> why do we need the line <code class=\"language-text\">fringe[d+1+cd] += mid</code>? Find a test case.</p>\n<h3>Discussion</h3>\n<p>References:</p>\n<ul>\n<li>Reingold and Tilford <a href=\"https://reingold.co/tidier-drawings.pdf\">https://reingold.co/tidier-drawings.pdf</a></li>\n<li>Brüggemann-Klein and Wood <a href=\"http://cajun.cs.nott.ac.uk/compsci/epo/papers/volume2/issue2/epabk022.pdf\">http://cajun.cs.nott.ac.uk/compsci/epo/papers/volume2/issue2/epabk022.pdf</a></li>\n<li>TikZ manual <a href=\"https://pgf-tikz.github.io/pgf/pgfmanual.pdf\">https://pgf-tikz.github.io/pgf/pgfmanual.pdf</a></li>\n</ul>\n</aside>\n<p>Trees are an important subclass of graphs that deserves special attention. While simpler than the case of general graphs, drawing trees with automatic layout already requires careful planning where to place children and parents with respect to each other, to make efficient use of space available at each layer:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nfunction succ(g) {\n  return Object.entries(g).reverse()\n    .filter(([k,v]) => k != \"pos\" && k != \"off\")\n}\nlet fringe = []\nfunction layoutForest(g,d) {\n  fringe[d] = fringe[d] || 0\n  let depth = 0\n  for (let [k,v] of succ(g)) {\n    let pos = fringe[d]\n    const cd = layoutForest(v, d+1)\n    const cp = succ(v).map(([k1,v1]) => v1)\n    if (cp.length > 0) {\n      const mid = (cp[0].pos + cp[cp.length-1].pos)/2\n      cp.forEach(v1 => v1.pos -= mid)\n      if (mid >= 0) {\n        pos += mid\n      } else {\n        // children are relative, fringe also relative\n        fringe[d+1] -= mid\n        fringe[d+1+cd] += mid\n      }\n    }\n    fringe[d+1] += fringe[d] - (pos+1)\n    fringe[d] = pos+1\n    v.pos = pos\n    if (cd + 1 > depth) depth = cd + 1\n  }\n  return depth\n}\nfunction placeForest(g,d,p) {\n  for (let [k,v] of succ(g)) {\n    const pos = (p||0) + v.pos\n    placeForest(v, d+1, pos)\n    placeNode(k, d, pos)\n  }\n}\ng = { 1: {\n2: { 3: { 4: {5: {}}, 6: {7:{}, 8:{}, 9:{}}}}, 10: { 11: { 12: {}, 13: {}}}}}\ngridY = 30\nlayoutForest(g,0)\nplaceForest(g,0)\ncreateCanvas()\ndrawForest(g)\n</code>\n<aside id=\"graphs-frontend\">\n<h2>Frontend - Drawing Graphs</h2>\n<h3>Algorithm 1: Spanning Trees</h3>\n<p>Find a spanning tree of the graph, draw it as a tree, then draw the remaining edges.</p>\n<p><strong>Exercise:</strong> implement it!</p>\n<h3>Algorithm 2: Layered Graph Drawing</h3>\n<p>Steps:</p>\n<ul>\n<li>Compute node ranks</li>\n<li>Route edges by creating dummy nodes</li>\n<li>Shuffle to minimize crossings</li>\n<li>Draw</li>\n</ul>\n<p>In rough pseudo-code:</p>\n<pre>\ncomputeRank()\ncomputePositions()\ncreateCanvas()\ndrawGraph()\n</pre>\n<p>Let’s fill it with life. As a first cut we assign positions by distributing the vertical space within each rank:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// Compute succ/pred relations from edge list\nfunction computeGraph(edges) {\n  let nodes = new Set(edges.flat())\n  let pred = {}\n  let succ = {}\n  for (let [n1,n2] of edges) {\n    if (pred[n2]) pred[n2].push(n1)\n    else pred[n2] = [n1]\n    if (succ[n1]) succ[n1].push(n2)\n    else succ[n1] = [n2]\n  }\n  return {\n     start: Array.from(nodes),//.filter(n => !pred[n]),\n    succ: succ, pred: pred\n  }\n}\n// Compute the rank of each node\nfunction computeRank(start, succ) {\n  const rank = {}\n  const mark = {} // is node on current path\n  const path = []\n  function visit(node) {\n    if (mark[node]) return // cycle\n    if (path.length < rank[node]) return // want to compute the max rank ...\n    rank[node] = path.length\n    mark[node] = true\n    path.push(node)\n    for (let n of succ[node]||[])\n      visit(n)\n    path.pop()\n    mark[node] = undefined\n  }\n  for (let n of start)\n    visit(n)\n  return rank\n}\n// Compute a list of nodes ordered by rank\nfunction computeLayout(rank) {\n  // Now compute ranked list of nodes\n  const layout = []\n  for (let n in rank) {\n    let ns = layout[rank[n]] || (layout[rank[n]] = [] )\n    ns.push(n)\n  }\n  return layout\n}\n// Compute positions based on layout\nfunction computePositions(layout) {\n  const pos = {}\n  const countX = layout.length\n  let countY = 0\n  for (let x = 0; x < countX; x++) {\n    countY = Math.max(countY, layout[x].length)\n  }\n  for (let x = 0; x < countX; x++) {\n    const ns = layout[x]\n    const freeY = (countY - ns.length)/2\n    for (let y = 0; y < ns.length; y++) {\n      pos[ns[y]] = { x: x, y: y + freeY}\n    }\n  }\n  //return { pos1: pos, width: countX, height: countY }\n  return pos\n}\nfunction placeGraph(pos1) {\n  for (let n in pos1) {\n    placeNode(n, pos1[n].x, pos1[n].y)\n  }\n}\nfunction drawGraph(succ) {\n  for (let n in pos) {\n    drawNode(n)\n    for (let n2 of g.succ[n]||[])\n      drawEdge(n,n2)\n  }\n}\n</code>\n<p>Let’s try it on an example:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,1]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\ngridX = 100\ngridY = 100 // more space\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>Pretty cool!</p>\n<p>But we don’t pay any special attention to edges yet. So edges may overlap, cross, etc. Especially back-edges are annoying:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"C\"],[\"D\",\"A\"]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\ngridX = 100\ngridY = 100 // more space\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>The first idea is to do something relatively simple. Let’s move those back edges out of the way.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet lastBackEdge = {}\nlet countBackEdge = {}\nfunction drawRaisedBackArrow(x1,y1,x2,y2) {\n  let dx = x2-x1\n  let dy = y2-y1\n  let h = -Math.min(0,dy) + 10\n  let u = y1-boxY/2-h\n  while (lastBackEdge[u] && x2 < lastBackEdge[u]) u -= 3\n  let v = (countBackEdge[x1]||0) * 3\n  let w = (countBackEdge[x2]||0) * 3\n  ctx.beginPath()\n  ctx.moveTo(x1+v, y1-boxY/2)\n  ctx.lineTo(x1+v, u)\n  ctx.lineTo(x2+w, u)\n  ctx.lineTo(x2+w, y2-boxY/2)\n  ctx.stroke()\n  drawArrowHead(x2+w,  y2-boxY/2, Math.PI/2)\n  lastBackEdge[u] = x1\n  countBackEdge[x1] = (countBackEdge[x1]||0) + 1\n  countBackEdge[x2] = (countBackEdge[x2]||0) + 1\n}\nfunction drawEdge(n1,n2) {\n  let [x1,y1] = pos[n1]\n  let [x2,y2] = pos[n2]\n  if (x1 < x2) {\n    drawArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n  } else {\n    drawRaisedBackArrow(originX + x1, originY + y1, originX + x2, originY + y2)\n  }\n}\n//\nfunction plotGraph(edges) {\n  pos = []\n  lastBackEdge = {}\n  countBackEdge = {}\n  g = computeGraph(edges)\n  g.rank = computeRank(g.start, g.succ)\n  const layout = computeLayout(g.rank)\n  const pos1 = computePositions(layout)\n  gridX = 100\n  gridY = 100 // more space\n  placeGraph(pos1)\n  createCanvas()\n  drawGraph(g.succ)\n  print(\"\")\n}\nplotGraph([[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,1]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"B\"]])\nplotGraph([[\"A\",\"B\"],[\"A\",\"C\"],[\"B\",\"A\"],[\"C\",\"A\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"B\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"B\"],[\"D\",\"A\"]])\nplotGraph([[\"A\",\"B\"],[\"B\",\"C\"],[\"C\",\"D\"],[\"C\",\"A\"],[\"D\",\"C\"],[\"D\",\"A\"]])\n</code>\n<p>This produces already some pretty neat results.</p>\n<h3>Algorithm 3: Layered with Edge Routing</h3>\n<p>A more principled idea is to insert dummy nodes along edges that traverse a layer, and then position nodes to minimize edge crossings.</p>\n<h4>Edge Routing</h4>\n<p>Let’s look at dummy nodes first. We need to create them:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction computeDummyEdges(edges,rank) {\n  // currently modifying rank table in place,\n  // could also return a new one\n  let edges1 = []\n  for (let [n1,n2] of edges) {\n    let links = []\n    const d = rank[n2] - rank[n1]\n    if (Math.abs(d) > 1) {\n      let m1 = n1\n      for (let j = 1; j < d; j++) {\n        let m2 = n1+\"-#\"+j+\"-\"+n2\n        links.push([m1,m2])\n        rank[m2] = rank[m1] + 1\n        m1 = m2\n      }\n      links.push([m1, n2])\n    } else {\n      links.push([n1,n2])\n    }\n    edges1.push(...links)\n  }\n  return edges1\n}\n</code>\n<p>And be able to draw them:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\nfunction drawPath(n,n2) {\n  let [[x1,y1],[x2,y2]] = [pos[n],pos[n2]]\n  if (n2 == n) {\n    drawCycle(originX + x1, originY + y1)\n  } else {\n    let points = [originX + x1, originY + y1, originX + x2, originY + y2]\n    // follow path to the next regular node\n    while (n2.toString().indexOf(\"#\") >= 0) {\n      n2 = g.succ[n2][0] // we know we have only a single successor\n      points.push(originX + pos[n2][0], originY + pos[n2][1])\n    }\n    drawArrowN(points)\n  }\n}\nfunction drawGraph(succ) {\n  for (let n in pos) {\n    if (n.indexOf(\"#\") < 0) {\n      drawNode(n)\n      for (let n2 of succ[n]||[])\n        drawPath(n,n2)\n    }\n  }\n}\n</code>\n<p>Here’s an example:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,2]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>As we can see, we have some proper routed edges now, but the overall layout isn’t great.</p>\n<p>So let’s go ahead and minimize crossings.</p>\n<h4>Minimizing Edge Crossings</h4>\n<p>We’ll use a heuristic that proceeds layer by layer, and assigns each node the average (“barycentric”, alternative: median) position of its parents.</p>\n<p>The process works best when iterated, alternating forward and backward passes. There’s some theory that says it actually minimizes crossings.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// Assign each node the average pos of its parents\nfunction recomputeLayerPositions(g, layout, pos, l, dir) {\n  for (let n2 of layout[l]) {\n    let nsy = dir > 0 ? (g.pred[n2]||[]) : (g.succ[n2]||[])\n    nsy = nsy.filter(n => g.rank[n] == l-dir).map(n => pos[n].y)\n    // TODO: include succ[n2] where rank = l-1 (outgoing back-edges)?\n    if (nsy.length > 0)\n      pos[n2].y = (Math.min(...nsy) + Math.max(...nsy))/2\n    // NOTES:\n    // GraphViz: also greedily swap adjacent nodes if that removes a crossing\n    // Note: we're computing screen positions, this may lead to overlap!\n    // Example: two nodes have same parents --> assign same position\n    // Solution step 1: sort by position (layout[l] = sortBy(pos))\n    // Solution step 2: move apart verlet-style (possible in 2 passes, but need more for best result)\n    // Alternative idea: GraphViz, run ranking in other dimension (extended constraint graph)\n  }\n}\nfunction recomputeLayerLayout(g, layout, pos, l) {\n  layout[l].sort((n1,n2) => pos[n1].y - pos[n2].y)\n}\n// Move apart overlapping nodes within a layer\nlet edgeSep = 0.15\nlet nodeSep = 0.25\nlet removeOverlapIterCount = 5\nfunction recomputeLayerOverlap(g, layout, pos, l) {\n  let rn = nodeSep // relative to grid\n  let re = edgeSep\n  for (let k = 0; k < removeOverlapIterCount; k++) {\n    for (let j = 1; j < layout[l].length; j++) {\n      let n1 = layout[l][j-1]\n      let n2 = layout[l][j]\n      let d = pos[n2].y - pos[n1].y\n      let dd1 = ((n1.indexOf(\"#\") < 0) ? rn : re)\n      let dd2 = ((n2.indexOf(\"#\") < 0) ? rn : re)\n      let dd = dd1 + dd2\n      if (d < dd) {\n        pos[n1].y -= (dd-d)*0.5//(dd2/dd)\n        pos[n2].y += (dd-d)*0.5//(dd1/dd)\n      }\n    }\n    for (let j = layout[l].length-1; j > 0; j--) {\n      let n1 = layout[l][j-1]\n      let n2 = layout[l][j]\n      let d = pos[n2].y - pos[n1].y\n      let dd1 = ((n1.indexOf(\"#\") < 0) ? rn : re)\n      let dd2 = ((n2.indexOf(\"#\") < 0) ? rn : re)\n      let dd = dd1 + dd2\n      if (d < dd) {\n        pos[n1].y -= (dd-d)*0.5//(dd2/dd)\n        pos[n2].y += (dd-d)*0.5//(dd1/dd)\n      }\n    }\n  }\n}\n// Client should iterate fwd/bwd a few times\nfunction improvePositions(g, layout, pos) {\n  for (let l = 1; l < layout.length; l++) {\n    recomputeLayerPositions(g, layout, pos, l, 1)\n    recomputeLayerLayout(g, layout, pos, l)\n    recomputeLayerOverlap(g, layout, pos, l)\n  }\n}\nfunction improvePositionsReverse(g, layout, pos) {\n  for (let l = layout.length-2; l >= 0; l--) {\n    recomputeLayerPositions(g, layout, pos, l, -1)\n    recomputeLayerLayout(g, layout, pos, l)\n    recomputeLayerOverlap(g, layout, pos, l)\n  }\n}\n</code>\n<p>Let’s try it!</p>\n<h3>Examples</h3>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 2], [3 ,1], [3,2], [4,1], [4,2], [2,2]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\nimprovePositions(g,layout,pos1)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>About as good as it gets for this graph, right? And already in a single pass of improving positions.</p>\n<p>Let’s try another one. This one stresses the elimination of overlap within a layer.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [[1, 11], [1, 12], [1, 13], [1, 14], [2, 21], [2, 22], [2, 23], [2, 24]]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nconst pos1 = computePositions(layout)\nimprovePositions(g,layout,pos1)\n// draw\ngridY = 100 // more space\ngridX = 50\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p>Here’s a larger example from the TikZ manual:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [\n  [\"Thompson\",\"Mashey\"],\n  [\"Thompson\",\"Bourne\"],\n  [\"Thompson\",\"csh\"],\n  [\"csh\",\"tcsh\"],\n  [\"Bourne\",\"ksh\"],\n  [\"Bourne\",\"esh\"],\n  [\"Bourne\",\"vsh\"],\n  [\"Bourne\",\"System-V\"],\n  [\"Bourne\",\"v9sh\"],\n  [\"v9sh\",\"rc\"],\n  [\"Bourne\",\"Bash\"],\n  [\"ksh-i\",\"Bash\"],\n  [\"KornShell\",\"Bash\"],\n  [\"esh\",\"ksh\"],\n  [\"vsh\",\"ksh\"],\n  [\"Formshell\",\"ksh\"],\n  [\"csh\",\"ksh\"],\n  [\"KornShell\",\"POSIX\"],\n  [\"System-V\",\"POSIX\"],\n  [\"ksh\",\"ksh-i\"],\n  [\"ksh-i\",\"KornShell\"],\n  [\"KornShell\",\"ksh-POSIX\"],\n  [\"Bourne\",\"Formshell\"],\n  [1972,1976],\n  [1976,1978],\n  [1978,1980],\n  [1980,1982],\n  [1982,1984],\n  [1984,1986],\n  [1986,1988],\n  [1988,1990],\n  [1990,\"future\"],\n]\nlet rank = {\n  \"1972\": 0,\n  \"Thompson\": 0,\n  \"1976\": 1,\n  \"Mashey\": 1,\n  \"Bourne\": 1,\n  \"1978\": 2,\n  \"Formshell\": 2,\n  \"csh\": 2,\n  \"1980\": 3,\n  \"esh\": 3,\n  \"vsh\": 3,\n  \"1982\": 4,\n  \"ksh\": 4,\n  \"System-V\": 4,\n  \"1984\": 5,\n  \"v9sh\": 5,\n  \"tcsh\": 5,\n  \"1986\": 6,\n  \"ksh-i\": 6,\n  \"1988\": 7,\n  \"KornShell\": 7,\n  //\"Perl\": 7,\n  \"rc\": 7,\n  \"1990\": 8,\n  //\"tcl\": 8,\n  \"Bash\": 8,\n  \"future\": 9,\n  \"POSIX\": 9,\n  \"ksh-POSIX\": 9,\n}\ng = computeGraph(edges)\ng.rank = rank // manually ranked, according to years\n//g.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nlet pos1 = computePositions(layout)\nedgeSep = 0.15\nnodeSep = 0.25\nimprovePositions(g,layout,pos1)\nimprovePositionsReverse(g,layout,pos1)\nimprovePositions(g,layout,pos1)\n//improvePositionsReverse(g,layout,pos1)\n//pos1 = computePositions(layout) // try this as well!\n// draw\nedgeBend = 30\ngridY = 80\ngridX = 50\nboxX = 30\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<p><strong>Exercise:</strong> try more examples, e.g., from Pohlmann’s thesis, TikZ manual, Tamassia’s handbook.</p>\n<h3>Algorithm 4: Layered with clusters</h3>\n<ul>\n<li>See, e.g., layout of compound directed graphs <a href=\"https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/25862\">https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/25862</a></li>\n</ul>\n<h3>Algorithm 5: Force-Based</h3>\n<ul>\n<li>See, e.g., Pohlmann’s thesis.</li>\n</ul>\n<h3>Discussion</h3>\n<p>References:</p>\n<ul>\n<li>Methods for visual understanding of hierarchical system structures. K. Sugiyama, S. Tagawa, and M. Toda, 1981 <a href=\"https://ieeexplore.ieee.org/abstract/document/4308636\">https://ieeexplore.ieee.org/abstract/document/4308636</a></li>\n<li>A Technique for Drawing Directed Graphs. Emden R. Gansner, Eleftherios Koutsofios, Stephen C. North, Kiem-Phong Vo, 1993 <a href=\"https://www.graphviz.org/Documentation/TSE93.pdf\">https://www.graphviz.org/Documentation/TSE93.pdf</a> (GraphViz)</li>\n<li>Configurable Graph Drawing Algorithms for the TikZ Graphics Description Language. Jannis Pohlmann, MS Thesis, 2011\n<a href=\"http://www.tcs.uni-luebeck.de/downloads/papers/2011/2011-configurable-graph-drawing-algorithms-jannis-pohlmann.pdf\">http://www.tcs.uni-luebeck.de/downloads/papers/2011/2011-configurable-graph-drawing-algorithms-jannis-pohlmann.pdf</a> (TikZ)</li>\n<li>Handbook of Graph Drawing and Visualization. Roberto Tamassia, Editor, 2013, <a href=\"http://cs.brown.edu/people/rtamassi/gdhandbook/\">http://cs.brown.edu/people/rtamassi/gdhandbook/</a> (Chapter 13: Hierarchical drawing algorithms by Healy &#x26; Nikolov <a href=\"http://cs.brown.edu/people/rtamassi/gdhandbook/chapters/hierarchical.pdf\">http://cs.brown.edu/people/rtamassi/gdhandbook/chapters/hierarchical.pdf</a>)</li>\n</ul>\n</aside>\n<p>GraphViz and similar tools are based on an approach known as the Sugiyama framework. This approach first partitions the graph into layers by assigning each node a rank, then routes edges by inserting dummy nodes whenever an edge traverses a layer, and finally minimizes edge crossings by shuffling nodes within each layer:</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nlet edges = [\n  [\"Th\",\"Ma\"],\n  [\"Th\",\"Bo\"],\n  [\"Th\",\"cs\"],\n  [\"cs\",\"tc\"],\n  [\"Bo\",\"ks\"],\n  [\"Bo\",\"es\"],\n  [\"Bo\",\"vs\"],\n  [\"Bo\",\"Sy\"],\n  [\"Bo\",\"v9\"],\n  [\"v9\",\"rc\"],\n  [\"Bo\",\"Ba\"],\n  [\"ks\",\"Ba\"],\n  [\"Ko\",\"Ba\"],\n  [\"es\",\"ks\"],\n  [\"vs\",\"ks\"],\n  [\"Fo\",\"ks\"],\n  [\"cs\",\"ks\"],\n  [\"Ko\",\"PO\"],\n  [\"Sy\",\"PO\"],\n  [\"ks\",\"ki\"],\n  [\"ki\",\"Ko\"],\n  [\"Ko\",\"kP\"],\n  [\"Bo\",\"Fo\"],\n  [\"kP\",\"kP\"],\n]\ng = computeGraph(edges)\ng.rank = computeRank(g.start, g.succ)\n// insert dummy edges and nodes\nlet edges1 = computeDummyEdges(edges,g.rank)\nlet rank1 = g.rank\n// recompute pred and succ\nedges = edges1\ng = computeGraph(edges)\ng.rank = rank1\n// layout, initial positions, improved positions\nconst layout = computeLayout(g.rank)\nlet pos1 = computePositions(layout)\nedgeSep = 0.15\nnodeSep = 0.25\nimprovePositions(g,layout,pos1)\nimprovePositionsReverse(g,layout,pos1)\nimprovePositions(g,layout,pos1)\n//improvePositionsReverse(g,layout,pos1)\n//pos1 = computePositions(layout) // try this as well!\n// draw\nedgeBend = 20\ngridY = 80\ngridX = 60\nboxX = 20\nplaceGraph(pos1)\ncreateCanvas()\ndrawGraph(g.succ)\n</code>\n<aside>\n<h2>Discussion</h2>\n<p>The algorithms discussed here achieve visually pleasing results with a relatively simple and modular implementation, which can be tweaked in many different ways to achieve particular visualization styles.</p>\n<p>The tree layout algorithm is commonly attributed to Reingold and Tilford, the graph layout framework to Sugiyama. Many variations and extensions exist, including for clustered graphs that include a form of hierarchy, i.e., super nodes that visually contain other nodes.</p>\n<p>Force-based layout is an alternative to the rank-based graph layout approach discussed here, based on the simulation of physical attraction and repulsion forces between nodes. This approach is implemented in D3.js and various other tools.</p>\n</aside>\n<p>These algorithms achieve good results and provide many tuning knobs. An alternative graph layout model, used for example by D3.js, is based on simulating physical forces between nodes.</p>","fields":{"slug":"/Public/Generic/drawing-graphs/"},"frontmatter":{"date":"June 28, 2020","title":"Drawing Graphs like GraphViz","description":"Automatic graph and tree layout. The core of GraphViz, implemented from scratch in JavaScript.","keywords":"Graphs, Graph Drawing, GraphViz, Sugiyama Framework, JavaScript","tags":null}}},{"node":{"excerpt":"I wanted to implement a piano practice app for my little son. Here’s what I came up with. Virtual Piano Implementation Preliminaries: we’ll…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>I wanted to implement a piano practice app for my little son. Here’s what I came up with.</p>\n<aside>\n<h2>Virtual Piano Implementation</h2>\n<aside>\n<p>Preliminaries: we’ll need buttons.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction button(s,eh) {\n  const e = document.createElement(\"button\")\n  e.innerText = s\n  e.addEventListener(\"click\",eh)\n  o.appendChild(e)\n  return e\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nbutton(\"click\", () => print(\"click\"))\n</code>\n</aside>\n<p>Let’s see how we can get our web browser to play sound.</p>\n<aside>\n<h2>Playing a sound</h2>\n<p>Let’s get started. Here’s how to play sounds in a web browser, using the WebAudio API:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet fadeOut = 0.5\nfunction play(freq) {\n  // recycle AudioContext instances, Browser won't\n  // let us create a lot of them\n  if (!window.audio)\n      window.audio = new (window.AudioContext || window.webkitAudioContext)()\n  let osc = audio.createOscillator()\n  let gain = audio.createGain()\n  osc.type = \"sine\"\n  osc.frequency.value = freq\n  gain.gain.value = 0.3 // without this, weird interference\n  osc.connect(gain)\n  gain.connect(audio.destination)\n  let startPlay = audio.currentTime\n  osc.start(audio.currentTime)\n  function stop() {\n    let startFade = audio.currentTime\n    let stopFade = startFade + fadeOut\n    // avoid weird click sound when turning off\n    // in the middle of a sine wave (exp decay)\n    gain.gain.setValueAtTime(gain.gain.value, startFade);\n    gain.gain.linearRampToValueAtTime(0.0001, stopFade);\n    osc.stop(stopFade)\n    return startFade - startPlay\n  }\n  return stop\n}\n</code>\n<p>Try it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nawait buttonClick(\"play\")\nlet stop = play(440)\nawait buttonClick(\"stop\")\nstop()\n</code>\n<p>There are a couple issues worth pointing at and how they are solved:</p>\n<ul>\n<li>Auto-play prevention (solution: lazy init, start in response to user action)</li>\n<li>Browser limits (solution: share audio context)</li>\n<li>Weird click sound at end (solution: fade out)</li>\n<li>Weird interference when playing multiple sounds (solution: reduce gain)</li>\n</ul>\n<p>The bottom line is that sound is disturbance of air pressure. A tone is rhythmic disturbance (sine wave, or other waveform) with a certain frequency.</p>\n</aside>\n<p>Now we can do this:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nawait buttonClick(\"play\")\nlet stop = play(440)\nawait buttonClick(\"stop\")\nstop()\n</code>\n<p>But what are the sounds that make up music? We have to work out which frequencies notes like C, D, E, etc. correspond to.</p>\n<aside>\n<h2>Playing a note</h2>\n<p>Raw frequencies are kinda boring. So let’s play some actual notes. For that we need to understand a bit about music.</p>\n<p>We know that notes C, D, E, F, G, A, B form an octave. We can go an octave lower or higher and have the same notes.</p>\n<p>The frequency we played, 440 Hz, is the middle A note, A4.</p>\n<p>Human perception of sound is logarithmic. What we perceive as one step higher or lower is actually a multiplication in frequency. We perceive sounds as similar if we double or halve the frequency (low C vs high C). And we find certain ratios <em>harmonic</em> but others not.</p>\n<p>An octave corresponds to a doubling or halving in frequency. So in addition to the A4 note at 440 Hz, there are A sounds at 55 Hz, 110 Hz, 220 Hz, 440 Hz, 880 Hz, and so on.</p>\n<p>An octave is typically split into 12 <em>half tones</em>, called\nC, C#, D, D#, E, F, F#, G, G#, A, A#, B. Note that there is no E# and no B#, so E, F and B,C are just half tones apart, unlike for example C,D or F,G.</p>\n<p>(This division by 12 is called the chromatic scale. There are other ways to divide an octave, e.g., pentatonic music has 5 notes per octave, some Jazz has 8.)</p>\n<p>Given that we know where the A’s are, how can we calculate the frequencies for other notes? The next A from, say, 220 Hz is a multiplication by 2 away, so we want to do 1/12 of that step to reach the next half tone. This means that the factor we are looking for is the 12th root of 2, or 2 to the power of 1/12 (since (2^(1/12))^12 = 2).</p>\n<p>The steps are easy to compute programmatically:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"A\",\"A#\",\"B\",\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\n\"G\",\"G#\"]\nawait buttonClick(\"play\")\nfor (let i = 0; i < 13; i++) {\n  print(notes[i%notes.length], 220*Math.pow(2,i/12))\n  let stop = play(220*Math.pow(2,i/12))\n  await sleep(300)\n  stop()\n}\n</code>\n<p>So let’s collect those in a table (for two octaves) and define a helper function to play notes:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet noteName = [\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\",\"C+\",\"C#+\",\"D+\",\"D#+\",\"E+\",\"F+\",\"F#+\",\"G+\",\"G#+\",\"A+\",\"A#+\",\"B+\"]\nlet noteIndx = {}\nlet noteFreq = {}\nfor (let i = 0; i < noteName.length; i++) {\n  let k = i + 3 // \"A\",\"A#\",\"B\",\"C\"\n  noteIndx[noteName[i]] = i\n  noteFreq[noteName[i]] = 220*Math.pow(2,k/12)\n}\nfunction playNote(k) {\n  return play(noteFreq[k])\n}\n</code>\n<p>Knowing how notes correspond to frequencies,\nwe can play a simple scale (this is the\nstandard “C Major” scale):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\nawait buttonClick(\"play\")\nfor (let i = 0; i < notes.length; i++) {\n  let stop = playNote(notes[i])\n  await sleep(300)\n  stop()\n}\n</code>\n</aside>\n<p>Knowing how notes correspond to frequencies, we can start playing interactively.</p>\n<aside>\n<h2>Drawing a piano keyboard</h2>\n<p>We can already support basic interactivity:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\nfor (let i = 0; i < notes.length; i++) {\n  button(notes[i], () => {\n    let stop = playNote(notes[i])\n    sleep(300).then(stop)\n  })\n}\n</code>\n<p>But we’d really like to have a better UI.</p>\n<p>So here we go for our first cut:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction piano(keys) {\n  let keyInputMap = [\"a\",\"s\",\"d\",\"f\",\"g\",\"h\",\"j\"] // kl;'\n  let width = 300\n  let height = 150\n  let cvs = document.createElement(\"canvas\")\n  cvs.width = width\n  cvs.height = height\n  o.appendChild(cvs)\n  // drawing\n  let ctx = cvs.getContext(\"2d\")\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n  let d = width/keys.length\n  function drawKey(k, pressed) {\n    ctx.save()\n    let bg = \"white\"\n    let fg = \"black\"\n    if (pressed) {\n      bg = \"black\"\n      fg = \"white\"\n    }\n    ctx.fillStyle = bg\n    ctx.fillRect(k*d, 0, d, height)\n    ctx.strokeStyle = fg\n    ctx.strokeRect(k*d, 0, d, height)\n    ctx.fillStyle = fg\n    if (keyInputMap[k])\n      ctx.fillText(keyInputMap[k],k*d+d/2, height-20)\n    ctx.fillText(keys[k],k*d+d/2, height-10)\n    ctx.restore()\n  }\n  for (let i = 0; i < keys.length; i++) {\n    drawKey(i,false)\n  }\n  // interactivity\n  let playing = []\n  let pressed = null\n  let touchDevice = false\n  function play(k) {\n      if (!playing[k]) {\n          drawKey(k,true)\n          playing[k] = playNote(keys[k])\n      }\n  }\n  function playStop(k) {\n      drawKey(k,false)\n      if (playing[k]) {\n          let stop = playing[k]\n          playing[k] = null\n          stop()\n      }\n  }\n  cvs.addEventListener(\"keydown\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          play(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"keyup\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          playStop(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"mouseenter\", (e) => {\n      // enable key input focus if not using touch\n      if (!touchDevice) {\n        cvs.setAttribute(\"contentEditable\", \"true\")\n        cvs.focus()\n      }\n  })\n  cvs.addEventListener(\"mousedown\", (e) => {\n      let x = e.offsetX\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n      }\n  })\n  cvs.addEventListener(\"mouseup\", (e) => {\n      playStop(pressed)\n  })\n  // could register this dynamically on mouse\n  // down with document and remove on mouse up\n  cvs.addEventListener(\"mousemove\", (e) => {\n      if (!e.buttons) return\n      let x = e.offsetX\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchstart\", (e) => {\n      touchDevice = true\n      let bounds = cvs.getBoundingClientRect()\n      let x = e.changedTouches[0].clientX-bounds.left\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n        e.preventDefault()\n        e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"touchmove\", (e) => {\n      let bounds = cvs.getBoundingClientRect()\n      let x = e.changedTouches[0].clientX-bounds.left\n      let k = Math.floor(x/d)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchend\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchcancel\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n}\n</code>\n<p>Here’s how we use it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet notes = [\"C\",\"D\",\"E\",\"F\",\"G\",\"A\",\"B\"]\npiano(notes)\n</code>\n<p>This is good and we could extend it to include half tones\nor multiple octaves by just adding more keys.</p>\n<p>However we prefer a layout that corresponds to a physical\npiano.</p>\n<p>Here is the more advanced version:</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction piano2(callback) {\n  let keys = [\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\",\n  \"C+\",\"C#+\",\"D+\",\"D#+\",\"E+\",\"F+\",\"F#+\",\"G+\",\"G#+\",\"A+\",\"A#+\",\"B+\"]\n  let keyNames = keys\n  let keyInputMap = [\"a\",\"w\",\"s\",\"e\",\"d\",\"f\",\"t\",\n  \"g\",\"y\",\"h\",\"u\",\"j\",\"k\",\"o\",\"l\",\"p\",\";\",\"'\",\"0\",\"[\",\"-\",\"]\",\"=\",\"\\\\\"]\n  let width = 600\n  let height = 200\n  let upperHeight = height-40\n  let cvs = document.createElement(\"canvas\")\n  cvs.width = width\n  cvs.height = height\n  // enable key input focus\n  cvs.setAttribute(\"contentEditable\", \"true\")\n  o.appendChild(cvs)\n  // drawing\n  let ctx = cvs.getContext(\"2d\")\n  ctx.textAlign = \"center\"\n  ctx.textBaseline = \"middle\"\n  let upperKeys = [1,3,null,6,8,10,null,13,15,null,18,20,22]\n  let lowerKeys = [0,2,4,5,7,9,11,12,14,16,17,19,21,23]\n  let d = width/lowerKeys.length\n  let upperD = d-10//d/2\n  let playing = []\n  let highlight = []\n  function drawKey1(k0, bgnd, upper) {\n    let k = upper ? upperKeys[k0] : lowerKeys[k0]\n    if (k == null) return\n    let xoffset = 0\n    let xgap = 0\n    let h = height\n    let pressed = playing[k]\n    if (upper) {\n      h = upperHeight\n      xgap = d - upperD\n      xoffset = d/2\n    }\n    let x = k0*d+xoffset\n    ctx.save()\n    let bg = upper ? \"black\" : \"white\"\n    let fg = upper ? \"white\" : \"black\"\n    if (pressed) {\n      bg = \"yellow\"\n      fg = \"black\"\n    }\n    if (bgnd) {\n      ctx.fillStyle = bg\n      ctx.fillRect(x+xgap/2, 0, d-xgap, h)\n    } else {\n      ctx.strokeStyle = \"black\"\n      ctx.strokeRect(x+xgap/2, 0, d-xgap, h)\n      ctx.fillStyle = fg\n      ctx.fillText(keyInputMap[k],x+d/2, h-20)\n      ctx.fillText(keys[k],x+d/2, h-10)\n    }\n    ctx.restore()\n  }\n  function drawHighlight(k,dur,start,i) {\n    let k0 = upperKeys.indexOf(k)\n    let upper = k0 >= 0\n    if (!upper) k0 = lowerKeys.indexOf(k)\n    let xoffset = 0\n    let xgap = 0\n    let h = upperKeys.indexOf(highlight[0])>=0 ? upperHeight : height\n    if (upper) {\n      xgap = d-upperD\n      xoffset = d/2\n    }\n    let x = k0*d+xoffset\n    const fill = [\"#FF0000\",\"#ff9999\",\"#ffe6e6\"]\n    ctx.save()\n    ctx.fillStyle = fill[Math.min(i,fill.length-1)]\n    let y = h-start*h\n    ctx.fillRect(x+xgap/2, y, d-xgap, -h*dur)\n    ctx.restore()\n  }\n  function redraw() {\n  // lower keys\n  for (let i = 0; i < lowerKeys.length; i++) {\n    drawKey1(i,true,false)\n  }\n  let start = 0\n  if (highlight)\n  for (let i = 0; i < highlight.length; i+=2) {\n    if (upperKeys.indexOf(highlight[i])<0)\n    drawHighlight(highlight[i],highlight[i+1],start,i/2)\n      start = start + highlight[i+1]\n  }\n  for (let i = 0; i < lowerKeys.length; i++) {\n    drawKey1(i,false,false)\n  }\n  for (let i = 0; i < upperKeys.length; i++) {\n    drawKey1(i,true,true)\n  }\n  // upper keys\n  start = 0\n  if (highlight)\n  for (let i = 0; i < highlight.length; i+=2) {\n    if (upperKeys.indexOf(highlight[i])>=0)\n    drawHighlight(highlight[i],highlight[i+1],start,i/2)\n      start = start + highlight[i+1]\n  }\n  for (let i = 0; i < upperKeys.length; i++) {\n    drawKey1(i,false,true)\n  }\n  }\n  function drawKey(i,pressed) {\n    redraw()\n  }\n  redraw()\n  // interactivity\n  let pressed = null\n  let touchDevice = false\n  function hit(x,y) {\n    if (y < upperHeight && x > d/2) { // try upper first\n      let u = upperKeys[Math.floor((x-d/2)/d)]\n      if (u) return u\n    }\n    return lowerKeys[Math.floor(x/d)]\n  }\n  function play(k) {\n      if (!playing[k]) {\n          playing[k] = playNote(keys[k])\n          drawKey(k,true)\n      }\n  }\n  function playStop(k) {\n      if (playing[k]) {\n          let stop = playing[k]\n          playing[k] = null\n          drawKey(k,false)\n          const d = stop()\n          if (callback) callback(keys[k],d)\n      }\n  }\n  cvs.addEventListener(\"keydown\", (e) => {\n      window.lastEvent = e\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          play(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"keyup\", (e) => {\n      let k = keyInputMap.indexOf(e.key)\n      if (k >= 0 && k < keys.length) {\n          playStop(k)\n          e.preventDefault()\n          e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"mouseenter\", (e) => {\n      // enable key input focus if not using touch\n      if (!touchDevice) {\n        cvs.setAttribute(\"contentEditable\", \"true\")\n        cvs.focus()\n      }\n  })\n  cvs.addEventListener(\"mousedown\", (e) => {\n      let k = hit(e.offsetX,e.offsetY)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n      }\n  })\n  cvs.addEventListener(\"mouseup\", (e) => {\n      playStop(pressed)\n  })\n  cvs.addEventListener(\"mousemove\", (e) => {\n      if (!e.buttons) return\n      let k = hit(e.offsetX,e.offsetY)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchstart\", (e) => {\n      touchDevice = true\n      let bounds = cvs.getBoundingClientRect()\n      let k = hit(e.changedTouches[0].clientX-bounds.left,e.changedTouches[0].clientY-bounds.top)\n      if (k >= 0 && k < keys.length) {\n        play(k)\n        pressed = k\n        e.preventDefault()\n        e.stopPropagation()\n      }\n  })\n  cvs.addEventListener(\"touchmove\", (e) => {\n      let bounds = cvs.getBoundingClientRect()\n      let k = hit(e.changedTouches[0].clientX-bounds.left,e.changedTouches[0].clientY-bounds.top)\n      if (k >= 0 && k < keys.length) {\n        if (k != pressed) {\n          playStop(pressed)\n          play(k)\n          pressed = k\n        }\n      }\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchend\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  cvs.addEventListener(\"touchcancel\", (e) => {\n      playStop(pressed)\n      e.preventDefault()\n      e.stopPropagation()\n  })\n  return { draw: (hl) => {\n    highlight = []\n    if (hl) for (let i = 0; i < hl.length; i+=2) {\n      let k = keys.indexOf(hl[i])\n      if (k >= 0) highlight.push(k, hl[i+1])\n    }\n    return redraw()\n  }}\n}\n</code>\n<p>Try it!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2()\n</code>\n<p>The code includes a facility to highlight some keys. This is extremely\nuseful when learning to play (hightlight the next ones to play).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2().draw([\"C\",1/4,\"F#\",1/2,\"F\",1/4])\n</code>\n</aside>\n<p>Try this on a phone or tablet!</p>\n<code class=\"runScript\" filter=\"coolEditor\">\npiano2()\n</code>\n<p>Cool, we can make some music now. But how do we play a song? We have to hit the right note at the right time, for the right duration.</p>\n<aside>\n<h2>Note durations</h2>\n<p>Notes are typically played for a power-of-two ratio of the duration of a full note, i.e., as one-eighth, quarter, or half notes. The duration of a full note is anchored to the tempo.</p>\n<p>Putting things together we can define helper functions to play notes for a given duration, and to play songs, which are lists of notes with their respective duration:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet tempo = 2000\nasync function playNote(k,d) {\n  let stop = play(noteFreq[k], d * tempo)\n  await sleep(d*tempo)\n  stop()\n}\nasync function playSong(song) {\n  for (let i = 0; i < song.length; i+=2)\n    await playNote(song[i], song[i+1])\n}\n// Now play a scale\nawait buttonClick(\"play\")\nawait playSong([\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\"G\",1/4,\"A\",1/4,\"B\",1/4,\"C+\",1/4])\n</code>\n<p>The “song” we play ist just a simple scale. We use quarter notes and a base tempo of 2 seconds for a full note. This means 2 quarter notes per second, or 120 per minute. We often find tempo specified in this way as beats per minute (BPM).</p>\n<p>Sometimes we want to play multiple notes together (chords). It is straightforward to extend the definitions above to do that. Exercise!</p>\n</aside>\n<p>Let’s define a song (this is a popular german children’s rhyme about some little ducklings).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet song = [\n\"C\",1/8,\"D\",1/8,\"E\",1/8,\"F\",1/8,\n\"G\",1/4,\"G\",1/4,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"F\",1/8,\"F\",1/8,\"F\",1/8,\"F\",1/8,\n\"E\",1/4,\"E\",1/4,\n\"D\",1/8,\"D\",1/8,\"D\",1/8,\"D\",1/8,\n\"C\",1/2\n]\n</code>\n<p>The 1/8, 1/4, etc. are the duration of each note, as fraction of a full base note. This is how we play it:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nlet tempo = 2000\nawait buttonClick(\"play\")\nfor (let i = 0; i < song.length; i+=2) {\n  let stop = playNote(song[i])\n  await sleep(song[i+1]*tempo)\n  stop()\n}\n</code>\n<p>If you want to play it on a piano, just run the code above in your head and implement <code class=\"language-text\">playNote</code> using your fingers. It’s easy once you got the song memorized. But until then, reading a sequence like <code class=\"language-text\">&quot;C&quot;,1/8,&quot;D&quot;,1/8,...</code> isn’t very natural for humans.</p>\n<p>No wonder that people came up with different notations. Let’s learn about sheet music notation.</p>\n<aside>\n<h2>Sheet music notation</h2>\n<p>A good reference is here: <a href=\"https://www.musicnotes.com/now/tips/how-to-read-sheet-music/\">How To Read Sheet Music: Step-by-Step Instructions</a></p>\n<p>The implementation is below. It might be useful to break it down into smaller increments, but for now this is what we have.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction sheet(song) {\n  let width = 600\n  let height = 100\n  let rows = 3\n  let keyIndex = {C:0, \"C#\":0, D:1, \"D#\":1, E:2, F:3, \"F#\":3, G:4, \"G#\":4, A:5, \"A#\":5, B:6,\n  \"C+\":7,\"C#+\":7,\"D+\":8,\"D#+\":8,\"E+\":9,\"F+\":10,\"F#+\":10,\"G+\":11,\"G#+\":11,\"A+\":12,\"A#+\":12,\"B+\":13}\n  let cvs2 = document.createElement(\"canvas\")\n  cvs2.width = width\n  cvs2.height = rows*height\n  o.appendChild(cvs2)\n  // drawing\n  let ctx2 = cvs2.getContext(\"2d\")\n  ctx2.strokeStyle = \"black\"\n  ctx2.lineWidth = 1\n  ctx2.textAlign = \"center\"\n  ctx2.textBaseline = \"middle\"\n  function hline(row,k) {\n    ctx2.beginPath()\n    ctx2.moveTo(0,row*100+20+k*10)\n    ctx2.lineTo(width-0,row*100+20+k*10)\n    ctx2.stroke()\n  }\n  function vline(row,k) {\n    let w = 30\n    ctx2.beginPath()\n    ctx2.moveTo(k*w,row*100+20)\n    ctx2.lineTo(k*w,row*100+60)\n    ctx2.stroke()\n  }\n  function drawSheet(rows, cols) {\n    for (let row = 0; row < rows; row++){\n      for (let j = 0; j < 5; j++) {\n        hline(row,j)\n      }\n      for (let j = 4; j <= 20; j+=4) {\n        vline(row,j)\n      }\n    }\n  }\n  function note(row,x,key,d,mark) {\n    let k = keyIndex[key]\n    let r = 5\n    let w = 15\n    let ox = w/2\n    let y = row*100+20+(5-k/2)*10\n    let o = 0\n    if (k < 0) return\n    //if (d == 4) o+=20 // if we'd want to center align notes\n    if (mark) {\n      ctx2.save()\n      ctx2.fillStyle = \"#00FFFF99\"\n      ctx2.beginPath()\n      //ctx2.arc(ox+x*w+o,y,r+r,0,2*Math.PI)\n      ctx2.rect(x*w+o,row*100+10,w,60)\n      ctx2.fill()\n      ctx2.restore()\n    }\n    ctx2.beginPath()\n    ctx2.arc(ox+x*w+o,y,r,0,2*Math.PI)\n    if (d >= 4) ctx2.fill()\n    else ctx2.stroke()\n    if (d >= 2) {\n      ctx2.beginPath()\n      ctx2.moveTo(ox+x*w+r-1+o,y)\n      ctx2.lineTo(ox+x*w+r+o,y-35)\n      ctx2.stroke()\n    }\n    if (d >= 8) { // draw 2 for 1/16, 3 for 1/32 etc\n      ctx2.beginPath()\n      ctx2.moveTo(ox+x*w+r+o,y-35)\n      ctx2.lineTo(ox+x*w+10+o,y-20)\n      ctx2.stroke()\n    }\n    //ctx2.fillText(keyInputMap[k],10+x*w+o,row*100+75)\n    ctx2.fillText(key,10+x*w+o,row*100+75)\n    ctx2.fillText(Math.ceil(d),10+x*w+o,row*100+90)\n  }\n  function drawSong(song,mark) {\n    let x = 0\n    let r = 0\n    for (let j = 0; j < song.length; j+=2) {\n      note(r,x,song[j],1/song[j+1],j==mark)\n      x+=8*song[j+1]\n      if (x >= 40) {\n        r += 1\n        x -= 40\n      }\n    }\n  }\n  drawSheet(rows)\n  drawSong(song,-1)\n  return { draw: function(song,mark) {\n    ctx2.clearRect(0,0,cvs2.width,cvs2.height)\n    drawSheet(rows)\n    drawSong(song,mark)\n  }}\n}\n</code>\n<p>Let’s use it to visualize (and play) a simple scale. We use quarter notes and a base of 2 seconds for a full note, which means 2 quarter notes per second, or 120 beats per minute (BPM).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nsong = [\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\"G\",1/4,\"A\",1/4,\"B\",1/4,\"C+\",1/4]\nlet sh = sheet(song)\nlet tempo = 2000\nawait buttonClick(\"play\")\nfor (let i = 0; i < song.length; i+=2) {\n  sh.draw(song, i)\n  let stop = playNote(song[i])\n  await sleep(song[i+1]*tempo)\n  stop()\n}\nsh.draw(song)\n</code>\n</aside>\n<p>We also define some more songs.</p>\n<aside>\n<h2>More Songs</h2>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction convertSong(song) {\nlet out = []\nfor (let j = 0; j < song.length; j+=2) {\nout[j] = keyNames[song[j]]\nout[j+1] = 1/song[j+1]\n}\nreturn out\n}\n// Oh Suzanna\nlet osz0 = [\n1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,1,4,\n2,2,/**/1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,2,4,\n1,2,/**/]\nlet osz1 = [\n4,2,4,2,\n6,4,6,2,6,4,\n5,4,5,4,3,4,1,4,\n2,2,/**/1,8,2,8,\n3,4,5,4,5,4,/**/6,8,\n5,4,3,4,1,4,/**/2,8,\n3,4,3,4,2,4,2,4,\n1,2,\n]\nlet alleMeineEntchen = [\n\"C\",1/8,\"D\",1/8,\"E\",1/8,\"F\",1/8,\n\"G\",1/4,\"G\",1/4,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"A\",1/8,\"A\",1/8,\"A\",1/8,\"A\",1/8,\n\"G\",1/2,\n\"F\",1/8,\"F\",1/8,\"F\",1/8,\"F\",1/8,\n\"E\",1/4,\"E\",1/4,\n\"D\",1/8,\"D\",1/8,\"D\",1/8,\"D\",1/8,\n\"C\",1/2\n]\nlet ohSuzannaChorus = [\n\"G\",0.5,\"G\",0.5,\n\"B\",0.25,\"B\",0.5,\"B\",0.25,\n\"A\",0.25,\"A\",0.25,\"F#\",0.25,\"D\",0.25,\n\"E\",0.5+0.25,\"D\",0.125,\"E\",0.125,\n\"F#\",0.25,\"A\",0.25,\"A\",0.25+0.125,\"B\",0.125,\n\"A\",0.25,\"F#\",0.25,\"D\",0.25+0.125,\"E\",0.125,\n\"F#\",0.25,\"F#\",0.25,\"E\",0.25,\"E\",0.25,\n\"D\",0.5\n]\nlet fuchsDuHastDieGansGestohlen = [\n\"C\",1/4,\"D\",1/4,\"E\",1/4,\"F\",1/4,\n\"G\",1/4,\"G\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"F\",1/4,\"C+\",1/4,\"A\",1/4,\n\"G\",1,\n\"A\",1/4,\"F\",1/4,\"C+\",1/4,\"A\",1/4,\n\"G\",1,\n\"G\",1/4,\"F\",1/4,\"F\",1/4,\"F\",1/4,\n\"F\",1/4,\"E\",1/4,\"E\",1/4,\"E\",1/4,\n\"E\",1/4,\"D\",1/4,\"E\",1/4,\"D\",1/4,\n\"C\",1/4,\"E\",1/4,\"G\",1/2,\n\"G\",1/4,\"F\",1/4,\"F\",1/4,\"F\",1/4,\n\"F\",1/4,\"E\",1/4,\"E\",1/4,\"E\",1/4,\n\"E\",1/4,\"D\",1/4,\"E\",1/4,\"D\",1/4,\n\"C\",1\n]\nlet katyusha = [\n\"A\",1/4+1/8,\"B\",1/8,\n\"C+\",1/4+1/8,\"A\",1/8,\n\"C+\",1/8,\"C+\",1/8,\"B\",1/8,\"A\",1/8,\n\"B\",1/4,\"E\",1/4,\n\"B\",1/4+1/8,\"C+\",1/8,\n\"D+\",1/4+1/8,\"B\",1/8,\n\"D+\",1/8,\"D+\",1/8,\"C+\",1/8,\"B\",1/8,\n\"A\",1/2,\n//\n\"E+\",1/4,\"A+\",1/4,\n\"G+\",1/4,\"A+\",1/8,\"G+\",1/8,\n\"F+\",1/8,\"F+\",1/8,\"E+\",1/8,\"D+\",1/8,\n\"E+\",1/4,\"A\",1/4,\n\"F+\",1/4+1/8,\"D+\",1/8,\n\"E+\",1/4+1/8,\"C+\",1/8,\n\"B\",1/8,\"E\",1/8,\"C+\",1/8,\"B\",1/8,\n\"A\",1/2,\n]\nlet wheelsOnTheBus = [\n\"D\",1/4,\n\"G\",1/4,\"G\",1/8,\"G\",1/8,\"G\",1/4,\"B\",1/4,\n\"D+\",1/4,\"B\",1/4,\"G\",1/2,\n\"A\",1/4,\"F#\",1/4,\"D\",1/2,\n\"D+\",1/4,\"B\",1/4,\"G\",1/4,\"D\",1/4,\n\"G\",1/4,\"G\",1/8,\"G\",1/8,\"G\",1/4,\"B\",1/4,\n\"D+\",1/4,\"B\",1/4,\"G\",1/2,\n\"A\",1/2,\"D\",1/4,\"D\",1/4,\"G\",1/2\n]\nlet ruleBritannia = [\n\"B\",1/4+1/8,\"B\",1/8,\"C+\",1/8,\"C+\",1/8+1/8,\"B\",1/8,\n\"C+\",1/8+1/16,\"B\",1/16,\"A\",1/8,\"G\",1/8,\"F\",1/4+1/8,\"A\",1/8,\n\"D+\",1/4,\"C+\",1/4,\"B\",1/16,\"G\",1/16,\"C+\",1/16,\"A\",1/16,\"D+\",1/8,\"C+\",1/8,\n\"B\",1/4,\"A\",1/4,\"G\",1/2\n]\nlet twinkleTwinkleLittleStar = [\n\"C\",1/4,\"C\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"A\",1/4,\"G\",1/2,\n\"F\",1/4,\"F\",1/4,\"E\",1/4,\"E\",1/4,\n\"D\",1/4,\"D\",1/4,\"C\",1/2,\n\"G\",1/4,\"G\",1/4,\"F\",1/4,\"F\",1/4,\n\"E\",1/4,\"E\",1/4,\"D\",1/2,\n\"G\",1/4,\"G\",1/4,\"F\",1/4,\"F\",1/4,\n\"E\",1/4,\"E\",1/4,\"D\",1/2,\n\"C\",1/4,\"C\",1/4,\"G\",1/4,\"G\",1/4,\n\"A\",1/4,\"A\",1/4,\"G\",1/2,\n\"F\",1/4,\"F\",1/4,\"E\",1/4,\"E\",1/4,\n\"D\",1/4,\"D\",1/4,\"C\",1/2,\n]\n/*\nlet enterSandman = [\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n//\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"E\",1/4,\"C\",1/8,\"D\",1/8,\"C\",1/8,\"D\",1/8,\"E\",1/8,\"D\",1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"C\",1/4,\"C\",1/8,\"C+\",1/8,\"F#\",1/8,\"F\",1/4+1/8,\n\"E\",1/4,\"C\",1/8,\"D\",1/8,\"C\",1/8,\"D\",1/8,\"E\",1/8,\"D\",1/8,\n\"C\",1/4,\n\"G+\",1/8,\"G+\",1/8,\"G+\",1/4,\"D+\",1/8,\"E+\",1/8,\"E+\",1/4,\n\"G+\",1/8,\"G+\",1/8,\"G+\",1/8,\"A+\",1/4,\"G+\",1/8,\"E+\",1/4,\n\"E+\",1/8,\"E+\",1/8,\"E+\",1/8,\"B\",1/8,\"D+\",1/8,\"E+\",1/8,\n\"D+\",1/8,\"E+\",1/8+1/2\n]*/\nlet enterSandman = [\n\"E\",1/4,\"E+\",1/8,\"G+\",1/8,\"A#\",1/8,\"A\",1/4,\"E+\",1/8,\n\"E\",1/4,\"E+\",1/8,\"G+\",1/8,\"A#\",1/8,\"A\",1/4,\"E+\",1/8,\n\"C\",1/4,\"C+\",1/8,\"D#+\",1/8,\"C+\",1/8,\"D#+\",1/8,\"E+\",1/8,\"D#+\",1/8,\"C+\",1/4,\n//EGEF#EF#GF#E\n]\nlet maennerMitBaerten = [\n\"E\",1/8,\"F#\",1/8,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/8,\"G\",1/8,\"F#\",1/8, \"E\",1/4,\"C\",1/8, /* really B- */\n\"E\",1/4,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/4,\"F#\",1/8, \"E\",1/4+1/8, // bärten sein\n\"G\",1/4,\"A\",1/8,\"B\",1/4,\"A\",1/8,\n\"G\",1/4,\"A\",1/8,\"B\",1/4+1/8, // pitt\n\"E\",1/8,\"F#\",1/8,\"G\",1/8, \"F#\",1/8,\"G\",1/8,\"A\",1/8,\n\"G\",1/4,\"F#\",1/8,\"E\",1/4+1/8\n]\nlet drEisenbart = [\n\"D\",1/8,\n\"G\",1/8, \"D\",1/8, \"D\",1/8, \"D\",1/8,\n\"E\",1/8, \"D\",1/8, \"D\",1/4,\n\"D\",1/16, \"E\",1/16, \"F#\",1/16, \"G\",1/16, \"A\",1/8, \"F#\",1/8,\n\"G\",1/4+1/8, \"D\",1/8,\n\"G\",1/8, \"D\",1/8, \"D\",1/8, \"D\",1/8,\n\"E\",1/8, \"D\",1/8, \"D\",1/4,\n\"D\",1/16, \"E\",1/16, \"F#\",1/16, \"G\",1/16, \"A\",1/8, \"F#\",1/8,\n\"G\",1/4+1/8, \"B\",1/8,\n\"A\",1/8, \"B\",1/8, \"A\",1/8, \"B\",1/8,\n\"A\",1/8, \"B\",1/8, \"A\",1/4,\n\"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/8, \"G\",1/8,\n\"F#\",1/8, \"E\",1/8, \"D\",1/4,\n\"D\",1/8+1/16, \"G\",1/16, \"G\",1/8, \"G\",1/8,\n\"G\",1/8, \"B\",1/8, \"B\",1/4,\n\"A\",1/16, \"A\",1/16, \"A\",1/16, \"A\",1/16, \"B\",1/8, \"A\",1/8,\n\"G\",1/4,\n]\nlet jingleBells = [\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"G\",1/4, \"C\",1/4, \"D\",1/4,\n\"E\",1,\n\"F\",1/4, \"F\",1/4, \"F\",1/4, \"F\",1/4,\n\"F\",1/4, \"E\",1/4, \"E\",1/4, \"E\",1/4,\n\"E\",1/4, \"D\",1/4, \"D\",1/4, \"E\",1/4,\n\"D\",1/2, \"G\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"E\",1/4, \"E\",1/2,\n\"E\",1/4, \"G\",1/4, \"C\",1/4, \"D\",1/4,\n\"E\",1,\n\"F\",1/4, \"F\",1/4, \"F\",1/4, \"F\",1/4,\n\"F\",1/4, \"E\",1/4, \"E\",1/4, \"E\",1/4,\n\"G\",1/4, \"G\",1/4, \"F\",1/4, \"D\",1/4,\n\"C\",1\n]\nfunction pickSong(callback) {\n  print(\"Pick a song:\")\n  button(\"Oh Suzanna\", () => callback(ohSuzannaChorus))\n  button(\"Twinkle Twinkle Little Star\", () => callback(twinkleTwinkleLittleStar))\n  button(\"The Wheels On The Bus\", () => callback(wheelsOnTheBus))\n  button(\"Katyusha\", () => callback(katyusha))\n  button(\"Enter Sandman\", () => callback(enterSandman))\n  button(\"Rule Britannia\", () => callback(ruleBritannia))\n  button(\"Alle Meine Entchen\", () => callback(alleMeineEntchen))\n  button(\"Fuchs Du Hast die Gans Gestohlen\", () => callback(fuchsDuHastDieGansGestohlen))\n  button(\"Männer mit Bärten\", () => callback(maennerMitBaerten))\n  button(\"Dr. Eisenbart\", () => callback(drEisenbart))\n  button(\"Jingle Bells\", () => callback(jingleBells))\n  print(\"\")\n}\n</code>\n</aside>\n<p>And now it’s time to play them while following along on the sheet:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nasync function playSong(song) {\n  clear()\n  pickSong(playSong)\n  let sh = sheet(song)\n  let tempo = 1500\n  await buttonClick(\"play\")\n  for (let i = 0; i < song.length; i+=2) {\n    sh.draw(song, i)\n    let stop = playNote(song[i])\n    await sleep(song[i+1]*tempo)\n    stop()\n  }\n  sh.draw(song)\n  playSong(song)\n}\nplaySong(ohSuzannaChorus)\n</code>\n<h2>Piano Drills</h2>\n<p>The nice thing is that everything is programmable, so we can do something more advanced. Let’s put everything together and do some piano drills. We use a piano keyboard that advances the marker only when hitting the right note, and we draw the notes hit by the user below:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet showRecorded = false\nasync function drill(song) {\n  clear()\n  pickSong(drill)\n  let rec = []\n  let handler = (k,d) => {}\n  let sh1 = sheet(song)\n  let pi = piano2((k,d) => handler(k,d))\n  let sh2 = showRecorded ? sheet(rec) : null\n  let tempo = 1500\n  function notePlayed(k0,d0) {\n    return new Promise(resolve => handler = (k,d) => {\n      if (showRecorded) {\n        rec.push(k,d/1000*tempo); sh2.draw(rec)\n      }\n      if (k == k0) resolve() })\n  }\n  for (;;) {\n    for (let i = 0; i < song.length; i+=2) {\n      sh1.draw(song, i)\n      pi.draw([song[i],song[i+1],song[i+2],song[i+3],song[i+4],song[i+5]])\n      await notePlayed(song[i],song[i+1])\n    }\n    sh1.draw(song)\n    pi.draw()\n  }\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\nshowRecorded = true\ndrill(ohSuzannaChorus)\n</code>\n<div class=\"cursive\">Have fun!</div>\n<h2>Hearing Practice</h2>\n<p>What else can we do? Let’s do some hearing practice. We play a random note, and have to hit the correct key on the piano keyboard.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nasync function ear() {\n  clear()\n  let handler = (k,d) => {}\n  let pi = piano2((k,d) => handler(k,d))\n  function notePlayed(k0) {\n    //print(\"want: \"+k0)\n    return new Promise(resolve => handler = (k,d) => {\n      if (k == k0) {\n        print(\"yay!\"); resolve()\n      }}) //else print(\"nope\")})\n  }\n  let rand = Math.floor(Math.random() * noteName.length);\n  let note = noteName[rand]\n  let stop = playNote(note)\n  let fut1 = sleep(2000)\n  let fut2 = notePlayed(note)\n  await fut1\n  stop()\n  await fut2\n  await sleep(1000)\n  await ear()\n}\nawait buttonClick(\"Go!\")\nawait ear()\n</code>\n</aside>\n<code class=\"runScript\" filter=\"coolEditor\">\ndrill(ohSuzannaChorus)\n</code>","fields":{"slug":"/Public/Generic/virtual-piano/"},"frontmatter":{"date":"June 20, 2020","title":"Virtual Piano Practice","description":"Building an interactive piano app. Drawing the keyboard, playing notes using Web Audio, and drawing sheet music notation.","keywords":null,"tags":null}}},{"node":{"excerpt":"Automatic Differentiation (AD) is a programming technique that supports transparent and efficient computation of gradients for numeric code…","html":"<!-- editor definition -->\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.setAttribute(\"contentEditable\", true)\np.setAttribute(\"spellcheck\", false)\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction print(...as) {\n  emit(as.toString())\n}\nfunction sleep(delay) {\n  return new Promise(resolve => setTimeout(resolve, delay))\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<p>Automatic Differentiation (AD) is a programming technique that supports transparent and efficient computation of gradients for numeric code in general-purpose programming languages.</p>\n<!-- We present a simple but powerful implementation of AD in JavaScript, with interactive examples. -->\n<aside>\n<h2>Context and Motivation</h2>\n<p>Deep learning crucially depends on the computation of gradients, and specifically on optimizing parameters of neural networks to fit a set of training samples using a process called gradient descent.</p>\n<p>Differentiable programming is a vision of generalizing deep learning from layer-oriented neural network architectures to training essentially arbitrary parameterized computations by gradient descent. AD is key enabler for such visions.</p>\n<p>Many explanations of AD are needlessly complex, and the topic often seems quite mysterious. The goal of this note is to provide a simple and interactive “from scratch” implementation of both forward- and reverse-mode AD that can be easily understood <em>in toto</em>. As we will show, even reverse-mode AD (“backpropagation”) can be almost ridiculously simple with the right techniques.</p>\n<p>For academically inclined readers, we refer to some of our recent publications that explain AD from a program transformation perspective:</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1803.10228\">Demystifying Differentiable Programming: Shift/Reset the Penultimate Backpropagator (Wang et al., ICFP ‘19)</a></li>\n<li><a href=\"https://papers.nips.cc/paper/8221-backpropagation-with-callbacks-foundations-for-efficient-and-expressive-differentiable-programming\">Backpropagation with Continuation Callbacks: Foundations for Efficient and Expressive Differentiable Programming (Wang et al., NeurIPS ‘19)</a></li>\n</ul>\n<p>Some utility code follows.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=\"true\">\n// some visualization utils\nlet cvs = null\nlet ctx = null\nlet plotScale = 1\nfunction newPlot(w,h) {\n    cvs = document.createElement(\"canvas\")\n    cvs.width = w\n    cvs.height = h\n    o.appendChild(cvs)\n    ctx = cvs.getContext(\"2d\")\n}\nfunction drawPoint(x,y) {\n    ctx.beginPath()\n    ctx.arc(x*plotScale,cvs.height-y*plotScale,4,0,2*Math.PI,true)\n    ctx.fill()\n}\nfunction drawPoints(data) {\n    for (let i = 0; i < data.length; i++)\n        drawPoint(data[2*i], data[2*i+1])\n}\nfunction drawFunction(f) {\n    ctx.beginPath()\n    ctx.moveTo(0,cvs.height-f(num(0)).val*plotScale)\n    for (let x = 1; x < cvs.width; x++)\n        ctx.lineTo(x,cvs.height-f((x)/plotScale)*plotScale)\n    ctx.stroke()\n}\nfunction drawLine(data) {\n    if (data.length == 0) return\n    let max = Math.max(...data)\n    let scaleY = 200/max\n    let scaleX = 200/data.length\n    ctx.beginPath()\n    ctx.moveTo(0, 200-data[0]*scaleY)\n    for (let i = 1; i < data.length; i++) {\n        ctx.lineTo(i*scaleX, 200-data[i]*scaleY)\n    }\n    ctx.stroke()\n}\nfunction randomInt(max) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n</code>\n</aside>\n<p>AD is a key enabler for deep learning and for visions of differentiable programming that generalize deep learning from layer-oriented neural networks to arbitrary computations.</p>\n<aside id=\"forward-mode-ad\">\n<h2>Forward-Mode AD</h2>\n<p>Let’s recall the standard rules for computing derivatives from high school:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(a+b)&#39; = a&#39; + b&#39;\n(a-b)&#39; = a&#39; - b&#39;\n(a*b)&#39; = a&#39;*b + b&#39;*a\n...</code></pre></div>\n<p>Observe that the order of steps to compute a derivative follows exactly the order of steps to compute the normal result. The multiplication rule is perhaps non-obvious, but if <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">a&#39;</code>, and <code class=\"language-text\">b&#39;</code> are already computed, then we can compute <code class=\"language-text\">a*b</code> and <code class=\"language-text\">(a*b)&#39;</code> at the same time.</p>\n<p>The basic idea behind forward-mode AD is to transform a program to do exactly that: compute derivatives in lockstep with every elementary arithmetic operation.</p>\n<h3>Implementation</h3>\n<p>We can implement forward-mode AD in any programming language by introducing a data type of <em>dual numbers</em>, with all arithmetic operations overriden to compute derivatives in addition to the standard (“primal”) return values.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// dual number api\nfunction num(x, d=0) {\n    return { val: x, grad: d }\n}\nfunction plus(x,y) {\n    return num(x.val + y.val, x.grad + y.grad)\n}\nfunction minus(x,y) {\n    return num(x.val - y.val, x.grad - y.grad)\n}\nfunction times(x,y) {\n    return num(x.val * y.val, x.val * y.grad + y.val * x.grad)\n}\n</code>\n<p>Real operator overloading as in Python, Scala, etc. would make client code more readable, but is unfortunately not available in plain JS (though possible via preprocessing with Babel or Sweet.js).</p>\n<p>The rules to compute the derivative components are exactly the differentiation rules from highschool-level calculus.</p>\n<p>Given a function on dual numbers, we can define accessors to obtain only the standard (“primal”) or the derivative component.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction primal(f) {\n    return (x => f(num(x,1)).val)\n}\nfunction deriv(f) {\n    return (x => f(num(x,1)).grad)\n}\n</code>\n<h3>Examples (Analytically)</h3>\n<p>Let’s verify that it works. Feel free to try some examples of your own:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// helper functions\nfunction expectFunc(f1,f2) {\n    for (let x = -10; x < 10; x++)\n        expect(f1(x), f2(x))\n}\nfunction testDeriv(label, f, d) {\n  test(label, () => expectFunc(deriv(f), d))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// test cases\ntestDeriv(\n  \"deriv(x^2) = 2x\",\n  x => times(x, x),\n  x => 2*x)\ntestDeriv(\n  \"deriv(2x^3) = 6x^2\",\n  x => times(num(2),times(x,times(x, x))),\n  x => 6*x*x)\n</code>\n<h3>Examples (Graphically)</h3>\n<p>We can also convince ourselves that we got it right by plotting a function along with its tangents at various points (try changing f or 0.8):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// draw tangent of f at x\nfunction drawTangent(f,x) {\n    let y = primal(f)(x)\n    let dy = deriv(f)(x)\n    let z = y-dy*x\n    drawPoint(x,y)\n    drawFunction(x1 => dy*x1+z)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example function (2(x-0.5))^2\nfunction sqr(x) {\n    return times(x,x)\n}\nfunction f(x) {\n    return sqr(times(num(2),minus(x,num(0.5))))\n}\n// draw it!\nnewPlot(200,200)\nplotScale = 200\ndrawFunction(primal(f))\ndrawTangent(f, 0.8) /* point for tangent -- play with it! */\n</code>\n<h3>Discussion</h3>\n<p>The beauty of AD is that we aren’t restricted to functions containing primitive arithmetic only. We can freely mix dual numbers with any other computation, including control flow, loops, recursion, objects, classes, etc.</p>\n<p>Of course we do not, in general, have any guarantee that a program with complex logic is differentiable in the mathematical sense across its entire input range. Basically, any <code class=\"language-text\">if</code> is a potential discontinuity. Thus, it is important to remember that the result of AD is only valid locally at the point it was computed, but it may not be valid in a neighborhood of that point. But since computer programs operate on discrete approximations rather than actual real numbers, talking about mathematical notions like continuity, smoothness, or differentiability in this context is murky anyways.</p>\n<p><strong>Exercise:</strong> how can we extend the scheme to compute partial derivatives for functions with multiple input arguments?</p>\n<p><strong>Exercise:</strong> what about higher (2nd, 3rd, …) order derivatives?</p>\n<p><strong>Exercise:</strong> what about nested invocations of <code class=\"language-text\">grad</code> (of which higher-order derivatives are a special case)? Hint: read up on “perturbation confusion”.</p>\n</aside>\n<p>Forward-mode AD computes derivatives for each intermediate result in lockstep with the normal program execution. It is straightforward but inefficient when computing gradients (i.e., many partial derivates), which is necessary for neural networks with many parameters.</p>\n<aside id=\"reverse-mode-ad\">\n<h2>Reverse-Mode AD (Backpropagation)</h2>\n<p><a href=\"/forward-mode-ad\">Forward-mode AD</a> can be extended to compute multiple partial derivatives (and therefore gradients) simultaneously by adding a field for each partial derivative to the dual number type. However, this is inefficient if the number of parameters gets large, as is the case for neural networks and many other practical applications.</p>\n<p>Reverse-mode AD solves the scalability issue of forward-mode AD through clever use of the chain rule of differentiation.</p>\n<h3>Intuition</h3>\n<p>Instead of computing derivates in lockstep with the normal computation as in forward-mode AD, we first execute the program normally to compute the primal result, and then we propagate gradient updates backwards for each intermediate result (this requires some bookkeeping).</p>\n<p>Mathematically speaking, we do not compute how each intermediate result changes in response to a change in the program input (as in forward-mode), but rather how the program output changes in response to a change in the intermediate value. At the end of the backward pass the result is the same: we obtain the change of the program output in response to a change in the program input.</p>\n<p>Consider as an example a program whose final output is <code class=\"language-text\">y</code> and whose intermediate computations include:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x3 = x1 + x2\n...\nx4 = x1 * x2\n...</code></pre></div>\n<p>Since we’re going backwards, we will have computed <code class=\"language-text\">dy/dx3</code> and <code class=\"language-text\">dy/dx4</code> at some point. These are the change of the program output relative to a change in <code class=\"language-text\">x3</code> and <code class=\"language-text\">x4</code>, respectively. Once these results are available, we can compute <code class=\"language-text\">dy/dx1</code> (and likewise <code class=\"language-text\">dy/dx2</code>) through the chain rule:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dy/dx1 = dy/dx4 * dx4/dx1 + dy/dx3 * dx3/dx1</code></pre></div>\n<p>Not that the computation of <code class=\"language-text\">dy/dx1</code> has to sum over all occurrences of <code class=\"language-text\">x1</code>, in this case <code class=\"language-text\">x3</code> and <code class=\"language-text\">x4</code>. Intuitively, each occurrence of <code class=\"language-text\">x1</code> contributes through different pahts to the final result <code class=\"language-text\">z</code>, so to express how <code class=\"language-text\">z</code> changes overall in response to a delta in <code class=\"language-text\">x1</code>, we have to consider all these paths, as each contributes an additive delta to <code class=\"language-text\">z</code>.</p>\n<p>Operationally, it is useful to express this summation as a series of updates to a read-only accumulator. For each intermediate result we keep an accumulator and when we reach <code class=\"language-text\">x3</code> in the backwards pass, we add the delta <code class=\"language-text\">dy/dx3 * dx3/dx1</code> to the accumulator for <code class=\"language-text\">dy/dx1</code> (and analogous for <code class=\"language-text\">x2</code>). Note that <code class=\"language-text\">dx3/dx1</code> can be computed solely from the right-hand side of <code class=\"language-text\">x3 = ...</code>, but may require the primal value of <code class=\"language-text\">x1</code> computed in the forward pass. By the time we reach <code class=\"language-text\">x1</code> in the backward pass, we know we have accumulated all updates to <code class=\"language-text\">dy/dx1</code> and we can proceed propagation gradient updates for the inputs of the computation of <code class=\"language-text\">x1</code>.</p>\n<h3>Implementation</h3>\n<p>The forwards-then-backwards execution can be achieved in different ways. For programming language buffs, there is an especially appealing relation with continuation passing style (CPS). Here, we use a slightly modified dual number type and a stack data structure (often called the <em>tape</em>) that accumulates closures for the backward pass in the right order.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// stack to remember backward operations\nlet tape = []\n// dual number api\nfunction num(x) {\n    return { val: x, grad: 0 }\n}\nfunction plus(x,y) {\n    let z = num(x.val + y.val)\n    tape.push(() => { x.grad += z.grad; y.grad += z.grad })\n    return z\n}\nfunction minus(x,y) {\n    let z = num(x.val - y.val)\n    tape.push(() => { x.grad += z.grad; y.grad -= z.grad })\n    return z\n}\nfunction times(x,y) {\n    let z = num(x.val * y.val)\n    tape.push(() => { x.grad += y.val * z.grad; y.grad += x.val * z.grad })\n    return z\n}\n</code>\n<p>The function that computes gradients/derivatives needs to traverse the tape in reverse order, popping and running all the accumulated “backpropagator” closures.</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// derivative/gradient api\nfunction grad(f) {\n    function d(x) {\n        // forward pass\n        let dx = num(x)\n        let dz = f(dx)\n        dz.grad = 1\n        // backward pass\n        for (b of tape.reverse()) b()\n        tape = []\n        return dx.grad\n    }\n    return d\n}\n</code>\n<p>This implementation of <code class=\"language-text\">grad</code> already demonstrates the key difference in capability/scalability to forward-mode AD.</p>\n<p><strong>Exercise:</strong> how to compute partial derivatives/gradients for functions with multiple arguments?</p>\n<p>All that is required is to change function <code class=\"language-text\">grad</code> to work with <code class=\"language-text\">dx1</code>,<code class=\"language-text\">dx2</code>, etc. instead of a singular <code class=\"language-text\">dx</code>. Crucially, no additional data needs to be computed and/or stored as part of the forward or backward pass.</p>\n<h3>Examples (Analytically)</h3>\n<p>Again we run some test cases, and we observe that we get the same, correct, result as in forward mode:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// helper functions\nfunction testGrad(label, f, d) {\n  test(label, () => expectFunc(grad(f), d))\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// test cases\ntestGrad(\n  \"grad(x^2) = 2x\",\n  x => times(x, x),\n  x => 2*x)\ntestGrad(\n  \"grad(2x^3) = 6x^2\",\n  x => times(num(2),times(x,times(x, x))),\n  x => 6*x*x)\n</code>\n<h3>Examples (Graphically)</h3>\n<p>Visualization (try variations yourself):</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// draw tangent of f at x\nfunction drawTangent(f,x) {\n    let y = primal(f)(x)\n    let dy = grad(f)(x)\n    let z = y-dy*x\n    drawPoint(x,y)\n    drawFunction(x1 => dy*x1+z)\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\">\n// example function (2(x-0.5))^2\nfunction sqr(x) {\n    return times(x,x)\n}\nfunction f(x) {\n    return sqr(times(num(2),minus(x,num(0.5))))\n}\n// draw it!\nnewPlot(200,200)\nplotScale = 200\ndrawFunction(primal(f))\ndrawTangent(f, 0.8) /* point for tangent -- play with it! */\n</code>\n<h3>Discussion</h3>\n<p>While we used the same single-argument examples as for forward-mode AD (mainly for consistency), it is important to stress once more that we can use the same code to compute partial derivatives and gradients for functions with multiple arguments, with only marginal overhead.</p>\n<p><strong>Exercise:</strong> consider a function with multiple <em>outputs</em>. Which variant is more efficient, forward- or reverse-mode AD?</p>\n</aside>\n<p>Reverse-mode AD solves the scalability issue of forward-mode AD through clever use of the chain rule of differentiation. The program is executed once to compute the normal result, and then traces back through each intermediate computation step to propagate gradient updates back to the input parameters.</p>\n<aside id=\"gradient-descent-optimization\">\n<h2>Gradient-Descent Optimization</h2>\n<p>What is <a href=\"/reverse-mode-ad\">AD</a> good for? The key motivation is optimization by gradient descent. We want to match a parameterized function (e.g., a neural network) to some observed data. To do so, we provide a function to compute the difference between the result computed based on the current parameter settings and the observed data (the loss function). Then, we compute the gradient of the loss function and adjust the parameters ever so slightly in the direction where the loss gets smaller.</p>\n<code class=\"runScript\" filter=\"addPreamble\" popout=true>\nfunction drawPoint(x,y) {\n    ctx.beginPath()\n    ctx.arc(x,200-y,4,0,2*Math.PI,true)\n    ctx.fill()\n}\nfunction drawFunction(f) {\n    ctx.beginPath()\n    ctx.moveTo(0,200-f(num(0)).val)\n    for (let x = 1; x < 200; x++)\n        ctx.lineTo(x,200-f(num(x)).val)\n    ctx.stroke()\n}\n</code>\n<p>We introduce an API to define optimizable parameters:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// basic functionality: keep track of\n// optimizable parameters\nlet params = []\nfunction param(x) {\n    const dx = num(x)\n    params.push(dx)\n    return dx\n}\n</code>\n<p>The second component is the optimization loop, which adjusts the parameter values based on the computed gradients:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// compute primal and gradient\nfunction compute(loss) {\n    tape = []\n    // forward\n    const d = loss()\n    // backprop\n    d.grad = 1\n    for (const b of tape.reverse()) b()\n    return d\n}\n// one optimization step\nlet lr = 0.0001 // learning rate\nfunction optimize(loss) {\n    const d = compute(loss)\n    // gradient descent\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        p.val -= lr * p.grad\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<h3>Example: Linear Regression</h3>\n<p>Here is an example. We define a linear function, which we want to fit to some data (linear regression).</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nconst a0 = param(0)\nconst a1 = param(1)\nfunction approx(x) {\n    return plus(times(a1,x), a0)\n}\n</code>\n<p>We also define a sample data set. We use only two points for now, and since two points uniquely define a line, we should be able to fit the function to the data exactly:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\n// x,y stored in interleaved order\nlet data = [40,120,160,40]\nlet nSamples = data.length/2\n</code>\n<p>Let’s quickly plot the initial situation:</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n</code>\n<p>Now to do the fitting, we first define the loss function (observed error) as the mean sum of squares:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nfunction loss() {\n    let total = num(0)\n    for (let i = 0; i < nSamples; i++) {\n        const x = data[2*i]\n        const y = data[2*i+1]\n        const d = minus(num(y), approx(num(x)))\n        total = plus(total, times(d,d))\n    }\n    return times(total, num(1.0/nSamples))\n}\n</code>\n<p>Let’s plot some optimization steps (go ahead and change the learning rate or the loop bounds):</p>\n<code class=\"runScript\" filter=\"coolEditor\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001 // <- try adding or removing a zero\nfor (let i = 0; i < 100; i++) {\n    optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\n</code>\n<p>We can see that the slope adjusts well initially, but then appears to get stuck. The y intercept by contrast doesn’t appear to move at all. When we increase the number of iterations we can see that it actually does move - however very very slowly. It takes around 10,000 iterations to see any visible change, and even at 100,000 iterations we aren’t anywhere close to where we want to be (try it!).</p>\n<p>Unfortunately, we cannot increase the learning rate to accelerate the process, because then the changes to the slope explode (try <code class=\"language-text\">lr = 0.0001</code>).</p>\n<p>Here are some variants with additional debug output to visualize how the overall error and the approximated values of <code class=\"language-text\">a0</code> and <code class=\"language-text\">a1</code> change from iteration to iteration:</p>\n<aside>\n<p>Batch mode</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<aside>\n<p>Batch size of 1</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    if (i%2 == 1)\n        data = [40,120]\n    else\n        data = [160,40]\n    nSamples = 1\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<aside>\n<p>Batch size of 1, randomized</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=\"true\">\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 0.00001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    if (randomInt(2) == 1)\n        data = [40,120]\n    else\n        data = [160,40]\n    nSamples = 1\n    p1[i] = a0.val\n    p2[i] = a1.val\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error:\"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + p2[0] + \" --> \" + p2[p2.length-1])\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<h3>Stochastic Gradient Descent (SGD)</h3>\n<p>The variants with batch size 1 deserve a little bit of discussion. For large datasets, it is inefficient to adjust parameters only after processing the whole dataset (which may be gigabytes or even terabytes). Thus, in practice, it is common to compute the loss and update parameters based on a randomly selected “minibatch” at a time. This is called <em>stochastic</em> gradient descent (SGD), and in the limit, with batch size 1, we update parameters after each and every processed training sample.</p>\n<h3>Discussion</h3>\n<p>In conclusion, plain gradient descent works but is brittle. It requires careful tuning of the initial parameter values and, especially, of the learning rate.</p>\n<p>Parameters change with wildly different rates, yet the learning rate must be small enough to ensure stability for all of them. This leads to overall slow convergence.</p>\n<p>What we would <em>really</em> like to have is <em>different</em> learning rates for different parameters. Fortunately, such variations of the gradient-descent approach exist (e.g., AdaGrad, ADAM, etc.) and they can even adapt learning rates dynamically to how parameters change. These algorithms are more robust, and more efficient in practice.</p>\n<p>Another option are second-order methods that include curvature information (variants of Newton’s method). For many applications, these methods tend to be more robust and converge faster, however they are also more computationally intensive and have a reputation (deserved or not) to get stuck in saddle points in high-dimensional spaces. For these reasons, they are not frequently used in machine learning.</p>\n<p>We will discuss <a href=\"/gradient-descent-with-adam\">ADAM next</a>.</p>\n</aside>\n<p>The key motivation for AD is optimization by gradient descent. We show the core algorithm, and discuss why it is almost never used in its pure form in practice.</p>\n<aside id=\"gradient-descent-with-adam\">\n<p>Gradient Descent with ADAM (Adaptive Moment Estimation)</p>\n<p>We have seen above that <a href=\"/gradient-descent-optimization\">standard gradient descent</a> is sensitive to initial conditions and, especially, the learning rate. Since the same learning rate is applied to all parameters and remains unchanged throughout the training/optimization process, it has to be chosen very small, which means that many iterations are necessary.</p>\n<p>Improving gradient descent has been an intense focus of research. A nice and comprehensive overview is given by Sebastian Ruder:</p>\n<ul>\n<li><a href=\"https://ruder.io/optimizing-gradient-descent/index.html\">An overview of gradient descent optimization algorithms</a></li>\n</ul>\n<p>We use the ADAM algorithm below, which combines two key ideas to adjust the learning rate for each parameter based on prior changes:</p>\n<ul>\n<li>exponentially decaying average of past gradients (momentum)</li>\n<li>exponentially decaying average of past squared gradients</li>\n</ul>\n<p>Roughly, one can view ADAM as behaving like a heavy ball (with momentum), rolling down a hill slope (the error surface), subject to friction. Thus the ball tends to prefer flat minima.</p>\n<p>As an intermediate step, here is an implementation using only momentum:</p>\n<aside>\n<h3>Gradient Descent with Momentum</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet lastV1 = params.map(x => 0)\nlet gamma = 0.9\nfunction optimize(f) {\n    const d = compute(loss)\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        const v = lastV1[j]\n        const v1 = gamma * v + lr * p.grad\n        p.val -= v1\n        lastV1[j] = v1\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\ngamma = 0.99\nlr = 0.0001\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 100; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val+1 // shift b/c negative\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error: \"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + (p2[0]-1) + \" --> \" + (p2[p2.length-1]-1))\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n</aside>\n<p>It converges in about 1000 steps for our linear regression example (down 2 orders of magnitude from over 100,000).</p>\n<p>With 1000 steps, it is interesting to note how <code class=\"language-text\">a0</code> “overshoots” its target (due to momentum) and then settles back into the correct value.</p>\n<h3>ADAM</h3>\n<p>Here is the implementation:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\nlet betaM = 0.9\nlet betaV = 0.999\nlet eps = 1e-8\nlet lastM = params.map(x => 0)\nlet lastV = params.map(x => 0)\nlet lastBetaM = betaM\nlet lastBetaV = betaV\nfunction optimize(f) {\n    const d = compute(loss)\n    for (let j = 0; j < params.length; j++) {\n        const p = params[j]\n        const m = betaM * lastM[j] + (1-betaM) * p.grad\n        const v = betaV * lastV[j] + (1-betaV) * p.grad * p.grad\n        const m1 = m/(1-lastBetaM)\n        const v1 = v/(1-lastBetaV)\n        p.val -= lr * m1 / (Math.sqrt(v1) + eps)\n        lastM[j] = m\n        lastV[j] = v\n        lastBetaM *= betaM\n        lastBetaV *= betaV\n        p.grad = 0\n    }\n    return d\n}\n</code>\n<h3>Example: Linear Regression</h3>\n<p>We apply ADAM to our running linear regression example.\nIn contrast to standard gradient descent, which needed about 300,000 iterations to converge and could not sustain learning rates of more than 0.00001, ADAM converges in only 150 iterations.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\nnewPlot(200,200)\ndrawPoints(data)\ndrawFunction(approx)\n// now optimize\nlr = 2 // absurdly high learning rate, but ok for this example!\nerror = []\np1 = []\np2 = []\nfor (let i = 0; i < 150; i++) {\n    p1[i] = a0.val\n    p2[i] = a1.val+1 // shift b/c negative\n    error[i] = optimize(loss).val\n    drawFunction(approx)\n}\nctx.lineWidth=3\nctx.strokeStyle=\"red\"\ndrawFunction(approx)\nprint(\"Error: \"+error[0] + \" --> \" + error[error.length-1])\nnewPlot(200,200)\ndrawLine(error)\nprint(\"a0: \" + p1[0] + \" --> \" + p1[p1.length-1])\nnewPlot(200,200)\ndrawLine(p1)\nprint(\"a1: \" + (p2[0]-1) + \" --> \" + (p2[p2.length-1]-1))\nnewPlot(200,200)\ndrawLine(p2)\n</code>\n<p>Looking at the curves above, we can see that <code class=\"language-text\">a0</code>, which stably moves in one direction, nicely accelerates but still manages a soft landing, and that <code class=\"language-text\">a1</code>, which oscillates a lot in the beginning due to the high learning rate, is slowed down to stabilize.</p>\n<h3>Discussion</h3>\n<p>Optimization algorithms for deep learning architectures are a subject of ongoing research. Some refinements to ADAM and similar algorithms were proposed based on the observation that SGD with momentum and careful learning-rate schedules tend to find better minima on certain classes of models:</p>\n<ul>\n<li><a href=\"https://johnchenresearch.github.io/demon/\">An updated overview of recent gradient descent algorithms. Chen, 2020</a></li>\n</ul>\n<p>Other topics worth mentioning are optimization methods based on higher-order gradients (not frequently used in deep learning because of computational overhead) and approaches to go meta and optimize hyperparameters such as the learning rate itself by gradient descent:</p>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1909.13371\">Gradient Descent: The Ultimate Optimizer. Chandra et al, 2019</a></li>\n</ul>\n</aside>\n<p>We discuss ADAM, a variant of gradient descent that performs well in many practical scenarios and hence is a popular  choice for training deep learning models.</p>\n<p><a href=\"/Public/Generic/differentiable-graphics\">Cool Application: Interactive Graphics</a></p>\n<p>As a neat application, we show how our small AD library can turn parameterized drawings into rich interactive diagrams.</p>","fields":{"slug":"/Public/Generic/differentiable-programming-in-js/"},"frontmatter":{"date":"June 14, 2020","title":"Differentiable Programming in JavaScript","description":"Implementing AutoDiff from scratch in JS. Forward and reverse mode, gradient descent with momentum and Adam.","keywords":"Differentiable programming, Automatic Differentiation, AutoDiff, Gradient Descent, Linear Regression, JavaScript","tags":null}}},{"node":{"excerpt":"Knuth, Literate Programming: … a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most…","html":"<p>Knuth, Literate Programming:</p>\n<blockquote>\n<p>… a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most important thing about a program is its structural relationships. A complex piece of software consists of simple parts and simple relations between those parts; the programmer’s task is to state those parts and those relationships, in whatever order is best for human comprehension not in some rigidly determined order like top-down or bottom-up.</p>\n</blockquote>\n<p>It’s nice to have <a href=\"/Public/Generic/interactive-coding\">interactive snippets</a> in web pages or <a href=\"/Public/Generic/octopus-notes\">Octopus Notes</a>, but we do not want to be restricted to isolated, self-contained, units.</p>\n<p>For larger documents, we want to develop code over a series of dependent snippets, and compose them freely.</p>\n<p>Importantly, we also want to be able to put code into asides and show the editor pane side by side with the output.</p>\n<aside>\n<p>How can we do that?</p>\n<p>Of course we can communicate through the global (window) scope. But there are issues with that:</p>\n<ul>\n<li>Scope pollution: what if multiple articles define and use the same name?</li>\n<li>\n<p>Order of evaluation: what if snippets are evaluated out of order?</p>\n<p>We can generally assume scripts within an article are executed top to bottom. But if we have an interactive editor, we may (re-)evaluate code at any time.</p>\n</li>\n</ul>\n<p>To solve these issues, we follow a relatively simple but robust idea to join multiple snippets:</p>\n<ul>\n<li>Remember the order of snippets</li>\n<li>Mark all that should form part of an inclusion chain</li>\n<li>Add them to the input of each following snippet</li>\n<li>Optional (not yet implemented): re-eval all following snippets if a previous one changes</li>\n</ul>\n<p>Why does this work even with asides?</p>\n<p>Because asides are extracted from the main article <em>after</em> scripts are run! Hence, no special treatment is necessary.</p>\n<p>Below are some tests and explanations.</p>\n<p>Here are some avenues for extension <a href=\"/Notes/todo-large\">tag:todo</a>:</p>\n<ul>\n<li>Right now we cannot modify preamble parts (actually we <em>can</em> modify them, but changes won’t be picked up by other snippets). We may or may not want to re-run all downstream dependencies for every change.</li>\n<li>Use <code class=\"language-text\">filter=&quot;editor&quot;</code> with attribute <code class=\"language-text\">preamble=&quot;set/add&quot;</code> instead of <code class=\"language-text\">filter=&quot;set/addPreamble</code>.</li>\n<li>We may want to support things like <code class=\"language-text\">preamble=&quot;push/pop&quot;</code>.</li>\n<li>Attribute <code class=\"language-text\">popout=true</code> could be generalized to <code class=\"language-text\">style=popout</code> to support other custom styles (think about plug-ins).</li>\n<li>Editor UX could be improved in various ways (syntax highlighting, smart editing, monospace console output, etc)</li>\n</ul>\n</aside>\n<p>Below are some examples and explanations. There are multiple avenues for extension.</p>\n<aside>\n<h2>What works right now</h2>\n<h3>Editor definition script</h3>\n<p>No visible output. We’d probably want to import this from a central location (once we’re done tweaking it globally).</p>\n<code class=\"runScript\">\nwindow.coolEditor = function coolEditor(codeElem) {\nconst startInput = window.preamble\nconst editInput = codeElem.innerText.trim()\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nfunction runInput() {\n  run(startInput + \"\\n\" + p.innerText.trim())\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    runInput()\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => runInput(), 0)\n})\nif (codeElem.getAttribute(\"popout\")) {\n    const as = document.createElement(\"aside\")\n    const la = document.createElement(\"div\")\n    la.innerText = \"code:\"\n    as.appendChild(la)\n    as.appendChild(p)\n    e.appendChild(as)\n} else\n    e.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrunInput()\nreturn e\n}\nwindow.addPreamble = function addPreamble(e) {\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = window.preamble + \"\\n\" + e.innerText.trim()\n  return ed\n}\nwindow.setPreamble = function setPreamble(e) {\n  window.preamble = \"\"\n  const ed = coolEditor(e)\n  ed.lastChild.remove()\n  window.preamble = e.innerText.trim()\n  return ed\n}\nwindow.preamble = \"\"\ndocument.createElement(\"div\")\n</code>\n<h3>Set Preamble</h3>\n<p>Putting <code class=\"language-text\">filter=&quot;setPreamble&quot;</code> on a script will prepend the code to any following script that uses the editor component.</p>\n<code class=\"runScript\" filter=\"setPreamble\">\nlet trace = []\ntrace.push(\"setPreamble1\")\n</code>\n<h3>Editor 1</h3>\n<p>Let’s verify this. This editor does not use <code class=\"language-text\">setPreamble</code>, so it will just execute the program (with the previously defined preamble prepended).</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"editor1\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 1</h3>\n<p>Of course we don’t always want to set the preamble wholesale, but accumulate it piecewise. For this we can use <code class=\"language-text\">filter=&quot;addPreamble&quot;</code>:</p>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"addPreamble1\")\n</code>\n<h3>Editor 2</h3>\n<p>Now we should see <code class=\"language-text\">setPreamble1</code>, <code class=\"language-text\">addPreamble1</code>, and <code class=\"language-text\">editor2</code> in the output, but not <code class=\"language-text\">editor1</code>.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\ntrace.push(\"editor2\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>Aside 1</h3>\n<p>All of this works transparently with asides, since they are pulled out after scripts execute.</p>\n<p>Here is an aside that contains preamble material and editors.</p>\n<aside>\n<p>Let’s try this!</p>\n<h3>Editor 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"aside1.editor1\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 1</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"aside1.addPreamble1\")\n</code>\n<h3>Editor 1</h3>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"aside1.editor2\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>AddPreamble 2</h3>\n<code class=\"runScript\" filter=\"addPreamble\">\ntrace.push(\"aside1.addPreamble2\")\n</code>\n</aside>\n<h3>Editor 3</h3>\n<p>We can verify that we have <code class=\"language-text\">aside1.addPreamble1</code> and <code class=\"language-text\">aside1.addPreamble2</code> in the trace, in addition to what we had before.</p>\n<code class=\"runScript\" filter=\"coolEditor\">\ntrace.push(\"editor3\")\nfor (let e of trace)\n  emit(e)\n</code>\n<h3>Aside 2 (Generated!)</h3>\n<p>A cool thing is that we can generate asides programmatically from scripts. Again, this works because asides are pulled out <em>after</em> scripts are run.</p>\n<code class=\"runScript\">\nconst aux = document.createElement(\"aside\")\naux.appendChild(document.createTextNode(\"Programmatically generated!\"))\naux\n</code>\n<h3>Editor 4 (Pop-Out!)</h3>\n<p>With this programmatic support we can also build editor components that show the results inline but put the code editor itself into an aside.</p>\n<code class=\"runScript\" filter=\"coolEditor\" popout=true>\ntrace.push(\"editor4\")\nfor (let e of trace)\n  emit(e)\n</code>\n<p>Editing the code in the aside will change the result displayed inline, as we expect.</p>\n</aside>","fields":{"slug":"/Public/Generic/interactive-literate-programming/"},"frontmatter":{"date":"June 12, 2020","title":"Interactive Literate Programming","description":"Modular live code snippets across multiple notes.","keywords":"Live coding, literate programming","tags":null}}},{"node":{"excerpt":"Web pages can be turned into interactive tutorials with just a little bit of embedded JavaScript. We are particularly interested in…","html":"<!--\n<pre id=\"code-onload\" contenteditable=\"true\">\nconsole.log(\"code-onload\")\nfunction runX() {\n    eval((document.getElementById(\"code-X\").innerText))\n}\n</pre>\n\n<pre id=\"code-X\" contenteditable=\"true\">\nconsole.log(\"foo!\")\nfunction foobar() {\n    console.log(\"bar!\")\n}\n</pre>\n\n<script>\nconsole.log(\"boo!\");\n</script>\n\n<a href=\"javascript:runX()\">▶ run</a>\n\n<img src=\"\" onerror=\"window.eval((document.getElementById('code-onload').innerText))\" width=\"0\" height=\"0\" />\n\n-->\n<p>Web pages can be turned into interactive tutorials with just a little bit of embedded JavaScript.</p>\n<p>We are particularly interested in interacting with editable and runnable code, inspired, among other things, by the work of <a href=\"http://worrydream.com/LearnableProgramming/\">Bret Victor</a>. Of course interactive documents are also useful in other fields (physics, math, music, etc).</p>\n<p>Below we explore a series of simple code interaction patterns, such as repls (read-eval-print loops) and embedded editable code snippets that are connected to live elements of the page.\nWe’re not aiming for maximal flashiness, but for simplicity.</p>\n<aside>\n<h2>Basic DOM manipulation</h2>\n<code class=\"runScript\">\nconst e = document.createElement(\"div\")\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ ping\"\na.addEventListener(\"click\", function(ev) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(\"Ping!\"))\n    e.appendChild(l)\n    ev.preventDefault()\n})\ne.appendChild(a)\ne\n</code>\n<h2>Eval expression on click</h2>\n<code class=\"runScript\">\nconst editInput = \"3+4\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction run() {\n    try {\n        const res = eval(p.innerText)\n        emit(res)\n    } catch(err) {\n        emit(err)\n    }\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run()\n})\ne.appendChild(a)\ne.appendChild(p)\ne.appendChild(o)\ne\n</code>\n</aside>\n<aside>\n<h2>Basic REPL</h2>\n<code class=\"runScript\">\nconst editInput = \"3+4\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nlet history = [editInput]\nlet historyIndex = 0\nlet historyCur = \"\"\nfunction run() {\n    try {\n        const src = p.innerText.trim()\n        if (src) {\n        // record in history, if not empty and not equal previous\n        if ((history.length < 2 || history[history.length - 2] != src) && src != \"\") {\n            history[history.length - 1] = src\n            history.push(\"\")\n        } else {\n            history[history.length - 1] = \"\"\n        }\n        historyIndex = 0\n        emit(\"> \"+src)\n        const res = eval(src)\n        if (res) emit(\"< \"+res)\n        }\n    } catch(err) {\n        emit(err)\n    }\n    p.innerText = \"\"\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run()\n})\np.addEventListener(\"keydown\", function(ev) {\n    if (ev.code == \"Enter\" && !ev.shiftKey) {\n        ev.preventDefault()\n        run()\n    } else if (ev.code == \"KeyK\" && ev.metaKey) {\n        ev.preventDefault()\n        clear()\n    } else if (ev.code == \"ArrowUp\") {\n        if (historyIndex < history.length - 1) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex + 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    } else if (ev.code == \"ArrowDown\") {\n        if (historyIndex > 0) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex - 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    }\n})\nconst c = document.createElement(\"a\")\nc.href = \"\"\nc.innerText = \"clear\"\nc.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    clear()\n})\ne.appendChild(o)\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(document.createTextNode(\" \"))\ne.appendChild(c)\ne\n</code>\n<p>Functionality / key bindings:</p>\n<ul>\n<li>Run command (Return)</li>\n<li>Line break (Shift-Return)</li>\n<li>Clear output (Cmd-k)</li>\n<li>Up/down arrows: history</li>\n<li>enter “emit(..)” to print</li>\n</ul>\n<h2>Basic DOM and canvas in REPL</h2>\n<p>Below is a scripted repl session that creates a canvas and draws in it.</p>\n<code class=\"runScript\">\n// code is copied from above -- should definitely factor out!\nconst editInput = \"\"\nconst e = document.createElement(\"div\")\nconst o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\nlet history = [editInput]\nlet historyIndex = 0\nlet historyCur = \"\"\nfunction run(src) {\n    try {\n        if (src) {\n        // record in history, if not empty and not equal previous\n        if ((history.length < 2 || history[history.length - 2] != src) && src != \"\") {\n            history[history.length - 1] = src\n            history.push(\"\")\n        } else {\n            history[history.length - 1] = \"\"\n        }\n        historyIndex = 0\n        emit(\"> \"+src)\n        const res = eval(src)\n        if (res) emit(\"< \"+res)\n        }\n    } catch(err) {\n        emit(err)\n    }\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"▶ run\"\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    run(p.innerText.trim())\n    p.innerText = \"\"\n})\np.addEventListener(\"keydown\", function(ev) {\n    if (ev.code == \"Enter\" && !ev.shiftKey) {\n        ev.preventDefault()\n        run(p.innerText.trim())\n        p.innerText = \"\"\n    } else if (ev.code == \"KeyK\" && ev.metaKey) {\n        ev.preventDefault()\n        clear()\n    } else if (ev.code == \"ArrowUp\") {\n        if (historyIndex < history.length - 1) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex + 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    } else if (ev.code == \"ArrowDown\") {\n        if (historyIndex > 0) {\n            ev.preventDefault()\n            history[history.length - 1 - historyIndex] = p.innerText\n            historyIndex = historyIndex - 1\n            p.innerText = history[history.length - 1 - historyIndex]\n            const sel = window.getSelection()\n            sel.selectAllChildren(p)\n            sel.collapseToEnd()\n        }\n    }\n})\nconst c = document.createElement(\"a\")\nc.href = \"\"\nc.innerText = \"clear\"\nc.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    clear()\n})\ne.appendChild(o)\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(document.createTextNode(\" \"))\ne.appendChild(c)\n// run stuff!\nrun('cvs = document.createElement(\"canvas\")')\nrun('cvs.width = 200')\nrun('cvs.height = 200')\nrun('o.appendChild(cvs)')\nrun('ctx = cvs.getContext(\"2d\")')\nrun('ctx.fillRect(10,10,100,100)')\nrun('ctx.fillRect(100,100,200,200)')\nrun('ctx.fillStyle = \"white\"')\nrun('ctx.fillRect(100,100,10,10)')\ne\n</code>\n</aside>\n<p>The key to a truly interactive feel is to eliminate the edit-compile-run cycle and immediately visualize how a change in the program affects its behavior.</p>\n<aside>\n<h2>Re-eval on edit</h2>\n<p>A text pane that re-evaluates output on the fly, on every edit.</p>\n<code class=\"runScript\">\nconst editInput = `const cvs = document.createElement(\"canvas\")\ncvs.width = 200\ncvs.height = 200\no.appendChild(cvs)\nconst ctx = cvs.getContext(\"2d\")\nctx.fillRect(10,10,100,100)\nctx.fillRect(100,100,200,200)\nctx.fillStyle = \"white\"\nctx.fillRect(100,100,10,10)\nemit(\"Do you like it?\")\nawait buttonClick(\"Yes!!!\")\nemit(\"Good!\")`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n<p>Try changing something that results in a syntax error, and note how the previous output remains visible (we might want to turn it gray or something).</p>\n<p>Note the <code class=\"language-text\">await</code> and how the button behaves.</p>\n<p>One could think about a richer programmatic UI library, including commands to open new dialog screens (graphics or text), to select options (e.g., <code class=\"language-text\">await pickOne(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</code> might show multiple buttons), and so on.</p>\n<h2>Test-driven development (TDD)</h2>\n<p>Basic unit testing facilty. Test are re-run on each edit.</p>\n<code class=\"runScript\">\nconst editInput = `\ntest(\"foo\", function() {\n    assert(7 == 8)\n})\ntest(\"bar\", function() {\n    assert(7 == 7)\n})\ntest(\"foo\", function() {\n    expect(7,8)\n})\ntest(\"bar\", function() {\n    expect(7,7)\n})`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction emit(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n</aside>\n<p>The most generally useful baseline widget seems to be an interactive editor that contains the source code for a component of the page. The editor re-runs the program on every keystroke, maintaining an always up-to-date output panel along with the source code.</p>\n<code class=\"runScript\">\nconst editInput = `\nprint(\"Hello World!\") // edit me\nprint(6*7)\n`\nconst e = document.createElement(\"div\")\nlet o = document.createElement(\"div\")\nconst p = document.createElement(\"pre\")\ne.className = \"editor_e\"\no.className = \"editor_o\"\np.className = \"editor_p\"\np.appendChild(document.createTextNode(editInput))\np.contentEditable = true\np.height = 200\nconst a = document.createElement(\"a\")\na.href = \"\"\na.innerText = \"idle\"\nlet status = \"idle\"\nlet result = undefined\nfunction setStatus(st, res) {\n    status = st\n    result = res\n    if (res)\n        a.innerText = st + \": \" + res\n    else\n        a.innerText = st\n}\nfunction run(src) {\n    const o1 = o\n    function onDone(res) {\n        setStatus(\"done\", res)\n    }\n    function onError(err) {\n        setStatus(\"error\", err)\n        // if no output, put back previous result\n        if (!o.firstChild) {\n            o.remove()\n            o = o1\n            e.appendChild(o)\n        }\n    }\n    try {\n        o.remove()\n        o = document.createElement(\"div\")\n        e.appendChild(o)\n        setStatus(\"running\")\n        const fullSrc = `async () => { ${src} }`\n        const fun = eval(fullSrc)\n        fun().then(onDone, onError)\n    } catch(err) {\n        onError(err)\n    }\n}\nasync function buttonClick(str) {\n    const btn = document.createElement(\"button\")\n    btn.innerText = str\n    o.appendChild(btn)\n    const res = await new Promise(resolve => btn.addEventListener(\"click\", () => resolve(str)))\n    btn.remove()\n    emit(\"> \"+res)\n    return res\n}\nfunction clear() {\n    while (o.firstChild) {\n        o.firstChild.remove()\n    }\n}\nfunction print(str) {\n    const l = document.createElement(\"div\")\n    l.appendChild(document.createTextNode(str))\n    o.appendChild(l)\n}\nfunction assert(cond,str) {\n    if (!cond) throw new Error(str || \"Assertion Failed\")\n}\nfunction expect(a,b) {\n    assert(a == b, \"Expected \"+a+\" but got \"+b)\n}\nfunction test(str, fun) {\n    const e = document.createElement(\"div\")\n    e.innerText = str + \" \".padEnd(15, \".\")\n    o.appendChild(e)\n    setTimeout(function() {\n        try {\n            fun()\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" OK\"\n        } catch(ex) {\n            e.innerText = (str + \" \").padEnd(30, \".\") + \" \" + ex\n        }}, 0)\n}\na.addEventListener(\"click\", function(ev) {\n    ev.preventDefault()\n    // run it again\n    run(p.innerText.trim())\n})\np.addEventListener(\"keydown\", function(ev) {\n    // could be a change listener\n    // for now, delay to run after char insertion\n    setTimeout(() => run(p.innerText.trim()), 0)\n})\ne.appendChild(p)\ne.appendChild(a)\ne.appendChild(o)\nrun(p.innerText.trim())\ne\n</code>\n<p>Graphics and user input are supported, too. See link above for details.</p>","fields":{"slug":"/Public/Generic/interactive-coding/"},"frontmatter":{"date":"June 06, 2020","title":"Interacting with Code","description":"How to turn web pages into interactive live-coding environments, with nothing but plain JavaScript.","keywords":"JavaScript, REPL, live coding, live programming","tags":null}}},{"node":{"excerpt":"Structuring complex information is difficult, whether it is for clarity of one’s own thought or for effective presentation. Specifically, it…","html":"<p>Structuring complex information is difficult, whether it is for clarity of one’s own thought or for effective presentation. Specifically, it’s difficult to decide:</p>\n<ul>\n<li>In which order?</li>\n<li>At which level of detail?</li>\n</ul>\n<p>And often, there is no single right answer.</p>\n<p>Octopus Notes, the prototype system you’re using to view this note, is an attempt at creating easily-browsable associative knowledge bases that sidestep these questions.\nLike other systems, the underlying idea is to structure information as a collection of densely linked, self-contained, notes.\nBut unlike other systems, the focus is on visually presenting linked information in context.</p>\n<aside>\n<h2>Presenting information in context, at multiple resolutions</h2>\n<p>This is a linked note that provides additional information and further details that are omitted from the main article.</p>\n<p>We can have as many notes and links as we want, nested arbitrarily deep, and we can open and close them selectively, while viewing them side-by-side with the more condensed material from the main article.</p>\n<p>We can follow arbitrary paths through the knowledge graph with ease, but in contrast to typical web navigation, we do not lose the context where we came from.</p>\n<p>We can access information at multiple resolutions, or levels of detail, simultaneously and selectively. We can view multiple levels of detail side-by-side and we can drill down as deep as we find useful, or remain at the surface for the tl;dr.</p>\n<p>Authors can add additional information anywhere without disrupting the flow of the main content.</p>\n</aside>\n<p>Clicking a link like the one above will not navigate away from the current page, but instead it will open the link target in an additional scrollable panel with an attached “tentacle”.\nThis enables engaging with information at multiple levels of detail simultaneously.</p>\n<aside>\n<h2>Features and implementation</h2>\n<p>User-facing features:</p>\n<ul>\n<li>Multi-resolution display of information</li>\n<li>Bidirectional links</li>\n<li>Interactive documents with live code</li>\n</ul>\n<p>Tech stack:</p>\n<ul>\n<li>Jamstack, single-page-app front-end</li>\n<li>Markdown syntax</li>\n</ul>\n<p>More information:</p>\n<ul>\n<li>\n<aside>\n<h2>Markdown reference</h2>\n<p>Octopus Notes supports standard markdown syntax, as defined by the static generation pipeline (currently Gatsby and Remark).</p>\n<p>A few things are worth highlighting.</p>\n<h3>Inline notes via “aside”</h3>\n<p>Notes are typically created as individual <code class=\"language-text\">.md</code> files. However it can be annoying to create a new file for every little side note. Hence, Octopus Notes support the definition of inline notes using html <code class=\"language-text\">&lt;aside&gt;</code> elements.</p>\n<p>As an example, here is the definition of the current note:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">More information:\n\n- &lt;aside&gt;\n\n    ## Markdown reference\n\n    Octopus note supports ...\n\n    &lt;/aside&gt;\n\n- ...</code></pre></div>\n<p>Note that:</p>\n<ul>\n<li>It is important to leave a blank line before and after <code class=\"language-text\">&lt;aside&gt;</code> or other HTML tags (otherwise adjacant markdown will be treated as HTML)</li>\n<li>Asides can be placed in lists or other elements; they are always pulled out and replaced with a link</li>\n<li>The link text is automatically extracted from text of the aside (usually the first line, but may be shorter, e.g, when hitting a ”:“)</li>\n</ul>\n<h3>Embedded code snippets</h3>\n<p>Notes can contain standard JavaScript <code class=\"language-text\">&lt;script&gt;</code> tags that are executed when the data is loaded.</p>\n<p>Often, a bit more control is needed, so Octopus Notes also supports script blocks of the form:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;code class=&quot;runScript&quot; filter=&quot;...&quot;&gt;\n...\n&lt;/code&gt;</code></pre></div>\n<p>Such code blocks may return a DOM element that will replace the script element in the DOM (highly useful for interactive documents).</p>\n<p>If the optional filter argument is given it is evaluated first, and the result is then called with the contents of the code block as argument. This way, code may be preprocessed in arbitrary ways.</p>\n<p>A key use case is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;code class=&quot;runScript&quot; filter=&quot;coolEditor&quot;&gt;\n...\n&lt;/code&gt;</code></pre></div>\n<p>which produces an inline-editable code snippet (<a href=\"/Public/Generic/interactive-coding\">Interactive code</a>).</p>\n<p>There are various helpers to enable interaction between such snippets (<a href=\"/Public/Generic/interactive-literate-programming\">Interactive code across multiple snippets</a>).</p>\n</aside>\n</li>\n<li>\n<aside>\n<h2>Static site generation</h2>\n<p>Octopus Notes currently uses Gatsby and Remark to turn Markdown input into static html.</p>\n<p>Right now we do not use the actual Gatsby site generation facility, and use Gatsby only to perform aggregation via GraphQL, resulting in a single <code class=\"language-text\">page-data.json</code> file that is then processed client-side by the custom Octopus front-end.</p>\n</aside>\n</li>\n<li><a href=\"/Public/Generic/interactive-coding\">Interactive code</a></li>\n<li><a href=\"/Public/Generic/interactive-literate-programming\">Interactive code across multiple notes</a></li>\n</ul>\n</aside>\n<p>The system is built on markdown and modern web front-end technologies, and it supports rich interactive content.</p>\n<aside>\n<h2>Inspiration and related work</h2>\n<p>Original ideas:</p>\n<ul>\n<li>Niklas Luhmann (Zettelkasten)</li>\n<li>Ted Nelson (Xanadu)</li>\n<li>Ward Cunningham (Wikis)</li>\n</ul>\n<p>Further inspiration:</p>\n<ul>\n<li>Sönke Ahrens (How to Take Smart Notes)</li>\n<li>Andy Matuschak (Evergreen Notes)</li>\n</ul>\n<p>Other software:</p>\n<ul>\n<li>Trilium, Obsidian, Notion, Gingko, Roam</li>\n</ul>\n</aside>\n<p>There is plenty of inspirational prior work, including Luhmann’s Zettelkasten method and Nelson’s original hyperlink concept.</p>","fields":{"slug":"/Public/Generic/octopus-notes/"},"frontmatter":{"date":"May 30, 2020","title":"Octopus Notes","description":"A system for presenting structured information and networked thought. Multiple levels of detail. Hyperlinks side-by-side with source. For knowledge bases, note taking, wikis, blogs, interactive books and tutorials. Based on Markdown.","keywords":"bidirectional links, zettelkasten, note-taking, personal wiki, knowledge bases, second brain","tags":null}}}]}},"pageContext":{}}}